// @generated by protobuf-ts 2.7.0
// @generated from protobuf file "game.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message AbilityActionGenerateElemBall
 */
export interface AbilityActionGenerateElemBall {
    /**
     * @generated from protobuf field: Vector pos = 1;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 2;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: uint32 room_id = 3;
     */
    roomId: number;
}
/**
 * @generated from protobuf message AbilityAppliedAbility
 */
export interface AbilityAppliedAbility {
    /**
     * @generated from protobuf field: AbilityString ability_name = 1;
     */
    abilityName?: AbilityString;
    /**
     * @generated from protobuf field: AbilityString ability_override = 2;
     */
    abilityOverride?: AbilityString;
    /**
     * @generated from protobuf field: repeated AbilityScalarValueEntry override_map = 3;
     */
    overrideMap: AbilityScalarValueEntry[];
    /**
     * @generated from protobuf field: uint32 instanced_ability_id = 4;
     */
    instancedAbilityId: number;
}
/**
 * @generated from protobuf message AbilityAppliedModifier
 */
export interface AbilityAppliedModifier {
    /**
     * @generated from protobuf field: int32 modifier_local_id = 1;
     */
    modifierLocalId: number;
    /**
     * @generated from protobuf field: uint32 parent_ability_entity_id = 2;
     */
    parentAbilityEntityId: number;
    /**
     * @generated from protobuf field: AbilityString parent_ability_name = 3;
     */
    parentAbilityName?: AbilityString;
    /**
     * @generated from protobuf field: AbilityString parent_ability_override = 4;
     */
    parentAbilityOverride?: AbilityString;
    /**
     * @generated from protobuf field: uint32 instanced_ability_id = 5;
     */
    instancedAbilityId: number;
    /**
     * @generated from protobuf field: uint32 instanced_modifier_id = 6;
     */
    instancedModifierId: number;
    /**
     * @generated from protobuf field: float exist_duration = 7;
     */
    existDuration: number;
    /**
     * @generated from protobuf field: AbilityAttachedModifier attached_instanced_modifier = 8;
     */
    attachedInstancedModifier?: AbilityAttachedModifier;
    /**
     * @generated from protobuf field: uint32 apply_entity_id = 9;
     */
    applyEntityId: number;
    /**
     * @generated from protobuf field: bool is_attached_parent_ability = 10;
     */
    isAttachedParentAbility: boolean;
    /**
     * @generated from protobuf field: ModifierDurability modifier_durability = 11;
     */
    modifierDurability?: ModifierDurability;
    /**
     * @generated from protobuf field: uint32 sbuff_uid = 12;
     */
    sbuffUid: number;
    /**
     * @generated from protobuf field: bool is_serverbuff_modifier = 13;
     */
    isServerbuffModifier: boolean;
}
/**
 * @generated from protobuf message AbilityAttachedModifier
 */
export interface AbilityAttachedModifier {
    /**
     * @generated from protobuf field: bool is_invalid = 1;
     */
    isInvalid: boolean;
    /**
     * @generated from protobuf field: uint32 owner_entity_id = 2;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: uint32 instanced_modifier_id = 3;
     */
    instancedModifierId: number;
    /**
     * @generated from protobuf field: bool is_serverbuff_modifier = 4;
     */
    isServerbuffModifier: boolean;
    /**
     * @generated from protobuf field: int32 attach_name_hash = 5;
     */
    attachNameHash: number;
}
/**
 * @generated from protobuf message AbilityChangeNotify
 */
export interface AbilityChangeNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 3;
     */
    entityId: number;
    /**
     * @generated from protobuf field: AbilityControlBlock ability_control_block = 10;
     */
    abilityControlBlock?: AbilityControlBlock;
}
/**
 * @generated from protobuf message AbilityControlBlock
 */
export interface AbilityControlBlock {
    /**
     * @generated from protobuf field: repeated AbilityEmbryo ability_embryo_list = 1;
     */
    abilityEmbryoList: AbilityEmbryo[];
}
/**
 * @generated from protobuf message AbilityEmbryo
 */
export interface AbilityEmbryo {
    /**
     * @generated from protobuf field: uint32 ability_id = 1;
     */
    abilityId: number;
    /**
     * @generated from protobuf field: fixed32 ability_name_hash = 2;
     */
    abilityNameHash: number;
    /**
     * @generated from protobuf field: fixed32 ability_override_name_hash = 3;
     */
    abilityOverrideNameHash: number;
}
/**
 * @generated from protobuf message AbilityGadgetInfo
 */
export interface AbilityGadgetInfo {
    /**
     * @generated from protobuf field: uint32 camp_id = 1;
     */
    campId: number;
    /**
     * @generated from protobuf field: uint32 camp_target_type = 2;
     */
    campTargetType: number;
    /**
     * @generated from protobuf field: uint32 target_entity_id = 3;
     */
    targetEntityId: number;
}
/**
 * @generated from protobuf message AbilityIdentifier
 */
export interface AbilityIdentifier {
    /**
     * @generated from protobuf field: uint32 instanced_ability_id = 8;
     */
    instancedAbilityId: number;
    /**
     * @generated from protobuf field: uint32 ability_caster_id = 14;
     */
    abilityCasterId: number;
    /**
     * @generated from protobuf field: int32 local_id = 7;
     */
    localId: number;
    /**
     * @generated from protobuf field: uint32 instanced_modifier_id = 9;
     */
    instancedModifierId: number;
    /**
     * @generated from protobuf field: uint32 modifier_owner_id = 11;
     */
    modifierOwnerId: number;
    /**
     * @generated from protobuf field: bool is_serverbuff_modifier = 6;
     */
    isServerbuffModifier: boolean;
}
/**
 * @generated from protobuf message AbilityInvocationsNotify
 */
export interface AbilityInvocationsNotify {
    /**
     * @generated from protobuf field: repeated AbilityInvokeEntry invokes = 8;
     */
    invokes: AbilityInvokeEntry[];
}
/**
 * @generated from protobuf message AbilityInvokeEntry
 */
export interface AbilityInvokeEntry {
    /**
     * @generated from protobuf field: AbilityInvokeEntryHead head = 1;
     */
    head?: AbilityInvokeEntryHead;
    /**
     * @generated from protobuf field: AbilityInvokeArgument argument_type = 7;
     */
    argumentType: AbilityInvokeArgument;
    /**
     * @generated from protobuf field: bytes ability_data = 12;
     */
    abilityData: Uint8Array;
    /**
     * @generated from protobuf field: uint32 entity_id = 14;
     */
    entityId: number;
    /**
     * @generated from protobuf field: ForwardType forward_type = 8;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: uint32 forward_peer = 4;
     */
    forwardPeer: number;
    /**
     * @generated from protobuf field: uint32 event_id = 3;
     */
    eventId: number;
    /**
     * @generated from protobuf field: double total_tick_time = 9;
     */
    totalTickTime: number;
}
/**
 * @generated from protobuf message AbilityInvokeEntryHead
 */
export interface AbilityInvokeEntryHead {
    /**
     * @generated from protobuf field: uint32 instanced_ability_id = 6;
     */
    instancedAbilityId: number;
    /**
     * @generated from protobuf field: uint32 instanced_modifier_id = 10;
     */
    instancedModifierId: number;
    /**
     * @generated from protobuf field: int32 local_id = 3;
     */
    localId: number;
    /**
     * @generated from protobuf field: int32 modifier_config_local_id = 14;
     */
    modifierConfigLocalId: number;
    /**
     * @generated from protobuf field: uint32 target_id = 11;
     */
    targetId: number;
    /**
     * @generated from protobuf field: bool is_serverbuff_modifier = 15;
     */
    isServerbuffModifier: boolean;
    /**
     * @generated from protobuf field: uint32 server_buff_uid = 5;
     */
    serverBuffUid: number;
}
/**
 * @generated from protobuf message AbilityMetaModifierChange
 */
export interface AbilityMetaModifierChange {
    /**
     * @generated from protobuf field: ModifierAction action = 1;
     */
    action: ModifierAction;
    /**
     * @generated from protobuf field: AbilityString parent_ability_name = 2;
     */
    parentAbilityName?: AbilityString;
    /**
     * @generated from protobuf field: AbilityString parent_ability_override = 3;
     */
    parentAbilityOverride?: AbilityString;
    /**
     * @generated from protobuf field: AbilityAttachedModifier attached_instanced_modifier = 4;
     */
    attachedInstancedModifier?: AbilityAttachedModifier;
    /**
     * @generated from protobuf field: repeated ModifierProperty properties = 5;
     */
    properties: ModifierProperty[];
    /**
     * @generated from protobuf field: int32 modifier_local_id = 6;
     */
    modifierLocalId: number;
    /**
     * @generated from protobuf field: bool is_mute_remote = 7;
     */
    isMuteRemote: boolean;
    /**
     * @generated from protobuf field: uint32 apply_entity_id = 8;
     */
    applyEntityId: number;
    /**
     * @generated from protobuf field: bool is_attached_parent_ability = 9;
     */
    isAttachedParentAbility: boolean;
    /**
     * @generated from protobuf field: uint32 server_buff_uid = 10;
     */
    serverBuffUid: number;
}
/**
 * @generated from protobuf message AbilityMetaReInitOverrideMap
 */
export interface AbilityMetaReInitOverrideMap {
    /**
     * @generated from protobuf field: repeated AbilityScalarValueEntry override_map = 1;
     */
    overrideMap: AbilityScalarValueEntry[];
}
/**
 * @generated from protobuf message AbilityMixinCostStamina
 */
export interface AbilityMixinCostStamina {
    /**
     * @generated from protobuf field: bool is_swim = 1;
     */
    isSwim: boolean;
}
/**
 * @generated from protobuf message AbilityMixinRecoverInfo
 */
export interface AbilityMixinRecoverInfo {
    /**
     * @generated from protobuf field: uint32 local_id = 3;
     */
    localId: number;
    /**
     * @generated from protobuf field: repeated uint32 data_list = 4;
     */
    dataList: number[];
    /**
     * @generated from protobuf field: bool is_serverbuff_modifier = 5;
     */
    isServerbuffModifier: boolean;
    /**
     * @generated from protobuf field: repeated MassivePropSyncInfo massive_prop_list = 6;
     */
    massivePropList: MassivePropSyncInfo[];
    /**
     * @generated from protobuf oneof: source
     */
    source: {
        oneofKind: "instancedAbilityId";
        /**
         * @generated from protobuf field: uint32 instanced_ability_id = 1;
         */
        instancedAbilityId: number;
    } | {
        oneofKind: "instancedModifierId";
        /**
         * @generated from protobuf field: uint32 instanced_modifier_id = 2;
         */
        instancedModifierId: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message AbilityMixinWidgetMpSupport
 */
export interface AbilityMixinWidgetMpSupport {
    /**
     * @generated from protobuf field: uint32 target_entity_id = 1;
     */
    targetEntityId: number;
}
/**
 * @generated from protobuf message AbilityScalarValueEntry
 */
export interface AbilityScalarValueEntry {
    /**
     * @generated from protobuf field: AbilityString key = 1;
     */
    key?: AbilityString;
    /**
     * @generated from protobuf field: AbilityScalarType value_type = 2;
     */
    valueType: AbilityScalarType;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "floatValue";
        /**
         * @generated from protobuf field: float float_value = 3;
         */
        floatValue: number;
    } | {
        oneofKind: "stringValue";
        /**
         * @generated from protobuf field: string string_value = 4;
         */
        stringValue: string;
    } | {
        oneofKind: "intValue";
        /**
         * @generated from protobuf field: int32 int_value = 5;
         */
        intValue: number;
    } | {
        oneofKind: "uintValue";
        /**
         * @generated from protobuf field: uint32 uint_value = 6;
         */
        uintValue: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message AbilityString
 */
export interface AbilityString {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "str";
        /**
         * @generated from protobuf field: string str = 1;
         */
        str: string;
    } | {
        oneofKind: "hash";
        /**
         * @generated from protobuf field: uint32 hash = 2;
         */
        hash: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message AbilitySyncStateInfo
 */
export interface AbilitySyncStateInfo {
    /**
     * @generated from protobuf field: bool is_inited = 1;
     */
    isInited: boolean;
    /**
     * @generated from protobuf field: repeated AbilityScalarValueEntry dynamic_value_map = 2;
     */
    dynamicValueMap: AbilityScalarValueEntry[];
    /**
     * @generated from protobuf field: repeated AbilityAppliedAbility applied_abilities = 3;
     */
    appliedAbilities: AbilityAppliedAbility[];
    /**
     * @generated from protobuf field: repeated AbilityAppliedModifier applied_modifiers = 4;
     */
    appliedModifiers: AbilityAppliedModifier[];
    /**
     * @generated from protobuf field: repeated AbilityMixinRecoverInfo mixin_recover_infos = 5;
     */
    mixinRecoverInfos: AbilityMixinRecoverInfo[];
    /**
     * @generated from protobuf field: repeated AbilityScalarValueEntry sgv_dynamic_value_map = 6;
     */
    sgvDynamicValueMap: AbilityScalarValueEntry[];
}
/**
 * @generated from protobuf message AchievementInfo
 */
export interface AchievementInfo {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: AchievementInfo.AchievementInfoStatus status = 2;
     */
    status: AchievementInfo_AchievementInfoStatus;
    /**
     * @generated from protobuf field: uint32 current = 3;
     */
    current: number;
    /**
     * @generated from protobuf field: uint32 goal = 4;
     */
    goal: number;
    /**
     * @generated from protobuf field: uint32 achievedate = 5;
     */
    achievedate: number;
}
/**
 * @generated from protobuf enum AchievementInfo.AchievementInfoStatus
 */
export enum AchievementInfo_AchievementInfoStatus {
    /**
     * @generated from protobuf enum value: ACHIEVEMENT_INVALID = 0;
     */
    ACHIEVEMENT_INVALID = 0,
    /**
     * @generated from protobuf enum value: ACHIEVEMENT_UNFINISHED = 1;
     */
    ACHIEVEMENT_UNFINISHED = 1,
    /**
     * @generated from protobuf enum value: ACHIEVEMENT_FINISHED = 2;
     */
    ACHIEVEMENT_FINISHED = 2,
    /**
     * @generated from protobuf enum value: ACHIEVEMENT_POINT_TAKEN = 3;
     */
    ACHIEVEMENT_POINT_TAKEN = 3
}
/**
 * @generated from protobuf message ActivityInfo
 */
export interface ActivityInfo {
    /**
     * @generated from protobuf oneof: Detail
     */
    detail: {
        oneofKind: "samLampInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo sam_lamp_info = 6;
         */
        samLampInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "crucibleInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo crucible_info = 5;
         */
        crucibleInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "salesmanInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo salesman_info = 3;
         */
        salesmanInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "trialAvatarInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo trial_avatar_info = 2;
         */
        trialAvatarInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "deliveryInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo delivery_info = 1673;
         */
        deliveryInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "asterInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo aster_info = 21;
         */
        asterInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "flightInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo flight_info = 25;
         */
        flightInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "dragonSpineInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo dragon_spine_info = 31;
         */
        dragonSpineInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "effigyInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo effigy_info = 32;
         */
        effigyInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "treasureMapInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo treasure_map_info = 35;
         */
        treasureMapInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "blessingInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo blessing_info = 41;
         */
        blessingInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "seaLampInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo sea_lamp_info = 42;
         */
        seaLampInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "expeditionInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo expedition_info = 43;
         */
        expeditionInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "arenaChallengeInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo arena_challenge_info = 44;
         */
        arenaChallengeInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "fleurFairInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo fleur_fair_info = 51;
         */
        fleurFairInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "waterSpiritInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo water_spirit_info = 52;
         */
        waterSpiritInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "challnelerSlabInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo challneler_slab_info = 61;
         */
        challnelerSlabInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "mistTrialActivityInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo mist_trial_activity_info = 62;
         */
        mistTrialActivityInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "hideAndSeekInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo hide_and_seek_info = 63;
         */
        hideAndSeekInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "findHilichurlInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo find_hilichurl_info = 64;
         */
        findHilichurlInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "summerTimeInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo summer_time_info = 65;
         */
        summerTimeInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "buoyantCombatInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo buoyant_combat_info = 66;
         */
        buoyantCombatInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "echoShellInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo echo_shell_info = 67;
         */
        echoShellInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "bounceConjuringInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo bounce_conjuring_info = 68;
         */
        bounceConjuringInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "blitzRushInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo blitz_rush_info = 69;
         */
        blitzRushInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "chessInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo chess_info = 70;
         */
        chessInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "sumoInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo sumo_info = 71;
         */
        sumoInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "moonfinTrialInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo moonfin_trial_info = 72;
         */
        moonfinTrialInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "lunaRiteInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo luna_rite_info = 73;
         */
        lunaRiteInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "plantFlowerInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo plant_flower_info = 74;
         */
        plantFlowerInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "musicGameInfo";
        /**
         * @generated from protobuf field: MusicGameActivityDetailInfo music_game_info = 1612;
         */
        musicGameInfo: MusicGameActivityDetailInfo;
    } | {
        oneofKind: "roguelikeDungoenInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo roguelike_dungoen_info = 76;
         */
        roguelikeDungoenInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: "digInfo";
        /**
         * @generated from protobuf field: ActivityNullDetailInfo dig_info = 77;
         */
        digInfo: ActivityNullDetailInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 activity_id = 12;
     */
    activityId: number;
    /**
     * @generated from protobuf field: uint32 schedule_id = 10;
     */
    scheduleId: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 13;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 11;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 activity_type = 8;
     */
    activityType: number;
    /**
     * @generated from protobuf field: bool is_play_open_anim = 14;
     */
    isPlayOpenAnim: boolean;
    /**
     * @generated from protobuf field: bool is_finished = 7;
     */
    isFinished: boolean;
    /**
     * @generated from protobuf field: bool is_starting = 9;
     */
    isStarting: boolean;
    /**
     * @generated from protobuf field: repeated ActivityWatcherInfo watcher_info_list = 4;
     */
    watcherInfoList: ActivityWatcherInfo[];
    /**
     * @generated from protobuf field: repeated uint32 meet_cond_list = 15;
     */
    meetCondList: number[];
    /**
     * @generated from protobuf field: repeated uint32 expire_cond_list = 1;
     */
    expireCondList: number[];
    /**
     * @generated from protobuf field: uint32 selected_avatar_reward_id = 1394;
     */
    selectedAvatarRewardId: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> activity_coin_map = 1648;
     */
    activityCoinMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 score_limit = 1187;
     */
    scoreLimit: number;
    /**
     * @generated from protobuf field: uint32 cur_score = 527;
     */
    curScore: number;
    /**
     * @generated from protobuf field: repeated uint32 taken_reward_list = 1262;
     */
    takenRewardList: number[];
    /**
     * @generated from protobuf field: bool is_hidden = 110;
     */
    isHidden: boolean;
    /**
     * @generated from protobuf field: uint32 first_day_start_time = 144;
     */
    firstDayStartTime: number;
}
/**
 * @generated from protobuf message ActivityInfoNotify
 */
export interface ActivityInfoNotify {
    /**
     * @generated from protobuf field: ActivityInfo activity_info = 11;
     */
    activityInfo?: ActivityInfo;
}
/**
 * @generated from protobuf message ActivityNullDetailInfo
 */
export interface ActivityNullDetailInfo {
}
/**
 * @generated from protobuf message ActivityScheduleInfo
 */
export interface ActivityScheduleInfo {
    /**
     * @generated from protobuf field: uint32 activity_id = 13;
     */
    activityId: number;
    /**
     * @generated from protobuf field: bool is_open = 9;
     */
    isOpen: boolean;
    /**
     * @generated from protobuf field: uint32 schedule_id = 12;
     */
    scheduleId: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 11;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 4;
     */
    endTime: number;
}
/**
 * @generated from protobuf message ActivityScheduleInfoNotify
 */
export interface ActivityScheduleInfoNotify {
    /**
     * @generated from protobuf field: repeated ActivityScheduleInfo activity_schedule_list = 8;
     */
    activityScheduleList: ActivityScheduleInfo[];
    /**
     * @generated from protobuf field: uint32 remain_fly_sea_lamp_num = 12;
     */
    remainFlySeaLampNum: number;
}
/**
 * @generated from protobuf message ActivityTakeWatcherRewardReq
 */
export interface ActivityTakeWatcherRewardReq {
    /**
     * @generated from protobuf field: uint32 activity_id = 11;
     */
    activityId: number;
    /**
     * @generated from protobuf field: uint32 watcher_id = 7;
     */
    watcherId: number;
}
/**
 * @generated from protobuf message ActivityTakeWatcherRewardRsp
 */
export interface ActivityTakeWatcherRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 activity_id = 8;
     */
    activityId: number;
    /**
     * @generated from protobuf field: uint32 watcher_id = 7;
     */
    watcherId: number;
}
/**
 * @generated from protobuf message ActivityUpdateWatcherNotify
 */
export interface ActivityUpdateWatcherNotify {
    /**
     * @generated from protobuf field: uint32 activity_id = 10;
     */
    activityId: number;
    /**
     * @generated from protobuf field: ActivityWatcherInfo watcher_info = 7;
     */
    watcherInfo?: ActivityWatcherInfo;
}
/**
 * @generated from protobuf message ActivityWatcherInfo
 */
export interface ActivityWatcherInfo {
    /**
     * @generated from protobuf field: uint32 watcher_id = 10;
     */
    watcherId: number;
    /**
     * @generated from protobuf field: uint32 cur_progress = 4;
     */
    curProgress: number;
    /**
     * @generated from protobuf field: uint32 total_progress = 9;
     */
    totalProgress: number;
    /**
     * @generated from protobuf field: bool is_taken_reward = 8;
     */
    isTakenReward: boolean;
}
/**
 * @generated from protobuf message AddQuestContentProgressReq
 */
export interface AddQuestContentProgressReq {
    /**
     * @generated from protobuf field: uint32 content_type = 9;
     */
    contentType: number;
    /**
     * @generated from protobuf field: uint32 param = 13;
     */
    param: number;
    /**
     * @generated from protobuf field: uint32 add_progress = 11;
     */
    addProgress: number;
}
/**
 * @generated from protobuf message AddQuestContentProgressRsp
 */
export interface AddQuestContentProgressRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 content_type = 7;
     */
    contentType: number;
}
/**
 * @generated from protobuf message AdjustTrackingInfo
 */
export interface AdjustTrackingInfo {
    /**
     * @generated from protobuf field: string idfa = 10;
     */
    idfa: string;
    /**
     * @generated from protobuf field: string gps_adid = 6;
     */
    gpsAdid: string;
    /**
     * @generated from protobuf field: string fire_adid = 7;
     */
    fireAdid: string;
    /**
     * @generated from protobuf field: string adid = 9;
     */
    adid: string;
    /**
     * @generated from protobuf field: string event_token = 12;
     */
    eventToken: string;
    /**
     * @generated from protobuf field: string app_token = 13;
     */
    appToken: string;
}
/**
 * @generated from protobuf message AiSkillCdInfo
 */
export interface AiSkillCdInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_cd_map = 1;
     */
    skillCdMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_group_cd_map = 2;
     */
    skillGroupCdMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message AiSyncInfo
 */
export interface AiSyncInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: bool has_path_to_target = 2;
     */
    hasPathToTarget: boolean;
    /**
     * @generated from protobuf field: bool is_self_killing = 3;
     */
    isSelfKilling: boolean;
}
/**
 * @generated from protobuf message AiThreatInfo
 */
export interface AiThreatInfo {
    /**
     * @generated from protobuf field: map<uint32, uint32> ai_threat_map = 1;
     */
    aiThreatMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message AllWidgetDataNotify
 */
export interface AllWidgetDataNotify {
    /**
     * @generated from protobuf field: repeated AnchorPointData anchor_point_list = 12;
     */
    anchorPointList: AnchorPointData[];
    /**
     * @generated from protobuf field: uint32 next_anchor_point_usable_time = 8;
     */
    nextAnchorPointUsableTime: number;
    /**
     * @generated from protobuf field: LunchBoxData lunch_box_data = 5;
     */
    lunchBoxData?: LunchBoxData;
    /**
     * @generated from protobuf field: repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list = 6;
     */
    oneoffGatherPointDetectorDataList: OneoffGatherPointDetectorData[];
    /**
     * @generated from protobuf field: repeated ClientCollectorData client_collector_data_list = 7;
     */
    clientCollectorDataList: ClientCollectorData[];
    /**
     * @generated from protobuf field: repeated WidgetCoolDownData cool_down_group_data_list = 13;
     */
    coolDownGroupDataList: WidgetCoolDownData[];
    /**
     * @generated from protobuf field: repeated WidgetCoolDownData normal_cool_down_data_list = 9;
     */
    normalCoolDownDataList: WidgetCoolDownData[];
    /**
     * @generated from protobuf field: repeated WidgetSlotData slot_list = 11;
     */
    slotList: WidgetSlotData[];
}
/**
 * @generated from protobuf message AnchorPointData
 */
export interface AnchorPointData {
    /**
     * @generated from protobuf field: uint32 anchor_point_id = 1;
     */
    anchorPointId: number;
    /**
     * @generated from protobuf field: Vector pos = 2;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 3;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: uint32 end_time = 4;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 5;
     */
    sceneId: number;
}
/**
 * @generated from protobuf message AnchorPointDataNotify
 */
export interface AnchorPointDataNotify {
    /**
     * @generated from protobuf field: repeated AnchorPointData anchor_point_list = 14;
     */
    anchorPointList: AnchorPointData[];
    /**
     * @generated from protobuf field: uint32 next_usable_time = 6;
     */
    nextUsableTime: number;
}
/**
 * @generated from protobuf message AnchorPointOpReq
 */
export interface AnchorPointOpReq {
    /**
     * @generated from protobuf field: uint32 anchor_point_op_type = 6;
     */
    anchorPointOpType: number;
    /**
     * @generated from protobuf field: uint32 anchor_point_id = 1;
     */
    anchorPointId: number;
}
/**
 * @generated from protobuf enum AnchorPointOpReq.AnchorPointOpType
 */
export enum AnchorPointOpReq_AnchorPointOpType {
    /**
     * @generated from protobuf enum value: ANCHOR_POINT_OP_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ANCHOR_POINT_OP_TYPE_TELEPORT = 1;
     */
    TELEPORT = 1,
    /**
     * @generated from protobuf enum value: ANCHOR_POINT_OP_TYPE_REMOVE = 2;
     */
    REMOVE = 2
}
/**
 * @generated from protobuf message AnchorPointOpRsp
 */
export interface AnchorPointOpRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 anchor_point_op_type = 3;
     */
    anchorPointOpType: number;
    /**
     * @generated from protobuf field: uint32 anchor_point_id = 2;
     */
    anchorPointId: number;
}
/**
 * @generated from protobuf message AnimatorParameterValueInfo
 */
export interface AnimatorParameterValueInfo {
    /**
     * @generated from protobuf field: uint32 para_type = 1;
     */
    paraType: number;
    /**
     * @generated from protobuf oneof: para_val
     */
    paraVal: {
        oneofKind: "intVal";
        /**
         * @generated from protobuf field: int32 int_val = 2;
         */
        intVal: number;
    } | {
        oneofKind: "floatVal";
        /**
         * @generated from protobuf field: float float_val = 3;
         */
        floatVal: number;
    } | {
        oneofKind: "boolVal";
        /**
         * @generated from protobuf field: bool bool_val = 4;
         */
        boolVal: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message AnimatorParameterValueInfoPair
 */
export interface AnimatorParameterValueInfoPair {
    /**
     * @generated from protobuf field: int32 name_id = 1;
     */
    nameId: number;
    /**
     * @generated from protobuf field: AnimatorParameterValueInfo animator_para = 2;
     */
    animatorPara?: AnimatorParameterValueInfo;
}
/**
 * @generated from protobuf message AnnounceData
 */
export interface AnnounceData {
    /**
     * @generated from protobuf field: uint32 config_id = 1;
     */
    configId: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 2;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 3;
     */
    endTime: number;
    /**
     * @generated from protobuf field: string center_system_text = 4;
     */
    centerSystemText: string;
    /**
     * @generated from protobuf field: string count_down_text = 5;
     */
    countDownText: string;
    /**
     * @generated from protobuf field: string dungeon_confirm_text = 6;
     */
    dungeonConfirmText: string;
    /**
     * @generated from protobuf field: uint32 center_system_frequency = 7;
     */
    centerSystemFrequency: number;
    /**
     * @generated from protobuf field: uint32 count_down_frequency = 8;
     */
    countDownFrequency: number;
    /**
     * @generated from protobuf field: bool is_center_system_last_5_every_minutes = 9;
     */
    isCenterSystemLast5EveryMinutes: boolean;
}
/**
 * @generated from protobuf message AskAddFriendNotify
 */
export interface AskAddFriendNotify {
    /**
     * @generated from protobuf field: uint32 target_uid = 13;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: FriendBrief target_friend_brief = 10;
     */
    targetFriendBrief?: FriendBrief;
}
/**
 * @generated from protobuf message AskAddFriendReq
 */
export interface AskAddFriendReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 8;
     */
    targetUid: number;
}
/**
 * @generated from protobuf message AskAddFriendRsp
 */
export interface AskAddFriendRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 14;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint32 param = 13;
     */
    param: number;
}
/**
 * @generated from protobuf message AttackHitEffectResult
 */
export interface AttackHitEffectResult {
    /**
     * @generated from protobuf field: uint32 hit_eff_level = 3;
     */
    hitEffLevel: number;
    /**
     * @generated from protobuf field: float retreat_strength = 15;
     */
    retreatStrength: number;
    /**
     * @generated from protobuf field: float air_strength = 8;
     */
    airStrength: number;
    /**
     * @generated from protobuf field: float hit_halt_time = 2;
     */
    hitHaltTime: number;
    /**
     * @generated from protobuf field: float hit_halt_time_scale = 1;
     */
    hitHaltTimeScale: number;
    /**
     * @generated from protobuf field: uint32 original_hit_eff_level = 4;
     */
    originalHitEffLevel: number;
}
/**
 * @generated from protobuf message AttackResult
 */
export interface AttackResult {
    /**
     * @generated from protobuf field: uint32 attacker_id = 5;
     */
    attackerId: number;
    /**
     * @generated from protobuf field: uint32 defense_id = 10;
     */
    defenseId: number;
    /**
     * @generated from protobuf field: string anim_event_id = 12;
     */
    animEventId: string;
    /**
     * @generated from protobuf field: AbilityIdentifier ability_identifier = 7;
     */
    abilityIdentifier?: AbilityIdentifier;
    /**
     * @generated from protobuf field: float damage = 15;
     */
    damage: number;
    /**
     * @generated from protobuf field: bool is_crit = 14;
     */
    isCrit: boolean;
    /**
     * @generated from protobuf field: HitCollision hit_collision = 9;
     */
    hitCollision?: HitCollision;
    /**
     * @generated from protobuf field: uint32 hit_pos_type = 2;
     */
    hitPosType: number;
    /**
     * @generated from protobuf field: uint32 endure_break = 1;
     */
    endureBreak: number;
    /**
     * @generated from protobuf field: Vector resolved_dir = 8;
     */
    resolvedDir?: Vector;
    /**
     * @generated from protobuf field: int32 hit_retreat_angle_compat = 4;
     */
    hitRetreatAngleCompat: number;
    /**
     * @generated from protobuf field: AttackHitEffectResult hit_eff_result = 11;
     */
    hitEffResult?: AttackHitEffectResult;
    /**
     * @generated from protobuf field: uint32 element_type = 13;
     */
    elementType: number;
    /**
     * @generated from protobuf field: bool use_gadget_damage_action = 1975;
     */
    useGadgetDamageAction: boolean;
    /**
     * @generated from protobuf field: uint32 gadget_damage_action_idx = 1092;
     */
    gadgetDamageActionIdx: number;
    /**
     * @generated from protobuf field: bool is_resist_text = 1855;
     */
    isResistText: boolean;
    /**
     * @generated from protobuf field: uint32 critical_rand = 1064;
     */
    criticalRand: number;
    /**
     * @generated from protobuf field: float element_amplify_rate = 180;
     */
    elementAmplifyRate: number;
    /**
     * @generated from protobuf field: float damage_shield = 1602;
     */
    damageShield: number;
    /**
     * @generated from protobuf field: bool mute_element_hurt = 1725;
     */
    muteElementHurt: boolean;
    /**
     * @generated from protobuf field: uint32 amplify_reaction_type = 1690;
     */
    amplifyReactionType: number;
    /**
     * @generated from protobuf field: uint32 addhurt_reaction_type = 335;
     */
    addhurtReactionType: number;
    /**
     * @generated from protobuf field: uint32 bullet_fly_time_ms = 797;
     */
    bulletFlyTimeMs: number;
    /**
     * @generated from protobuf field: uint32 attack_count = 819;
     */
    attackCount: number;
    /**
     * @generated from protobuf field: uint32 hashed_anim_event_id = 950;
     */
    hashedAnimEventId: number;
    /**
     * @generated from protobuf field: uint32 attack_timestamp_ms = 873;
     */
    attackTimestampMs: number;
    /**
     * @generated from protobuf field: float endure_delta = 1088;
     */
    endureDelta: number;
    /**
     * @generated from protobuf field: uint32 target_type = 531;
     */
    targetType: number;
    /**
     * @generated from protobuf field: float element_durability_attenuation = 1994;
     */
    elementDurabilityAttenuation: number;
    /**
     * @generated from protobuf field: uint32 EGPFEACDCLP = 40 [json_name = "EGPFEACDCLP"];
     */
    eGPFEACDCLP: number;
}
/**
 * @generated from protobuf message AvatarAddNotify
 */
export interface AvatarAddNotify {
    /**
     * @generated from protobuf field: AvatarInfo avatar = 11;
     */
    avatar?: AvatarInfo;
    /**
     * @generated from protobuf field: bool is_in_team = 15;
     */
    isInTeam: boolean;
}
/**
 * @generated from protobuf message AvatarChangeCostumeNotify
 */
export interface AvatarChangeCostumeNotify {
    /**
     * @generated from protobuf field: SceneEntityInfo entity_info = 1;
     */
    entityInfo?: SceneEntityInfo;
}
/**
 * @generated from protobuf message AvatarChangeCostumeReq
 */
export interface AvatarChangeCostumeReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 7;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 costume_id = 8;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message AvatarChangeCostumeRsp
 */
export interface AvatarChangeCostumeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 3;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 costume_id = 1;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message AvatarChangeElementTypeReq
 */
export interface AvatarChangeElementTypeReq {
    /**
     * @generated from protobuf field: uint32 scene_id = 15;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 area_id = 4;
     */
    areaId: number;
}
/**
 * @generated from protobuf message AvatarChangeElementTypeRsp
 */
export interface AvatarChangeElementTypeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
}
/**
 * @generated from protobuf message AvatarDataNotify
 */
export interface AvatarDataNotify {
    /**
     * @generated from protobuf field: repeated AvatarInfo avatar_list = 15;
     */
    avatarList: AvatarInfo[];
    /**
     * @generated from protobuf field: map<uint32, AvatarTeam> avatar_team_map = 6;
     */
    avatarTeamMap: {
        [key: number]: AvatarTeam;
    };
    /**
     * @generated from protobuf field: uint32 cur_avatar_team_id = 2;
     */
    curAvatarTeamId: number;
    /**
     * @generated from protobuf field: fixed64 choose_avatar_guid = 11;
     */
    chooseAvatarGuid: bigint;
    /**
     * @generated from protobuf field: repeated uint64 temp_avatar_guid_list = 14;
     */
    tempAvatarGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated uint32 owned_flycloak_list = 8;
     */
    ownedFlycloakList: number[];
    /**
     * @generated from protobuf field: repeated uint32 owned_costume_list = 7;
     */
    ownedCostumeList: number[];
}
/**
 * @generated from protobuf message AvatarDieAnimationEndReq
 */
export interface AvatarDieAnimationEndReq {
    /**
     * @generated from protobuf field: uint64 die_guid = 14;
     */
    dieGuid: bigint;
    /**
     * @generated from protobuf field: uint32 skill_id = 4;
     */
    skillId: number;
    /**
     * @generated from protobuf field: Vector reborn_pos = 13;
     */
    rebornPos?: Vector;
}
/**
 * @generated from protobuf message AvatarDieAnimationEndRsp
 */
export interface AvatarDieAnimationEndRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 die_guid = 11;
     */
    dieGuid: bigint;
    /**
     * @generated from protobuf field: uint32 skill_id = 13;
     */
    skillId: number;
}
/**
 * @generated from protobuf message AvatarEnterSceneInfo
 */
export interface AvatarEnterSceneInfo {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 1;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 avatar_entity_id = 2;
     */
    avatarEntityId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo avatar_ability_info = 3;
     */
    avatarAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: repeated uint32 buff_id_list = 4;
     */
    buffIdList: number[];
    /**
     * @generated from protobuf field: uint64 weapon_guid = 5;
     */
    weaponGuid: bigint;
    /**
     * @generated from protobuf field: uint32 weapon_entity_id = 6;
     */
    weaponEntityId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo weapon_ability_info = 7;
     */
    weaponAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 8;
     */
    serverBuffList: ServerBuff[];
}
/**
 * @generated from protobuf message AvatarEquipAffixInfo
 */
export interface AvatarEquipAffixInfo {
    /**
     * @generated from protobuf field: uint32 equip_affix_id = 1;
     */
    equipAffixId: number;
    /**
     * @generated from protobuf field: uint32 left_cd_time = 2;
     */
    leftCdTime: number;
}
/**
 * @generated from protobuf message AvatarEquipChangeNotify
 */
export interface AvatarEquipChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 1;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 equip_type = 2;
     */
    equipType: number;
    /**
     * @generated from protobuf field: uint32 item_id = 8;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint64 equip_guid = 4;
     */
    equipGuid: bigint;
    /**
     * @generated from protobuf field: SceneWeaponInfo weapon = 13;
     */
    weapon?: SceneWeaponInfo;
    /**
     * @generated from protobuf field: SceneReliquaryInfo reliquary = 11;
     */
    reliquary?: SceneReliquaryInfo;
}
/**
 * @generated from protobuf message AvatarExcelInfo
 */
export interface AvatarExcelInfo {
    /**
     * @generated from protobuf field: uint64 prefab_path_hash = 1;
     */
    prefabPathHash: bigint;
    /**
     * @generated from protobuf field: uint64 prefab_path_remote_hash = 2;
     */
    prefabPathRemoteHash: bigint;
    /**
     * @generated from protobuf field: uint64 controller_path_hash = 3;
     */
    controllerPathHash: bigint;
    /**
     * @generated from protobuf field: uint64 controller_path_remote_hash = 4;
     */
    controllerPathRemoteHash: bigint;
    /**
     * @generated from protobuf field: uint64 combat_config_hash = 5;
     */
    combatConfigHash: bigint;
}
/**
 * @generated from protobuf message AvatarExpeditionAllDataRsp
 */
export interface AvatarExpeditionAllDataRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: map<uint64, AvatarExpeditionInfo> expedition_info_map = 1;
     */
    expeditionInfoMap: {
        [key: string]: AvatarExpeditionInfo;
    };
    /**
     * @generated from protobuf field: repeated uint32 open_expedition_list = 6;
     */
    openExpeditionList: number[];
    /**
     * @generated from protobuf field: uint32 expedition_count_limit = 7;
     */
    expeditionCountLimit: number;
}
/**
 * @generated from protobuf message AvatarExpeditionCallBackReq
 */
export interface AvatarExpeditionCallBackReq {
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid = 12;
     */
    avatarGuid: bigint[];
}
/**
 * @generated from protobuf message AvatarExpeditionCallBackRsp
 */
export interface AvatarExpeditionCallBackRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: map<uint64, AvatarExpeditionInfo> expedition_info_map = 14;
     */
    expeditionInfoMap: {
        [key: string]: AvatarExpeditionInfo;
    };
}
/**
 * @generated from protobuf message AvatarExpeditionDataNotify
 */
export interface AvatarExpeditionDataNotify {
    /**
     * @generated from protobuf field: map<uint64, AvatarExpeditionInfo> expedition_info_map = 1;
     */
    expeditionInfoMap: {
        [key: string]: AvatarExpeditionInfo;
    };
}
/**
 * @generated from protobuf message AvatarExpeditionGetRewardReq
 */
export interface AvatarExpeditionGetRewardReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 5;
     */
    avatarGuid: bigint;
}
/**
 * @generated from protobuf message AvatarExpeditionGetRewardRsp
 */
export interface AvatarExpeditionGetRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: map<uint64, AvatarExpeditionInfo> expedition_info_map = 5;
     */
    expeditionInfoMap: {
        [key: string]: AvatarExpeditionInfo;
    };
    /**
     * @generated from protobuf field: repeated ItemParam item_list = 6;
     */
    itemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam BNFDDKNNJJH = 2 [json_name = "BNFDDKNNJJH"];
     */
    bNFDDKNNJJH: ItemParam[];
}
/**
 * @generated from protobuf message AvatarExpeditionInfo
 */
export interface AvatarExpeditionInfo {
    /**
     * @generated from protobuf field: AvatarExpeditionState state = 1;
     */
    state: AvatarExpeditionState;
    /**
     * @generated from protobuf field: uint32 exp_id = 2;
     */
    expId: number;
    /**
     * @generated from protobuf field: uint32 hour_time = 3;
     */
    hourTime: number;
    /**
     * @generated from protobuf field: uint32 start_time = 4;
     */
    startTime: number;
    /**
     * @generated from protobuf field: float shorten_ratio = 5;
     */
    shortenRatio: number;
}
/**
 * @generated from protobuf message AvatarExpeditionStartReq
 */
export interface AvatarExpeditionStartReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 8;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 exp_id = 2;
     */
    expId: number;
    /**
     * @generated from protobuf field: uint32 hour_time = 7;
     */
    hourTime: number;
}
/**
 * @generated from protobuf message AvatarExpeditionStartRsp
 */
export interface AvatarExpeditionStartRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: map<uint64, AvatarExpeditionInfo> expedition_info_map = 1;
     */
    expeditionInfoMap: {
        [key: string]: AvatarExpeditionInfo;
    };
}
/**
 * @generated from protobuf message AvatarFetterDataNotify
 */
export interface AvatarFetterDataNotify {
    /**
     * @generated from protobuf field: map<uint64, AvatarFetterInfo> fetter_info_map = 1;
     */
    fetterInfoMap: {
        [key: string]: AvatarFetterInfo;
    };
}
/**
 * @generated from protobuf message AvatarFetterInfo
 */
export interface AvatarFetterInfo {
    /**
     * @generated from protobuf field: uint32 exp_number = 1;
     */
    expNumber: number;
    /**
     * @generated from protobuf field: uint32 exp_level = 2;
     */
    expLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 open_id_list = 3;
     */
    openIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 finish_id_list = 4;
     */
    finishIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 rewarded_fetter_level_list = 5;
     */
    rewardedFetterLevelList: number[];
    /**
     * @generated from protobuf field: repeated FetterData fetter_list = 6;
     */
    fetterList: FetterData[];
}
/**
 * @generated from protobuf message AvatarFetterLevelRewardReq
 */
export interface AvatarFetterLevelRewardReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 15;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 fetter_level = 2;
     */
    fetterLevel: number;
}
/**
 * @generated from protobuf message AvatarFetterLevelRewardRsp
 */
export interface AvatarFetterLevelRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 12;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 fetter_level = 10;
     */
    fetterLevel: number;
    /**
     * @generated from protobuf field: uint32 reward_id = 11;
     */
    rewardId: number;
}
/**
 * @generated from protobuf message AvatarFightPropNotify
 */
export interface AvatarFightPropNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 3;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: map<uint32, float> fight_prop_map = 6;
     */
    fightPropMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message AvatarFightPropUpdateNotify
 */
export interface AvatarFightPropUpdateNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 1;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: map<uint32, float> fight_prop_map = 6;
     */
    fightPropMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message AvatarFlycloakChangeNotify
 */
export interface AvatarFlycloakChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 12;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 flycloak_id = 14;
     */
    flycloakId: number;
}
/**
 * @generated from protobuf message AvatarGainCostumeNotify
 */
export interface AvatarGainCostumeNotify {
    /**
     * @generated from protobuf field: uint32 costume_id = 15;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message AvatarGainFlycloakNotify
 */
export interface AvatarGainFlycloakNotify {
    /**
     * @generated from protobuf field: uint32 flycloak_id = 2;
     */
    flycloakId: number;
}
/**
 * @generated from protobuf message AvatarInfo
 */
export interface AvatarInfo {
    /**
     * @generated from protobuf field: uint32 avatar_id = 1;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint64 guid = 2;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: map<uint32, PropValue> prop_map = 3;
     */
    propMap: {
        [key: number]: PropValue;
    };
    /**
     * @generated from protobuf field: uint32 life_state = 4;
     */
    lifeState: number;
    /**
     * @generated from protobuf field: repeated uint64 equip_guid_list = 5;
     */
    equipGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated uint32 talent_id_list = 6;
     */
    talentIdList: number[];
    /**
     * @generated from protobuf field: map<uint32, float> fight_prop_map = 7;
     */
    fightPropMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: TrialAvatarInfo trial_avatar_info = 9;
     */
    trialAvatarInfo?: TrialAvatarInfo;
    /**
     * @generated from protobuf field: map<uint32, AvatarSkillInfo> skill_map = 10;
     */
    skillMap: {
        [key: number]: AvatarSkillInfo;
    };
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 11;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: AvatarFetterInfo fetter_info = 12;
     */
    fetterInfo?: AvatarFetterInfo;
    /**
     * @generated from protobuf field: uint32 core_proud_skill_level = 13;
     */
    coreProudSkillLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 inherent_proud_skill_list = 14;
     */
    inherentProudSkillList: number[];
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_level_map = 15;
     */
    skillLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: AvatarExpeditionState expedition_state = 16;
     */
    expeditionState: AvatarExpeditionState;
    /**
     * @generated from protobuf field: map<uint32, uint32> proud_skill_extra_level_map = 17;
     */
    proudSkillExtraLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: bool is_focus = 18;
     */
    isFocus: boolean;
    /**
     * @generated from protobuf field: uint32 avatar_type = 19;
     */
    avatarType: number;
    /**
     * @generated from protobuf field: repeated uint32 team_resonance_list = 20;
     */
    teamResonanceList: number[];
    /**
     * @generated from protobuf field: uint32 wearing_flycloak_id = 21;
     */
    wearingFlycloakId: number;
    /**
     * @generated from protobuf field: repeated AvatarEquipAffixInfo equip_affix_list = 22;
     */
    equipAffixList: AvatarEquipAffixInfo[];
    /**
     * @generated from protobuf field: uint32 born_time = 23;
     */
    bornTime: number;
    /**
     * @generated from protobuf field: repeated uint32 pending_promote_reward_list = 24;
     */
    pendingPromoteRewardList: number[];
    /**
     * @generated from protobuf field: uint32 costume_id = 25;
     */
    costumeId: number;
    /**
     * @generated from protobuf field: AvatarExcelInfo excel_info = 26;
     */
    excelInfo?: AvatarExcelInfo;
    /**
     * @generated from protobuf field: uint32 anim_hash = 27;
     */
    animHash: number;
}
/**
 * @generated from protobuf message AvatarLifeStateChangeNotify
 */
export interface AvatarLifeStateChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 8;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 life_state = 15;
     */
    lifeState: number;
    /**
     * @generated from protobuf field: uint32 source_entity_id = 1;
     */
    sourceEntityId: number;
    /**
     * @generated from protobuf field: string attack_tag = 10;
     */
    attackTag: string;
    /**
     * @generated from protobuf field: PlayerDieType die_type = 11;
     */
    dieType: PlayerDieType;
    /**
     * @generated from protobuf field: uint32 move_reliable_seq = 7;
     */
    moveReliableSeq: number;
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 6;
     */
    serverBuffList: ServerBuff[];
}
/**
 * @generated from protobuf message AvatarPromoteGetRewardReq
 */
export interface AvatarPromoteGetRewardReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 12;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 promote_level = 8;
     */
    promoteLevel: number;
}
/**
 * @generated from protobuf message AvatarPromoteGetRewardRsp
 */
export interface AvatarPromoteGetRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 2;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 promote_level = 14;
     */
    promoteLevel: number;
    /**
     * @generated from protobuf field: uint32 reward_id = 1;
     */
    rewardId: number;
}
/**
 * @generated from protobuf message AvatarPromoteReq
 */
export interface AvatarPromoteReq {
    /**
     * @generated from protobuf field: uint64 guid = 9;
     */
    guid: bigint;
}
/**
 * @generated from protobuf message AvatarPromoteRsp
 */
export interface AvatarPromoteRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 guid = 7;
     */
    guid: bigint;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1255;
 * }
 *
 * @generated from protobuf message AvatarPropNotify
 */
export interface AvatarPropNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 4;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: map<uint32, int64> prop_map = 1;
     */
    propMap: {
        [key: number]: bigint;
    };
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1030;
 * }
 *
 * @generated from protobuf message AvatarSkillChangeNotify
 */
export interface AvatarSkillChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 4;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 entity_id = 15;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 5;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: uint32 avatar_skill_id = 2;
     */
    avatarSkillId: number;
    /**
     * @generated from protobuf field: uint32 old_level = 10;
     */
    oldLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 7;
     */
    curLevel: number;
}
/**
 * @generated from protobuf message AvatarSkillDepotChangeNotify
 */
export interface AvatarSkillDepotChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 2;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 9;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: repeated uint32 talent_id_list = 1;
     */
    talentIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 proud_skill_list = 5;
     */
    proudSkillList: number[];
    /**
     * @generated from protobuf field: uint32 core_proud_skill_level = 4;
     */
    coreProudSkillLevel: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_level_map = 10;
     */
    skillLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> proud_skill_extra_level_map = 11;
     */
    proudSkillExtraLevelMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message AvatarSkillInfo
 */
export interface AvatarSkillInfo {
    /**
     * @generated from protobuf field: uint32 pass_cd_time = 1;
     */
    passCdTime: number;
    /**
     * @generated from protobuf field: repeated uint32 full_cd_time_list = 2;
     */
    fullCdTimeList: number[];
    /**
     * @generated from protobuf field: uint32 max_charge_count = 3;
     */
    maxChargeCount: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1035;
 * }
 *
 * @generated from protobuf message AvatarSkillInfoNotify
 */
export interface AvatarSkillInfoNotify {
    /**
     * @generated from protobuf field: uint64 guid = 4;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: map<uint32, AvatarSkillInfo> skill_map = 2;
     */
    skillMap: {
        [key: number]: AvatarSkillInfo;
    };
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1085;
 * }
 *
 * @generated from protobuf message AvatarSkillMaxChargeCountNotify
 */
export interface AvatarSkillMaxChargeCountNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 15;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 skill_id = 2;
     */
    skillId: number;
    /**
     * @generated from protobuf field: uint32 max_charge_count = 1;
     */
    maxChargeCount: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1027;
 * }
 *
 * @generated from protobuf message AvatarSkillUpgradeReq
 */
export interface AvatarSkillUpgradeReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 1;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 avatar_skill_id = 5;
     */
    avatarSkillId: number;
    /**
     * @generated from protobuf field: uint32 old_level = 10;
     */
    oldLevel: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1007;
 * }
 *
 * @generated from protobuf message AvatarSkillUpgradeRsp
 */
export interface AvatarSkillUpgradeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 3;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 10;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 avatar_skill_id = 2;
     */
    avatarSkillId: number;
    /**
     * @generated from protobuf field: uint32 old_level = 5;
     */
    oldLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 7;
     */
    curLevel: number;
}
/**
 * @generated from protobuf message AvatarTeam
 */
export interface AvatarTeam {
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid_list = 9;
     */
    avatarGuidList: bigint[];
    /**
     * @generated from protobuf field: string team_name = 13;
     */
    teamName: string;
}
/**
 * @generated from protobuf message AvatarTeamResonanceInfo
 */
export interface AvatarTeamResonanceInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 2;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: repeated uint32 add_team_resonance_id_list = 3;
     */
    addTeamResonanceIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 del_team_resonance_id_list = 4;
     */
    delTeamResonanceIdList: number[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1713;
 * }
 *
 * @generated from protobuf message AvatarTeamUpdateNotify
 */
export interface AvatarTeamUpdateNotify {
    /**
     * @generated from protobuf field: map<uint32, AvatarTeam> avatar_team_map = 6;
     */
    avatarTeamMap: {
        [key: number]: AvatarTeam;
    };
    /**
     * @generated from protobuf field: repeated uint64 temp_avatar_guid_list = 9;
     */
    tempAvatarGuidList: bigint[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1041;
 * }
 *
 * @generated from protobuf message AvatarUnlockTalentNotify
 */
export interface AvatarUnlockTalentNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 1;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 entity_id = 15;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 talent_id = 13;
     */
    talentId: number;
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 14;
     */
    skillDepotId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1680;
 * }
 *
 * @generated from protobuf message AvatarUpgradeReq
 */
export interface AvatarUpgradeReq {
    /**
     * @generated from protobuf field: uint32 item_id = 9;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint32 count = 12;
     */
    count: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 14;
     */
    avatarGuid: bigint;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1779;
 * }
 *
 * @generated from protobuf message AvatarUpgradeRsp
 */
export interface AvatarUpgradeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 15;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 old_level = 5;
     */
    oldLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 7;
     */
    curLevel: number;
    /**
     * @generated from protobuf field: map<uint32, float> old_fight_prop_map = 2;
     */
    oldFightPropMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, float> cur_fight_prop_map = 4;
     */
    curFightPropMap: {
        [key: number]: number;
    };
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1728;
 * }
 *
 * @generated from protobuf message AvatarWearFlycloakReq
 */
export interface AvatarWearFlycloakReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 11;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 flycloak_id = 9;
     */
    flycloakId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1770;
 * }
 *
 * @generated from protobuf message AvatarWearFlycloakRsp
 */
export interface AvatarWearFlycloakRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 8;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 flycloak_id = 2;
     */
    flycloakId: number;
}
/**
 * @generated from protobuf message BattlePassAllDataNotify
 */
export interface BattlePassAllDataNotify {
    /**
     * @generated from protobuf field: bool have_cur_schedule = 11;
     */
    haveCurSchedule: boolean;
    /**
     * @generated from protobuf field: BattlePassSchedule cur_schedule = 10;
     */
    curSchedule?: BattlePassSchedule;
    /**
     * @generated from protobuf field: repeated BattlePassMission mission_list = 1;
     */
    missionList: BattlePassMission[];
}
/**
 * @generated from protobuf message BattlePassBuySuccNotify
 */
export interface BattlePassBuySuccNotify {
    /**
     * @generated from protobuf field: uint32 schedule_id = 7;
     */
    scheduleId: number;
    /**
     * @generated from protobuf field: uint32 product_play_type = 9;
     */
    productPlayType: number;
    /**
     * @generated from protobuf field: repeated ItemParam item_list = 6;
     */
    itemList: ItemParam[];
    /**
     * @generated from protobuf field: uint32 add_point = 2;
     */
    addPoint: number;
}
/**
 * @generated from protobuf message BattlePassCurScheduleUpdateNotify
 */
export interface BattlePassCurScheduleUpdateNotify {
    /**
     * @generated from protobuf field: bool have_cur_schedule = 9;
     */
    haveCurSchedule: boolean;
    /**
     * @generated from protobuf field: BattlePassSchedule cur_schedule = 15;
     */
    curSchedule?: BattlePassSchedule;
}
/**
 * @generated from protobuf message BattlePassCycle
 */
export interface BattlePassCycle {
    /**
     * @generated from protobuf field: uint32 cycle_idx = 8;
     */
    cycleIdx: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 14;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 9;
     */
    endTime: number;
}
/**
 * @generated from protobuf message BattlePassMission
 */
export interface BattlePassMission {
    /**
     * @generated from protobuf field: uint32 mission_id = 9;
     */
    missionId: number;
    /**
     * @generated from protobuf field: uint32 cur_progress = 2;
     */
    curProgress: number;
    /**
     * @generated from protobuf field: uint32 total_progress = 1;
     */
    totalProgress: number;
    /**
     * @generated from protobuf field: uint32 reward_battle_pass_point = 15;
     */
    rewardBattlePassPoint: number;
    /**
     * @generated from protobuf field: uint32 mission_type = 7;
     */
    missionType: number;
    /**
     * @generated from protobuf field: BattlePassMission.MissionStatus mission_status = 13;
     */
    missionStatus: BattlePassMission_MissionStatus;
}
/**
 * @generated from protobuf enum BattlePassMission.MissionStatus
 */
export enum BattlePassMission_MissionStatus {
    /**
     * @generated from protobuf enum value: MISSION_STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: MISSION_STATUS_UNFINISHED = 1;
     */
    UNFINISHED = 1,
    /**
     * @generated from protobuf enum value: MISSION_STATUS_FINISHED = 2;
     */
    FINISHED = 2,
    /**
     * @generated from protobuf enum value: MISSION_STATUS_POINT_TAKEN = 3;
     */
    POINT_TAKEN = 3
}
/**
 * @generated from protobuf message BattlePassMissionDelNotify
 */
export interface BattlePassMissionDelNotify {
    /**
     * @generated from protobuf field: repeated uint32 del_mission_id_list = 4;
     */
    delMissionIdList: number[];
}
/**
 * @generated from protobuf message BattlePassMissionUpdateNotify
 */
export interface BattlePassMissionUpdateNotify {
    /**
     * @generated from protobuf field: repeated BattlePassMission mission_list = 6;
     */
    missionList: BattlePassMission[];
}
/**
 * @generated from protobuf message BattlePassProduct
 */
export interface BattlePassProduct {
    /**
     * @generated from protobuf field: string normal_product_id = 8;
     */
    normalProductId: string;
    /**
     * @generated from protobuf field: string extra_product_id = 4;
     */
    extraProductId: string;
    /**
     * @generated from protobuf field: string upgrade_product_id = 14;
     */
    upgradeProductId: string;
}
/**
 * @generated from protobuf message BattlePassRewardTag
 */
export interface BattlePassRewardTag {
    /**
     * @generated from protobuf field: BattlePassUnlockStatus unlock_status = 7;
     */
    unlockStatus: BattlePassUnlockStatus;
    /**
     * @generated from protobuf field: uint32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 reward_id = 15;
     */
    rewardId: number;
}
/**
 * @generated from protobuf message BattlePassRewardTakeOption
 */
export interface BattlePassRewardTakeOption {
    /**
     * @generated from protobuf field: BattlePassRewardTag tag = 8;
     */
    tag?: BattlePassRewardTag;
    /**
     * @generated from protobuf field: uint32 option_idx = 5;
     */
    optionIdx: number;
}
/**
 * @generated from protobuf message BattlePassSchedule
 */
export interface BattlePassSchedule {
    /**
     * @generated from protobuf field: uint32 schedule_id = 12;
     */
    scheduleId: number;
    /**
     * @generated from protobuf field: uint32 level = 10;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 point = 7;
     */
    point: number;
    /**
     * @generated from protobuf field: BattlePassUnlockStatus unlock_status = 5;
     */
    unlockStatus: BattlePassUnlockStatus;
    /**
     * @generated from protobuf field: repeated BattlePassRewardTag reward_taken_list = 4;
     */
    rewardTakenList: BattlePassRewardTag[];
    /**
     * @generated from protobuf field: uint32 begin_time = 9;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 1;
     */
    endTime: number;
    /**
     * @generated from protobuf field: BattlePassCycle cur_cycle = 14;
     */
    curCycle?: BattlePassCycle;
    /**
     * @generated from protobuf field: bool is_extra_paid_reward_taken = 8;
     */
    isExtraPaidRewardTaken: boolean;
    /**
     * @generated from protobuf field: BattlePassProduct product_info = 13;
     */
    productInfo?: BattlePassProduct;
    /**
     * @generated from protobuf field: bool is_viewed = 11;
     */
    isViewed: boolean;
    /**
     * @generated from protobuf field: uint32 cur_cycle_points = 3;
     */
    curCyclePoints: number;
    /**
     * @generated from protobuf field: uint32 JPFMGBEBBBJ = 6 [json_name = "JPFMGBEBBBJ"];
     */
    jPFMGBEBBBJ: number;
}
/**
 * @generated from protobuf message Birthday
 */
export interface Birthday {
    /**
     * @generated from protobuf field: uint32 month = 1;
     */
    month: number;
    /**
     * @generated from protobuf field: uint32 day = 2;
     */
    day: number;
}
/**
 * @generated from protobuf message BlockInfo
 */
export interface BlockInfo {
    /**
     * @generated from protobuf field: uint32 block_id = 1;
     */
    blockId: number;
    /**
     * @generated from protobuf field: uint32 data_version = 2;
     */
    dataVersion: number;
    /**
     * @generated from protobuf field: bytes bin_data = 3;
     */
    binData: Uint8Array;
    /**
     * @generated from protobuf field: bool is_dirty = 4;
     */
    isDirty: boolean;
}
/**
 * @generated from protobuf message BlossomBriefInfo
 */
export interface BlossomBriefInfo {
    /**
     * @generated from protobuf field: uint32 refresh_id = 14;
     */
    refreshId: number;
    /**
     * @generated from protobuf field: uint32 circle_camp_id = 5;
     */
    circleCampId: number;
    /**
     * @generated from protobuf field: uint32 city_id = 3;
     */
    cityId: number;
    /**
     * @generated from protobuf field: uint32 resin = 10;
     */
    resin: number;
    /**
     * @generated from protobuf field: Vector pos = 12;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: uint32 reward_id = 15;
     */
    rewardId: number;
    /**
     * @generated from protobuf field: uint32 monster_level = 9;
     */
    monsterLevel: number;
    /**
     * @generated from protobuf field: bool is_guide_opened = 4;
     */
    isGuideOpened: boolean;
    /**
     * @generated from protobuf field: uint32 state = 6;
     */
    state: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 11;
     */
    sceneId: number;
}
/**
 * @generated from protobuf message BlossomChestInfo
 */
export interface BlossomChestInfo {
    /**
     * @generated from protobuf field: uint32 resin = 1;
     */
    resin: number;
    /**
     * @generated from protobuf field: repeated uint32 qualify_uid_list = 2;
     */
    qualifyUidList: number[];
    /**
     * @generated from protobuf field: repeated uint32 remain_uid_list = 3;
     */
    remainUidList: number[];
    /**
     * @generated from protobuf field: uint32 dead_time = 4;
     */
    deadTime: number;
    /**
     * @generated from protobuf field: uint32 blossom_refresh_type = 5;
     */
    blossomRefreshType: number;
    /**
     * @generated from protobuf field: uint32 refresh_id = 6;
     */
    refreshId: number;
}
/**
 * @generated from protobuf message BossChestInfo
 */
export interface BossChestInfo {
    /**
     * @generated from protobuf field: uint32 monster_config_id = 1;
     */
    monsterConfigId: number;
    /**
     * @generated from protobuf field: uint32 resin = 2;
     */
    resin: number;
    /**
     * @generated from protobuf field: repeated uint32 remain_uid_list = 3;
     */
    remainUidList: number[];
    /**
     * @generated from protobuf field: repeated uint32 qualify_uid_list = 4;
     */
    qualifyUidList: number[];
    /**
     * @generated from protobuf field: map<uint32, WeeklyBossResinDiscountInfo> uid_discount_map = 5;
     */
    uidDiscountMap: {
        [key: number]: WeeklyBossResinDiscountInfo;
    };
}
/**
 * @generated from protobuf message BuildingInfo
 */
export interface BuildingInfo {
    /**
     * @generated from protobuf field: uint32 building_id = 1;
     */
    buildingId: number;
    /**
     * @generated from protobuf field: uint32 point_config_id = 2;
     */
    pointConfigId: number;
    /**
     * @generated from protobuf field: uint32 cost = 3;
     */
    cost: number;
    /**
     * @generated from protobuf field: uint32 level = 4;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 refund = 5;
     */
    refund: number;
    /**
     * @generated from protobuf field: uint32 owner_uid = 6;
     */
    ownerUid: number;
}
/**
 * @generated from protobuf message BuyBattlePassLevelReq
 */
export interface BuyBattlePassLevelReq {
    /**
     * @generated from protobuf field: uint32 buy_level = 10;
     */
    buyLevel: number;
}
/**
 * @generated from protobuf message BuyBattlePassLevelRsp
 */
export interface BuyBattlePassLevelRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 buy_level = 6;
     */
    buyLevel: number;
}
/**
 * @generated from protobuf message BuyGoodsReq
 */
export interface BuyGoodsReq {
    /**
     * @generated from protobuf field: uint32 shop_type = 15;
     */
    shopType: number;
    /**
     * @generated from protobuf field: ShopGoods goods = 13;
     */
    goods?: ShopGoods;
    /**
     * @generated from protobuf field: uint32 buy_count = 6;
     */
    buyCount: number;
}
/**
 * @generated from protobuf message BuyGoodsRsp
 */
export interface BuyGoodsRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 shop_type = 12;
     */
    shopType: number;
    /**
     * @generated from protobuf field: ShopGoods goods = 13;
     */
    goods?: ShopGoods;
    /**
     * @generated from protobuf field: uint32 buy_count = 8;
     */
    buyCount: number;
    /**
     * @generated from protobuf field: repeated ShopGoods goods_list = 1;
     */
    goodsList: ShopGoods[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 610;
 * }
 *
 * @generated from protobuf message CalcWeaponUpgradeReturnItemsReq
 */
export interface CalcWeaponUpgradeReturnItemsReq {
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 9;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: repeated uint64 food_weapon_guid_list = 10;
     */
    foodWeaponGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 14;
     */
    itemParamList: ItemParam[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 666;
 * }
 *
 * @generated from protobuf message CalcWeaponUpgradeReturnItemsRsp
 */
export interface CalcWeaponUpgradeReturnItemsRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 10;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 3;
     */
    itemParamList: ItemParam[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1098;
 * }
 *
 * @generated from protobuf message CanUseSkillNotify
 */
export interface CanUseSkillNotify {
    /**
     * @generated from protobuf field: bool is_can_use_skill = 6;
     */
    isCanUseSkill: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 4104;
 * }
 *
 * @generated from protobuf message CardProductRewardNotify
 */
export interface CardProductRewardNotify {
    /**
     * @generated from protobuf field: string product_id = 6;
     */
    productId: string;
    /**
     * @generated from protobuf field: uint32 hcoin = 11;
     */
    hcoin: number;
    /**
     * @generated from protobuf field: uint32 remain_days = 5;
     */
    remainDays: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 963;
 * }
 *
 * @generated from protobuf message ChallengeDataNotify
 */
export interface ChallengeDataNotify {
    /**
     * @generated from protobuf field: uint32 challenge_index = 8;
     */
    challengeIndex: number;
    /**
     * @generated from protobuf field: uint32 param_index = 9;
     */
    paramIndex: number;
    /**
     * @generated from protobuf field: uint32 value = 1;
     */
    value: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1662;
 * }
 *
 * @generated from protobuf message ChangeAvatarReq
 */
export interface ChangeAvatarReq {
    /**
     * @generated from protobuf field: uint64 guid = 5;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 skill_id = 11;
     */
    skillId: number;
    /**
     * @generated from protobuf field: bool is_move = 7;
     */
    isMove: boolean;
    /**
     * @generated from protobuf field: Vector move_pos = 9;
     */
    movePos?: Vector;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1710;
 * }
 *
 * @generated from protobuf message ChangeAvatarRsp
 */
export interface ChangeAvatarRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 cur_guid = 11;
     */
    curGuid: bigint;
    /**
     * @generated from protobuf field: uint32 skill_id = 5;
     */
    skillId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 149;
 * }
 *
 * @generated from protobuf message ChangeGameTimeReq
 */
export interface ChangeGameTimeReq {
    /**
     * @generated from protobuf field: uint32 game_time = 9;
     */
    gameTime: number;
    /**
     * @generated from protobuf field: bool is_force_set = 7;
     */
    isForceSet: boolean;
    /**
     * @generated from protobuf field: uint32 extra_days = 6;
     */
    extraDays: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 182;
 * }
 *
 * @generated from protobuf message ChangeGameTimeRsp
 */
export interface ChangeGameTimeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 cur_game_time = 1;
     */
    curGameTime: number;
    /**
     * @generated from protobuf field: uint32 extra_days = 2;
     */
    extraDays: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1407;
 * }
 *
 * @generated from protobuf message ChangeMailStarNotify
 */
export interface ChangeMailStarNotify {
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 5;
     */
    mailIdList: number[];
    /**
     * @generated from protobuf field: bool is_star = 9;
     */
    isStar: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1689;
 * }
 *
 * @generated from protobuf message ChangeMpTeamAvatarReq
 */
export interface ChangeMpTeamAvatarReq {
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid_list = 5;
     */
    avatarGuidList: bigint[];
    /**
     * @generated from protobuf field: uint64 cur_avatar_guid = 12;
     */
    curAvatarGuid: bigint;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1617;
 * }
 *
 * @generated from protobuf message ChangeMpTeamAvatarRsp
 */
export interface ChangeMpTeamAvatarRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid_list = 3;
     */
    avatarGuidList: bigint[];
    /**
     * @generated from protobuf field: uint64 cur_avatar_guid = 8;
     */
    curAvatarGuid: bigint;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1762;
 * }
 *
 * @generated from protobuf message ChangeTeamNameReq
 */
export interface ChangeTeamNameReq {
    /**
     * @generated from protobuf field: int32 team_id = 12;
     */
    teamId: number;
    /**
     * @generated from protobuf field: string team_name = 15;
     */
    teamName: string;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1789;
 * }
 *
 * @generated from protobuf message ChangeTeamNameRsp
 */
export interface ChangeTeamNameRsp {
    /**
     * @generated from protobuf field: int32 team_id = 6;
     */
    teamId: number;
    /**
     * @generated from protobuf field: string team_name = 2;
     */
    teamName: string;
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
}
/**
 * @generated from protobuf message ChannelerSlabLoopDungeonResultInfo
 */
export interface ChannelerSlabLoopDungeonResultInfo {
    /**
     * @generated from protobuf field: bool is_success = 11;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_max_score = 8;
     */
    challengeMaxScore: number;
    /**
     * @generated from protobuf field: uint32 dungeon_index = 7;
     */
    dungeonIndex: number;
    /**
     * @generated from protobuf field: bool is_in_time_limit = 10;
     */
    isInTimeLimit: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_score = 12;
     */
    challengeScore: number;
}
/**
 * @generated from protobuf message ChannellerSlabLoopDungeonResultInfo
 */
export interface ChannellerSlabLoopDungeonResultInfo {
    /**
     * @generated from protobuf field: uint32 dungeon_index = 1;
     */
    dungeonIndex: number;
    /**
     * @generated from protobuf field: bool is_success = 2;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_score = 3;
     */
    challengeScore: number;
    /**
     * @generated from protobuf field: uint32 challenge_max_score = 4;
     */
    challengeMaxScore: number;
    /**
     * @generated from protobuf field: bool is_in_time_limit = 5;
     */
    isInTimeLimit: boolean;
}
/**
 * @generated from protobuf message ChapterStateNotify
 */
export interface ChapterStateNotify {
    /**
     * @generated from protobuf field: uint32 chapter_id = 1;
     */
    chapterId: number;
    /**
     * @generated from protobuf field: ChapterState chapter_state = 12;
     */
    chapterState: ChapterState;
    /**
     * @generated from protobuf field: ChapterStateNotify.NeedPlayerLevel need_player_level = 10;
     */
    needPlayerLevel?: ChapterStateNotify_NeedPlayerLevel;
    /**
     * @generated from protobuf field: ChapterStateNotify.NeedBeginTime need_begin_time = 14;
     */
    needBeginTime?: ChapterStateNotify_NeedBeginTime;
}
/**
 * @generated from protobuf message ChapterStateNotify.NeedPlayerLevel
 */
export interface ChapterStateNotify_NeedPlayerLevel {
    /**
     * @generated from protobuf field: bool is_limit = 3;
     */
    isLimit: boolean;
    /**
     * @generated from protobuf field: uint32 config_need_player_level = 10;
     */
    configNeedPlayerLevel: number;
}
/**
 * @generated from protobuf message ChapterStateNotify.NeedBeginTime
 */
export interface ChapterStateNotify_NeedBeginTime {
    /**
     * @generated from protobuf field: bool is_limit = 13;
     */
    isLimit: boolean;
    /**
     * @generated from protobuf field: uint32 config_need_begin_time = 6;
     */
    configNeedBeginTime: number;
}
/**
 * @generated from protobuf message ChatInfo
 */
export interface ChatInfo {
    /**
     * @generated from protobuf field: uint32 time = 10;
     */
    time: number;
    /**
     * @generated from protobuf field: uint32 uid = 2;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 sequence = 13;
     */
    sequence: number;
    /**
     * @generated from protobuf field: uint32 to_uid = 4;
     */
    toUid: number;
    /**
     * @generated from protobuf field: bool is_read = 6;
     */
    isRead: boolean;
    /**
     * @generated from protobuf oneof: content
     */
    content: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 439;
         */
        text: string;
    } | {
        oneofKind: "icon";
        /**
         * @generated from protobuf field: uint32 icon = 960;
         */
        icon: number;
    } | {
        oneofKind: "systemHint";
        /**
         * @generated from protobuf field: ChatInfo.SystemHint system_hint = 1632;
         */
        systemHint: ChatInfo_SystemHint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ChatInfo.SystemHint
 */
export interface ChatInfo_SystemHint {
    /**
     * @generated from protobuf field: uint32 type = 6;
     */
    type: number;
}
/**
 * @generated from protobuf enum ChatInfo.SystemHintType
 */
export enum ChatInfo_SystemHintType {
    /**
     * @generated from protobuf enum value: SYSTEM_HINT_TYPE_CHAT_NONE = 0;
     */
    CHAT_NONE = 0,
    /**
     * @generated from protobuf enum value: SYSTEM_HINT_TYPE_CHAT_ENTER_WORLD = 1;
     */
    CHAT_ENTER_WORLD = 1,
    /**
     * @generated from protobuf enum value: SYSTEM_HINT_TYPE_CHAT_LEAVE_WORLD = 2;
     */
    CHAT_LEAVE_WORLD = 2
}
/**
 * @generated from protobuf message CheckAddItemExceedLimitNotify
 */
export interface CheckAddItemExceedLimitNotify {
    /**
     * @generated from protobuf field: bool is_drop = 1;
     */
    isDrop: boolean;
    /**
     * @generated from protobuf field: repeated uint32 exceeded_item_list = 8;
     */
    exceededItemList: number[];
    /**
     * @generated from protobuf field: repeated uint32 exceeded_item_type_list = 3;
     */
    exceededItemTypeList: number[];
    /**
     * @generated from protobuf field: CheckAddItemExceedLimitNotify.ItemExceedLimitMsgType msg_type = 14;
     */
    msgType: CheckAddItemExceedLimitNotify_ItemExceedLimitMsgType;
}
/**
 * @generated from protobuf enum CheckAddItemExceedLimitNotify.ItemExceedLimitMsgType
 */
export enum CheckAddItemExceedLimitNotify_ItemExceedLimitMsgType {
    /**
     * @generated from protobuf enum value: ITEM_EXCEED_LIMIT_MSG_TYPE_DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * @generated from protobuf enum value: ITEM_EXCEED_LIMIT_MSG_TYPE_TEXT = 1;
     */
    TEXT = 1,
    /**
     * @generated from protobuf enum value: ITEM_EXCEED_LIMIT_MSG_TYPE_DIALOG = 2;
     */
    DIALOG = 2
}
/**
 * @generated from protobuf message ChildQuest
 */
export interface ChildQuest {
    /**
     * @generated from protobuf field: uint32 quest_id = 1;
     */
    questId: number;
    /**
     * @generated from protobuf field: uint32 state = 2;
     */
    state: number;
    /**
     * @generated from protobuf field: uint32 quest_config_id = 3;
     */
    questConfigId: number;
}
/**
 * @generated from protobuf message ChooseCurAvatarTeamReq
 */
export interface ChooseCurAvatarTeamReq {
    /**
     * @generated from protobuf field: uint32 team_id = 14;
     */
    teamId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1673;
 * }
 *
 * @generated from protobuf message ChooseCurAvatarTeamRsp
 */
export interface ChooseCurAvatarTeamRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 cur_team_id = 4;
     */
    curTeamId: number;
}
/**
 * @generated from protobuf message CityInfo
 */
export interface CityInfo {
    /**
     * @generated from protobuf field: uint32 city_id = 14;
     */
    cityId: number;
    /**
     * @generated from protobuf field: uint32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 crystal_num = 12;
     */
    crystalNum: number;
}
/**
 * @generated from protobuf message ClientAbilityChangeNotify
 */
export interface ClientAbilityChangeNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 6;
     */
    entityId: number;
    /**
     * @generated from protobuf field: repeated AbilityInvokeEntry invokes = 8;
     */
    invokes: AbilityInvokeEntry[];
}
/**
 * @generated from protobuf message ClientAbilityInitBeginNotify
 */
export interface ClientAbilityInitBeginNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 1137;
 * }
 *
 * @generated from protobuf message ClientAbilityInitFinishNotify
 */
export interface ClientAbilityInitFinishNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 13;
     */
    entityId: number;
    /**
     * @generated from protobuf field: repeated AbilityInvokeEntry invokes = 9;
     */
    invokes: AbilityInvokeEntry[];
}
/**
 * @generated from protobuf message ClientCollectorData
 */
export interface ClientCollectorData {
    /**
     * @generated from protobuf field: uint32 material_id = 6;
     */
    materialId: number;
    /**
     * @generated from protobuf field: uint32 max_points = 2;
     */
    maxPoints: number;
    /**
     * @generated from protobuf field: uint32 curr_points = 8;
     */
    currPoints: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 4264;
 * }
 *
 * @generated from protobuf message ClientCollectorDataNotify
 */
export interface ClientCollectorDataNotify {
    /**
     * @generated from protobuf field: repeated ClientCollectorData client_collector_data_list = 8;
     */
    clientCollectorDataList: ClientCollectorData[];
}
/**
 * @generated from protobuf message ClientGadgetInfo
 */
export interface ClientGadgetInfo {
    /**
     * @generated from protobuf field: uint32 camp_id = 1;
     */
    campId: number;
    /**
     * @generated from protobuf field: uint32 camp_type = 2;
     */
    campType: number;
    /**
     * @generated from protobuf field: uint64 guid = 3;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 owner_entity_id = 4;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: uint32 target_entity_id = 5;
     */
    targetEntityId: number;
    /**
     * @generated from protobuf field: bool async_load = 6;
     */
    asyncLoad: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 4201;
 * }
 *
 * @generated from protobuf message CodexDataFullNotify
 */
export interface CodexDataFullNotify {
    /**
     * @generated from protobuf field: repeated CodexTypeData type_data_list = 5;
     */
    typeDataList: CodexTypeData[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 4210;
 * }
 *
 * @generated from protobuf message CodexDataUpdateNotify
 */
export interface CodexDataUpdateNotify {
    /**
     * @generated from protobuf field: CodexType type = 3;
     */
    type: CodexType;
    /**
     * @generated from protobuf field: uint32 id = 4;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 weapon_max_promote_level = 12;
     */
    weaponMaxPromoteLevel: number;
}
/**
 * @generated from protobuf message CodexTypeComparer
 */
export interface CodexTypeComparer {
}
/**
 * @generated from protobuf message CodexTypeData
 */
export interface CodexTypeData {
    /**
     * @generated from protobuf field: CodexType type = 3;
     */
    type: CodexType;
    /**
     * @generated from protobuf field: repeated uint32 codex_id_list = 11;
     */
    codexIdList: number[];
    /**
     * @generated from protobuf field: repeated bool have_viewed_list = 7;
     */
    haveViewedList: boolean[];
    /**
     * @generated from protobuf field: map<uint32, uint32> weapon_max_promote_level_map = 12;
     */
    weaponMaxPromoteLevelMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message CombatInvocationsNotify
 */
export interface CombatInvocationsNotify {
    /**
     * @generated from protobuf field: repeated CombatInvokeEntry invoke_list = 4;
     */
    invokeList: CombatInvokeEntry[];
}
/**
 * @generated from protobuf message CombatInvokeEntry
 */
export interface CombatInvokeEntry {
    /**
     * @generated from protobuf field: CombatTypeArgument argument_type = 14;
     */
    argumentType: CombatTypeArgument;
    /**
     * @generated from protobuf field: ForwardType forward_type = 12;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: bytes combat_data = 11;
     */
    combatData: Uint8Array;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 661;
 * }
 *
 * @generated from protobuf message CombineDataNotify
 */
export interface CombineDataNotify {
    /**
     * @generated from protobuf field: repeated uint32 combine_id_list = 5;
     */
    combineIdList: number[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 688;
 * }
 *
 * @generated from protobuf message CombineFormulaDataNotify
 */
export interface CombineFormulaDataNotify {
    /**
     * @generated from protobuf field: uint32 combine_id = 6;
     */
    combineId: number;
    /**
     * @generated from protobuf field: bool is_locked = 5;
     */
    isLocked: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 654;
 * }
 *
 * @generated from protobuf message CombineReq
 */
export interface CombineReq {
    /**
     * @generated from protobuf field: uint32 combine_id = 5;
     */
    combineId: number;
    /**
     * @generated from protobuf field: uint32 combine_count = 3;
     */
    combineCount: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 8;
     */
    avatarGuid: bigint;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 646;
 * }
 *
 * @generated from protobuf message CombineRsp
 */
export interface CombineRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 combine_id = 12;
     */
    combineId: number;
    /**
     * @generated from protobuf field: uint32 combine_count = 6;
     */
    combineCount: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 15;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: repeated ItemParam cost_item_list = 10;
     */
    costItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam result_item_list = 2;
     */
    resultItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam total_random_item_list = 9;
     */
    totalRandomItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam total_return_item_list = 4;
     */
    totalReturnItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam total_extra_item_list = 8;
     */
    totalExtraItemList: ItemParam[];
}
/**
 * @generated from protobuf message CookDataNotify
 */
export interface CookDataNotify {
    /**
     * @generated from protobuf field: uint32 grade = 8;
     */
    grade: number;
    /**
     * @generated from protobuf field: repeated CookRecipeData recipe_data_list = 2;
     */
    recipeDataList: CookRecipeData[];
}
/**
 * @generated from protobuf message CookGradeDataNotify
 */
export interface CookGradeDataNotify {
    /**
     * @generated from protobuf field: uint32 grade = 6;
     */
    grade: number;
}
/**
 * @generated from protobuf message CookRecipeData
 */
export interface CookRecipeData {
    /**
     * @generated from protobuf field: uint32 recipe_id = 6;
     */
    recipeId: number;
    /**
     * @generated from protobuf field: uint32 proficiency = 12;
     */
    proficiency: number;
}
/**
 * @generated from protobuf message CookRecipeDataNotify
 */
export interface CookRecipeDataNotify {
    /**
     * @generated from protobuf field: CookRecipeData recipe_data = 1;
     */
    recipeData?: CookRecipeData;
}
/**
 * @generated from protobuf message CoopCg
 */
export interface CoopCg {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: bool is_unlock = 2;
     */
    isUnlock: boolean;
}
/**
 * @generated from protobuf message CoopChapter
 */
export interface CoopChapter {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: CoopChapter.State state = 2;
     */
    state: CoopChapter_State;
    /**
     * @generated from protobuf field: repeated uint32 lock_reason_list = 3;
     */
    lockReasonList: number[];
    /**
     * @generated from protobuf field: repeated CoopPoint coop_point_list = 4;
     */
    coopPointList: CoopPoint[];
    /**
     * @generated from protobuf field: repeated CoopReward coop_reward_list = 5;
     */
    coopRewardList: CoopReward[];
    /**
     * @generated from protobuf field: repeated CoopCg coop_cg_list = 6;
     */
    coopCgList: CoopCg[];
    /**
     * @generated from protobuf field: uint32 total_end_count = 7;
     */
    totalEndCount: number;
    /**
     * @generated from protobuf field: uint32 finished_end_count = 8;
     */
    finishedEndCount: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> seen_ending_map = 9;
     */
    seenEndingMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: repeated uint32 finish_dialog_list = 10;
     */
    finishDialogList: number[];
}
/**
 * @generated from protobuf enum CoopChapter.State
 */
export enum CoopChapter_State {
    /**
     * @generated from protobuf enum value: STATE_CLOSE = 0;
     */
    CLOSE = 0,
    /**
     * @generated from protobuf enum value: STATE_COND_NOT_MEET = 1;
     */
    COND_NOT_MEET = 1,
    /**
     * @generated from protobuf enum value: STATE_COND_MEET = 2;
     */
    COND_MEET = 2,
    /**
     * @generated from protobuf enum value: STATE_ACCEPT = 3;
     */
    ACCEPT = 3
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 1976;
 * }
 *
 * @generated from protobuf message CoopDataNotify
 */
export interface CoopDataNotify {
    /**
     * @generated from protobuf field: repeated CoopChapter chapter_list = 13;
     */
    chapterList: CoopChapter[];
    /**
     * @generated from protobuf field: bool is_have_progress = 14;
     */
    isHaveProgress: boolean;
    /**
     * @generated from protobuf field: uint32 cur_coop_point = 5;
     */
    curCoopPoint: number;
    /**
     * @generated from protobuf field: repeated uint32 viewed_chapter_list = 2;
     */
    viewedChapterList: number[];
}
/**
 * @generated from protobuf message CoopPoint
 */
export interface CoopPoint {
    /**
     * @generated from protobuf field: uint32 id = 15;
     */
    id: number;
    /**
     * @generated from protobuf field: CoopPoint.State state = 11;
     */
    state: CoopPoint_State;
    /**
     * @generated from protobuf field: uint32 self_confidence = 8;
     */
    selfConfidence: number;
}
/**
 * @generated from protobuf enum CoopPoint.State
 */
export enum CoopPoint_State {
    /**
     * @generated from protobuf enum value: STATE_UNSTARTED = 0;
     */
    UNSTARTED = 0,
    /**
     * @generated from protobuf enum value: STATE_STARTED = 1;
     */
    STARTED = 1,
    /**
     * @generated from protobuf enum value: STATE_FINISHED = 2;
     */
    FINISHED = 2
}
/**
 * @generated from protobuf message CoopReward
 */
export interface CoopReward {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: CoopReward.State state = 2;
     */
    state: CoopReward_State;
}
/**
 * @generated from protobuf enum CoopReward.State
 */
export enum CoopReward_State {
    /**
     * @generated from protobuf enum value: STATE_UNLOCK = 0;
     */
    UNLOCK = 0,
    /**
     * @generated from protobuf enum value: STATE_LOCK = 1;
     */
    LOCK = 1,
    /**
     * @generated from protobuf enum value: STATE_TAKEN = 2;
     */
    TAKEN = 2
}
/**
 * @generated from protobuf message CountDownDelete
 */
export interface CountDownDelete {
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 819;
 * }
 *
 * @generated from protobuf message CreateVehicleReq
 */
export interface CreateVehicleReq {
    /**
     * @generated from protobuf field: uint32 vehicle_id = 9;
     */
    vehicleId: number;
    /**
     * @generated from protobuf field: uint32 scene_point_id = 15;
     */
    scenePointId: number;
    /**
     * @generated from protobuf field: Vector pos = 1;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 7;
     */
    rot?: Vector;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 812;
 * }
 *
 * @generated from protobuf message CreateVehicleRsp
 */
export interface CreateVehicleRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 vehicle_id = 8;
     */
    vehicleId: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 10;
     */
    entityId: number;
}
/**
 * @generated from protobuf message CrystalLinkSettleInfo
 */
export interface CrystalLinkSettleInfo {
    /**
     * @generated from protobuf field: uint32 kill_elite_monster_num = 2;
     */
    killEliteMonsterNum: number;
    /**
     * @generated from protobuf field: uint32 final_score = 6;
     */
    finalScore: number;
    /**
     * @generated from protobuf field: uint32 level_id = 12;
     */
    levelId: number;
    /**
     * @generated from protobuf field: bool is_new_record = 13;
     */
    isNewRecord: boolean;
    /**
     * @generated from protobuf field: uint32 difficulty_id = 9;
     */
    difficultyId: number;
    /**
     * @generated from protobuf field: uint32 kill_normal_mosnter_num = 3;
     */
    killNormalMosnterNum: number;
}
/**
 * @generated from protobuf message CurVehicleInfo
 */
export interface CurVehicleInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 pos = 2;
     */
    pos: number;
}
/**
 * @generated from protobuf message CustomCommonNodeInfo
 */
export interface CustomCommonNodeInfo {
    /**
     * @generated from protobuf field: int32 parent_index = 1;
     */
    parentIndex: number;
    /**
     * @generated from protobuf field: uint32 config_id = 2;
     */
    configId: number;
    /**
     * @generated from protobuf field: string slot_identifier = 3;
     */
    slotIdentifier: string;
}
/**
 * @generated from protobuf message CustomDungeonResultInfo
 */
export interface CustomDungeonResultInfo {
    /**
     * @generated from protobuf field: bool Unk2700_BONNHGKDLFO = 12 [json_name = "Unk2700BONNHGKDLFO"];
     */
    unk2700BONNHGKDLFO: boolean;
    /**
     * @generated from protobuf field: uint32 Unk2700_FBBEJKCDMEI = 9 [json_name = "Unk2700FBBEJKCDMEI"];
     */
    unk2700FBBEJKCDMEI: number;
    /**
     * @generated from protobuf field: repeated Unk2700_FDEGJOCDDGH child_challenge_list = 6;
     */
    childChallengeList: Unk2700_FDEGJOCDDGH[];
    /**
     * @generated from protobuf field: uint64 Unk2700_ONOOJBEABOE = 3 [json_name = "Unk2700ONOOJBEABOE"];
     */
    unk2700ONOOJBEABOE: bigint;
    /**
     * @generated from protobuf field: Unk2700_OCOKILBJIPJ Unk2700_ONCDLPDHFAB = 7 [json_name = "Unk2700ONCDLPDHFAB"];
     */
    unk2700ONCDLPDHFAB: Unk2700_OCOKILBJIPJ;
    /**
     * @generated from protobuf field: uint32 time_cost = 11;
     */
    timeCost: number;
    /**
     * @generated from protobuf field: bool Unk2700_IBDCFAMBGOK = 2 [json_name = "Unk2700IBDCFAMBGOK"];
     */
    unk2700IBDCFAMBGOK: boolean;
    /**
     * @generated from protobuf field: bool Unk2700_HBFLKFOCKBF = 14 [json_name = "Unk2700HBFLKFOCKBF"];
     */
    unk2700HBFLKFOCKBF: boolean;
}
/**
 * @generated from protobuf message CustomGadgetTreeInfo
 */
export interface CustomGadgetTreeInfo {
    /**
     * @generated from protobuf field: repeated CustomCommonNodeInfo node_list = 1;
     */
    nodeList: CustomCommonNodeInfo[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 300;
 * }
 *
 * @generated from protobuf message CutSceneBeginNotify
 */
export interface CutSceneBeginNotify {
    /**
     * @generated from protobuf field: uint32 cutscene_id = 9;
     */
    cutsceneId: number;
    /**
     * @generated from protobuf field: bool is_wait_others = 11;
     */
    isWaitOthers: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 299;
 * }
 *
 * @generated from protobuf message CutSceneEndNotify
 */
export interface CutSceneEndNotify {
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 cutscene_id = 11;
     */
    cutsceneId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 294;
 * }
 *
 * @generated from protobuf message CutSceneFinishNotify
 */
export interface CutSceneFinishNotify {
    /**
     * @generated from protobuf field: uint32 cutscene_id = 14;
     */
    cutsceneId: number;
}
/**
 * @generated from protobuf message DailyDungeonEntryInfo
 */
export interface DailyDungeonEntryInfo {
    /**
     * @generated from protobuf field: uint32 dungeon_entry_id = 3;
     */
    dungeonEntryId: number;
    /**
     * @generated from protobuf field: uint32 dungeon_entry_config_id = 1;
     */
    dungeonEntryConfigId: number;
    /**
     * @generated from protobuf field: uint32 recommend_dungeon_id = 13;
     */
    recommendDungeonId: number;
    /**
     * @generated from protobuf field: DungeonEntryInfo recommend_dungeon_entry_info = 7;
     */
    recommendDungeonEntryInfo?: DungeonEntryInfo;
}
/**
 * @generated from protobuf message DateTimeDelete
 */
export interface DateTimeDelete {
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 4085;
 * }
 *
 * @generated from protobuf message DealAddFriendReq
 */
export interface DealAddFriendReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 7;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: DealAddFriendResultType deal_add_friend_result = 1;
     */
    dealAddFriendResult: DealAddFriendResultType;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4035;
 * }
 *
 * @generated from protobuf message DealAddFriendRsp
 */
export interface DealAddFriendRsp {
    /**
     * @generated from protobuf field: int32 retcode = 3;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 2;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: DealAddFriendResultType deal_add_friend_result = 15;
     */
    dealAddFriendResult: DealAddFriendResultType;
}
/**
 * @generated from protobuf message DelayWeekCountDownDelete
 */
export interface DelayWeekCountDownDelete {
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4063;
 * }
 *
 * @generated from protobuf message DeleteFriendNotify
 */
export interface DeleteFriendNotify {
    /**
     * @generated from protobuf field: uint32 target_uid = 14;
     */
    targetUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4055;
 * }
 *
 * @generated from protobuf message DeleteFriendReq
 */
export interface DeleteFriendReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 7;
     */
    targetUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4027;
 * }
 *
 * @generated from protobuf message DeleteFriendRsp
 */
export interface DeleteFriendRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 8;
     */
    targetUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1417;
 * }
 *
 * @generated from protobuf message DelMailReq
 */
export interface DelMailReq {
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 6;
     */
    mailIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1485;
 * }
 *
 * @generated from protobuf message DelMailRsp
 */
export interface DelMailRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 4;
     */
    mailIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 302;
 * }
 *
 * @generated from protobuf message DelTeamEntityNotify
 */
export interface DelTeamEntityNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 8;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated uint32 del_entity_id_list = 15;
     */
    delEntityIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 678;
 * }
 *
 * @generated from protobuf message DestroyMaterialReq
 */
export interface DestroyMaterialReq {
    /**
     * @generated from protobuf field: repeated MaterialInfo material_list = 12;
     */
    materialList: MaterialInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 608;
 * }
 *
 * @generated from protobuf message DestroyMaterialRsp
 */
export interface DestroyMaterialRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 item_id_list = 11;
     */
    itemIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 item_count_list = 10;
     */
    itemCountList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1541;
 * }
 *
 * @generated from protobuf message DoGachaReq
 */
export interface DoGachaReq {
    /**
     * @generated from protobuf field: uint32 gacha_type = 10;
     */
    gachaType: number;
    /**
     * @generated from protobuf field: uint32 gacha_times = 15;
     */
    gachaTimes: number;
    /**
     * @generated from protobuf field: uint32 gacha_random = 5;
     */
    gachaRandom: number;
    /**
     * @generated from protobuf field: uint32 gacha_schedule_id = 6;
     */
    gachaScheduleId: number;
    /**
     * @generated from protobuf field: string gacha_tag = 4;
     */
    gachaTag: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1537;
 * }
 *
 * @generated from protobuf message DoGachaRsp
 */
export interface DoGachaRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 gacha_type = 11;
     */
    gachaType: number;
    /**
     * @generated from protobuf field: uint32 gacha_times = 3;
     */
    gachaTimes: number;
    /**
     * @generated from protobuf field: uint32 gacha_schedule_id = 4;
     */
    gachaScheduleId: number;
    /**
     * @generated from protobuf field: repeated GachaItem gacha_item_list = 2;
     */
    gachaItemList: GachaItem[];
    /**
     * @generated from protobuf field: uint32 new_gacha_random = 8;
     */
    newGachaRandom: number;
    /**
     * @generated from protobuf field: uint32 cost_item_id = 6;
     */
    costItemId: number;
    /**
     * @generated from protobuf field: uint32 cost_item_num = 1;
     */
    costItemNum: number;
    /**
     * @generated from protobuf field: uint32 ten_cost_item_id = 14;
     */
    tenCostItemId: number;
    /**
     * @generated from protobuf field: uint32 ten_cost_item_num = 7;
     */
    tenCostItemNum: number;
    /**
     * @generated from protobuf field: uint32 left_gacha_times = 15;
     */
    leftGachaTimes: number;
    /**
     * @generated from protobuf field: uint32 gacha_times_limit = 13;
     */
    gachaTimesLimit: number;
    /**
     * @generated from protobuf field: uint32 wish_item_id = 10;
     */
    wishItemId: number;
    /**
     * @generated from protobuf field: uint32 wish_progress = 5;
     */
    wishProgress: number;
    /**
     * @generated from protobuf field: uint32 wish_max_progress = 12;
     */
    wishMaxProgress: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 622;
 * }
 *
 * @generated from protobuf message DropHintNotify
 */
export interface DropHintNotify {
    /**
     * @generated from protobuf field: repeated uint32 item_id_list = 12;
     */
    itemIdList: number[];
    /**
     * @generated from protobuf field: Vector position = 1;
     */
    position?: Vector;
}
/**
 * @generated from protobuf message DungeonChallengeBeginNotify
 */
export interface DungeonChallengeBeginNotify {
    /**
     * @generated from protobuf field: uint32 challenge_id = 8;
     */
    challengeId: number;
    /**
     * @generated from protobuf field: uint32 challenge_index = 11;
     */
    challengeIndex: number;
    /**
     * @generated from protobuf field: repeated uint32 param_list = 13;
     */
    paramList: number[];
    /**
     * @generated from protobuf field: uint32 group_id = 12;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 father_index = 6;
     */
    fatherIndex: number;
    /**
     * @generated from protobuf field: repeated uint32 uid_list = 9;
     */
    uidList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 986;
 * }
 *
 * @generated from protobuf message DungeonChallengeFinishNotify
 */
export interface DungeonChallengeFinishNotify {
    /**
     * @generated from protobuf oneof: Detail
     */
    detail: {
        oneofKind: "channellerSlabLoopDungeonResultInfo";
        /**
         * @generated from protobuf field: ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info = 1758;
         */
        channellerSlabLoopDungeonResultInfo: ChannellerSlabLoopDungeonResultInfo;
    } | {
        oneofKind: "effigyChallengeDungeonResultInfo";
        /**
         * @generated from protobuf field: EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info = 913;
         */
        effigyChallengeDungeonResultInfo: EffigyChallengeDungeonResultInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 challenge_index = 11;
     */
    challengeIndex: number;
    /**
     * @generated from protobuf field: bool is_success = 4;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: bool is_new_record = 2;
     */
    isNewRecord: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_record_type = 10;
     */
    challengeRecordType: number;
    /**
     * @generated from protobuf field: uint32 current_value = 12;
     */
    currentValue: number;
    /**
     * @generated from protobuf field: map<uint32, StrengthenPointData> strengthen_point_data_map = 13;
     */
    strengthenPointDataMap: {
        [key: number]: StrengthenPointData;
    };
}
/**
 * @generated from protobuf message DungeonDataNotify
 */
export interface DungeonDataNotify {
    /**
     * @generated from protobuf field: map<uint32, uint32> dungeon_data_map = 6;
     */
    dungeonDataMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message DungeonEntryInfo
 */
export interface DungeonEntryInfo {
    /**
     * @generated from protobuf field: uint32 dungeon_id = 8;
     */
    dungeonId: number;
    /**
     * @generated from protobuf field: bool is_passed = 15;
     */
    isPassed: boolean;
    /**
     * @generated from protobuf field: uint32 left_times = 2;
     */
    leftTimes: number;
    /**
     * @generated from protobuf field: uint32 start_time = 7;
     */
    startTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 3;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 max_boss_chest_num = 9;
     */
    maxBossChestNum: number;
    /**
     * @generated from protobuf field: uint32 boss_chest_num = 13;
     */
    bossChestNum: number;
    /**
     * @generated from protobuf field: uint32 next_refresh_time = 10;
     */
    nextRefreshTime: number;
    /**
     * @generated from protobuf field: WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info = 1;
     */
    weeklyBossResinDiscountInfo?: WeeklyBossResinDiscountInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 909;
 * }
 *
 * @generated from protobuf message DungeonEntryInfoReq
 */
export interface DungeonEntryInfoReq {
    /**
     * @generated from protobuf field: uint32 point_id = 15;
     */
    pointId: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 3;
     */
    sceneId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 931;
 * }
 *
 * @generated from protobuf message DungeonEntryInfoRsp
 */
export interface DungeonEntryInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 point_id = 9;
     */
    pointId: number;
    /**
     * @generated from protobuf field: repeated DungeonEntryInfo dungeon_entry_list = 10;
     */
    dungeonEntryList: DungeonEntryInfo[];
    /**
     * @generated from protobuf field: uint32 recommend_dungeon_id = 4;
     */
    recommendDungeonId: number;
}
/**
 * @generated from protobuf message DungeonGetStatueDropRsp
 */
export interface DungeonGetStatueDropRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
}
/**
 * @generated from protobuf message DungeonSettleExhibitionInfo
 */
export interface DungeonSettleExhibitionInfo {
    /**
     * @generated from protobuf field: OnlinePlayerInfo player_info = 3;
     */
    playerInfo?: OnlinePlayerInfo;
    /**
     * @generated from protobuf field: repeated ExhibitionDisplayInfo card_list = 9;
     */
    cardList: ExhibitionDisplayInfo[];
}
/**
 * @generated from protobuf message DungeonSettleNotify
 */
export interface DungeonSettleNotify {
    /**
     * @generated from protobuf field: uint32 dungeon_id = 9;
     */
    dungeonId: number;
    /**
     * @generated from protobuf field: bool is_success = 10;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: repeated uint32 fail_cond_list = 13;
     */
    failCondList: number[];
    /**
     * @generated from protobuf field: map<uint32, ParamList> settle_show = 11;
     */
    settleShow: {
        [key: number]: ParamList;
    };
    /**
     * @generated from protobuf field: uint32 close_time = 12;
     */
    closeTime: number;
    /**
     * @generated from protobuf field: map<uint32, StrengthenPointData> strengthen_point_data_map = 4;
     */
    strengthenPointDataMap: {
        [key: number]: StrengthenPointData;
    };
    /**
     * @generated from protobuf field: uint32 result = 15;
     */
    result: number;
    /**
     * @generated from protobuf field: repeated DungeonSettleExhibitionInfo exhibition_info_list = 14;
     */
    exhibitionInfoList: DungeonSettleExhibitionInfo[];
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "towerLevelEndNotify";
        /**
         * @generated from protobuf field: TowerLevelEndNotify tower_level_end_notify = 97;
         */
        towerLevelEndNotify: TowerLevelEndNotify;
    } | {
        oneofKind: "trialAvatarFirstPassDungeonNotify";
        /**
         * @generated from protobuf field: TrialAvatarFirstPassDungeonNotify trial_avatar_first_pass_dungeon_notify = 796;
         */
        trialAvatarFirstPassDungeonNotify: TrialAvatarFirstPassDungeonNotify;
    } | {
        oneofKind: "channellerSlabLoopDungeonResultInfo";
        /**
         * @generated from protobuf field: ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info = 1671;
         */
        channellerSlabLoopDungeonResultInfo: ChannellerSlabLoopDungeonResultInfo;
    } | {
        oneofKind: "effigyChallengeDungeonResultInfo";
        /**
         * @generated from protobuf field: EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info = 1638;
         */
        effigyChallengeDungeonResultInfo: EffigyChallengeDungeonResultInfo;
    } | {
        oneofKind: "roguelikeDungeonSettleInfo";
        /**
         * @generated from protobuf field: RoguelikeDungeonSettleInfo roguelike_dungeon_settle_info = 71;
         */
        roguelikeDungeonSettleInfo: RoguelikeDungeonSettleInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message DungeonShowReminderNotify
 */
export interface DungeonShowReminderNotify {
    /**
     * @generated from protobuf field: uint32 reminder_id = 10;
     */
    reminderId: number;
}
/**
 * @generated from protobuf message EchoShellInfo
 */
export interface EchoShellInfo {
    /**
     * @generated from protobuf field: uint32 shell_id = 1;
     */
    shellId: number;
}
/**
 * @generated from protobuf message EffigyChallengeDungeonResultInfo
 */
export interface EffigyChallengeDungeonResultInfo {
    /**
     * @generated from protobuf field: uint32 challenge_id = 1;
     */
    challengeId: number;
    /**
     * @generated from protobuf field: bool is_success = 2;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_score = 3;
     */
    challengeScore: number;
    /**
     * @generated from protobuf field: uint32 challenge_max_score = 4;
     */
    challengeMaxScore: number;
    /**
     * @generated from protobuf field: bool is_in_time_limit = 5;
     */
    isInTimeLimit: boolean;
}
/**
 * @generated from protobuf message EnterSceneDoneRsp
 */
export interface EnterSceneDoneRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 8;
     */
    enterSceneToken: number;
}
/**
 * @generated from protobuf message EnterScenePeerNotify
 */
export interface EnterScenePeerNotify {
    /**
     * @generated from protobuf field: uint32 dest_scene_id = 13;
     */
    destSceneId: number;
    /**
     * @generated from protobuf field: uint32 peer_id = 11;
     */
    peerId: number;
    /**
     * @generated from protobuf field: uint32 host_peer_id = 6;
     */
    hostPeerId: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 15;
     */
    enterSceneToken: number;
}
/**
 * @generated from protobuf message EnterSceneReadyRsp
 */
export interface EnterSceneReadyRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 8;
     */
    enterSceneToken: number;
}
/**
 * @generated from protobuf message EnterTransPointRegionNotify
 */
export interface EnterTransPointRegionNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 15;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 point_id = 12;
     */
    pointId: number;
}
/**
 * @generated from protobuf message EnterWorldAreaReq
 */
export interface EnterWorldAreaReq {
    /**
     * @generated from protobuf field: uint32 area_type = 12;
     */
    areaType: number;
    /**
     * @generated from protobuf field: uint32 area_id = 10;
     */
    areaId: number;
}
/**
 * @generated from protobuf message EnterWorldAreaRsp
 */
export interface EnterWorldAreaRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 area_type = 2;
     */
    areaType: number;
    /**
     * @generated from protobuf field: uint32 area_id = 4;
     */
    areaId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 343;
 * }
 *
 * @generated from protobuf message EntityAiSyncNotify
 */
export interface EntityAiSyncNotify {
    /**
     * @generated from protobuf field: repeated AiSyncInfo info_list = 1;
     */
    infoList: AiSyncInfo[];
    /**
     * @generated from protobuf field: repeated uint32 local_avatar_alerted_monster_list = 10;
     */
    localAvatarAlertedMonsterList: number[];
}
/**
 * @generated from protobuf message EntityAuthorityInfo
 */
export interface EntityAuthorityInfo {
    /**
     * @generated from protobuf field: AbilitySyncStateInfo ability_info = 1;
     */
    abilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: EntityRendererChangedInfo renderer_changed_info = 2;
     */
    rendererChangedInfo?: EntityRendererChangedInfo;
    /**
     * @generated from protobuf field: SceneEntityAiInfo ai_info = 3;
     */
    aiInfo?: SceneEntityAiInfo;
    /**
     * @generated from protobuf field: Vector born_pos = 4;
     */
    bornPos?: Vector;
    /**
     * @generated from protobuf field: repeated AnimatorParameterValueInfoPair pose_para_list = 5;
     */
    poseParaList: AnimatorParameterValueInfoPair[];
}
/**
 * @generated from protobuf message EntityClientData
 */
export interface EntityClientData {
    /**
     * @generated from protobuf field: uint32 wind_change_scene_time = 1;
     */
    windChangeSceneTime: number;
    /**
     * @generated from protobuf field: float windmill_sync_angle = 2;
     */
    windmillSyncAngle: number;
    /**
     * @generated from protobuf field: int32 wind_change_target_level = 3;
     */
    windChangeTargetLevel: number;
}
/**
 * @generated from protobuf message EntityEnvironmentInfo
 */
export interface EntityEnvironmentInfo {
    /**
     * @generated from protobuf field: uint32 json_climate_type = 1;
     */
    jsonClimateType: number;
    /**
     * @generated from protobuf field: uint32 climate_area_id = 2;
     */
    climateAreaId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1285;
 * }
 *
 * @generated from protobuf message EntityFightPropChangeReasonNotify
 */
export interface EntityFightPropChangeReasonNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 11;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 prop_type = 6;
     */
    propType: number;
    /**
     * @generated from protobuf field: float prop_delta = 9;
     */
    propDelta: number;
    /**
     * @generated from protobuf field: PropChangeReason reason = 5;
     */
    reason: PropChangeReason;
    /**
     * @generated from protobuf field: repeated uint32 param_list = 10;
     */
    paramList: number[];
    /**
     * @generated from protobuf field: ChangeHpReason change_hp_reason = 12;
     */
    changeHpReason: ChangeHpReason;
    /**
     * @generated from protobuf field: ChangeEnergyReason change_energy_reson = 4;
     */
    changeEnergyReson: ChangeEnergyReason;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1237;
 * }
 *
 * @generated from protobuf message EntityFightPropUpdateNotify
 */
export interface EntityFightPropUpdateNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: map<uint32, float> fight_prop_map = 8;
     */
    fightPropMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message EntityMoveInfo
 */
export interface EntityMoveInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: MotionInfo motion_info = 2;
     */
    motionInfo?: MotionInfo;
    /**
     * @generated from protobuf field: uint32 scene_time = 3;
     */
    sceneTime: number;
    /**
     * @generated from protobuf field: uint32 reliable_seq = 4;
     */
    reliableSeq: number;
    /**
     * @generated from protobuf field: bool is_reliable = 5;
     */
    isReliable: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1209;
 * }
 *
 * @generated from protobuf message EntityPropNotify
 */
export interface EntityPropNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 5;
     */
    entityId: number;
    /**
     * @generated from protobuf field: map<uint32, PropValue> prop_map = 4;
     */
    propMap: {
        [key: number]: PropValue;
    };
}
/**
 * @generated from protobuf message EntityRendererChangedInfo
 */
export interface EntityRendererChangedInfo {
    /**
     * @generated from protobuf field: map<string, uint32> changed_renderers = 1;
     */
    changedRenderers: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: uint32 visibility_count = 2;
     */
    visibilityCount: number;
    /**
     * @generated from protobuf field: bool is_cached = 3;
     */
    isCached: boolean;
}
/**
 * @generated from protobuf message Equip
 */
export interface Equip {
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "reliquary";
        /**
         * @generated from protobuf field: Reliquary reliquary = 1;
         */
        reliquary: Reliquary;
    } | {
        oneofKind: "weapon";
        /**
         * @generated from protobuf field: Weapon weapon = 2;
         */
        weapon: Weapon;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool is_locked = 3;
     */
    isLocked: boolean;
}
/**
 * @generated from protobuf message EquipParam
 */
export interface EquipParam {
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint32 item_num = 2;
     */
    itemNum: number;
    /**
     * @generated from protobuf field: uint32 item_level = 3;
     */
    itemLevel: number;
    /**
     * @generated from protobuf field: uint32 promote_level = 4;
     */
    promoteLevel: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 360;
 * }
 *
 * @generated from protobuf message EvtAiSyncCombatThreatInfoNotify
 */
export interface EvtAiSyncCombatThreatInfoNotify {
    /**
     * @generated from protobuf field: map<uint32, AiThreatInfo> combat_threat_info_map = 14;
     */
    combatThreatInfoMap: {
        [key: number]: AiThreatInfo;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 333;
 * }
 *
 * @generated from protobuf message EvtAiSyncSkillCdNotify
 */
export interface EvtAiSyncSkillCdNotify {
    /**
     * @generated from protobuf field: map<uint32, AiSkillCdInfo> ai_cd_map = 5;
     */
    aiCdMap: {
        [key: number]: AiSkillCdInfo;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 308;
 * }
 *
 * @generated from protobuf message EvtAvatarLockChairReq
 */
export interface EvtAvatarLockChairReq {
    /**
     * @generated from protobuf field: uint64 chair_id = 10;
     */
    chairId: bigint;
    /**
     * @generated from protobuf field: Vector position = 3;
     */
    position?: Vector;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 304;
 * }
 *
 * @generated from protobuf message EvtAvatarLockChairRsp
 */
export interface EvtAvatarLockChairRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 4;
     */
    entityId: number;
    /**
     * @generated from protobuf field: Vector position = 12;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: uint64 chair_id = 15;
     */
    chairId: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 359;
 * }
 *
 * @generated from protobuf message EvtAvatarSitDownNotify
 */
export interface EvtAvatarSitDownNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 10;
     */
    entityId: number;
    /**
     * @generated from protobuf field: Vector position = 5;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: uint64 chair_id = 8;
     */
    chairId: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 384;
 * }
 *
 * @generated from protobuf message EvtAvatarStandUpNotify
 */
export interface EvtAvatarStandUpNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 10;
     */
    entityId: number;
    /**
     * @generated from protobuf field: int32 direction = 3;
     */
    direction: number;
    /**
     * @generated from protobuf field: int32 perform_id = 8;
     */
    performId: number;
    /**
     * @generated from protobuf field: uint64 chair_id = 11;
     */
    chairId: bigint;
}
/**
 * @generated from protobuf message EvtBeingHitInfo
 */
export interface EvtBeingHitInfo {
    /**
     * @generated from protobuf field: uint32 peer_id = 12;
     */
    peerId: number;
    /**
     * @generated from protobuf field: AttackResult attack_result = 8;
     */
    attackResult?: AttackResult;
    /**
     * @generated from protobuf field: uint32 frame_num = 3;
     */
    frameNum: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 309;
 * }
 *
 * @generated from protobuf message EvtBeingHitNotify
 */
export interface EvtBeingHitNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 13;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: EvtBeingHitInfo being_hit_info = 7;
     */
    beingHitInfo?: EvtBeingHitInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 336;
 * }
 *
 * @generated from protobuf message EvtBeingHitsCombineNotify
 */
export interface EvtBeingHitsCombineNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 1;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: repeated EvtBeingHitInfo evt_being_hit_info_list = 14;
     */
    evtBeingHitInfoList: EvtBeingHitInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 332;
 * }
 *
 * @generated from protobuf message EvtCreateGadgetNotify
 */
export interface EvtCreateGadgetNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 8;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: uint32 entity_id = 14;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 11;
     */
    configId: number;
    /**
     * @generated from protobuf field: uint32 camp_id = 13;
     */
    campId: number;
    /**
     * @generated from protobuf field: uint32 camp_type = 3;
     */
    campType: number;
    /**
     * @generated from protobuf field: Vector init_pos = 15;
     */
    initPos?: Vector;
    /**
     * @generated from protobuf field: Vector init_euler_angles = 5;
     */
    initEulerAngles?: Vector;
    /**
     * @generated from protobuf field: uint64 guid = 1;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 owner_entity_id = 2;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: uint32 target_entity_id = 7;
     */
    targetEntityId: number;
    /**
     * @generated from protobuf field: bool is_async_load = 9;
     */
    isAsyncLoad: boolean;
    /**
     * @generated from protobuf field: uint32 target_lock_point_index = 4;
     */
    targetLockPointIndex: number;
    /**
     * @generated from protobuf field: uint32 room_id = 10;
     */
    roomId: number;
    /**
     * @generated from protobuf field: uint32 prop_owner_entity_id = 6;
     */
    propOwnerEntityId: number;
    /**
     * @generated from protobuf field: bool sight_group_with_owner = 12;
     */
    sightGroupWithOwner: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 317;
 * }
 *
 * @generated from protobuf message EvtDestroyGadgetNotify
 */
export interface EvtDestroyGadgetNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 10;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 337;
 * }
 *
 * @generated from protobuf message EvtDoSkillSuccNotify
 */
export interface EvtDoSkillSuccNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 6;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: uint32 caster_id = 10;
     */
    casterId: number;
    /**
     * @generated from protobuf field: uint32 skill_id = 1;
     */
    skillId: number;
    /**
     * @generated from protobuf field: Vector forward = 8;
     */
    forward?: Vector;
}
/**
 * @generated from protobuf message EvtEntityRenderersChangedNotify
 */
export interface EvtEntityRenderersChangedNotify {
    /**
     * @generated from protobuf field: ForwardType forward_type = 2;
     */
    forwardType: ForwardType;
    /**
     * @generated from protobuf field: uint32 entity_id = 7;
     */
    entityId: number;
    /**
     * @generated from protobuf field: bool is_server_cache = 15;
     */
    isServerCache: boolean;
    /**
     * @generated from protobuf field: EntityRendererChangedInfo renderer_changed_info = 3;
     */
    rendererChangedInfo?: EntityRendererChangedInfo;
}
/**
 * @generated from protobuf message EvtHittingOtherInfo
 */
export interface EvtHittingOtherInfo {
    /**
     * @generated from protobuf field: uint32 peer_id = 1;
     */
    peerId: number;
    /**
     * @generated from protobuf field: AttackResult attack_result = 2;
     */
    attackResult?: AttackResult;
}
/**
 * @generated from protobuf message ExhibitionDisplayInfo
 */
export interface ExhibitionDisplayInfo {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 param = 2;
     */
    param: number;
    /**
     * @generated from protobuf field: uint32 detail_param = 3;
     */
    detailParam: number;
}
/**
 * @generated from protobuf message FeatureBlockInfo
 */
export interface FeatureBlockInfo {
    /**
     * @generated from protobuf field: uint32 feature_type = 1;
     */
    featureType: number;
    /**
     * @generated from protobuf field: uint32 end_time = 2;
     */
    endTime: number;
}
/**
 * @generated from protobuf message FetterData
 */
export interface FetterData {
    /**
     * @generated from protobuf field: uint32 fetter_id = 1;
     */
    fetterId: number;
    /**
     * @generated from protobuf field: uint32 fetter_state = 2;
     */
    fetterState: number;
    /**
     * @generated from protobuf field: repeated uint32 cond_index_list = 3;
     */
    condIndexList: number[];
}
/**
 * @generated from protobuf message FightPropPair
 */
export interface FightPropPair {
    /**
     * @generated from protobuf field: uint32 prop_type = 1;
     */
    propType: number;
    /**
     * @generated from protobuf field: float prop_value = 2;
     */
    propValue: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 437;
 * }
 *
 * @generated from protobuf message FinishedParentQuestNotify
 */
export interface FinishedParentQuestNotify {
    /**
     * @generated from protobuf field: repeated ParentQuest parent_quest_list = 12;
     */
    parentQuestList: ParentQuest[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 432;
 * }
 *
 * @generated from protobuf message FinishedParentQuestUpdateNotify
 */
export interface FinishedParentQuestUpdateNotify {
    /**
     * @generated from protobuf field: repeated ParentQuest parent_quest_list = 6;
     */
    parentQuestList: ParentQuest[];
}
/**
 * @generated from protobuf message FireWorkData
 */
export interface FireWorkData {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: repeated FireWorkInstance fireWorkInstance = 2;
     */
    fireWorkInstance: FireWorkInstance[];
}
/**
 * @generated from protobuf message FireWorkInstance
 */
export interface FireWorkInstance {
    /**
     * @generated from protobuf field: FireWorkType type = 1;
     */
    type: FireWorkType;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message FireWorkNotify
 */
export interface FireWorkNotify {
    /**
     * @generated from protobuf field: repeated FireWorkData fireWorkData = 1;
     */
    fireWorkData: FireWorkData[];
}
/**
 * @generated from protobuf message FireWorkReq
 */
export interface FireWorkReq {
    /**
     * @generated from protobuf field: FireWorkData fireWorkData = 7;
     */
    fireWorkData?: FireWorkData;
}
/**
 * @generated from protobuf message FireWorkRsp
 */
export interface FireWorkRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
}
/**
 * @generated from protobuf message FireworkSetData
 */
export interface FireworkSetData {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: repeated uint32 _unknown_field_ = 2;
     */
    UnknownField: number[];
    /**
     * @generated from protobuf field: repeated FireWorkInstance fireWorkInstance = 3;
     */
    fireWorkInstance: FireWorkInstance[];
}
/**
 * @generated from protobuf message FireworkSetNotify
 */
export interface FireworkSetNotify {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated FireworkSetData data = 9;
     */
    data: FireworkSetData[];
}
/**
 * @generated from protobuf message FireworkSetReq
 */
export interface FireworkSetReq {
    /**
     * @generated from protobuf field: FireworkSetData data = 2;
     */
    data?: FireworkSetData;
}
/**
 * @generated from protobuf message NBFJOJPCCEK_Rsp
 */
export interface NBFJOJPCCEK_Rsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
}
/**
 * @generated from protobuf message FishPoolInfo
 */
export interface FishPoolInfo {
    /**
     * @generated from protobuf field: uint32 pool_id = 1;
     */
    poolId: number;
    /**
     * @generated from protobuf field: repeated uint32 fish_area_list = 2;
     */
    fishAreaList: number[];
    /**
     * @generated from protobuf field: uint32 today_fish_num = 3;
     */
    todayFishNum: number;
}
/**
 * @generated from protobuf message ForceUpdateInfo
 */
export interface ForceUpdateInfo {
    /**
     * @generated from protobuf field: string force_update_url = 1;
     */
    forceUpdateUrl: string;
}
/**
 * @generated from protobuf message ForgeDataNotify
 */
export interface ForgeDataNotify {
    /**
     * @generated from protobuf field: repeated uint32 forge_id_list = 13;
     */
    forgeIdList: number[];
    /**
     * @generated from protobuf field: uint32 max_queue_num = 15;
     */
    maxQueueNum: number;
    /**
     * @generated from protobuf field: map<uint32, ForgeQueueData> forge_queue_map = 1;
     */
    forgeQueueMap: {
        [key: number]: ForgeQueueData;
    };
}
/**
 * @generated from protobuf message ForgeFormulaDataNotify
 */
export interface ForgeFormulaDataNotify {
    /**
     * @generated from protobuf field: uint32 forge_id = 11;
     */
    forgeId: number;
    /**
     * @generated from protobuf field: bool is_locked = 8;
     */
    isLocked: boolean;
}
/**
 * @generated from protobuf message ForgeGetQueueDataRsp
 */
export interface ForgeGetQueueDataRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 max_queue_num = 13;
     */
    maxQueueNum: number;
    /**
     * @generated from protobuf field: map<uint32, ForgeQueueData> forge_queue_map = 11;
     */
    forgeQueueMap: {
        [key: number]: ForgeQueueData;
    };
}
/**
 * @generated from protobuf message ForgeQueueData
 */
export interface ForgeQueueData {
    /**
     * @generated from protobuf field: uint32 queue_id = 1;
     */
    queueId: number;
    /**
     * @generated from protobuf field: uint32 forge_id = 2;
     */
    forgeId: number;
    /**
     * @generated from protobuf field: uint32 finish_count = 3;
     */
    finishCount: number;
    /**
     * @generated from protobuf field: uint32 unfinish_count = 4;
     */
    unfinishCount: number;
    /**
     * @generated from protobuf field: uint32 next_finish_timestamp = 5;
     */
    nextFinishTimestamp: number;
    /**
     * @generated from protobuf field: uint32 total_finish_timestamp = 6;
     */
    totalFinishTimestamp: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 7;
     */
    avatarId: number;
}
/**
 * @generated from protobuf message ForgeQueueDataNotify
 */
export interface ForgeQueueDataNotify {
    /**
     * @generated from protobuf field: map<uint32, ForgeQueueData> forge_queue_map = 14;
     */
    forgeQueueMap: {
        [key: number]: ForgeQueueData;
    };
    /**
     * @generated from protobuf field: repeated uint32 removed_forge_queue_list = 8;
     */
    removedForgeQueueList: number[];
}
/**
 * @generated from protobuf message ForgeQueueManipulateReq
 */
export interface ForgeQueueManipulateReq {
    /**
     * @generated from protobuf field: uint32 forge_queue_id = 11;
     */
    forgeQueueId: number;
    /**
     * @generated from protobuf field: ForgeQueueManipulateType manipulate_type = 7;
     */
    manipulateType: ForgeQueueManipulateType;
}
/**
 * @generated from protobuf message ForgeQueueManipulateRsp
 */
export interface ForgeQueueManipulateRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: ForgeQueueManipulateType manipulate_type = 8;
     */
    manipulateType: ForgeQueueManipulateType;
    /**
     * @generated from protobuf field: repeated ItemParam output_item_list = 6;
     */
    outputItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam return_item_list = 10;
     */
    returnItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam extra_output_item_list = 3;
     */
    extraOutputItemList: ItemParam[];
}
/**
 * @generated from protobuf message ForgeStartReq
 */
export interface ForgeStartReq {
    /**
     * @generated from protobuf field: uint32 forge_id = 9;
     */
    forgeId: number;
    /**
     * @generated from protobuf field: uint32 forge_count = 11;
     */
    forgeCount: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 13;
     */
    avatarId: number;
}
/**
 * @generated from protobuf message ForgeStartRsp
 */
export interface ForgeStartRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
}
/**
 * @generated from protobuf message FoundationInfo
 */
export interface FoundationInfo {
    /**
     * @generated from protobuf field: FoundationStatus status = 1;
     */
    status: FoundationStatus;
    /**
     * @generated from protobuf field: repeated uint32 uid_list = 2;
     */
    uidList: number[];
    /**
     * @generated from protobuf field: uint32 current_building_id = 3;
     */
    currentBuildingId: number;
    /**
     * @generated from protobuf field: uint32 begin_build_time_ms = 4;
     */
    beginBuildTimeMs: number;
    /**
     * @generated from protobuf field: uint32 demolition_refund = 5;
     */
    demolitionRefund: number;
    /**
     * @generated from protobuf field: repeated BuildingInfo building_list = 6;
     */
    buildingList: BuildingInfo[];
    /**
     * @generated from protobuf field: uint32 current_num = 7;
     */
    currentNum: number;
    /**
     * @generated from protobuf field: uint32 max_num = 8;
     */
    maxNum: number;
    /**
     * @generated from protobuf field: uint32 locked_by_uid = 9;
     */
    lockedByUid: number;
}
/**
 * @generated from protobuf message FriendBrief
 */
export interface FriendBrief {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: string nickname = 2;
     */
    nickname: string;
    /**
     * @generated from protobuf field: uint32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 4;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint32 world_level = 5;
     */
    worldLevel: number;
    /**
     * @generated from protobuf field: string signature = 6;
     */
    signature: string;
    /**
     * @generated from protobuf field: FriendOnlineState online_state = 7;
     */
    onlineState: FriendOnlineState;
    /**
     * @generated from protobuf field: uint32 param = 8;
     */
    param: number;
    /**
     * @generated from protobuf field: bool is_mp_mode_available = 10;
     */
    isMpModeAvailable: boolean;
    /**
     * @generated from protobuf field: string online_id = 11;
     */
    onlineId: string;
    /**
     * @generated from protobuf field: uint32 last_active_time = 12;
     */
    lastActiveTime: number;
    /**
     * @generated from protobuf field: uint32 name_card_id = 13;
     */
    nameCardId: number;
    /**
     * @generated from protobuf field: uint32 mp_player_num = 14;
     */
    mpPlayerNum: number;
    /**
     * @generated from protobuf field: bool is_chat_no_disturb = 15;
     */
    isChatNoDisturb: boolean;
    /**
     * @generated from protobuf field: uint32 chat_sequence = 16;
     */
    chatSequence: number;
    /**
     * @generated from protobuf field: string remark_name = 17;
     */
    remarkName: string;
    /**
     * @generated from protobuf field: repeated SocialShowAvatarInfo show_avatar_info_list = 22;
     */
    showAvatarInfoList: SocialShowAvatarInfo[];
    /**
     * @generated from protobuf field: FriendEnterHomeOption friend_enter_home_option = 23;
     */
    friendEnterHomeOption: FriendEnterHomeOption;
    /**
     * @generated from protobuf field: ProfilePicture profile_picture = 24;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: bool is_game_source = 25;
     */
    isGameSource: boolean;
    /**
     * @generated from protobuf field: bool is_psn_source = 26;
     */
    isPsnSource: boolean;
    /**
     * @generated from protobuf field: PlatformType platform_type = 27;
     */
    platformType: PlatformType;
}
/**
 * @generated from protobuf message Furniture
 */
export interface Furniture {
    /**
     * @generated from protobuf field: uint32 count = 1;
     */
    count: number;
}
/**
 * @generated from protobuf message FurnitureCurModuleArrangeCountNotify
 */
export interface FurnitureCurModuleArrangeCountNotify {
    /**
     * @generated from protobuf field: repeated Uint32Pair furniture_arrange_count_list = 9;
     */
    furnitureArrangeCountList: Uint32Pair[];
}
/**
 * @generated from protobuf message FurnitureMakeBeHelpedData
 */
export interface FurnitureMakeBeHelpedData {
    /**
     * @generated from protobuf field: string player_name = 9;
     */
    playerName: string;
    /**
     * @generated from protobuf field: uint32 time = 10;
     */
    time: number;
    /**
     * @generated from protobuf field: uint32 uid = 13;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 icon = 8;
     */
    icon: number;
    /**
     * @generated from protobuf field: ProfilePicture profile_picture = 1;
     */
    profilePicture?: ProfilePicture;
}
/**
 * @generated from protobuf message FurnitureMakeData
 */
export interface FurnitureMakeData {
    /**
     * @generated from protobuf field: uint32 index = 9;
     */
    index: number;
    /**
     * @generated from protobuf field: uint32 make_id = 11;
     */
    makeId: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 4;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 dur_time = 7;
     */
    durTime: number;
    /**
     * @generated from protobuf field: uint32 accelerate_time = 1;
     */
    accelerateTime: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 14;
     */
    avatarId: number;
}
/**
 * @generated from protobuf message FurnitureMakeHelpData
 */
export interface FurnitureMakeHelpData {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 times = 11;
     */
    times: number;
}
/**
 * @generated from protobuf message FurnitureMakeMakeInfo
 */
export interface FurnitureMakeMakeInfo {
    /**
     * @generated from protobuf field: uint32 furniture_id = 7;
     */
    furnitureId: number;
    /**
     * @generated from protobuf field: uint32 make_count = 11;
     */
    makeCount: number;
}
/**
 * @generated from protobuf message FurnitureMakeReq
 */
export interface FurnitureMakeReq {
}
/**
 * @generated from protobuf message FurnitureMakeRsp
 */
export interface FurnitureMakeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: FurnitureMakeSlot furniture_make_slot = 10;
     */
    furnitureMakeSlot?: FurnitureMakeSlot;
    /**
     * @generated from protobuf field: repeated FurnitureMakeHelpData help_data_list = 13;
     */
    helpDataList: FurnitureMakeHelpData[];
    /**
     * @generated from protobuf field: repeated FurnitureMakeBeHelpedData helped_data_list = 12;
     */
    helpedDataList: FurnitureMakeBeHelpedData[];
    /**
     * @generated from protobuf field: repeated FurnitureMakeMakeInfo make_info_list = 11;
     */
    makeInfoList: FurnitureMakeMakeInfo[];
}
/**
 * @generated from protobuf message FurnitureMakeSlot
 */
export interface FurnitureMakeSlot {
    /**
     * @generated from protobuf field: repeated FurnitureMakeData furniture_make_data_list = 15;
     */
    furnitureMakeDataList: FurnitureMakeData[];
}
/**
 * @generated from protobuf message FurnitureMakeStartReq
 */
export interface FurnitureMakeStartReq {
    /**
     * @generated from protobuf field: uint32 make_id = 1;
     */
    makeId: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 14;
     */
    avatarId: number;
}
/**
 * @generated from protobuf message FurnitureMakeStartRsp
 */
export interface FurnitureMakeStartRsp {
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
    /**
     * @generated from protobuf field: FurnitureMakeSlot furniture_make_slot = 10;
     */
    furnitureMakeSlot?: FurnitureMakeSlot;
}
/**
 * @generated from protobuf message GachaInfo
 */
export interface GachaInfo {
    /**
     * @generated from protobuf field: uint32 gacha_type = 13;
     */
    gachaType: number;
    /**
     * @generated from protobuf field: uint32 schedule_id = 4;
     */
    scheduleId: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 2;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 6;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 cost_item_id = 10;
     */
    costItemId: number;
    /**
     * @generated from protobuf field: uint32 cost_item_num = 1;
     */
    costItemNum: number;
    /**
     * @generated from protobuf field: string gacha_prefab_path = 11;
     */
    gachaPrefabPath: string;
    /**
     * @generated from protobuf field: string gacha_prob_url = 14;
     */
    gachaProbUrl: string;
    /**
     * @generated from protobuf field: string gacha_record_url = 9;
     */
    gachaRecordUrl: string;
    /**
     * @generated from protobuf field: string gacha_preview_prefab_path = 7;
     */
    gachaPreviewPrefabPath: string;
    /**
     * @generated from protobuf field: uint32 ten_cost_item_id = 8;
     */
    tenCostItemId: number;
    /**
     * @generated from protobuf field: uint32 ten_cost_item_num = 12;
     */
    tenCostItemNum: number;
    /**
     * @generated from protobuf field: uint32 left_gacha_times = 3;
     */
    leftGachaTimes: number;
    /**
     * @generated from protobuf field: uint32 gacha_times_limit = 5;
     */
    gachaTimesLimit: number;
    /**
     * @generated from protobuf field: uint32 gacha_sort_id = 15;
     */
    gachaSortId: number;
    /**
     * @generated from protobuf field: string gacha_prob_url_oversea = 227;
     */
    gachaProbUrlOversea: string;
    /**
     * @generated from protobuf field: string gacha_record_url_oversea = 1995;
     */
    gachaRecordUrlOversea: string;
    /**
     * @generated from protobuf field: repeated GachaUpInfo gacha_up_info_list = 883;
     */
    gachaUpInfoList: GachaUpInfo[];
    /**
     * @generated from protobuf field: string title_textmap = 1044;
     */
    titleTextmap: string;
    /**
     * @generated from protobuf field: repeated uint32 display_up_5_item_list = 1743;
     */
    displayUp5ItemList: number[];
    /**
     * @generated from protobuf field: repeated uint32 display_up_4_item_list = 969;
     */
    displayUp4ItemList: number[];
    /**
     * @generated from protobuf field: uint32 wish_item_id = 1344;
     */
    wishItemId: number;
    /**
     * @generated from protobuf field: uint32 wish_progress = 1519;
     */
    wishProgress: number;
    /**
     * @generated from protobuf field: uint32 wish_max_progress = 219;
     */
    wishMaxProgress: number;
    /**
     * @generated from protobuf field: bool is_new_wish = 472;
     */
    isNewWish: boolean;
}
/**
 * @generated from protobuf message GachaItem
 */
export interface GachaItem {
    /**
     * @generated from protobuf field: ItemParam gacha_item_ = 5;
     */
    gachaItem?: ItemParam;
    /**
     * @generated from protobuf field: repeated GachaTransferItem transfer_items = 3;
     */
    transferItems: GachaTransferItem[];
    /**
     * @generated from protobuf field: bool is_flash_card = 4;
     */
    isFlashCard: boolean;
    /**
     * @generated from protobuf field: bool is_gacha_item_new = 8;
     */
    isGachaItemNew: boolean;
    /**
     * @generated from protobuf field: repeated ItemParam token_item_list = 13;
     */
    tokenItemList: ItemParam[];
}
/**
 * @generated from protobuf message GachaTransferItem
 */
export interface GachaTransferItem {
    /**
     * @generated from protobuf field: ItemParam item = 8;
     */
    item?: ItemParam;
    /**
     * @generated from protobuf field: bool is_transfer_item_new = 13;
     */
    isTransferItemNew: boolean;
}
/**
 * @generated from protobuf message GachaUpInfo
 */
export interface GachaUpInfo {
    /**
     * @generated from protobuf field: uint32 item_parent_type = 12;
     */
    itemParentType: number;
    /**
     * @generated from protobuf field: repeated uint32 item_id_list = 10;
     */
    itemIdList: number[];
}
/**
 * @generated from protobuf message GachaWishReq
 */
export interface GachaWishReq {
    /**
     * @generated from protobuf field: uint32 gacha_type = 2;
     */
    gachaType: number;
    /**
     * @generated from protobuf field: uint32 gacha_schedule_id = 4;
     */
    gachaScheduleId: number;
    /**
     * @generated from protobuf field: uint32 item_id = 14;
     */
    itemId: number;
}
/**
 * @generated from protobuf message GachaWishRsp
 */
export interface GachaWishRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 gacha_type = 14;
     */
    gachaType: number;
    /**
     * @generated from protobuf field: uint32 gacha_schedule_id = 15;
     */
    gachaScheduleId: number;
    /**
     * @generated from protobuf field: uint32 wish_item_id = 3;
     */
    wishItemId: number;
    /**
     * @generated from protobuf field: uint32 wish_progress = 12;
     */
    wishProgress: number;
    /**
     * @generated from protobuf field: uint32 wish_max_progress = 10;
     */
    wishMaxProgress: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 830;
 * }
 *
 * @generated from protobuf message GadgetAutoPickDropInfoNotify
 */
export interface GadgetAutoPickDropInfoNotify {
    /**
     * @generated from protobuf field: repeated Item item_list = 15;
     */
    itemList: Item[];
}
/**
 * @generated from protobuf message GadgetClientParam
 */
export interface GadgetClientParam {
    /**
     * @generated from protobuf field: uint32 campId = 1;
     */
    campId: number;
    /**
     * @generated from protobuf field: uint32 campType = 2;
     */
    campType: number;
    /**
     * @generated from protobuf field: uint64 guid = 3;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 ownerEntityId = 4;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: uint32 targetEntityId = 5;
     */
    targetEntityId: number;
    /**
     * @generated from protobuf field: bool asyncLoad = 6;
     */
    asyncLoad: boolean;
}
/**
 * @generated from protobuf message GadgetCrucibleInfo
 */
export interface GadgetCrucibleInfo {
    /**
     * @generated from protobuf field: uint32 mp_play_id = 1;
     */
    mpPlayId: number;
    /**
     * @generated from protobuf field: uint32 prepare_end_time = 2;
     */
    prepareEndTime: number;
}
/**
 * @generated from protobuf message GadgetGeneralRewardInfo
 */
export interface GadgetGeneralRewardInfo {
    /**
     * @generated from protobuf field: uint32 resin = 1;
     */
    resin: number;
    /**
     * @generated from protobuf field: uint32 dead_time = 2;
     */
    deadTime: number;
    /**
     * @generated from protobuf field: repeated uint32 remain_uid_list = 3;
     */
    remainUidList: number[];
    /**
     * @generated from protobuf field: repeated uint32 qualify_uid_list = 4;
     */
    qualifyUidList: number[];
    /**
     * @generated from protobuf field: ItemParam item_param = 5;
     */
    itemParam?: ItemParam;
}
/**
 * @generated from protobuf message GadgetInteractReq
 */
export interface GadgetInteractReq {
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 9;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: InterOpType op_type = 6;
     */
    opType: InterOpType;
    /**
     * @generated from protobuf field: uint32 gadget_id = 14;
     */
    gadgetId: number;
    /**
     * @generated from protobuf field: bool is_use_condense_resin = 15;
     */
    isUseCondenseResin: boolean;
    /**
     * @generated from protobuf field: ResinCostType resin_cost_type = 11;
     */
    resinCostType: ResinCostType;
    /**
     * @generated from protobuf field: uint32 MPDBGIONLDB = 12 [json_name = "MPDBGIONLDB"];
     */
    mPDBGIONLDB: number;
}
/**
 * @generated from protobuf message GadgetInteractRsp
 */
export interface GadgetInteractRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 6;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: InteractType interact_type = 9;
     */
    interactType: InteractType;
    /**
     * @generated from protobuf field: InterOpType op_type = 1;
     */
    opType: InterOpType;
    /**
     * @generated from protobuf field: uint32 gadget_id = 14;
     */
    gadgetId: number;
}
/**
 * @generated from protobuf message GadgetPlayInfo
 */
export interface GadgetPlayInfo {
    /**
     * @generated from protobuf oneof: PlayInfo
     */
    playInfo: {
        oneofKind: "crucibleInfo";
        /**
         * @generated from protobuf field: GadgetCrucibleInfo crucible_info = 21;
         */
        crucibleInfo: GadgetCrucibleInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 play_type = 1;
     */
    playType: number;
    /**
     * @generated from protobuf field: uint32 duration = 2;
     */
    duration: number;
    /**
     * @generated from protobuf field: repeated uint32 progress_stage_list = 3;
     */
    progressStageList: number[];
    /**
     * @generated from protobuf field: uint32 start_cd = 4;
     */
    startCd: number;
    /**
     * @generated from protobuf field: uint32 start_time = 5;
     */
    startTime: number;
    /**
     * @generated from protobuf field: uint32 progress = 6;
     */
    progress: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 841;
 * }
 *
 * @generated from protobuf message GadgetStateNotify
 */
export interface GadgetStateNotify {
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 2;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: uint32 gadget_state = 11;
     */
    gadgetState: number;
    /**
     * @generated from protobuf field: bool is_enable_interact = 10;
     */
    isEnableInteract: boolean;
}
/**
 * @generated from protobuf message GatherGadgetInfo
 */
export interface GatherGadgetInfo {
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: bool is_forbid_guest = 2;
     */
    isForbidGuest: boolean;
}
/**
 * @generated from protobuf message GetActivityInfoReq
 */
export interface GetActivityInfoReq {
    /**
     * @generated from protobuf field: repeated uint32 activity_id_list = 14;
     */
    activityIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2144;
 * }
 *
 * @generated from protobuf message GetActivityInfoRsp
 */
export interface GetActivityInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated ActivityInfo activity_info_list = 14;
     */
    activityInfoList: ActivityInfo[];
    /**
     * @generated from protobuf field: repeated uint32 activated_sale_id_list = 2;
     */
    activatedSaleIdList: number[];
    /**
     * @generated from protobuf field: repeated Uint32Pair disable_transfer_point_interaction_list = 4;
     */
    disableTransferPointInteractionList: Uint32Pair[];
}
/**
 * @generated from protobuf message GetAllMailReq
 */
export interface GetAllMailReq {
    /**
     * @generated from protobuf field: bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"];
     */
    aNKKGPJCINB: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1427;
 * }
 *
 * @generated from protobuf message GetAllMailRsp
 */
export interface GetAllMailRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated MailData mail_list = 9;
     */
    mailList: MailData[];
    /**
     * @generated from protobuf field: bool is_truncated = 5;
     */
    isTruncated: boolean;
    /**
     * @generated from protobuf field: bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"];
     */
    aNKKGPJCINB: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4058;
 * }
 *
 * @generated from protobuf message GetAllUnlockNameCardRsp
 */
export interface GetAllUnlockNameCardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 name_card_list = 2;
     */
    nameCardList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1435;
 * }
 *
 * @generated from protobuf message GetAuthkeyReq
 */
export interface GetAuthkeyReq {
    /**
     * @generated from protobuf field: string auth_appid = 12;
     */
    authAppid: string;
    /**
     * @generated from protobuf field: uint32 sign_type = 15;
     */
    signType: number;
    /**
     * @generated from protobuf field: uint32 authkey_ver = 7;
     */
    authkeyVer: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1449;
 * }
 *
 * @generated from protobuf message GetAuthkeyRsp
 */
export interface GetAuthkeyRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: string authkey = 1;
     */
    authkey: string;
    /**
     * @generated from protobuf field: string auth_appid = 2;
     */
    authAppid: string;
    /**
     * @generated from protobuf field: uint32 sign_type = 7;
     */
    signType: number;
    /**
     * @generated from protobuf field: uint32 authkey_ver = 10;
     */
    authkeyVer: number;
    /**
     * @generated from protobuf field: string game_biz = 4;
     */
    gameBiz: string;
}
/**
 * @generated from protobuf message GetBattlePassProductReq
 */
export interface GetBattlePassProductReq {
    /**
     * @generated from protobuf field: uint32 battle_pass_product_play_type = 2;
     */
    battlePassProductPlayType: number;
}
/**
 * @generated from protobuf message GetBattlePassProductRsp
 */
export interface GetBattlePassProductRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 battle_pass_product_play_type = 9;
     */
    battlePassProductPlayType: number;
    /**
     * @generated from protobuf field: uint32 cur_schedule_id = 12;
     */
    curScheduleId: number;
    /**
     * @generated from protobuf field: string product_id = 7;
     */
    productId: string;
    /**
     * @generated from protobuf field: string price_tier = 5;
     */
    priceTier: string;
}
/**
 * @generated from protobuf message GetDailyDungeonEntryInfoReq
 */
export interface GetDailyDungeonEntryInfoReq {
    /**
     * @generated from protobuf field: uint32 scene_id = 11;
     */
    sceneId: number;
}
/**
 * @generated from protobuf message GetDailyDungeonEntryInfoRsp
 */
export interface GetDailyDungeonEntryInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated DailyDungeonEntryInfo daily_dungeon_info_list = 4;
     */
    dailyDungeonInfoList: DailyDungeonEntryInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4003;
 * }
 *
 * @generated from protobuf message GetFriendShowAvatarInfoReq
 */
export interface GetFriendShowAvatarInfoReq {
    /**
     * @generated from protobuf field: uint32 uid = 9;
     */
    uid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4034;
 * }
 *
 * @generated from protobuf message GetFriendShowAvatarInfoRsp
 */
export interface GetFriendShowAvatarInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 uid = 11;
     */
    uid: number;
    /**
     * @generated from protobuf field: repeated ShowAvatarInfo show_avatar_info_list = 7;
     */
    showAvatarInfoList: ShowAvatarInfo[];
}
/**
 * @generated from protobuf message GetFurnitureCurModuleArrangeCountReq
 */
export interface GetFurnitureCurModuleArrangeCountReq {
}
/**
 * @generated from protobuf message GetGachaInfoRsp
 */
export interface GetGachaInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated GachaInfo gacha_info_list = 12;
     */
    gachaInfoList: GachaInfo[];
    /**
     * @generated from protobuf field: uint32 gacha_random = 13;
     */
    gachaRandom: number;
    /**
     * @generated from protobuf field: uint32 KKHCOFPEMNJ = 7 [json_name = "KKHCOFPEMNJ"];
     */
    kKHCOFPEMNJ: number;
    /**
     * @generated from protobuf field: bool LCPFDBAGIEC = 9 [json_name = "LCPFDBAGIEC"];
     */
    lCPFDBAGIEC: boolean;
}
/**
 * @generated from protobuf message GetInvestigationMonsterReq
 */
export interface GetInvestigationMonsterReq {
    /**
     * @generated from protobuf field: repeated uint32 city_id_list = 13;
     */
    cityIdList: number[];
    /**
     * @generated from protobuf field: bool ABFECCDJENJ = 11 [json_name = "ABFECCDJENJ"];
     */
    aBFECCDJENJ: boolean;
}
/**
 * @generated from protobuf message GetInvestigationMonsterRsp
 */
export interface GetInvestigationMonsterRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated InvestigationMonster monster_list = 7;
     */
    monsterList: InvestigationMonster[];
    /**
     * @generated from protobuf field: bool ABFECCDJENJ = 10 [json_name = "ABFECCDJENJ"];
     */
    aBFECCDJENJ: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1437;
 * }
 *
 * @generated from protobuf message GetMailItemReq
 */
export interface GetMailItemReq {
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 8;
     */
    mailIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1432;
 * }
 *
 * @generated from protobuf message GetMailItemRsp
 */
export interface GetMailItemRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 10;
     */
    mailIdList: number[];
    /**
     * @generated from protobuf field: repeated EquipParam item_list = 5;
     */
    itemList: EquipParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 35;
 * }
 *
 * @generated from protobuf message GetOnlinePlayerListReq
 */
export interface GetOnlinePlayerListReq {
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 49;
 * }
 *
 * @generated from protobuf message GetOnlinePlayerListRsp
 */
export interface GetOnlinePlayerListRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated OnlinePlayerInfo player_info_list = 10;
     */
    playerInfoList: OnlinePlayerInfo[];
    /**
     * @generated from protobuf field: uint32 param = 2;
     */
    param: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4004;
 * }
 *
 * @generated from protobuf message GetPlayerAskFriendListRsp
 */
export interface GetPlayerAskFriendListRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated FriendBrief ask_friend_list = 13;
     */
    askFriendList: FriendBrief[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4072;
 * }
 *
 * @generated from protobuf message GetPlayerBlacklistRsp
 */
export interface GetPlayerBlacklistRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated FriendBrief blacklist = 5;
     */
    blacklist: FriendBrief[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4031;
 * }
 *
 * @generated from protobuf message GetPlayerFriendListRsp
 */
export interface GetPlayerFriendListRsp {
    /**
     * @generated from protobuf field: int32 retcode = 3;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated FriendBrief friend_list = 6;
     */
    friendList: FriendBrief[];
    /**
     * @generated from protobuf field: repeated FriendBrief ask_friend_list = 5;
     */
    askFriendList: FriendBrief[];
}
/**
 * @generated from protobuf message GetPlayerHomeCompInfoReq
 */
export interface GetPlayerHomeCompInfoReq {
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4049;
 * }
 *
 * @generated from protobuf message GetPlayerSocialDetailReq
 */
export interface GetPlayerSocialDetailReq {
    /**
     * @generated from protobuf field: uint32 uid = 14;
     */
    uid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4082;
 * }
 *
 * @generated from protobuf message GetPlayerSocialDetailRsp
 */
export interface GetPlayerSocialDetailRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: SocialDetail detail_data = 15;
     */
    detailData?: SocialDetail;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 109;
 * }
 *
 * @generated from protobuf message GetPlayerTokenReq
 */
export interface GetPlayerTokenReq {
    /**
     * @generated from protobuf field: uint32 account_type = 3;
     */
    accountType: number;
    /**
     * @generated from protobuf field: string account_uid = 12;
     */
    accountUid: string;
    /**
     * @generated from protobuf field: string account_token = 14;
     */
    accountToken: string;
    /**
     * @generated from protobuf field: string account_ext = 2;
     */
    accountExt: string;
    /**
     * @generated from protobuf field: uint32 uid = 8;
     */
    uid: number;
    /**
     * @generated from protobuf field: bool is_guest = 4;
     */
    isGuest: boolean;
    /**
     * @generated from protobuf field: uint32 platform_type = 7;
     */
    platformType: number;
    /**
     * @generated from protobuf field: uint32 cloud_client_ip = 13;
     */
    cloudClientIp: number;
    /**
     * @generated from protobuf field: string online_id = 9;
     */
    onlineId: string;
    /**
     * @generated from protobuf field: string psn_region = 15;
     */
    psnRegion: string;
    /**
     * @generated from protobuf field: uint32 channel_id = 10;
     */
    channelId: number;
    /**
     * @generated from protobuf field: uint32 sub_channel_id = 1;
     */
    subChannelId: number;
    /**
     * @generated from protobuf field: string country_code = 11;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: string psn_id = 5;
     */
    psnId: string;
    /**
     * @generated from protobuf field: string client_ip_str = 6;
     */
    clientIpStr: string;
    /**
     * @generated from protobuf field: string birthday = 966;
     */
    birthday: string;
    /**
     * @generated from protobuf field: uint32 unk1 = 1883;
     */
    unk1: number;
    /**
     * @generated from protobuf field: string client_seed = 924;
     */
    clientSeed: string;
    /**
     * @generated from protobuf field: uint32 key_id = 550;
     */
    keyId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 131;
 * }
 *
 * @generated from protobuf message GetPlayerTokenRsp
 */
export interface GetPlayerTokenRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: string msg = 10;
     */
    msg: string;
    /**
     * @generated from protobuf field: uint32 uid = 2;
     */
    uid: number;
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
    /**
     * @generated from protobuf field: uint32 black_uid_end_time = 15;
     */
    blackUidEndTime: number;
    /**
     * @generated from protobuf field: uint32 account_type = 12;
     */
    accountType: number;
    /**
     * @generated from protobuf field: string account_uid = 4;
     */
    accountUid: string;
    /**
     * @generated from protobuf field: bool is_proficient_player = 5;
     */
    isProficientPlayer: boolean;
    /**
     * @generated from protobuf field: string secret_key = 13;
     */
    secretKey: string;
    /**
     * @generated from protobuf field: uint32 gm_uid = 14;
     */
    gmUid: number;
    /**
     * @generated from protobuf field: uint64 secret_key_seed = 11;
     */
    secretKeySeed: bigint;
    /**
     * @generated from protobuf field: bytes security_cmd_buffer = 6;
     */
    securityCmdBuffer: Uint8Array;
    /**
     * @generated from protobuf field: uint32 platform_type = 3;
     */
    platformType: number;
    /**
     * @generated from protobuf field: bytes extra_bin_data = 8;
     */
    extraBinData: Uint8Array;
    /**
     * @generated from protobuf field: bool is_guest = 9;
     */
    isGuest: boolean;
    /**
     * @generated from protobuf field: uint32 channel_id = 1614;
     */
    channelId: number;
    /**
     * @generated from protobuf field: uint32 sub_channel_id = 1911;
     */
    subChannelId: number;
    /**
     * @generated from protobuf field: uint32 tag = 1855;
     */
    tag: number;
    /**
     * @generated from protobuf field: string country_code = 739;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: bool is_login_white_list = 977;
     */
    isLoginWhiteList: boolean;
    /**
     * @generated from protobuf field: string psn_id = 245;
     */
    psnId: string;
    /**
     * @generated from protobuf field: string client_version_random_key = 1387;
     */
    clientVersionRandomKey: string;
    /**
     * @generated from protobuf field: uint32 reg_platform = 633;
     */
    regPlatform: number;
    /**
     * @generated from protobuf field: string client_ip_str = 1238;
     */
    clientIpStr: string;
    /**
     * @generated from protobuf field: string birthday = 1109;
     */
    birthday: string;
    /**
     * @generated from protobuf field: uint32 unk1 = 1728;
     */
    unk1: number;
    /**
     * @generated from protobuf field: bool unk2 = 1679;
     */
    unk2: boolean;
    /**
     * @generated from protobuf field: repeated uint32 unk3 = 2012;
     */
    unk3: number[];
    /**
     * @generated from protobuf field: string encrypted_seed = 1596;
     */
    encryptedSeed: string;
    /**
     * @generated from protobuf field: string seed_signature = 1501;
     */
    seedSignature: string;
    /**
     * @generated from protobuf field: uint32 unk6 = 1447;
     */
    unk6: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 238;
 * }
 *
 * @generated from protobuf message GetSceneAreaReq
 */
export interface GetSceneAreaReq {
    /**
     * @generated from protobuf field: uint32 scene_id = 4;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 belong_uid = 3;
     */
    belongUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 206;
 * }
 *
 * @generated from protobuf message GetSceneAreaRsp
 */
export interface GetSceneAreaRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 13;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated uint32 area_id_list = 6;
     */
    areaIdList: number[];
    /**
     * @generated from protobuf field: repeated CityInfo city_info_list = 3;
     */
    cityInfoList: CityInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 230;
 * }
 *
 * @generated from protobuf message GetScenePointReq
 */
export interface GetScenePointReq {
    /**
     * @generated from protobuf field: uint32 scene_id = 4;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 belong_uid = 10;
     */
    belongUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 297;
 * }
 *
 * @generated from protobuf message GetScenePointRsp
 */
export interface GetScenePointRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 12;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated uint32 unlocked_point_list = 14;
     */
    unlockedPointList: number[];
    /**
     * @generated from protobuf field: uint32 belong_uid = 15;
     */
    belongUid: number;
    /**
     * @generated from protobuf field: repeated uint32 unlock_area_list = 11;
     */
    unlockAreaList: number[];
    /**
     * @generated from protobuf field: repeated uint32 locked_point_list = 4;
     */
    lockedPointList: number[];
    /**
     * @generated from protobuf field: repeated uint32 to_be_explore_dungeon_entry_list = 8;
     */
    toBeExploreDungeonEntryList: number[];
    /**
     * @generated from protobuf field: repeated uint32 not_explored_dungeon_entry_list = 3;
     */
    notExploredDungeonEntryList: number[];
    /**
     * @generated from protobuf field: repeated uint32 group_unlimit_point_list = 6;
     */
    groupUnlimitPointList: number[];
    /**
     * @generated from protobuf field: repeated uint32 not_interact_dungeon_entry_list = 1;
     */
    notInteractDungeonEntryList: number[];
    /**
     * @generated from protobuf field: repeated uint32 hide_point_list = 9;
     */
    hidePointList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 717;
 * }
 *
 * @generated from protobuf message GetShopmallDataRsp
 */
export interface GetShopmallDataRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 shop_type_list = 15;
     */
    shopTypeList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 709;
 * }
 *
 * @generated from protobuf message GetShopReq
 */
export interface GetShopReq {
    /**
     * @generated from protobuf field: uint32 shop_type = 5;
     */
    shopType: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 731;
 * }
 *
 * @generated from protobuf message GetShopRsp
 */
export interface GetShopRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: Shop shop = 14;
     */
    shop?: Shop;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4274;
 * }
 *
 * @generated from protobuf message GetWidgetSlotReq
 */
export interface GetWidgetSlotReq {
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4267;
 * }
 *
 * @generated from protobuf message GetWidgetSlotRsp
 */
export interface GetWidgetSlotRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated WidgetSlotData slot_list = 8;
     */
    slotList: WidgetSlotData[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3179;
 * }
 *
 * @generated from protobuf message GetWorldMpInfoRsp
 */
export interface GetWorldMpInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: bool is_in_mp_mode = 5;
     */
    isInMpMode: boolean;
    /**
     * @generated from protobuf field: uint32 quit_mp_valid_time = 13;
     */
    quitMpValidTime: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3098;
 * }
 *
 * @generated from protobuf message GroupSuiteNotify
 */
export interface GroupSuiteNotify {
    /**
     * @generated from protobuf field: map<uint32, uint32> group_map = 11;
     */
    groupMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message GroupUnloadNotify
 */
export interface GroupUnloadNotify {
    /**
     * @generated from protobuf field: repeated uint32 group_list = 1;
     */
    groupList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 5693;
 * }
 *
 * @generated from protobuf message H5ActivityIdsNotify
 */
export interface H5ActivityIdsNotify {
    /**
     * @generated from protobuf field: map<uint32, uint32> h_5_activity_map = 3;
     */
    h5ActivityMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 client_red_dot_timestamp = 15;
     */
    clientRedDotTimestamp: number;
}
/**
 * @generated from protobuf message HitCollision
 */
export interface HitCollision {
    /**
     * @generated from protobuf field: HitColliderType hit_collider_type = 10;
     */
    hitColliderType: HitColliderType;
    /**
     * @generated from protobuf field: int32 hit_box_index = 1;
     */
    hitBoxIndex: number;
    /**
     * @generated from protobuf field: Vector hit_point = 11;
     */
    hitPoint?: Vector;
    /**
     * @generated from protobuf field: Vector hit_dir = 5;
     */
    hitDir?: Vector;
    /**
     * @generated from protobuf field: float attackee_hit_force_angle = 14;
     */
    attackeeHitForceAngle: number;
    /**
     * @generated from protobuf field: float attackee_hit_entity_angle = 8;
     */
    attackeeHitEntityAngle: number;
}
/**
 * @generated from protobuf message HitTreeNotify
 */
export interface HitTreeNotify {
    /**
     * @generated from protobuf field: uint32 wood_type = 4;
     */
    woodType: number;
    /**
     * @generated from protobuf field: uint32 unknown_data = 3;
     */
    unknownData: number;
    /**
     * @generated from protobuf field: Vector hit_postion = 13;
     */
    hitPostion?: Vector;
}
/**
 * @generated from protobuf message HomeAnimalData
 */
export interface HomeAnimalData {
    /**
     * @generated from protobuf field: uint32 furniture_id = 4;
     */
    furnitureId: number;
    /**
     * @generated from protobuf field: Vector spawn_pos = 3;
     */
    spawnPos?: Vector;
    /**
     * @generated from protobuf field: Vector spawn_rot = 13;
     */
    spawnRot?: Vector;
}
/**
 * @generated from protobuf message HomeBasicInfo
 */
export interface HomeBasicInfo {
    /**
     * @generated from protobuf field: uint32 cur_module_id = 9;
     */
    curModuleId: number;
    /**
     * @generated from protobuf field: uint32 cur_room_scene_id = 4;
     */
    curRoomSceneId: number;
    /**
     * @generated from protobuf field: bool is_in_edit_mode = 3;
     */
    isInEditMode: boolean;
    /**
     * @generated from protobuf field: uint64 exp = 10;
     */
    exp: bigint;
    /**
     * @generated from protobuf field: uint32 level = 12;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 home_owner_uid = 1;
     */
    homeOwnerUid: number;
    /**
     * @generated from protobuf field: HomeLimitedShopInfo limited_shop_info = 2;
     */
    limitedShopInfo?: HomeLimitedShopInfo;
    /**
     * @generated from protobuf field: string owner_nick_name = 5;
     */
    ownerNickName: string;
}
/**
 * @generated from protobuf message HomeBasicInfoNotify
 */
export interface HomeBasicInfoNotify {
    /**
     * @generated from protobuf field: HomeBasicInfo basic_info = 9;
     */
    basicInfo?: HomeBasicInfo;
}
/**
 * @generated from protobuf message HomeBlockArrangementInfo
 */
export interface HomeBlockArrangementInfo {
    /**
     * @generated from protobuf field: uint32 block_id = 4;
     */
    blockId: number;
    /**
     * @generated from protobuf field: repeated HomeFurnitureData persistent_furniture_list = 2;
     */
    persistentFurnitureList: HomeFurnitureData[];
    /**
     * @generated from protobuf field: repeated HomeFurnitureData deploy_furniure_list = 7;
     */
    deployFurniureList: HomeFurnitureData[];
    /**
     * @generated from protobuf field: repeated HomeNpcData deploy_npc_list = 11;
     */
    deployNpcList: HomeNpcData[];
    /**
     * @generated from protobuf field: repeated HomeFurnitureSuiteData furniture_suite_list = 10;
     */
    furnitureSuiteList: HomeFurnitureSuiteData[];
    /**
     * @generated from protobuf field: repeated HomeAnimalData deploy_animal_list = 14;
     */
    deployAnimalList: HomeAnimalData[];
    /**
     * @generated from protobuf field: bool is_unlocked = 15;
     */
    isUnlocked: boolean;
    /**
     * @generated from protobuf field: uint32 comfort_value = 1;
     */
    comfortValue: number;
    /**
     * repeated WeekendDjinnInfo weekend_djinn_info_list = 3;
     *
     * @generated from protobuf field: repeated HomeBlockDotPattern dot_pattern_list = 6;
     */
    dotPatternList: HomeBlockDotPattern[];
    /**
     * @generated from protobuf field: repeated HomeBlockFieldData field_list = 13;
     */
    fieldList: HomeBlockFieldData[]; // repeated JAFDCHOLLOA LJJFHDEHAJF = 5;
    // repeated PKDMPNNKGNE IIIDMLAICKE = 8;
}
/**
 * @generated from protobuf message HomeBlockDotPattern
 */
export interface HomeBlockDotPattern {
    /**
     * @generated from protobuf field: uint32 height = 8;
     */
    height: number;
    /**
     * @generated from protobuf field: uint32 width = 4;
     */
    width: number;
    /**
     * @generated from protobuf field: bytes data = 14;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message HomeBlockFieldData
 */
export interface HomeBlockFieldData {
    /**
     * @generated from protobuf field: uint32 guid = 7;
     */
    guid: number;
    /**
     * @generated from protobuf field: uint32 furniture_id = 1;
     */
    furnitureId: number;
    /**
     * @generated from protobuf field: Vector pos = 12;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 11;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: repeated HomeBlockSubFieldData sub_field_list = 14;
     */
    subFieldList: HomeBlockSubFieldData[];
}
/**
 * @generated from protobuf message HomeBlockNotify
 */
export interface HomeBlockNotify {
    /**
     * @generated from protobuf field: uint32 end_time = 7;
     */
    endTime: number;
}
/**
 * @generated from protobuf message HomeBlockSubFieldData
 */
export interface HomeBlockSubFieldData {
    /**
     * @generated from protobuf field: Vector pos = 12;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 14;
     */
    rot?: Vector;
}
/**
 * @generated from protobuf message HomeChangeEditModeReq
 */
export interface HomeChangeEditModeReq {
    /**
     * @generated from protobuf field: bool is_enter_edit_mode = 5;
     */
    isEnterEditMode: boolean;
}
/**
 * @generated from protobuf message HomeChangeEditModeRsp
 */
export interface HomeChangeEditModeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: bool is_enter_edit_mode = 5;
     */
    isEnterEditMode: boolean;
}
/**
 * @generated from protobuf message HomeChooseModuleReq
 */
export interface HomeChooseModuleReq {
    /**
     * @generated from protobuf field: uint32 module_id = 2;
     */
    moduleId: number;
}
/**
 * @generated from protobuf message HomeChooseModuleRsp
 */
export interface HomeChooseModuleRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 module_id = 11;
     */
    moduleId: number;
}
/**
 * @generated from protobuf message HomeComfortInfoNotify
 */
export interface HomeComfortInfoNotify {
    /**
     * @generated from protobuf field: repeated HomeModuleComfortInfo module_info_list = 1;
     */
    moduleInfoList: HomeModuleComfortInfo[];
}
/**
 * @generated from protobuf message HomeFurnitureData
 */
export interface HomeFurnitureData {
    /**
     * @generated from protobuf field: uint32 furniture_id = 13;
     */
    furnitureId: number;
    /**
     * @generated from protobuf field: Vector spawn_pos = 9;
     */
    spawnPos?: Vector;
    /**
     * @generated from protobuf field: Vector spawn_rot = 7;
     */
    spawnRot?: Vector;
    /**
     * @generated from protobuf field: int32 parent_furniture_index = 4;
     */
    parentFurnitureIndex: number;
    /**
     * @generated from protobuf field: uint32 guid = 3;
     */
    guid: number;
    /**
     * @generated from protobuf field: uint32 version = 12;
     */
    version: number;
}
/**
 * @generated from protobuf message HomeFurnitureSuiteData
 */
export interface HomeFurnitureSuiteData {
    /**
     * @generated from protobuf field: uint32 suite_id = 11;
     */
    suiteId: number;
    /**
     * @generated from protobuf field: Vector spawn_pos = 14;
     */
    spawnPos?: Vector;
    /**
     * @generated from protobuf field: repeated int32 included_furniture_index_list = 12;
     */
    includedFurnitureIndexList: number[];
    /**
     * @generated from protobuf field: uint32 guid = 3;
     */
    guid: number;
    /**
     * @generated from protobuf field: bool is_allow_summon = 10;
     */
    isAllowSummon: boolean;
}
/**
 * @generated from protobuf message HomeGetArrangementInfoReq
 */
export interface HomeGetArrangementInfoReq {
    /**
     * @generated from protobuf field: repeated uint32 scene_id_list = 6;
     */
    sceneIdList: number[];
}
/**
 * @generated from protobuf message HomeGetArrangementInfoRsp
 */
export interface HomeGetArrangementInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated HomeSceneArrangementInfo scene_arrangement_info_list = 12;
     */
    sceneArrangementInfoList: HomeSceneArrangementInfo[];
}
/**
 * @generated from protobuf message HomeGetBasicInfoReq
 */
export interface HomeGetBasicInfoReq {
}
/**
 * @generated from protobuf message HomeLimitedShopInfo
 */
export interface HomeLimitedShopInfo {
    /**
     * @generated from protobuf field: uint32 uid = 6;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 next_open_time = 5;
     */
    nextOpenTime: number;
    /**
     * @generated from protobuf field: uint32 next_guest_open_time = 1;
     */
    nextGuestOpenTime: number;
    /**
     * @generated from protobuf field: uint32 next_close_time = 10;
     */
    nextCloseTime: number;
    /**
     * @generated from protobuf field: Vector djinn_pos = 11;
     */
    djinnPos?: Vector;
    /**
     * @generated from protobuf field: Vector djinn_rot = 3;
     */
    djinnRot?: Vector;
}
/**
 * @generated from protobuf message HomeMarkPointFurnitureData
 */
export interface HomeMarkPointFurnitureData {
    /**
     * @generated from protobuf field: uint32 guid = 1;
     */
    guid: number;
    /**
     * @generated from protobuf field: uint32 furniture_id = 2;
     */
    furnitureId: number;
    /**
     * @generated from protobuf field: uint32 furniture_type = 3;
     */
    furnitureType: number;
    /**
     * @generated from protobuf field: Vector pos = 4;
     */
    pos?: Vector;
    /**
     * @generated from protobuf oneof: extra
     */
    extra: {
        oneofKind: "npcData";
        /**
         * @generated from protobuf field: HomeMarkPointNPCData npc_data = 6;
         */
        npcData: HomeMarkPointNPCData;
    } | {
        oneofKind: "suiteData";
        /**
         * @generated from protobuf field: HomeMarkPointSuiteData suite_data = 7;
         */
        suiteData: HomeMarkPointSuiteData;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message HomeMarkPointNotify
 */
export interface HomeMarkPointNotify {
    /**
     * @generated from protobuf field: repeated HomeMarkPointSceneData mark_point_data_list = 13;
     */
    markPointDataList: HomeMarkPointSceneData[];
}
/**
 * @generated from protobuf message HomeMarkPointNPCData
 */
export interface HomeMarkPointNPCData {
    /**
     * @generated from protobuf field: uint32 avatar_id = 1;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint32 costume_id = 2;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message HomeMarkPointSceneData
 */
export interface HomeMarkPointSceneData {
    /**
     * @generated from protobuf field: uint32 module_id = 1;
     */
    moduleId: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 11;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated HomeMarkPointFurnitureData furniture_list = 9;
     */
    furnitureList: HomeMarkPointFurnitureData[];
    /**
     * @generated from protobuf field: Vector teapot_spirit_pos = 10;
     */
    teapotSpiritPos?: Vector;
}
/**
 * @generated from protobuf message HomeMarkPointSuiteData
 */
export interface HomeMarkPointSuiteData {
    /**
     * @generated from protobuf field: uint32 suite_id = 1;
     */
    suiteId: number;
}
/**
 * @generated from protobuf message HomeModuleComfortInfo
 */
export interface HomeModuleComfortInfo {
    /**
     * @generated from protobuf field: uint32 module_id = 8;
     */
    moduleId: number;
    /**
     * @generated from protobuf field: repeated uint32 world_scene_block_comfort_value_list = 15;
     */
    worldSceneBlockComfortValueList: number[];
    /**
     * @generated from protobuf field: uint32 room_scene_comfort_value = 2;
     */
    roomSceneComfortValue: number;
}
/**
 * @generated from protobuf message HomeNpcData
 */
export interface HomeNpcData {
    /**
     * @generated from protobuf field: uint32 avatar_id = 13;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: Vector spawn_pos = 10;
     */
    spawnPos?: Vector;
    /**
     * @generated from protobuf field: Vector spawn_rot = 4;
     */
    spawnRot?: Vector;
    /**
     * @generated from protobuf field: uint32 costume_id = 2;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message HomeSceneArrangementInfo
 */
export interface HomeSceneArrangementInfo {
    /**
     * @generated from protobuf field: uint32 scene_id = 10;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated HomeBlockArrangementInfo block_arrangement_info_list = 11;
     */
    blockArrangementInfoList: HomeBlockArrangementInfo[];
    /**
     * @generated from protobuf field: bool is_set_born_pos = 3;
     */
    isSetBornPos: boolean;
    /**
     * @generated from protobuf field: Vector born_pos = 5;
     */
    bornPos?: Vector;
    /**
     * @generated from protobuf field: Vector born_rot = 1;
     */
    bornRot?: Vector;
    /**
     * @generated from protobuf field: repeated HomeFurnitureData door_list = 8;
     */
    doorList: HomeFurnitureData[];
    /**
     * @generated from protobuf field: repeated HomeFurnitureData stair_list = 6;
     */
    stairList: HomeFurnitureData[];
    /**
     * @generated from protobuf field: HomeFurnitureData main_house = 9;
     */
    mainHouse?: HomeFurnitureData;
    /**
     * @generated from protobuf field: uint32 comfort_value = 13;
     */
    comfortValue: number;
    /**
     * @generated from protobuf field: Vector djinn_pos = 7;
     */
    djinnPos?: Vector;
    /**
     * @generated from protobuf field: uint32 tmp_version = 12;
     */
    tmpVersion: number;
    /**
     * @generated from protobuf field: uint32 CNLMNOEGKME = 15 [json_name = "CNLMNOEGKME"];
     */
    cNLMNOEGKME: number;
}
/**
 * @generated from protobuf message HomeSceneInitFinishReq
 */
export interface HomeSceneInitFinishReq {
}
/**
 * @generated from protobuf message HomeSceneInitFinishRsp
 */
export interface HomeSceneInitFinishRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
}
/**
 * @generated from protobuf message HomeSceneJumpReq
 */
export interface HomeSceneJumpReq {
    /**
     * @generated from protobuf field: bool is_enter_room_scene = 12;
     */
    isEnterRoomScene: boolean;
}
/**
 * @generated from protobuf message HomeSceneJumpRsp
 */
export interface HomeSceneJumpRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
    /**
     * @generated from protobuf field: bool is_enter_room_scene = 8;
     */
    isEnterRoomScene: boolean;
}
/**
 * @generated from protobuf message HomeUnknown1Notify
 */
export interface HomeUnknown1Notify {
    /**
     * @generated from protobuf field: bool is_enter_edit_mode = 12;
     */
    isEnterEditMode: boolean;
}
/**
 * @generated from protobuf message HomeUpdateArrangementInfoReq
 */
export interface HomeUpdateArrangementInfoReq {
    /**
     * @generated from protobuf field: HomeSceneArrangementInfo scene_arrangement_info = 12;
     */
    sceneArrangementInfo?: HomeSceneArrangementInfo;
}
/**
 * @generated from protobuf message HomeUpdateArrangementInfoRsp
 */
export interface HomeUpdateArrangementInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 341;
 * }
 *
 * @generated from protobuf message HostPlayerNotify
 */
export interface HostPlayerNotify {
    /**
     * @generated from protobuf field: uint32 host_uid = 10;
     */
    hostUid: number;
    /**
     * @generated from protobuf field: uint32 host_peer_id = 7;
     */
    hostPeerId: number;
}
/**
 * @generated from protobuf message InvestigationMonster
 */
export interface InvestigationMonster {
    /**
     * @generated from protobuf field: uint32 id = 15;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 city_id = 9;
     */
    cityId: number;
    /**
     * @generated from protobuf field: uint32 level = 10;
     */
    level: number;
    /**
     * @generated from protobuf field: bool is_alive = 4;
     */
    isAlive: boolean;
    /**
     * @generated from protobuf field: uint32 next_refresh_time = 3;
     */
    nextRefreshTime: number;
    /**
     * @generated from protobuf field: uint32 refresh_interval = 6;
     */
    refreshInterval: number;
    /**
     * @generated from protobuf field: Vector pos = 1;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: InvestigationMonster.LockState lock_state = 2;
     */
    lockState: InvestigationMonster_LockState;
    /**
     * @generated from protobuf field: uint32 max_boss_chest_num = 12;
     */
    maxBossChestNum: number;
    /**
     * @generated from protobuf field: uint32 boss_chest_num = 7;
     */
    bossChestNum: number;
    /**
     * @generated from protobuf field: uint32 resin = 8;
     */
    resin: number;
    /**
     * @generated from protobuf field: bool is_area_locked = 13;
     */
    isAreaLocked: boolean;
    /**
     * @generated from protobuf field: uint32 next_boss_chest_refresh_time = 5;
     */
    nextBossChestRefreshTime: number;
    /**
     * @generated from protobuf field: WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info = 14;
     */
    weeklyBossResinDiscountInfo?: WeeklyBossResinDiscountInfo;
    /**
     * @generated from protobuf field: uint32 scene_id = 11;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 group_id = 1014;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 monster_id = 1638;
     */
    monsterId: number;
}
/**
 * @generated from protobuf enum InvestigationMonster.LockState
 */
export enum InvestigationMonster_LockState {
    /**
     * @generated from protobuf enum value: LOCK_STATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: LOCK_STATE_QUEST = 1;
     */
    QUEST = 1
}
/**
 * @generated from protobuf message Item
 */
export interface Item {
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint64 guid = 2;
     */
    guid: bigint;
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "material";
        /**
         * @generated from protobuf field: Material material = 5;
         */
        material: Material;
    } | {
        oneofKind: "equip";
        /**
         * @generated from protobuf field: Equip equip = 6;
         */
        equip: Equip;
    } | {
        oneofKind: "furniture";
        /**
         * @generated from protobuf field: Furniture furniture = 7;
         */
        furniture: Furniture;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 632;
 * }
 *
 * @generated from protobuf message ItemAddHintNotify
 */
export interface ItemAddHintNotify {
    /**
     * @generated from protobuf field: repeated ItemHint item_list = 10;
     */
    itemList: ItemHint[];
    /**
     * @generated from protobuf field: Vector position = 12;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: bool is_position_valid = 13;
     */
    isPositionValid: boolean;
    /**
     * @generated from protobuf field: uint32 reason = 5;
     */
    reason: number;
    /**
     * @generated from protobuf field: uint32 quest_id = 14;
     */
    questId: number;
    /**
     * @generated from protobuf field: bool is_transfered_from_avatar_card = 11;
     */
    isTransferedFromAvatarCard: boolean;
    /**
     * @generated from protobuf field: repeated ItemHint overflow_transformed_item_list = 3;
     */
    overflowTransformedItemList: ItemHint[];
    /**
     * @generated from protobuf field: bool is_general_reward_hiden = 7;
     */
    isGeneralRewardHiden: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 178;
 * }
 *
 * @generated from protobuf message ItemGivingReq
 */
export interface ItemGivingReq {
    /**
     * @generated from protobuf field: uint32 giving_id = 14;
     */
    givingId: number;
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 10;
     */
    itemParamList: ItemParam[];
    /**
     * @generated from protobuf field: map<uint64, uint32> item_guid_count_map = 6;
     */
    itemGuidCountMap: {
        [key: string]: number;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 108;
 * }
 *
 * @generated from protobuf message ItemGivingRsp
 */
export interface ItemGivingRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 giving_id = 6;
     */
    givingId: number;
}
/**
 * @generated from protobuf message ItemHint
 */
export interface ItemHint {
    /**
     * @generated from protobuf field: uint32 item_id = 7;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint32 count = 14;
     */
    count: number;
    /**
     * @generated from protobuf field: bool is_new = 2;
     */
    isNew: boolean;
    /**
     * @generated from protobuf field: uint64 guid = 15;
     */
    guid: bigint;
}
/**
 * @generated from protobuf message ItemParam
 */
export interface ItemParam {
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint32 count = 2;
     */
    count: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1231;
 * }
 *
 * @generated from protobuf message LifeStateChangeNotify
 */
export interface LifeStateChangeNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 4;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 life_state = 6;
     */
    lifeState: number;
    /**
     * @generated from protobuf field: uint32 source_entity_id = 5;
     */
    sourceEntityId: number;
    /**
     * @generated from protobuf field: string attack_tag = 1;
     */
    attackTag: string;
    /**
     * @generated from protobuf field: PlayerDieType die_type = 13;
     */
    dieType: PlayerDieType;
    /**
     * @generated from protobuf field: uint32 move_reliable_seq = 9;
     */
    moveReliableSeq: number;
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 14;
     */
    serverBuffList: ServerBuff[];
}
/**
 * @generated from protobuf message LockedPersonallineData
 */
export interface LockedPersonallineData {
    /**
     * @generated from protobuf field: uint32 personal_line_id = 1;
     */
    personalLineId: number;
    /**
     * @generated from protobuf field: LockedPersonallineData.LockReason lock_reason = 2;
     */
    lockReason: LockedPersonallineData_LockReason;
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "chapterId";
        /**
         * @generated from protobuf field: uint32 chapter_id = 3;
         */
        chapterId: number;
    } | {
        oneofKind: "level";
        /**
         * @generated from protobuf field: uint32 level = 4;
         */
        level: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum LockedPersonallineData.LockReason
 */
export enum LockedPersonallineData_LockReason {
    /**
     * @generated from protobuf enum value: LOCK_REASON_LEVEL = 0;
     */
    LEVEL = 0,
    /**
     * @generated from protobuf enum value: LOCK_REASON_QUEST = 1;
     */
    QUEST = 1
}
/**
 * @generated from protobuf message LunchBoxData
 */
export interface LunchBoxData {
    /**
     * @generated from protobuf field: map<uint32, uint32> slot_material_map = 5;
     */
    slotMaterialMap: {
        [key: number]: number;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1431;
 * }
 *
 * @generated from protobuf message MailChangeNotify
 */
export interface MailChangeNotify {
    /**
     * @generated from protobuf field: repeated MailData mail_list = 3;
     */
    mailList: MailData[];
    /**
     * @generated from protobuf field: repeated uint32 del_mail_id_list = 7;
     */
    delMailIdList: number[];
}
/**
 * @generated from protobuf message MailData
 */
export interface MailData {
    /**
     * @generated from protobuf field: uint32 mail_id = 1;
     */
    mailId: number;
    /**
     * @generated from protobuf field: MailTextContent mail_text_content = 4;
     */
    mailTextContent?: MailTextContent;
    /**
     * @generated from protobuf field: repeated MailItem item_list = 7;
     */
    itemList: MailItem[];
    /**
     * @generated from protobuf field: uint32 send_time = 8;
     */
    sendTime: number;
    /**
     * @generated from protobuf field: uint32 expire_time = 9;
     */
    expireTime: number;
    /**
     * @generated from protobuf field: uint32 importance = 10;
     */
    importance: number;
    /**
     * @generated from protobuf field: bool is_read = 11;
     */
    isRead: boolean;
    /**
     * @generated from protobuf field: bool is_attachment_got = 12;
     */
    isAttachmentGot: boolean;
    /**
     * @generated from protobuf field: uint32 config_id = 13;
     */
    configId: number;
    /**
     * @generated from protobuf field: repeated string argument_list = 14;
     */
    argumentList: string[];
    /**
     * @generated from protobuf field: CBJEDMGOBPL BHCAHLJIKFF = 15 [json_name = "BHCAHLJIKFF"];
     */
    bHCAHLJIKFF: CBJEDMGOBPL;
}
/**
 * @generated from protobuf message MailItem
 */
export interface MailItem {
    /**
     * @generated from protobuf field: EquipParam equip_param = 1;
     */
    equipParam?: EquipParam;
    /**
     * @generated from protobuf field: MaterialDeleteInfo delete_info = 2;
     */
    deleteInfo?: MaterialDeleteInfo;
}
/**
 * @generated from protobuf message MailTextContent
 */
export interface MailTextContent {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string content = 2;
     */
    content: string;
    /**
     * @generated from protobuf field: string sender = 3;
     */
    sender: string;
}
/**
 * @generated from protobuf message MapMarkPoint
 */
export interface MapMarkPoint {
    /**
     * @generated from protobuf field: uint32 scene_id = 1;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: Vector pos = 3;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: MapMarkPointType point_type = 4;
     */
    pointType: MapMarkPointType;
    /**
     * @generated from protobuf field: uint32 monster_id = 5;
     */
    monsterId: number;
    /**
     * @generated from protobuf field: MapMarkFromType from_type = 6;
     */
    fromType: MapMarkFromType;
    /**
     * @generated from protobuf field: uint32 quest_id = 7;
     */
    questId: number;
}
/**
 * @generated from protobuf message MapMarkTipsInfo
 */
export interface MapMarkTipsInfo {
    /**
     * @generated from protobuf field: MapMarkTipsType tips_type = 1;
     */
    tipsType: MapMarkTipsType;
    /**
     * @generated from protobuf field: repeated uint32 point_id_list = 2;
     */
    pointIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 202;
 * }
 *
 * @generated from protobuf message MarkEntityInMinMapNotify
 */
export interface MarkEntityInMinMapNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 5;
     */
    entityId: number;
    /**
     * @generated from protobuf field: Vector position = 13;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: uint32 monster_id = 6;
     */
    monsterId: number;
}
/**
 * @generated from protobuf message MarkMapReq
 */
export interface MarkMapReq {
    /**
     * @generated from protobuf field: MarkMapReq.Operation op = 15;
     */
    op: MarkMapReq_Operation;
    /**
     * @generated from protobuf field: MapMarkPoint old = 10;
     */
    old?: MapMarkPoint;
    /**
     * @generated from protobuf field: MapMarkPoint mark = 4;
     */
    mark?: MapMarkPoint;
}
/**
 * @generated from protobuf enum MarkMapReq.Operation
 */
export enum MarkMapReq_Operation {
    /**
     * @generated from protobuf enum value: OPERATION_ADD = 0;
     */
    ADD = 0,
    /**
     * @generated from protobuf enum value: OPERATION_MOD = 1;
     */
    MOD = 1,
    /**
     * @generated from protobuf enum value: OPERATION_DEL = 2;
     */
    DEL = 2,
    /**
     * @generated from protobuf enum value: OPERATION_GET = 3;
     */
    GET = 3
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3421;
 * }
 *
 * @generated from protobuf message MarkMapRsp
 */
export interface MarkMapRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated MapMarkPoint mark_list = 7;
     */
    markList: MapMarkPoint[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1227;
 * }
 *
 * @generated from protobuf message MarkNewNotify
 */
export interface MarkNewNotify {
    /**
     * @generated from protobuf field: uint32 mark_new_type = 10;
     */
    markNewType: number;
    /**
     * @generated from protobuf field: repeated uint32 id_list = 13;
     */
    idList: number[];
}
/**
 * @generated from protobuf message MassivePropParam
 */
export interface MassivePropParam {
    /**
     * @generated from protobuf field: int32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: repeated uint32 reaction_info_list = 2;
     */
    reactionInfoList: number[];
    /**
     * @generated from protobuf field: repeated float param_list = 3;
     */
    paramList: number[];
    /**
     * @generated from protobuf field: uint32 sync_flag = 4;
     */
    syncFlag: number;
}
/**
 * @generated from protobuf message MassivePropSyncInfo
 */
export interface MassivePropSyncInfo {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: repeated MassivePropParam prop_list = 2;
     */
    propList: MassivePropParam[];
}
/**
 * @generated from protobuf message Material
 */
export interface Material {
    /**
     * @generated from protobuf field: uint32 count = 1;
     */
    count: number;
    /**
     * @generated from protobuf field: MaterialDeleteInfo delete_info = 2;
     */
    deleteInfo?: MaterialDeleteInfo;
}
/**
 * @generated from protobuf message MaterialDeleteInfo
 */
export interface MaterialDeleteInfo {
    /**
     * @generated from protobuf oneof: DeleteInfo
     */
    deleteInfo: {
        oneofKind: "countDownDelete";
        /**
         * @generated from protobuf field: MaterialDeleteInfo.CountDownDelete count_down_delete = 2;
         */
        countDownDelete: MaterialDeleteInfo_CountDownDelete;
    } | {
        oneofKind: "dateDelete";
        /**
         * @generated from protobuf field: MaterialDeleteInfo.DateTimeDelete date_delete = 3;
         */
        dateDelete: MaterialDeleteInfo_DateTimeDelete;
    } | {
        oneofKind: "delayWeekCountDownDelete";
        /**
         * @generated from protobuf field: MaterialDeleteInfo.DelayWeekCountDownDelete delay_week_count_down_delete = 4;
         */
        delayWeekCountDownDelete: MaterialDeleteInfo_DelayWeekCountDownDelete;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool has_delete_config = 1;
     */
    hasDeleteConfig: boolean;
}
/**
 * @generated from protobuf message MaterialDeleteInfo.CountDownDelete
 */
export interface MaterialDeleteInfo_CountDownDelete {
    /**
     * @generated from protobuf field: map<uint32, uint32> delete_time_num_map = 1;
     */
    deleteTimeNumMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 config_count_down_time = 2;
     */
    configCountDownTime: number;
}
/**
 * @generated from protobuf message MaterialDeleteInfo.DateTimeDelete
 */
export interface MaterialDeleteInfo_DateTimeDelete {
    /**
     * @generated from protobuf field: uint32 delete_time = 1;
     */
    deleteTime: number;
}
/**
 * @generated from protobuf message MaterialDeleteInfo.DelayWeekCountDownDelete
 */
export interface MaterialDeleteInfo_DelayWeekCountDownDelete {
    /**
     * @generated from protobuf field: map<uint32, uint32> delete_time_num_map = 1;
     */
    deleteTimeNumMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 config_delay_week = 2;
     */
    configDelayWeek: number;
    /**
     * @generated from protobuf field: uint32 config_count_down_time = 3;
     */
    configCountDownTime: number;
}
/**
 * @generated from protobuf message MaterialInfo
 */
export interface MaterialInfo {
    /**
     * @generated from protobuf field: uint64 guid = 1;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 count = 2;
     */
    count: number;
}
/**
 * @generated from protobuf message MathQuaternion
 */
export interface MathQuaternion {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
    /**
     * @generated from protobuf field: float w = 4;
     */
    w: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 687;
 * }
 *
 * @generated from protobuf message McoinExchangeHcoinReq
 */
export interface McoinExchangeHcoinReq {
    /**
     * @generated from protobuf field: uint32 mcoin_cost = 8;
     */
    mcoinCost: number;
    /**
     * @generated from protobuf field: uint32 hcoin = 12;
     */
    hcoin: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 689;
 * }
 *
 * @generated from protobuf message McoinExchangeHcoinRsp
 */
export interface McoinExchangeHcoinRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 mcoin_cost = 10;
     */
    mcoinCost: number;
    /**
     * @generated from protobuf field: uint32 hcoin = 15;
     */
    hcoin: number;
}
/**
 * @generated from protobuf message ModifierDurability
 */
export interface ModifierDurability {
    /**
     * @generated from protobuf field: float reduce_ratio = 1;
     */
    reduceRatio: number;
    /**
     * @generated from protobuf field: float remaining_durability = 2;
     */
    remainingDurability: number;
}
/**
 * @generated from protobuf message ModifierProperty
 */
export interface ModifierProperty {
    /**
     * @generated from protobuf field: AbilityString key = 1;
     */
    key?: AbilityString;
    /**
     * @generated from protobuf field: float value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message MonsterRoute
 */
export interface MonsterRoute {
    /**
     * @generated from protobuf field: repeated RoutePoint route_points = 1;
     */
    routePoints: RoutePoint[];
    /**
     * @generated from protobuf field: uint32 speed_level = 2;
     */
    speedLevel: number;
    /**
     * @generated from protobuf field: uint32 route_type = 3;
     */
    routeType: number;
    /**
     * @generated from protobuf field: float arrive_range = 4;
     */
    arriveRange: number;
}
/**
 * @generated from protobuf message MotionInfo
 */
export interface MotionInfo {
    /**
     * @generated from protobuf field: Vector pos = 1;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 2;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: Vector speed = 3;
     */
    speed?: Vector;
    /**
     * @generated from protobuf field: MotionState state = 4;
     */
    state: MotionState;
    /**
     * @generated from protobuf field: repeated Vector params = 5;
     */
    params: Vector[];
    /**
     * @generated from protobuf field: Vector ref_pos = 6;
     */
    refPos?: Vector;
    /**
     * @generated from protobuf field: uint32 ref_id = 7;
     */
    refId: number;
    /**
     * @generated from protobuf field: uint32 scene_time = 8;
     */
    sceneTime: number;
    /**
     * @generated from protobuf field: uint64 interval_velocity = 9;
     */
    intervalVelocity: bigint;
}
/**
 * @generated from protobuf message MPLevelEntityInfo
 */
export interface MPLevelEntityInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 4;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 authority_peer_id = 3;
     */
    authorityPeerId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo ability_info = 12;
     */
    abilityInfo?: AbilitySyncStateInfo;
}
/**
 * @generated from protobuf message MpPlayRewardInfo
 */
export interface MpPlayRewardInfo {
    /**
     * @generated from protobuf field: uint32 resin = 1;
     */
    resin: number;
    /**
     * @generated from protobuf field: repeated uint32 remain_uid_list = 2;
     */
    remainUidList: number[];
    /**
     * @generated from protobuf field: repeated uint32 qualify_uid_list = 3;
     */
    qualifyUidList: number[];
}
/**
 * @generated from protobuf message MusicBeatmap
 */
export interface MusicBeatmap {
    /**
     * @generated from protobuf field: uint32 music_id = 1;
     */
    musicId: number;
    /**
     * @generated from protobuf field: repeated MusicBeatmapList beatmap_item_list = 2;
     */
    beatmapItemList: MusicBeatmapList[];
}
/**
 * @generated from protobuf message MusicBeatmapList
 */
export interface MusicBeatmapList {
    /**
     * @generated from protobuf field: repeated MusicBeatmapNote beatmap_note_list = 1;
     */
    beatmapNoteList: MusicBeatmapNote[];
}
/**
 * @generated from protobuf message MusicBeatmapNote
 */
export interface MusicBeatmapNote {
    /**
     * @generated from protobuf field: uint32 start_time = 1;
     */
    startTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 2;
     */
    endTime: number;
}
/**
 * @generated from protobuf message MusicBriefInfo
 */
export interface MusicBriefInfo {
    /**
     * @generated from protobuf field: uint64 music_share_id = 10;
     */
    musicShareId: bigint;
    /**
     * @generated from protobuf field: uint32 music_id = 9;
     */
    musicId: number;
    /**
     * @generated from protobuf field: string author_nickname = 12;
     */
    authorNickname: string;
    /**
     * @generated from protobuf field: uint32 music_note_count = 8;
     */
    musicNoteCount: number;
    /**
     * @generated from protobuf field: uint32 max_score = 3;
     */
    maxScore: number;
    /**
     * @generated from protobuf field: uint32 score = 5;
     */
    score: number;
    /**
     * @generated from protobuf field: uint32 create_time = 13;
     */
    createTime: number;
    /**
     * @generated from protobuf field: uint32 share_time = 14;
     */
    shareTime: number;
    /**
     * @generated from protobuf field: uint32 position = 2;
     */
    position: number;
    /**
     * @generated from protobuf field: bool settle = 6;
     */
    settle: boolean;
    /**
     * @generated from protobuf field: uint32 version = 4;
     */
    version: number;
    /**
     * @generated from protobuf field: bool can_share = 15;
     */
    canShare: boolean;
    /**
     * @generated from protobuf field: bool OAPKHNELBPH = 11 [json_name = "OAPKHNELBPH"];
     */
    oAPKHNELBPH: boolean;
    /**
     * @generated from protobuf field: bool NJHAMJMHPAA = 7 [json_name = "NJHAMJMHPAA"];
     */
    nJHAMJMHPAA: boolean;
    /**
     * @generated from protobuf field: uint64 ADIBIKKNPKK = 1 [json_name = "ADIBIKKNPKK"];
     */
    aDIBIKKNPKK: bigint;
    /**
     * @generated from protobuf field: uint32 unknown = 1684;
     */
    unknown: number;
    /**
     * @generated from protobuf field: repeated uint32 GIDFMAJFIFE = 763 [json_name = "GIDFMAJFIFE"];
     */
    gIDFMAJFIFE: number[];
    /**
     * @generated from protobuf field: repeated uint32 OKBJPAKOLIH = 921 [json_name = "OKBJPAKOLIH"];
     */
    oKBJPAKOLIH: number[];
    /**
     * @generated from protobuf field: uint32 FAOPBAMDFJB = 335 [json_name = "FAOPBAMDFJB"];
     */
    fAOPBAMDFJB: number;
    /**
     * @generated from protobuf field: uint32 FELMANEFAOE = 938 [json_name = "FELMANEFAOE"];
     */
    fELMANEFAOE: number;
}
/**
 * @generated from protobuf message MusicGameActivityDetailInfo
 */
export interface MusicGameActivityDetailInfo {
    /**
     * @generated from protobuf field: map<uint32, MusicGameRecord> music_game_record_map = 8;
     */
    musicGameRecordMap: {
        [key: number]: MusicGameRecord;
    };
    /**
     * @generated from protobuf field: repeated MusicBriefInfo person_custom_beatmap = 2;
     */
    personCustomBeatmap: MusicBriefInfo[];
    /**
     * @generated from protobuf field: repeated MusicBriefInfo others_custom_beatmap = 12;
     */
    othersCustomBeatmap: MusicBriefInfo[];
}
/**
 * @generated from protobuf message MusicGameCreateBeatmapReq
 */
export interface MusicGameCreateBeatmapReq {
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 12;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf oneof: beatmap
     */
    beatmap: {
        oneofKind: "musicRecord";
        /**
         * @generated from protobuf field: MusicBeatmap music_record = 10;
         */
        musicRecord: MusicBeatmap;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: brief_info
     */
    briefInfo: {
        oneofKind: "musicBriefInfo";
        /**
         * @generated from protobuf field: MusicBriefInfo music_brief_info = 1021;
         */
        musicBriefInfo: MusicBriefInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message MusicGameCreateBeatmapRsp
 */
export interface MusicGameCreateBeatmapRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 12;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: uint64 music_share_id = 5;
     */
    musicShareId: bigint;
}
/**
 * @generated from protobuf message MusicGameGetBeatmapReq
 */
export interface MusicGameGetBeatmapReq {
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 1;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: uint64 music_share_id = 10;
     */
    musicShareId: bigint;
    /**
     * @generated from protobuf field: MusicGameUnknown2Enum unknown_enum2 = 12;
     */
    unknownEnum2: MusicGameUnknown2Enum;
    /**
     * @generated from protobuf field: bool CDFOGGDLKNA = 15 [json_name = "CDFOGGDLKNA"];
     */
    cDFOGGDLKNA: boolean;
    /**
     * @generated from protobuf field: MusicGameGetBeatmapReqType req_type = 11;
     */
    reqType: MusicGameGetBeatmapReqType;
}
/**
 * @generated from protobuf message MusicGameGetBeatmapRsp
 */
export interface MusicGameGetBeatmapRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 1;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: uint64 music_share_id = 5;
     */
    musicShareId: bigint;
    /**
     * @generated from protobuf field: MusicGameGetBeatmapReqType req_type = 2;
     */
    reqType: MusicGameGetBeatmapReqType;
    /**
     * @generated from protobuf oneof: beatmap
     */
    beatmap: {
        oneofKind: "musicRecord";
        /**
         * @generated from protobuf field: MusicBeatmap music_record = 9;
         */
        musicRecord: MusicBeatmap;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: brief_info
     */
    briefInfo: {
        oneofKind: "musicBriefInfo";
        /**
         * @generated from protobuf field: MusicBriefInfo music_brief_info = 953;
         */
        musicBriefInfo: MusicBriefInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message MusicGameRecord
 */
export interface MusicGameRecord {
    /**
     * @generated from protobuf field: uint32 max_score = 3;
     */
    maxScore: number;
    /**
     * @generated from protobuf field: uint32 max_combo = 12;
     */
    maxCombo: number;
    /**
     * @generated from protobuf field: bool is_unlock = 11;
     */
    isUnlock: boolean;
}
/**
 * @generated from protobuf message MusicGameSearchBeatmapReq
 */
export interface MusicGameSearchBeatmapReq {
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 10;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: uint64 music_share_id = 6;
     */
    musicShareId: bigint;
}
/**
 * @generated from protobuf message MusicGameSearchBeatmapRsp
 */
export interface MusicGameSearchBeatmapRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 3;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: uint64 music_share_id = 4;
     */
    musicShareId: bigint;
    /**
     * @generated from protobuf oneof: ELBEIFGDBMM
     */
    eLBEIFGDBMM: {
        oneofKind: "musicBriefInfo";
        /**
         * @generated from protobuf field: MusicBriefInfo music_brief_info = 11;
         */
        musicBriefInfo: MusicBriefInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message MusicGameSettleReq
 */
export interface MusicGameSettleReq {
    /**
     * @generated from protobuf field: uint32 music_basic_id = 14;
     */
    musicBasicId: number;
    /**
     * @generated from protobuf field: uint32 score = 2;
     */
    score: number;
    /**
     * @generated from protobuf field: uint32 combo = 10;
     */
    combo: number;
    /**
     * @generated from protobuf field: uint32 correct_hit = 8;
     */
    correctHit: number;
    /**
     * @generated from protobuf field: uint64 music_share_id = 11;
     */
    musicShareId: bigint;
    /**
     * is_default_beatmap
     *
     * @generated from protobuf field: bool KJNDJLBOJLM = 4 [json_name = "KJNDJLBOJLM"];
     */
    kJNDJLBOJLM: boolean;
    /**
     * @generated from protobuf field: uint32 FBELCAFFGIJ = 3 [json_name = "FBELCAFFGIJ"];
     */
    fBELCAFFGIJ: number;
    /**
     * @generated from protobuf field: uint32 OOFMAKIDFOL = 15 [json_name = "OOFMAKIDFOL"];
     */
    oOFMAKIDFOL: number;
    /**
     * beatmap_difficulty_level
     *
     * @generated from protobuf field: uint32 HJPDEIMECHB = 1 [json_name = "HJPDEIMECHB"];
     */
    hJPDEIMECHB: number;
    /**
     * @generated from protobuf field: repeated uint32 MNCMGANHCFI = 13 [json_name = "MNCMGANHCFI"];
     */
    mNCMGANHCFI: number[];
    /**
     * @generated from protobuf field: uint32 max_combo = 9;
     */
    maxCombo: number;
    /**
     * @generated from protobuf field: uint32 JJADNMELLAH = 1975 [json_name = "JJADNMELLAH"];
     */
    jJADNMELLAH: number;
    /**
     * detail_score
     *
     * @generated from protobuf field: repeated uint32 EIAGEEFABPO = 1171 [json_name = "EIAGEEFABPO"];
     */
    eIAGEEFABPO: number[];
    /**
     * @generated from protobuf field: uint32 CPIFLFBHNJP = 1104 [json_name = "CPIFLFBHNJP"];
     */
    cPIFLFBHNJP: number;
    /**
     * @generated from protobuf field: bool success = 998;
     */
    success: boolean;
    /**
     * @generated from protobuf field: uint32 GGHBOMGJGFP = 268 [json_name = "GGHBOMGJGFP"];
     */
    gGHBOMGJGFP: number;
    /**
     * @generated from protobuf field: bool PFHCIHKCJFJ = 238 [json_name = "PFHCIHKCJFJ"];
     */
    pFHCIHKCJFJ: boolean;
    /**
     * @generated from protobuf field: float speed = 887;
     */
    speed: number;
}
/**
 * @generated from protobuf message MusicGameSettleRsp
 */
export interface MusicGameSettleRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 music_basic_id = 9;
     */
    musicBasicId: number;
    /**
     * @generated from protobuf field: bool is_unlock_next_level = 1;
     */
    isUnlockNextLevel: boolean;
    /**
     * @generated from protobuf field: bool is_new_record = 3;
     */
    isNewRecord: boolean;
    /**
     * @generated from protobuf field: uint64 music_share_id = 11;
     */
    musicShareId: bigint;
}
/**
 * @generated from protobuf message MusicGameStartReq
 */
export interface MusicGameStartReq {
    /**
     * @generated from protobuf field: uint32 music_basic_id = 10;
     */
    musicBasicId: number;
    /**
     * @generated from protobuf field: uint64 music_share_id = 8;
     */
    musicShareId: bigint;
    /**
     * @generated from protobuf field: bool KJNDJLBOJLM = 5 [json_name = "KJNDJLBOJLM"];
     */
    kJNDJLBOJLM: boolean;
}
/**
 * @generated from protobuf message MusicGameStartRsp
 */
export interface MusicGameStartRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 music_basic_id = 14;
     */
    musicBasicId: number;
    /**
     * @generated from protobuf field: uint64 music_share_id = 12;
     */
    musicShareId: bigint;
}
/**
 * @generated from protobuf message MusicGameStartToPlayOthersBeatmapReq
 */
export interface MusicGameStartToPlayOthersBeatmapReq {
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 12;
     */
    unknownEnum1: MusicGameUnknown1Enum;
}
/**
 * @generated from protobuf message MusicGameStartToPlayOthersBeatmapRsp
 */
export interface MusicGameStartToPlayOthersBeatmapRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: MusicGameUnknown1Enum unknown_enum1 = 11;
     */
    unknownEnum1: MusicGameUnknown1Enum;
    /**
     * @generated from protobuf field: repeated uint64 AMNODOLNOIM = 6 [json_name = "AMNODOLNOIM"];
     */
    aMNODOLNOIM: bigint[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 509;
 * }
 *
 * @generated from protobuf message NpcTalkReq
 */
export interface NpcTalkReq {
    /**
     * @generated from protobuf field: uint32 npc_entity_id = 5;
     */
    npcEntityId: number;
    /**
     * @generated from protobuf field: uint32 talk_id = 7;
     */
    talkId: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 6;
     */
    entityId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 531;
 * }
 *
 * @generated from protobuf message NpcTalkRsp
 */
export interface NpcTalkRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 npc_entity_id = 9;
     */
    npcEntityId: number;
    /**
     * @generated from protobuf field: uint32 cur_talk_id = 6;
     */
    curTalkId: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 7;
     */
    entityId: number;
}
/**
 * @generated from protobuf message OfferingInfo
 */
export interface OfferingInfo {
    /**
     * @generated from protobuf field: uint32 offering_id = 1;
     */
    offeringId: number;
}
/**
 * @generated from protobuf message OneoffGatherPointDetectorData
 */
export interface OneoffGatherPointDetectorData {
    /**
     * @generated from protobuf field: uint32 material_id = 1;
     */
    materialId: number;
    /**
     * @generated from protobuf field: bool is_all_collected = 2;
     */
    isAllCollected: boolean;
    /**
     * @generated from protobuf field: bool is_hint_valid = 3;
     */
    isHintValid: boolean;
    /**
     * @generated from protobuf field: Vector hint_center_pos = 4;
     */
    hintCenterPos?: Vector;
    /**
     * @generated from protobuf field: uint32 hint_radius = 5;
     */
    hintRadius: number;
    /**
     * @generated from protobuf field: uint32 group_id = 6;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 7;
     */
    configId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4262;
 * }
 *
 * @generated from protobuf message OneoffGatherPointDetectorDataNotify
 */
export interface OneoffGatherPointDetectorDataNotify {
    /**
     * @generated from protobuf field: repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list = 6;
     */
    oneoffGatherPointDetectorDataList: OneoffGatherPointDetectorData[];
}
/**
 * @generated from protobuf message OneofGatherPointDetectorData
 */
export interface OneofGatherPointDetectorData {
    /**
     * @generated from protobuf field: Vector hint_center_pos = 7;
     */
    hintCenterPos?: Vector;
    /**
     * @generated from protobuf field: uint32 hint_radius = 14;
     */
    hintRadius: number;
    /**
     * @generated from protobuf field: uint32 material_id = 10;
     */
    materialId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 6;
     */
    configId: number;
    /**
     * @generated from protobuf field: uint32 group_id = 13;
     */
    groupId: number;
    /**
     * @generated from protobuf field: bool is_all_collected = 4;
     */
    isAllCollected: boolean;
    /**
     * @generated from protobuf field: bool is_hint_valid = 15;
     */
    isHintValid: boolean;
}
/**
 * @generated from protobuf message OneofGatherPointDetectorDataNotify
 */
export interface OneofGatherPointDetectorDataNotify {
    /**
     * @generated from protobuf field: repeated OneofGatherPointDetectorData oneof_gather_point_detector_data_list = 3;
     */
    oneofGatherPointDetectorDataList: OneofGatherPointDetectorData[];
}
/**
 * @generated from protobuf message OnlinePlayerInfo
 */
export interface OnlinePlayerInfo {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: string nickname = 2;
     */
    nickname: string;
    /**
     * @generated from protobuf field: uint32 player_level = 3;
     */
    playerLevel: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 4;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: MpSettingType mp_setting_type = 5;
     */
    mpSettingType: MpSettingType;
    /**
     * @generated from protobuf field: uint32 cur_player_num_in_world = 6;
     */
    curPlayerNumInWorld: number;
    /**
     * @generated from protobuf field: uint32 world_level = 7;
     */
    worldLevel: number;
    /**
     * @generated from protobuf field: string online_id = 8;
     */
    onlineId: string;
    /**
     * @generated from protobuf field: uint32 name_card_id = 9;
     */
    nameCardId: number;
    /**
     * @generated from protobuf field: repeated uint32 blacklist_uid_list = 10;
     */
    blacklistUidList: number[];
    /**
     * @generated from protobuf field: string signature = 11;
     */
    signature: string;
    /**
     * @generated from protobuf field: ProfilePicture profile_picture = 12;
     */
    profilePicture?: ProfilePicture;
    /**
     * @generated from protobuf field: string psn_id = 13;
     */
    psnId: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 119;
 * }
 *
 * @generated from protobuf message OpenStateUpdateNotify
 */
export interface OpenStateUpdateNotify {
    /**
     * @generated from protobuf field: map<uint32, uint32> open_state_map = 12;
     */
    openStateMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message PacketHead
 */
export interface PacketHead {
    /**
     * @generated from protobuf field: uint32 client_sequence_id = 3;
     */
    clientSequenceId: number;
    /**
     * @generated from protobuf field: uint64 timestamp = 6;
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message ParamList
 */
export interface ParamList {
    /**
     * @generated from protobuf field: repeated uint32 param_list_ = 1;
     */
    paramList: number[];
}
/**
 * @generated from protobuf message ParentQuest
 */
export interface ParentQuest {
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 1;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: repeated ChildQuest child_quest_list = 2;
     */
    childQuestList: ChildQuest[];
    /**
     * @generated from protobuf field: bool is_finished = 3;
     */
    isFinished: boolean;
    /**
     * @generated from protobuf field: bool is_random = 4;
     */
    isRandom: boolean;
    /**
     * @generated from protobuf field: ParentQuestRandomInfo random_info = 5;
     */
    randomInfo?: ParentQuestRandomInfo;
    /**
     * @generated from protobuf field: repeated int32 quest_var = 6;
     */
    questVar: number[];
    /**
     * @generated from protobuf field: uint32 parent_quest_state = 7;
     */
    parentQuestState: number;
    /**
     * @generated from protobuf field: uint32 quest_var_seq = 8;
     */
    questVarSeq: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> time_var_map = 9;
     */
    timeVarMap: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message ParentQuestRandomInfo
 */
export interface ParentQuestRandomInfo {
    /**
     * @generated from protobuf field: uint32 entrance_id = 1;
     */
    entranceId: number;
    /**
     * @generated from protobuf field: uint32 template_id = 2;
     */
    templateId: number;
    /**
     * @generated from protobuf field: repeated uint32 factor_list = 3;
     */
    factorList: number[];
}
/**
 * @generated from protobuf message PersonalLineAllDataReq
 */
export interface PersonalLineAllDataReq {
}
/**
 * @generated from protobuf message PersonalLineAllDataRsp
 */
export interface PersonalLineAllDataRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 cur_finished_daily_task_count = 4;
     */
    curFinishedDailyTaskCount: number;
    /**
     * @generated from protobuf field: uint32 legendary_key_count = 3;
     */
    legendaryKeyCount: number;
    /**
     * @generated from protobuf field: repeated uint32 ongoing_personal_line_list = 13;
     */
    ongoingPersonalLineList: number[];
    /**
     * @generated from protobuf field: repeated uint32 can_be_unlocked_personal_line_list = 12;
     */
    canBeUnlockedPersonalLineList: number[];
    /**
     * @generated from protobuf field: repeated LockedPersonallineData locked_personal_line_list = 14;
     */
    lockedPersonalLineList: LockedPersonallineData[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 266;
 * }
 *
 * @generated from protobuf message PersonalSceneJumpReq
 */
export interface PersonalSceneJumpReq {
    /**
     * @generated from protobuf field: uint32 point_id = 2;
     */
    pointId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 248;
 * }
 *
 * @generated from protobuf message PersonalSceneJumpRsp
 */
export interface PersonalSceneJumpRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 dest_scene_id = 2;
     */
    destSceneId: number;
    /**
     * @generated from protobuf field: Vector dest_pos = 6;
     */
    destPos?: Vector;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 32;
 * }
 *
 * @generated from protobuf message PingReq
 */
export interface PingReq {
    /**
     * @generated from protobuf field: uint32 seq = 2;
     */
    seq: number;
    /**
     * @generated from protobuf field: uint32 client_time = 14;
     */
    clientTime: number;
    /**
     * @generated from protobuf field: bytes sc_data = 11;
     */
    scData: Uint8Array;
    /**
     * @generated from protobuf field: float ue_time = 15;
     */
    ueTime: number;
    /**
     * @generated from protobuf field: double total_tick_time = 12;
     */
    totalTickTime: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 17;
 * }
 *
 * @generated from protobuf message PingRsp
 */
export interface PingRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 seq = 4;
     */
    seq: number;
    /**
     * @generated from protobuf field: uint32 client_time = 8;
     */
    clientTime: number;
}
/**
 * @generated from protobuf message PlatformInfo
 */
export interface PlatformInfo {
    /**
     * @generated from protobuf field: uint32 route_id = 1;
     */
    routeId: number;
    /**
     * @generated from protobuf field: int32 start_index = 2;
     */
    startIndex: number;
    /**
     * @generated from protobuf field: uint32 start_route_time = 3;
     */
    startRouteTime: number;
    /**
     * @generated from protobuf field: uint32 start_scene_time = 4;
     */
    startSceneTime: number;
    /**
     * @generated from protobuf field: Vector start_pos = 7;
     */
    startPos?: Vector;
    /**
     * @generated from protobuf field: bool is_started = 8;
     */
    isStarted: boolean;
    /**
     * @generated from protobuf field: MathQuaternion start_rot = 9;
     */
    startRot?: MathQuaternion;
    /**
     * @generated from protobuf field: uint32 stop_scene_time = 10;
     */
    stopSceneTime: number;
    /**
     * @generated from protobuf field: Vector pos_offset = 11;
     */
    posOffset?: Vector;
    /**
     * @generated from protobuf field: MathQuaternion rot_offset = 12;
     */
    rotOffset?: MathQuaternion;
    /**
     * @generated from protobuf field: MovingPlatformType moving_platform_type = 13;
     */
    movingPlatformType: MovingPlatformType;
    /**
     * @generated from protobuf field: bool is_active = 14;
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: Route route = 15;
     */
    route?: Route;
    /**
     * @generated from protobuf field: uint32 point_id = 16;
     */
    pointId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1818;
 * }
 *
 * @generated from protobuf message PlayerApplyEnterMpNotify
 */
export interface PlayerApplyEnterMpNotify {
    /**
     * @generated from protobuf field: OnlinePlayerInfo src_player_info = 11;
     */
    srcPlayerInfo?: OnlinePlayerInfo;
    /**
     * @generated from protobuf field: uint32 src_app_id = 6;
     */
    srcAppId: number;
    /**
     * @generated from protobuf field: uint32 src_thread_index = 13;
     */
    srcThreadIndex: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1809;
 * }
 *
 * @generated from protobuf message PlayerApplyEnterMpReq
 */
export interface PlayerApplyEnterMpReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 3;
     */
    targetUid: number;
}
/**
 * @generated from protobuf message PlayerApplyEnterMpResultNotify
 */
export interface PlayerApplyEnterMpResultNotify {
    /**
     * @generated from protobuf field: uint32 target_uid = 7;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: bool is_agreed = 4;
     */
    isAgreed: boolean;
    /**
     * @generated from protobuf field: PlayerApplyEnterMpResultNotify.Reason reason = 14;
     */
    reason: PlayerApplyEnterMpResultNotify_Reason;
    /**
     * @generated from protobuf field: string target_nickname = 5;
     */
    targetNickname: string;
}
/**
 * @generated from protobuf enum PlayerApplyEnterMpResultNotify.Reason
 */
export enum PlayerApplyEnterMpResultNotify_Reason {
    /**
     * @generated from protobuf enum value: REASON_PLAYER_JUDGE = 0;
     */
    PLAYER_JUDGE = 0,
    /**
     * @generated from protobuf enum value: REASON_SCENE_CANNOT_ENTER = 1;
     */
    SCENE_CANNOT_ENTER = 1,
    /**
     * @generated from protobuf enum value: REASON_PLAYER_CANNOT_ENTER_MP = 2;
     */
    PLAYER_CANNOT_ENTER_MP = 2,
    /**
     * @generated from protobuf enum value: REASON_SYSTEM_JUDGE = 3;
     */
    SYSTEM_JUDGE = 3,
    /**
     * @generated from protobuf enum value: REASON_ALLOW_ENTER_PLAYER_FULL = 4;
     */
    ALLOW_ENTER_PLAYER_FULL = 4,
    /**
     * @generated from protobuf enum value: REASON_WORLD_LEVEL_LOWER_THAN_HOST = 5;
     */
    WORLD_LEVEL_LOWER_THAN_HOST = 5,
    /**
     * @generated from protobuf enum value: REASON_HOST_IN_MATCH = 6;
     */
    HOST_IN_MATCH = 6,
    /**
     * @generated from protobuf enum value: REASON_PLAYER_IN_BLACKLIST = 7;
     */
    PLAYER_IN_BLACKLIST = 7,
    /**
     * @generated from protobuf enum value: REASON_PS_PLAYER_NOT_ACCEPT_OTHERS = 8;
     */
    PS_PLAYER_NOT_ACCEPT_OTHERS = 8,
    /**
     * @generated from protobuf enum value: REASON_HOST_IS_BLOCKED = 9;
     */
    HOST_IS_BLOCKED = 9,
    /**
     * @generated from protobuf enum value: REASON_OTHER_DATA_VERSION_NOT_LATEST = 10;
     */
    OTHER_DATA_VERSION_NOT_LATEST = 10,
    /**
     * @generated from protobuf enum value: REASON_DATA_VERSION_NOT_LATEST = 11;
     */
    DATA_VERSION_NOT_LATEST = 11,
    /**
     * @generated from protobuf enum value: REASON_PLAYER_NOT_IN_PLAYER_WORLD = 12;
     */
    PLAYER_NOT_IN_PLAYER_WORLD = 12,
    /**
     * @generated from protobuf enum value: REASON_MAX_PLAYER = 13;
     */
    MAX_PLAYER = 13
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1828;
 * }
 *
 * @generated from protobuf message PlayerApplyEnterMpResultReq
 */
export interface PlayerApplyEnterMpResultReq {
    /**
     * @generated from protobuf field: uint32 apply_uid = 15;
     */
    applyUid: number;
    /**
     * @generated from protobuf field: bool is_agreed = 9;
     */
    isAgreed: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1803;
 * }
 *
 * @generated from protobuf message PlayerApplyEnterMpResultRsp
 */
export interface PlayerApplyEnterMpResultRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 apply_uid = 4;
     */
    applyUid: number;
    /**
     * @generated from protobuf field: bool is_agreed = 12;
     */
    isAgreed: boolean;
    /**
     * @generated from protobuf field: uint32 param = 9;
     */
    param: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1843;
 * }
 *
 * @generated from protobuf message PlayerApplyEnterMpRsp
 */
export interface PlayerApplyEnterMpRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 4;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint32 param = 9;
     */
    param: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3295;
 * }
 *
 * @generated from protobuf message PlayerChatNotify
 */
export interface PlayerChatNotify {
    /**
     * @generated from protobuf field: uint32 channel_id = 14;
     */
    channelId: number;
    /**
     * @generated from protobuf field: ChatInfo chat_info = 12;
     */
    chatInfo?: ChatInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 3378;
 * }
 *
 * @generated from protobuf message PlayerChatReq
 */
export interface PlayerChatReq {
    /**
     * @generated from protobuf field: uint32 channel_id = 9;
     */
    channelId: number;
    /**
     * @generated from protobuf field: ChatInfo chat_info = 1;
     */
    chatInfo?: ChatInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3321;
 * }
 *
 * @generated from protobuf message PlayerChatRsp
 */
export interface PlayerChatRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 chat_forbidden_endtime = 15;
     */
    chatForbiddenEndtime: number;
}
/**
 * @generated from protobuf message PlayerCookArgsReq
 */
export interface PlayerCookArgsReq {
    /**
     * @generated from protobuf field: uint32 recipe_id = 3;
     */
    recipeId: number;
    /**
     * @generated from protobuf field: uint32 assist_avatar = 15;
     */
    assistAvatar: number;
}
/**
 * @generated from protobuf message PlayerCookArgsRsp
 */
export interface PlayerCookArgsRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: float qte_range_ratio = 15;
     */
    qteRangeRatio: number;
}
/**
 * @generated from protobuf message PlayerCookReq
 */
export interface PlayerCookReq {
    /**
     * @generated from protobuf field: uint32 recipe_id = 6;
     */
    recipeId: number;
    /**
     * @generated from protobuf field: uint32 qte_quality = 2;
     */
    qteQuality: number;
    /**
     * @generated from protobuf field: uint32 assist_avatar = 11;
     */
    assistAvatar: number;
    /**
     * @generated from protobuf field: uint32 cook_count = 7;
     */
    cookCount: number;
}
/**
 * @generated from protobuf message PlayerCookRsp
 */
export interface PlayerCookRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: CookRecipeData recipe_data = 14;
     */
    recipeData?: CookRecipeData;
    /**
     * @generated from protobuf field: repeated ItemParam item_list = 13;
     */
    itemList: ItemParam[];
    /**
     * @generated from protobuf field: uint32 qte_quality = 11;
     */
    qteQuality: number;
    /**
     * @generated from protobuf field: uint32 cook_count = 15;
     */
    cookCount: number;
    /**
     * @generated from protobuf field: repeated ItemParam extral_item_list = 3;
     */
    extralItemList: ItemParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 135;
 * }
 *
 * @generated from protobuf message PlayerDataNotify
 */
export interface PlayerDataNotify {
    /**
     * @generated from protobuf field: string nick_name = 15;
     */
    nickName: string;
    /**
     * @generated from protobuf field: uint64 server_time = 2;
     */
    serverTime: bigint;
    /**
     * @generated from protobuf field: bool is_first_login_today = 11;
     */
    isFirstLoginToday: boolean;
    /**
     * @generated from protobuf field: uint32 region_id = 9;
     */
    regionId: number;
    /**
     * @generated from protobuf field: map<uint32, PropValue> prop_map = 8;
     */
    propMap: {
        [key: number]: PropValue;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 941;
 * }
 *
 * @generated from protobuf message PlayerEnterDungeonReq
 */
export interface PlayerEnterDungeonReq {
    /**
     * @generated from protobuf field: uint32 point_id = 5;
     */
    pointId: number;
    /**
     * @generated from protobuf field: uint32 dungeon_id = 12;
     */
    dungeonId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 937;
 * }
 *
 * @generated from protobuf message PlayerEnterDungeonRsp
 */
export interface PlayerEnterDungeonRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 point_id = 1;
     */
    pointId: number;
    /**
     * @generated from protobuf field: uint32 dungeon_id = 13;
     */
    dungeonId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 274;
 * }
 *
 * @generated from protobuf message PlayerEnterSceneInfoNotify
 */
export interface PlayerEnterSceneInfoNotify {
    /**
     * @generated from protobuf field: uint32 cur_avatar_entity_id = 8;
     */
    curAvatarEntityId: number;
    /**
     * @generated from protobuf field: repeated AvatarEnterSceneInfo avatar_enter_info = 14;
     */
    avatarEnterInfo: AvatarEnterSceneInfo[];
    /**
     * @generated from protobuf field: TeamEnterSceneInfo team_enter_info = 9;
     */
    teamEnterInfo?: TeamEnterSceneInfo;
    /**
     * @generated from protobuf field: MPLevelEntityInfo mp_level_entity_info = 5;
     */
    mpLevelEntityInfo?: MPLevelEntityInfo;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 7;
     */
    enterSceneToken: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 209;
 * }
 *
 * @generated from protobuf message PlayerEnterSceneNotify
 */
export interface PlayerEnterSceneNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 14;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: Vector pos = 15;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: uint64 scene_begin_time = 12;
     */
    sceneBeginTime: bigint;
    /**
     * @generated from protobuf field: EnterType type = 2;
     */
    type: EnterType;
    /**
     * @generated from protobuf field: uint32 target_uid = 4;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint32 prev_scene_id = 7;
     */
    prevSceneId: number;
    /**
     * @generated from protobuf field: Vector prev_pos = 6;
     */
    prevPos?: Vector;
    /**
     * @generated from protobuf field: uint32 dungeon_id = 13;
     */
    dungeonId: number;
    /**
     * @generated from protobuf field: uint32 world_level = 3;
     */
    worldLevel: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 9;
     */
    enterSceneToken: number;
    /**
     * @generated from protobuf field: bool is_first_login_enter_scene = 11;
     */
    isFirstLoginEnterScene: boolean;
    /**
     * @generated from protobuf field: repeated uint32 scene_tag_id_list = 1;
     */
    sceneTagIdList: number[];
    /**
     * @generated from protobuf field: bool is_skip_ui = 1430;
     */
    isSkipUi: boolean;
    /**
     * @generated from protobuf field: uint32 enter_reason = 1982;
     */
    enterReason: number;
    /**
     * @generated from protobuf field: uint32 world_type = 1067;
     */
    worldType: number;
    /**
     * @generated from protobuf field: string scene_transaction = 1081;
     */
    sceneTransaction: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 155;
 * }
 *
 * @generated from protobuf message PlayerGameTimeNotify
 */
export interface PlayerGameTimeNotify {
    /**
     * @generated from protobuf field: uint32 game_time = 7;
     */
    gameTime: number;
    /**
     * @generated from protobuf field: uint32 uid = 13;
     */
    uid: number;
    /**
     * @generated from protobuf field: bool is_home = 12;
     */
    isHome: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4162;
 * }
 *
 * @generated from protobuf message PlayerGetForceQuitBanInfoRsp
 */
export interface PlayerGetForceQuitBanInfoRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 match_id = 8;
     */
    matchId: number;
    /**
     * @generated from protobuf field: uint32 expire_time = 5;
     */
    expireTime: number;
}
/**
 * @generated from protobuf message PlayerHomeCompInfo
 */
export interface PlayerHomeCompInfo {
    /**
     * @generated from protobuf field: FriendEnterHomeOption friend_enter_home_option = 5;
     */
    friendEnterHomeOption: FriendEnterHomeOption;
    /**
     * @generated from protobuf field: repeated uint32 unlocked_module_id_list = 1;
     */
    unlockedModuleIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 levelup_reward_got_level_list = 10;
     */
    levelupRewardGotLevelList: number[];
    /**
     * @generated from protobuf field: repeated uint32 seen_module_id_list = 14;
     */
    seenModuleIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4563;
 * }
 *
 * @generated from protobuf message PlayerHomeCompInfoNotify
 */
export interface PlayerHomeCompInfoNotify {
    /**
     * @generated from protobuf field: PlayerHomeCompInfo comp_info = 2;
     */
    compInfo?: PlayerHomeCompInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 143;
 * }
 *
 * @generated from protobuf message PlayerLevelRewardUpdateNotify
 */
export interface PlayerLevelRewardUpdateNotify {
    /**
     * @generated from protobuf field: repeated uint32 level_list = 14;
     */
    levelList: number[];
}
/**
 * @generated from protobuf message PlayerLocationInfo
 */
export interface PlayerLocationInfo {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: Vector pos = 2;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 3;
     */
    rot?: Vector;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 141;
 * }
 *
 * @generated from protobuf message PlayerLoginReq
 */
export interface PlayerLoginReq {
    /**
     * @generated from protobuf field: string token = 5;
     */
    token: string;
    /**
     * @generated from protobuf field: string client_version = 7;
     */
    clientVersion: string;
    /**
     * @generated from protobuf field: string system_version = 12;
     */
    systemVersion: string;
    /**
     * @generated from protobuf field: string device_name = 3;
     */
    deviceName: string;
    /**
     * @generated from protobuf field: string device_uuid = 14;
     */
    deviceUuid: string;
    /**
     * @generated from protobuf field: uint32 target_uid = 15;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint64 login_rand = 11;
     */
    loginRand: bigint;
    /**
     * @generated from protobuf field: bool is_editor = 2;
     */
    isEditor: boolean;
    /**
     * @generated from protobuf field: uint32 language_type = 13;
     */
    languageType: number;
    /**
     * @generated from protobuf field: uint32 account_type = 1;
     */
    accountType: number;
    /**
     * @generated from protobuf field: string account_uid = 8;
     */
    accountUid: string;
    /**
     * @generated from protobuf field: string platform = 6;
     */
    platform: string;
    /**
     * @generated from protobuf field: string device_info = 4;
     */
    deviceInfo: string;
    /**
     * @generated from protobuf field: uint32 platform_type = 10;
     */
    platformType: number;
    /**
     * @generated from protobuf field: bool is_guest = 9;
     */
    isGuest: boolean;
    /**
     * @generated from protobuf field: uint32 cloud_client_ip = 233;
     */
    cloudClientIp: number;
    /**
     * @generated from protobuf field: uint32 gm_uid = 1423;
     */
    gmUid: number;
    /**
     * @generated from protobuf field: string checksum = 485;
     */
    checksum: string;
    /**
     * @generated from protobuf field: string online_id = 1974;
     */
    onlineId: string;
    /**
     * @generated from protobuf field: uint32 client_token = 133;
     */
    clientToken: number;
    /**
     * @generated from protobuf field: bytes security_cmd_reply = 96;
     */
    securityCmdReply: Uint8Array;
    /**
     * @generated from protobuf field: bytes extra_bin_data = 814;
     */
    extraBinData: Uint8Array;
    /**
     * @generated from protobuf field: string cps = 467;
     */
    cps: string;
    /**
     * @generated from protobuf field: uint32 channel_id = 2028;
     */
    channelId: number;
    /**
     * @generated from protobuf field: uint32 sub_channel_id = 1571;
     */
    subChannelId: number;
    /**
     * @generated from protobuf field: string checksum_client_version = 1844;
     */
    checksumClientVersion: string;
    /**
     * @generated from protobuf field: uint32 tag = 843;
     */
    tag: number;
    /**
     * @generated from protobuf field: TrackingIOInfo tracking_io_info = 1882;
     */
    trackingIoInfo?: TrackingIOInfo;
    /**
     * @generated from protobuf field: string country_code = 1060;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: uint32 client_data_version = 1570;
     */
    clientDataVersion: number;
    /**
     * @generated from protobuf field: bytes environment_error_code = 1303;
     */
    environmentErrorCode: Uint8Array;
    /**
     * @generated from protobuf field: uint32 target_home_owner_uid = 1054;
     */
    targetHomeOwnerUid: number;
    /**
     * @generated from protobuf field: string psn_id = 921;
     */
    psnId: string;
    /**
     * @generated from protobuf field: string client_verison_hash = 1972;
     */
    clientVerisonHash: string;
    /**
     * @generated from protobuf field: bool is_transfer = 1918;
     */
    isTransfer: boolean;
    /**
     * @generated from protobuf field: uint32 reg_platform = 167;
     */
    regPlatform: number;
    /**
     * @generated from protobuf field: uint32 target_home_param = 1129;
     */
    targetHomeParam: number;
    /**
     * @generated from protobuf field: AdjustTrackingInfo adjust_tracking_info = 280;
     */
    adjustTrackingInfo?: AdjustTrackingInfo;
    /**
     * @generated from protobuf field: string birthday = 174;
     */
    birthday: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 137;
 * }
 *
 * @generated from protobuf message PlayerLoginRsp
 */
export interface PlayerLoginRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: bytes player_data = 6;
     */
    playerData: Uint8Array;
    /**
     * @generated from protobuf field: bool is_new_player = 11;
     */
    isNewPlayer: boolean;
    /**
     * @generated from protobuf field: uint32 target_uid = 15;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint64 login_rand = 12;
     */
    loginRand: bigint;
    /**
     * @generated from protobuf field: bool is_use_ability_hash = 3;
     */
    isUseAbilityHash: boolean;
    /**
     * @generated from protobuf field: int32 ability_hash_code = 7;
     */
    abilityHashCode: number;
    /**
     * @generated from protobuf field: map<string, int32> ability_hash_map = 13;
     */
    abilityHashMap: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: uint32 client_data_version = 14;
     */
    clientDataVersion: number;
    /**
     * @generated from protobuf field: bool is_relogin = 2;
     */
    isRelogin: boolean;
    /**
     * @generated from protobuf field: uint32 client_silence_data_version = 10;
     */
    clientSilenceDataVersion: number;
    /**
     * @generated from protobuf field: string game_biz = 9;
     */
    gameBiz: string;
    /**
     * @generated from protobuf field: uint32 player_data_version = 8;
     */
    playerDataVersion: number;
    /**
     * @generated from protobuf field: string client_md_5 = 1706;
     */
    clientMd5: string;
    /**
     * @generated from protobuf field: string client_silence_md_5 = 271;
     */
    clientSilenceMd5: string;
    /**
     * @generated from protobuf field: ResVersionConfig res_version_config = 933;
     */
    resVersionConfig?: ResVersionConfig;
    /**
     * @generated from protobuf field: map<uint32, BlockInfo> block_info_map = 1156;
     */
    blockInfoMap: {
        [key: number]: BlockInfo;
    };
    /**
     * @generated from protobuf field: string client_version_suffix = 1984;
     */
    clientVersionSuffix: string;
    /**
     * @generated from protobuf field: string client_silence_version_suffix = 49;
     */
    clientSilenceVersionSuffix: string;
    /**
     * @generated from protobuf field: repeated ShortAbilityHashPair short_ability_hash_map = 364;
     */
    shortAbilityHashMap: ShortAbilityHashPair[];
    /**
     * @generated from protobuf field: bytes sc_info = 2014;
     */
    scInfo: Uint8Array;
    /**
     * @generated from protobuf field: bool is_audit = 1545;
     */
    isAudit: boolean;
    /**
     * @generated from protobuf field: bool is_sc_open = 1974;
     */
    isScOpen: boolean;
    /**
     * @generated from protobuf field: string register_cps = 715;
     */
    registerCps: string;
    /**
     * @generated from protobuf field: repeated FeatureBlockInfo feature_block_info_list = 408;
     */
    featureBlockInfoList: FeatureBlockInfo[];
    /**
     * @generated from protobuf field: bool is_data_need_relogin = 110;
     */
    isDataNeedRelogin: boolean;
    /**
     * @generated from protobuf field: string country_code = 1306;
     */
    countryCode: string;
    /**
     * @generated from protobuf field: ResVersionConfig next_res_version_config = 749;
     */
    nextResVersionConfig?: ResVersionConfig;
    /**
     * @generated from protobuf field: string next_resource_url = 1744;
     */
    nextResourceUrl: string;
    /**
     * @generated from protobuf field: uint32 target_home_owner_uid = 945;
     */
    targetHomeOwnerUid: number;
    /**
     * @generated from protobuf field: bool is_enable_client_hash_debug = 713;
     */
    isEnableClientHashDebug: boolean;
    /**
     * @generated from protobuf field: bool is_transfer = 138;
     */
    isTransfer: boolean;
    /**
     * @generated from protobuf field: double total_tick_time = 1923;
     */
    totalTickTime: number;
    /**
     * @generated from protobuf field: string birthday = 1977;
     */
    birthday: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 127;
 * }
 *
 * @generated from protobuf message PlayerPropNotify
 */
export interface PlayerPropNotify {
    /**
     * @generated from protobuf field: map<uint32, PropValue> prop_map = 10;
     */
    propMap: {
        [key: number]: PropValue;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 932;
 * }
 *
 * @generated from protobuf message PlayerQuitDungeonReq
 */
export interface PlayerQuitDungeonReq {
    /**
     * @generated from protobuf field: uint32 point_id = 12;
     */
    pointId: number;
    /**
     * @generated from protobuf field: bool is_quit_immediately = 4;
     */
    isQuitImmediately: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 917;
 * }
 *
 * @generated from protobuf message PlayerQuitDungeonRsp
 */
export interface PlayerQuitDungeonRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 point_id = 6;
     */
    pointId: number;
}
/**
 * @generated from protobuf message PlayerRTTInfo
 */
export interface PlayerRTTInfo {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 rtt = 2;
     */
    rtt: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 159;
 * }
 *
 * @generated from protobuf message PlayerSetPauseReq
 */
export interface PlayerSetPauseReq {
    /**
     * @generated from protobuf field: bool is_paused = 7;
     */
    isPaused: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 609;
 * }
 *
 * @generated from protobuf message PlayerStoreNotify
 */
export interface PlayerStoreNotify {
    /**
     * @generated from protobuf field: StoreType store_type = 4;
     */
    storeType: StoreType;
    /**
     * @generated from protobuf field: repeated Item item_list = 3;
     */
    itemList: Item[];
    /**
     * @generated from protobuf field: uint32 weight_limit = 15;
     */
    weightLimit: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 172;
 * }
 *
 * @generated from protobuf message PlayerTimeNotify
 */
export interface PlayerTimeNotify {
    /**
     * @generated from protobuf field: bool is_paused = 8;
     */
    isPaused: boolean;
    /**
     * @generated from protobuf field: uint64 player_time = 4;
     */
    playerTime: bigint;
    /**
     * @generated from protobuf field: uint64 server_time = 14;
     */
    serverTime: bigint;
}
/**
 * @generated from protobuf message PlayerWorldLocationInfo
 */
export interface PlayerWorldLocationInfo {
    /**
     * @generated from protobuf field: uint32 scene_id = 1;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: PlayerLocationInfo player_loc = 2;
     */
    playerLoc?: PlayerLocationInfo;
}
/**
 * @generated from protobuf message PlayerWorldSceneInfo
 */
export interface PlayerWorldSceneInfo {
    /**
     * @generated from protobuf field: uint32 scene_id = 13;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: bool is_locked = 6;
     */
    isLocked: boolean;
    /**
     * @generated from protobuf field: repeated uint32 scene_tag_id_list = 9;
     */
    sceneTagIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3172;
 * }
 *
 * @generated from protobuf message PlayerWorldSceneInfoListNotify
 */
export interface PlayerWorldSceneInfoListNotify {
    /**
     * @generated from protobuf field: repeated PlayerWorldSceneInfo info_list = 5;
     */
    infoList: PlayerWorldSceneInfo[];
}
/**
 * @generated from protobuf message PlayTeamEntityInfo
 */
export interface PlayTeamEntityInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 player_uid = 2;
     */
    playerUid: number;
    /**
     * @generated from protobuf field: uint32 authority_peer_id = 3;
     */
    authorityPeerId: number;
    /**
     * @generated from protobuf field: uint32 gadget_config_id = 5;
     */
    gadgetConfigId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo ability_info = 6;
     */
    abilityInfo?: AbilitySyncStateInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3344;
 * }
 *
 * @generated from protobuf message PostEnterSceneRsp
 */
export interface PostEnterSceneRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 15;
     */
    enterSceneToken: number;
}
/**
 * @generated from protobuf message PotionDungeonResultInfo
 */
export interface PotionDungeonResultInfo {
    /**
     * @generated from protobuf field: uint32 final_score = 8;
     */
    finalScore: number;
    /**
     * @generated from protobuf field: uint32 left_time = 9;
     */
    leftTime: number;
    /**
     * @generated from protobuf field: uint32 Unk2700_FHEHGDABALE = 14 [json_name = "Unk2700FHEHGDABALE"];
     */
    unk2700FHEHGDABALE: number;
    /**
     * @generated from protobuf field: uint32 Unk2700_HKFEBBCMBHL = 11 [json_name = "Unk2700HKFEBBCMBHL"];
     */
    unk2700HKFEBBCMBHL: number;
    /**
     * @generated from protobuf field: uint32 level_id = 4;
     */
    levelId: number;
    /**
     * @generated from protobuf field: uint32 stage_id = 2;
     */
    stageId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4991;
 * }
 *
 * @generated from protobuf message PrivateChatNotify
 */
export interface PrivateChatNotify {
    /**
     * @generated from protobuf field: ChatInfo chat_info = 1;
     */
    chatInfo?: ChatInfo;
}
/**
 * @generated from protobuf message PrivateChatReq
 */
export interface PrivateChatReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 2;
     */
    targetUid: number;
    /**
     * @generated from protobuf oneof: content
     */
    content: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 8;
         */
        text: string;
    } | {
        oneofKind: "icon";
        /**
         * @generated from protobuf field: uint32 icon = 6;
         */
        icon: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4981;
 * }
 *
 * @generated from protobuf message PrivateChatRsp
 */
export interface PrivateChatRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 chat_forbidden_endtime = 10;
     */
    chatForbiddenEndtime: number;
}
/**
 * @generated from protobuf message ProfilePicture
 */
export interface ProfilePicture {
    /**
     * @generated from protobuf field: uint32 avatar_id = 1;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint32 costume_id = 2;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message PropPair
 */
export interface PropPair {
    /**
     * @generated from protobuf field: uint32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: PropValue prop_value = 2;
     */
    propValue?: PropValue;
}
/**
 * @generated from protobuf message PropValue
 */
export interface PropValue {
    /**
     * @generated from protobuf field: uint32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: int64 val = 4;
     */
    val: bigint;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "ival";
        /**
         * @generated from protobuf field: int64 ival = 2;
         */
        ival: bigint;
    } | {
        oneofKind: "fval";
        /**
         * @generated from protobuf field: float fval = 3;
         */
        fval: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1055;
 * }
 *
 * @generated from protobuf message ProudSkillChangeNotify
 */
export interface ProudSkillChangeNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 12;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 entity_id = 11;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 7;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: repeated uint32 proud_skill_list = 4;
     */
    proudSkillList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1097;
 * }
 *
 * @generated from protobuf message ProudSkillExtraLevelNotify
 */
export interface ProudSkillExtraLevelNotify {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 14;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 talent_type = 10;
     */
    talentType: number;
    /**
     * @generated from protobuf field: uint32 talent_index = 4;
     */
    talentIndex: number;
    /**
     * @generated from protobuf field: uint32 extra_level = 5;
     */
    extraLevel: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4967;
 * }
 *
 * @generated from protobuf message PullPrivateChatReq
 */
export interface PullPrivateChatReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 2;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint32 from_sequence = 7;
     */
    fromSequence: number;
    /**
     * @generated from protobuf field: uint32 pull_num = 5;
     */
    pullNum: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 5035;
 * }
 *
 * @generated from protobuf message PullPrivateChatRsp
 */
export interface PullPrivateChatRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated ChatInfo chat_info = 12;
     */
    chatInfo: ChatInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4999;
 * }
 *
 * @generated from protobuf message PullRecentChatRsp
 */
export interface PullRecentChatRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated ChatInfo chat_info = 12;
     */
    chatInfo: ChatInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4207;
 * }
 *
 * @generated from protobuf message QueryCodexMonsterBeKilledNumReq
 */
export interface QueryCodexMonsterBeKilledNumReq {
    /**
     * @generated from protobuf field: repeated uint32 codex_id_list = 11;
     */
    codexIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4205;
 * }
 *
 * @generated from protobuf message QueryCodexMonsterBeKilledNumRsp
 */
export interface QueryCodexMonsterBeKilledNumRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 codex_id_list = 4;
     */
    codexIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 be_killed_num_list = 11;
     */
    beKilledNumList: number[];
    /**
     * @generated from protobuf field: repeated uint32 CHPBKCLKPCJ = 2 [json_name = "CHPBKCLKPCJ"];
     */
    cHPBKCLKPCJ: number[];
}
/**
 * @generated from protobuf message QueryCurrRegionHttpRsp
 */
export interface QueryCurrRegionHttpRsp {
    /**
     * @generated from protobuf oneof: Detail
     */
    detail: {
        oneofKind: "forceUdpate";
        /**
         * @generated from protobuf field: ForceUpdateInfo force_udpate = 4;
         */
        forceUdpate: ForceUpdateInfo;
    } | {
        oneofKind: "stopServer";
        /**
         * @generated from protobuf field: StopServerInfo stop_server = 5;
         */
        stopServer: StopServerInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: string msg = 2;
     */
    msg: string;
    /**
     * @generated from protobuf field: RegionInfo region_info = 3;
     */
    regionInfo?: RegionInfo;
    /**
     * @generated from protobuf field: bytes client_secret_key = 11;
     */
    clientSecretKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes region_custom_config_encrypted = 12;
     */
    regionCustomConfigEncrypted: Uint8Array;
    /**
     * @generated from protobuf field: bytes client_region_custom_config_encrypted = 13;
     */
    clientRegionCustomConfigEncrypted: Uint8Array;
}
/**
 * @generated from protobuf message QueryFilter
 */
export interface QueryFilter {
    /**
     * @generated from protobuf field: int32 type_id = 2;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int32 area_mask = 14;
     */
    areaMask: number;
}
/**
 * @generated from protobuf message QueryPathReq
 */
export interface QueryPathReq {
    /**
     * @generated from protobuf field: QueryPathReq.OptionType query_type = 9;
     */
    queryType: QueryPathReq_OptionType;
    /**
     * @generated from protobuf field: int32 query_id = 4;
     */
    queryId: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 8;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: Vector source_pos = 14;
     */
    sourcePos?: Vector;
    /**
     * @generated from protobuf field: repeated Vector destination_pos = 11;
     */
    destinationPos: Vector[];
    /**
     * @generated from protobuf field: QueryFilter filter = 5;
     */
    filter?: QueryFilter;
    /**
     * @generated from protobuf field: Vector3Int destination_extend = 7;
     */
    destinationExtend?: Vector3Int;
    /**
     * @generated from protobuf field: Vector3Int source_extend = 15;
     */
    sourceExtend?: Vector3Int;
}
/**
 * @generated from protobuf enum QueryPathReq.OptionType
 */
export enum QueryPathReq_OptionType {
    /**
     * @generated from protobuf enum value: OPTION_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: OPTION_TYPE_NORMAL = 1;
     */
    NORMAL = 1,
    /**
     * @generated from protobuf enum value: OPTION_TYPE_FIRST_CAN_GO = 2;
     */
    FIRST_CAN_GO = 2
}
/**
 * @generated from protobuf message QueryPathRsp
 */
export interface QueryPathRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: int32 query_id = 2;
     */
    queryId: number;
    /**
     * @generated from protobuf field: QueryPathRsp.PathStatusType query_status = 5;
     */
    queryStatus: QueryPathRsp_PathStatusType;
    /**
     * @generated from protobuf field: repeated Vector corners = 12;
     */
    corners: Vector[];
}
/**
 * @generated from protobuf enum QueryPathRsp.PathStatusType
 */
export enum QueryPathRsp_PathStatusType {
    /**
     * @generated from protobuf enum value: PATH_STATUS_TYPE_FAIL = 0;
     */
    FAIL = 0,
    /**
     * @generated from protobuf enum value: PATH_STATUS_TYPE_SUCC = 1;
     */
    SUCC = 1,
    /**
     * @generated from protobuf enum value: PATH_STATUS_TYPE_PARTIAL = 2;
     */
    PARTIAL = 2
}
/**
 * @generated from protobuf message QueryRegionListHttpRsp
 */
export interface QueryRegionListHttpRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated RegionSimpleInfo region_list = 2;
     */
    regionList: RegionSimpleInfo[];
    /**
     * @generated from protobuf field: bytes client_secret_key = 5;
     */
    clientSecretKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes client_custom_config_encrypted = 6;
     */
    clientCustomConfigEncrypted: Uint8Array;
    /**
     * @generated from protobuf field: bool enable_login_pc = 7;
     */
    enableLoginPc: boolean;
}
/**
 * @generated from protobuf message Quest
 */
export interface Quest {
    /**
     * @generated from protobuf field: uint32 quest_id = 1;
     */
    questId: number;
    /**
     * @generated from protobuf field: uint32 state = 2;
     */
    state: number;
    /**
     * @generated from protobuf field: uint32 start_time = 4;
     */
    startTime: number;
    /**
     * @generated from protobuf field: bool is_random = 5;
     */
    isRandom: boolean;
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 6;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: uint32 quest_config_id = 7;
     */
    questConfigId: number;
    /**
     * @generated from protobuf field: uint32 start_game_time = 8;
     */
    startGameTime: number;
    /**
     * @generated from protobuf field: uint32 accept_time = 9;
     */
    acceptTime: number;
    /**
     * @generated from protobuf field: repeated uint32 lacked_npc_list = 10;
     */
    lackedNpcList: number[];
    /**
     * @generated from protobuf field: repeated uint32 finish_progress_list = 11;
     */
    finishProgressList: number[];
    /**
     * @generated from protobuf field: repeated uint32 fail_progress_list = 12;
     */
    failProgressList: number[];
    /**
     * @generated from protobuf field: map<uint32, uint32> lacked_npc_map = 13;
     */
    lackedNpcMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: repeated uint32 lacked_place_list = 14;
     */
    lackedPlaceList: number[];
    /**
     * @generated from protobuf field: map<uint32, uint32> lacked_place_map = 15;
     */
    lackedPlaceMap: {
        [key: number]: number;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 441;
 * }
 *
 * @generated from protobuf message QuestDelNotify
 */
export interface QuestDelNotify {
    /**
     * @generated from protobuf field: uint32 quest_id = 12;
     */
    questId: number;
}
/**
 * @generated from protobuf message QuestGlobalVar
 */
export interface QuestGlobalVar {
    /**
     * @generated from protobuf field: uint32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 411;
 * }
 *
 * @generated from protobuf message QuestGlobalVarNotify
 */
export interface QuestGlobalVarNotify {
    /**
     * @generated from protobuf field: repeated QuestGlobalVar var_list = 9;
     */
    varList: QuestGlobalVar[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 409;
 * }
 *
 * @generated from protobuf message QuestListNotify
 */
export interface QuestListNotify {
    /**
     * @generated from protobuf field: repeated Quest quest_list = 12;
     */
    questList: Quest[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 431;
 * }
 *
 * @generated from protobuf message QuestListUpdateNotify
 */
export interface QuestListUpdateNotify {
    /**
     * @generated from protobuf field: repeated Quest quest_list = 13;
     */
    questList: Quest[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 445;
 * }
 *
 * @generated from protobuf message QuestProgressUpdateNotify
 */
export interface QuestProgressUpdateNotify {
    /**
     * @generated from protobuf field: uint32 quest_id = 14;
     */
    questId: number;
    /**
     * @generated from protobuf field: repeated uint32 finish_progress_list = 7;
     */
    finishProgressList: number[];
    /**
     * @generated from protobuf field: repeated uint32 fail_progress_list = 12;
     */
    failProgressList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 463;
 * }
 *
 * @generated from protobuf message QuestUpdateQuestVarNotify
 */
export interface QuestUpdateQuestVarNotify {
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 3;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: repeated int32 quest_var = 6;
     */
    questVar: number[];
    /**
     * @generated from protobuf field: uint32 parent_quest_var_seq = 15;
     */
    parentQuestVarSeq: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 490;
 * }
 *
 * @generated from protobuf message QuestUpdateQuestVarReq
 */
export interface QuestUpdateQuestVarReq {
    /**
     * @generated from protobuf field: uint32 quest_id = 15;
     */
    questId: number;
    /**
     * @generated from protobuf field: repeated QuestVarOp quest_var_op_list = 11;
     */
    questVarOpList: QuestVarOp[];
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 3;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: uint32 parent_quest_var_seq = 8;
     */
    parentQuestVarSeq: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 486;
 * }
 *
 * @generated from protobuf message QuestUpdateQuestVarRsp
 */
export interface QuestUpdateQuestVarRsp {
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 quest_id = 7;
     */
    questId: number;
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 12;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: uint32 parent_quest_var_seq = 3;
     */
    parentQuestVarSeq: number;
}
/**
 * @generated from protobuf message QuestVarOp
 */
export interface QuestVarOp {
    /**
     * @generated from protobuf field: uint32 index = 1;
     */
    index: number;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
    /**
     * @generated from protobuf field: bool is_add = 3;
     */
    isAdd: boolean;
}
/**
 * @generated from protobuf message QuickUseWidgetReq
 */
export interface QuickUseWidgetReq {
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "locationInfo";
        /**
         * @generated from protobuf field: WidgetCreateLocationInfo location_info = 1800;
         */
        locationInfo: WidgetCreateLocationInfo;
    } | {
        oneofKind: "cameraInfo";
        /**
         * @generated from protobuf field: WidgetCameraInfo camera_info = 479;
         */
        cameraInfo: WidgetCameraInfo;
    } | {
        oneofKind: "creatorInfo";
        /**
         * @generated from protobuf field: WidgetCreatorInfo creator_info = 1204;
         */
        creatorInfo: WidgetCreatorInfo;
    } | {
        oneofKind: "thunderBirdFeatherInfo";
        /**
         * @generated from protobuf field: WidgetThunderBirdFeatherInfo thunder_bird_feather_info = 1198;
         */
        thunderBirdFeatherInfo: WidgetThunderBirdFeatherInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4252;
 * }
 *
 * @generated from protobuf message QuickUseWidgetRsp
 */
export interface QuickUseWidgetRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 material_id = 1;
     */
    materialId: number;
    /**
     * @generated from protobuf field: OneoffGatherPointDetectorData detector_data = 3;
     */
    detectorData?: OneoffGatherPointDetectorData;
    /**
     * @generated from protobuf field: ClientCollectorData client_collector_data = 4;
     */
    clientCollectorData?: ClientCollectorData;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1441;
 * }
 *
 * @generated from protobuf message ReadMailNotify
 */
export interface ReadMailNotify {
    /**
     * @generated from protobuf field: repeated uint32 mail_id_list = 9;
     */
    mailIdList: number[];
}
/**
 * @generated from protobuf message RegionInfo
 */
export interface RegionInfo {
    /**
     * @generated from protobuf field: string gateserver_ip = 1;
     */
    gateserverIp: string;
    /**
     * @generated from protobuf field: uint32 gateserver_port = 2;
     */
    gateserverPort: number;
    /**
     * @generated from protobuf field: string pay_callback_url = 3;
     */
    payCallbackUrl: string;
    /**
     * @generated from protobuf field: string area_type = 7;
     */
    areaType: string;
    /**
     * @generated from protobuf field: string resource_url = 8;
     */
    resourceUrl: string;
    /**
     * @generated from protobuf field: string data_url = 9;
     */
    dataUrl: string;
    /**
     * @generated from protobuf field: string feedback_url = 10;
     */
    feedbackUrl: string;
    /**
     * @generated from protobuf field: string bulletin_url = 11;
     */
    bulletinUrl: string;
    /**
     * @generated from protobuf field: string resource_url_bak = 12;
     */
    resourceUrlBak: string;
    /**
     * @generated from protobuf field: string data_url_bak = 13;
     */
    dataUrlBak: string;
    /**
     * @generated from protobuf field: uint32 client_data_version = 14;
     */
    clientDataVersion: number;
    /**
     * @generated from protobuf field: string handbook_url = 16;
     */
    handbookUrl: string;
    /**
     * @generated from protobuf field: uint32 client_silence_data_version = 18;
     */
    clientSilenceDataVersion: number;
    /**
     * @generated from protobuf field: string client_data_md5 = 19;
     */
    clientDataMd5: string;
    /**
     * @generated from protobuf field: string client_silence_data_md5 = 20;
     */
    clientSilenceDataMd5: string;
    /**
     * @generated from protobuf field: ResVersionConfig res_version_config = 22;
     */
    resVersionConfig?: ResVersionConfig;
    /**
     * @generated from protobuf field: bytes secret_key = 23;
     */
    secretKey: Uint8Array;
    /**
     * @generated from protobuf field: string official_community_url = 24;
     */
    officialCommunityUrl: string;
    /**
     * @generated from protobuf field: string client_version_suffix = 26;
     */
    clientVersionSuffix: string;
    /**
     * @generated from protobuf field: string client_silence_version_suffix = 27;
     */
    clientSilenceVersionSuffix: string;
    /**
     * @generated from protobuf field: bool use_gateserver_domain_name = 28;
     */
    useGateserverDomainName: boolean;
    /**
     * @generated from protobuf field: string gateserver_domain_name = 29;
     */
    gateserverDomainName: string;
    /**
     * @generated from protobuf field: string user_center_url = 30;
     */
    userCenterUrl: string;
    /**
     * @generated from protobuf field: string account_bind_url = 31;
     */
    accountBindUrl: string;
    /**
     * @generated from protobuf field: string cdkey_url = 32;
     */
    cdkeyUrl: string;
    /**
     * @generated from protobuf field: string privacy_policy_url = 33;
     */
    privacyPolicyUrl: string;
    /**
     * @generated from protobuf field: string next_resource_url = 34;
     */
    nextResourceUrl: string;
    /**
     * @generated from protobuf field: ResVersionConfig next_res_version_config = 35;
     */
    nextResVersionConfig?: ResVersionConfig;
}
/**
 * @generated from protobuf message RegionSimpleInfo
 */
export interface RegionSimpleInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * @generated from protobuf field: string dispatch_url = 4;
     */
    dispatchUrl: string;
}
/**
 * @generated from protobuf message Reliquary
 */
export interface Reliquary {
    /**
     * @generated from protobuf field: uint32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 exp = 2;
     */
    exp: number;
    /**
     * @generated from protobuf field: uint32 promote_level = 3;
     */
    promoteLevel: number;
    /**
     * @generated from protobuf field: uint32 main_prop_id = 4;
     */
    mainPropId: number;
    /**
     * @generated from protobuf field: repeated uint32 append_prop_id_list = 5;
     */
    appendPropIdList: number[];
}
/**
 * @generated from protobuf message ReliquaryDecomposeReq
 */
export interface ReliquaryDecomposeReq {
    /**
     * @generated from protobuf field: uint32 config_id = 1;
     */
    configId: number;
    /**
     * @generated from protobuf field: uint32 target_count = 4;
     */
    targetCount: number;
    /**
     * @generated from protobuf field: repeated uint64 guid_list = 15;
     */
    guidList: bigint[];
}
/**
 * @generated from protobuf message ReliquaryDecomposeRsp
 */
export interface ReliquaryDecomposeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint64 guid_list = 14;
     */
    guidList: bigint[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 612;
 * }
 *
 * @generated from protobuf message ReliquaryPromoteReq
 */
export interface ReliquaryPromoteReq {
    /**
     * @generated from protobuf field: uint64 target_guid = 4;
     */
    targetGuid: bigint;
    /**
     * @generated from protobuf field: uint64 item_guid = 14;
     */
    itemGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 658;
 * }
 *
 * @generated from protobuf message ReliquaryPromoteRsp
 */
export interface ReliquaryPromoteRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_reliquary_guid = 4;
     */
    targetReliquaryGuid: bigint;
    /**
     * @generated from protobuf field: uint32 old_promote_level = 11;
     */
    oldPromoteLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_promote_level = 14;
     */
    curPromoteLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 old_append_prop_list = 3;
     */
    oldAppendPropList: number[];
    /**
     * @generated from protobuf field: repeated uint32 cur_append_prop_list = 13;
     */
    curAppendPropList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 606;
 * }
 *
 * @generated from protobuf message ReliquaryUpgradeReq
 */
export interface ReliquaryUpgradeReq {
    /**
     * @generated from protobuf field: uint64 target_reliquary_guid = 5;
     */
    targetReliquaryGuid: bigint;
    /**
     * @generated from protobuf field: repeated uint64 food_reliquary_guid_list = 15;
     */
    foodReliquaryGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 13;
     */
    itemParamList: ItemParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 619;
 * }
 *
 * @generated from protobuf message ReliquaryUpgradeRsp
 */
export interface ReliquaryUpgradeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_reliquary_guid = 10;
     */
    targetReliquaryGuid: bigint;
    /**
     * @generated from protobuf field: uint32 old_level = 5;
     */
    oldLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 6;
     */
    curLevel: number;
    /**
     * @generated from protobuf field: uint32 power_up_rate = 2;
     */
    powerUpRate: number;
    /**
     * @generated from protobuf field: repeated uint32 old_append_prop_list = 7;
     */
    oldAppendPropList: number[];
    /**
     * @generated from protobuf field: repeated uint32 cur_append_prop_list = 14;
     */
    curAppendPropList: number[];
}
/**
 * @generated from protobuf message ResinCard
 */
export interface ResinCard {
    /**
     * @generated from protobuf field: repeated ItemParam baseItemList = 1;
     */
    baseItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam perDayItemList = 2;
     */
    perDayItemList: ItemParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 670;
 * }
 *
 * @generated from protobuf message ResinChangeNotify
 */
export interface ResinChangeNotify {
    /**
     * @generated from protobuf field: uint32 cur_value = 4;
     */
    curValue: number;
    /**
     * @generated from protobuf field: uint32 next_add_timestamp = 2;
     */
    nextAddTimestamp: number;
    /**
     * @generated from protobuf field: uint32 cur_buy_count = 3;
     */
    curBuyCount: number;
}
/**
 * @generated from protobuf message ResVersionConfig
 */
export interface ResVersionConfig {
    /**
     * @generated from protobuf field: uint32 version = 1;
     */
    version: number;
    /**
     * @generated from protobuf field: bool relogin = 2;
     */
    relogin: boolean;
    /**
     * @generated from protobuf field: string md_5 = 3;
     */
    md5: string;
    /**
     * @generated from protobuf field: string release_total_size = 4;
     */
    releaseTotalSize: string;
    /**
     * @generated from protobuf field: string version_suffix = 5;
     */
    versionSuffix: string;
    /**
     * @generated from protobuf field: string branch = 6;
     */
    branch: string;
    /**
     * @generated from protobuf field: string next_script_version = 7;
     */
    nextScriptVersion: string;
}
/**
 * @generated from protobuf message RoguelikeDungeonSettleInfo
 */
export interface RoguelikeDungeonSettleInfo {
    /**
     * @generated from protobuf field: uint32 stage_id = 1;
     */
    stageId: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 2;
     */
    curLevel: number;
    /**
     * @generated from protobuf field: map<uint32, RoguelikeSettleCoinInfo> finished_challenge_cell_num_map = 3;
     */
    finishedChallengeCellNumMap: {
        [key: number]: RoguelikeSettleCoinInfo;
    };
    /**
     * @generated from protobuf field: bool is_final_level = 4;
     */
    isFinalLevel: boolean;
    /**
     * @generated from protobuf field: uint32 total_coin_b_num = 5;
     */
    totalCoinBNum: number;
    /**
     * @generated from protobuf field: uint32 total_coin_c_num = 6;
     */
    totalCoinCNum: number;
    /**
     * @generated from protobuf field: bool is_coin_c_reach_limit = 7;
     */
    isCoinCReachLimit: boolean;
}
/**
 * @generated from protobuf message RoguelikeGadgetInfo
 */
export interface RoguelikeGadgetInfo {
    /**
     * @generated from protobuf field: uint32 cell_config_id = 1;
     */
    cellConfigId: number;
    /**
     * @generated from protobuf field: uint32 cell_type = 2;
     */
    cellType: number;
    /**
     * @generated from protobuf field: uint32 cell_state = 3;
     */
    cellState: number;
    /**
     * @generated from protobuf field: uint32 cell_id = 4;
     */
    cellId: number;
}
/**
 * @generated from protobuf message RoguelikeSettleCoinInfo
 */
export interface RoguelikeSettleCoinInfo {
    /**
     * @generated from protobuf field: uint32 cell_num = 1;
     */
    cellNum: number;
    /**
     * @generated from protobuf field: uint32 coin_b = 2;
     */
    coinB: number;
    /**
     * @generated from protobuf field: uint32 coin_c = 3;
     */
    coinC: number;
}
/**
 * @generated from protobuf message Route
 */
export interface Route {
    /**
     * @generated from protobuf field: repeated RoutePoint route_points = 1;
     */
    routePoints: RoutePoint[];
    /**
     * @generated from protobuf field: uint32 route_type = 2;
     */
    routeType: number;
}
/**
 * @generated from protobuf message RoutePoint
 */
export interface RoutePoint {
    /**
     * @generated from protobuf field: Vector position = 1;
     */
    position?: Vector;
    /**
     * @generated from protobuf field: float arrive_range = 2;
     */
    arriveRange: number;
    /**
     * @generated from protobuf oneof: move_params
     */
    moveParams: {
        oneofKind: "velocity";
        /**
         * @generated from protobuf field: float velocity = 11;
         */
        velocity: number;
    } | {
        oneofKind: "time";
        /**
         * @generated from protobuf field: float time = 12;
         */
        time: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: rotate_params
     */
    rotateParams: {
        oneofKind: "rotation";
        /**
         * @generated from protobuf field: Vector rotation = 21;
         */
        rotation: Vector;
    } | {
        oneofKind: "rotationSpeed";
        /**
         * @generated from protobuf field: MathQuaternion rotation_speed = 22;
         */
        rotationSpeed: MathQuaternion;
    } | {
        oneofKind: "axisSpeed";
        /**
         * @generated from protobuf field: MathQuaternion axis_speed = 23;
         */
        axisSpeed: MathQuaternion;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 229;
 * }
 *
 * @generated from protobuf message SceneAreaWeatherNotify
 */
export interface SceneAreaWeatherNotify {
    /**
     * @generated from protobuf field: uint32 weather_gadget_id = 13;
     */
    weatherGadgetId: number;
    /**
     * @generated from protobuf field: map<uint32, string> weather_value_map = 10;
     */
    weatherValueMap: {
        [key: number]: string;
    };
    /**
     * @generated from protobuf field: uint32 weather_area_id = 15;
     */
    weatherAreaId: number;
    /**
     * @generated from protobuf field: uint32 climate_type = 14;
     */
    climateType: number;
    /**
     * @generated from protobuf field: float trans_duration = 11;
     */
    transDuration: number;
}
/**
 * @generated from protobuf message SceneAvatarInfo
 */
export interface SceneAvatarInfo {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 2;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint64 guid = 3;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 peer_id = 4;
     */
    peerId: number;
    /**
     * @generated from protobuf field: repeated uint32 equip_id_list = 5;
     */
    equipIdList: number[];
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 6;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: repeated uint32 talent_id_list = 7;
     */
    talentIdList: number[];
    /**
     * @generated from protobuf field: SceneWeaponInfo weapon = 8;
     */
    weapon?: SceneWeaponInfo;
    /**
     * @generated from protobuf field: repeated SceneReliquaryInfo reliquary_list = 9;
     */
    reliquaryList: SceneReliquaryInfo[];
    /**
     * @generated from protobuf field: uint32 core_proud_skill_level = 11;
     */
    coreProudSkillLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 inherent_proud_skill_list = 12;
     */
    inherentProudSkillList: number[];
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_level_map = 13;
     */
    skillLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> proud_skill_extra_level_map = 14;
     */
    proudSkillExtraLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 15;
     */
    serverBuffList: ServerBuff[];
    /**
     * @generated from protobuf field: repeated uint32 team_resonance_list = 16;
     */
    teamResonanceList: number[];
    /**
     * @generated from protobuf field: uint32 wearing_flycloak_id = 17;
     */
    wearingFlycloakId: number;
    /**
     * @generated from protobuf field: uint32 born_time = 18;
     */
    bornTime: number;
    /**
     * @generated from protobuf field: uint32 costume_id = 19;
     */
    costumeId: number;
    /**
     * @generated from protobuf field: CurVehicleInfo cur_vehicle_info = 20;
     */
    curVehicleInfo?: CurVehicleInfo;
    /**
     * @generated from protobuf field: AvatarExcelInfo excel_info = 21;
     */
    excelInfo?: AvatarExcelInfo;
    /**
     * @generated from protobuf field: uint32 anim_hash = 22;
     */
    animHash: number;
}
/**
 * @generated from protobuf message SceneEntityAiInfo
 */
export interface SceneEntityAiInfo {
    /**
     * @generated from protobuf field: bool is_ai_open = 1;
     */
    isAiOpen: boolean;
    /**
     * @generated from protobuf field: Vector born_pos = 2;
     */
    bornPos?: Vector;
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_cd_map = 3;
     */
    skillCdMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: ServantInfo servant_info = 4;
     */
    servantInfo?: ServantInfo;
    /**
     * @generated from protobuf field: map<uint32, uint32> ai_threat_map = 5;
     */
    aiThreatMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_group_cd_map = 6;
     */
    skillGroupCdMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 cur_tactic = 7;
     */
    curTactic: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 217;
 * }
 *
 * @generated from protobuf message SceneEntityAppearNotify
 */
export interface SceneEntityAppearNotify {
    /**
     * @generated from protobuf field: repeated SceneEntityInfo entity_list = 6;
     */
    entityList: SceneEntityInfo[];
    /**
     * @generated from protobuf field: VisionType appear_type = 8;
     */
    appearType: VisionType;
    /**
     * @generated from protobuf field: uint32 param = 11;
     */
    param: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 285;
 * }
 *
 * @generated from protobuf message SceneEntityDisappearNotify
 */
export interface SceneEntityDisappearNotify {
    /**
     * @generated from protobuf field: repeated uint32 entity_list = 9;
     */
    entityList: number[];
    /**
     * @generated from protobuf field: VisionType disappear_type = 10;
     */
    disappearType: VisionType;
    /**
     * @generated from protobuf field: uint32 param = 6;
     */
    param: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 212;
 * }
 *
 * @generated from protobuf message SceneEntityDrownReq
 */
export interface SceneEntityDrownReq {
    /**
     * @generated from protobuf field: uint32 entity_id = 14;
     */
    entityId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 258;
 * }
 *
 * @generated from protobuf message SceneEntityDrownRsp
 */
export interface SceneEntityDrownRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 10;
     */
    entityId: number;
}
/**
 * @generated from protobuf message SceneEntityInfo
 */
export interface SceneEntityInfo {
    /**
     * @generated from protobuf oneof: Entity
     */
    entity: {
        oneofKind: "avatar";
        /**
         * @generated from protobuf field: SceneAvatarInfo avatar = 10;
         */
        avatar: SceneAvatarInfo;
    } | {
        oneofKind: "monster";
        /**
         * @generated from protobuf field: SceneMonsterInfo monster = 11;
         */
        monster: SceneMonsterInfo;
    } | {
        oneofKind: "npc";
        /**
         * @generated from protobuf field: SceneNpcInfo npc = 12;
         */
        npc: SceneNpcInfo;
    } | {
        oneofKind: "gadget";
        /**
         * @generated from protobuf field: SceneGadgetInfo gadget = 13;
         */
        gadget: SceneGadgetInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: ProtEntityType entity_type = 1;
     */
    entityType: ProtEntityType;
    /**
     * @generated from protobuf field: uint32 entity_id = 2;
     */
    entityId: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: MotionInfo motion_info = 4;
     */
    motionInfo?: MotionInfo;
    /**
     * @generated from protobuf field: repeated PropPair prop_list = 5;
     */
    propList: PropPair[];
    /**
     * @generated from protobuf field: repeated FightPropPair fight_prop_list = 6;
     */
    fightPropList: FightPropPair[];
    /**
     * @generated from protobuf field: uint32 life_state = 7;
     */
    lifeState: number;
    /**
     * @generated from protobuf field: repeated AnimatorParameterValueInfoPair animator_para_list = 9;
     */
    animatorParaList: AnimatorParameterValueInfoPair[];
    /**
     * @generated from protobuf field: uint32 last_move_scene_time_ms = 17;
     */
    lastMoveSceneTimeMs: number;
    /**
     * @generated from protobuf field: uint32 last_move_reliable_seq = 18;
     */
    lastMoveReliableSeq: number;
    /**
     * @generated from protobuf field: EntityClientData entity_client_data = 19;
     */
    entityClientData?: EntityClientData;
    /**
     * @generated from protobuf field: repeated EntityEnvironmentInfo entity_environment_info_list = 20;
     */
    entityEnvironmentInfoList: EntityEnvironmentInfo[];
    /**
     * @generated from protobuf field: EntityAuthorityInfo entity_authority_info = 21;
     */
    entityAuthorityInfo?: EntityAuthorityInfo;
    /**
     * @generated from protobuf field: repeated string tag_list = 22;
     */
    tagList: string[];
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 23;
     */
    serverBuffList: ServerBuff[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 1;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 227;
 * }
 *
 * @generated from protobuf message SceneEntityMoveNotify
 */
export interface SceneEntityMoveNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 10;
     */
    entityId: number;
    /**
     * @generated from protobuf field: MotionInfo motion_info = 3;
     */
    motionInfo?: MotionInfo;
    /**
     * @generated from protobuf field: uint32 scene_time = 12;
     */
    sceneTime: number;
    /**
     * @generated from protobuf field: uint32 reliable_seq = 11;
     */
    reliableSeq: number;
}
/**
 * @generated from protobuf message SceneFishInfo
 */
export interface SceneFishInfo {
    /**
     * @generated from protobuf field: uint32 fish_id = 1;
     */
    fishId: number;
    /**
     * @generated from protobuf field: uint32 fish_pool_entity_id = 2;
     */
    fishPoolEntityId: number;
    /**
     * @generated from protobuf field: Vector fish_pool_pos = 3;
     */
    fishPoolPos?: Vector;
    /**
     * @generated from protobuf field: uint32 fish_pool_gadget_id = 4;
     */
    fishPoolGadgetId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 201;
 * }
 *
 * @generated from protobuf message SceneForceUnlockNotify
 */
export interface SceneForceUnlockNotify {
    /**
     * @generated from protobuf field: repeated uint32 force_id_list = 1;
     */
    forceIdList: number[];
    /**
     * @generated from protobuf field: bool is_add = 5;
     */
    isAdd: boolean;
}
/**
 * @generated from protobuf message SceneGadgetInfo
 */
export interface SceneGadgetInfo {
    /**
     * @generated from protobuf field: uint32 gadget_id = 1;
     */
    gadgetId: number;
    /**
     * @generated from protobuf field: uint32 group_id = 2;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 3;
     */
    configId: number;
    /**
     * @generated from protobuf field: uint32 owner_entity_id = 4;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: GadgetBornType born_type = 5;
     */
    bornType: GadgetBornType;
    /**
     * @generated from protobuf field: uint32 gadget_state = 6;
     */
    gadgetState: number;
    /**
     * @generated from protobuf field: uint32 gadget_type = 7;
     */
    gadgetType: number;
    /**
     * @generated from protobuf field: bool is_show_cutscene = 8;
     */
    isShowCutscene: boolean;
    /**
     * @generated from protobuf field: uint32 authority_peer_id = 9;
     */
    authorityPeerId: number;
    /**
     * @generated from protobuf field: bool is_enable_interact = 10;
     */
    isEnableInteract: boolean;
    /**
     * @generated from protobuf field: uint32 interact_id = 11;
     */
    interactId: number;
    /**
     * @generated from protobuf field: uint32 mark_flag = 21;
     */
    markFlag: number;
    /**
     * @generated from protobuf field: uint32 prop_owner_entity_id = 22;
     */
    propOwnerEntityId: number;
    /**
     * @generated from protobuf field: PlatformInfo platform = 23;
     */
    platform?: PlatformInfo;
    /**
     * @generated from protobuf field: repeated uint32 interact_uid_list = 24;
     */
    interactUidList: number[];
    /**
     * @generated from protobuf field: uint32 draft_id = 25;
     */
    draftId: number;
    /**
     * @generated from protobuf field: uint32 gadget_talk_state = 26;
     */
    gadgetTalkState: number;
    /**
     * @generated from protobuf field: GadgetPlayInfo play_info = 100;
     */
    playInfo?: GadgetPlayInfo;
    /**
     * @generated from protobuf oneof: content
     */
    content: {
        oneofKind: "trifleItem";
        /**
         * @generated from protobuf field: Item trifle_item = 12;
         */
        trifleItem: Item;
    } | {
        oneofKind: "gatherGadget";
        /**
         * @generated from protobuf field: GatherGadgetInfo gather_gadget = 13;
         */
        gatherGadget: GatherGadgetInfo;
    } | {
        oneofKind: "worktop";
        /**
         * @generated from protobuf field: WorktopInfo worktop = 14;
         */
        worktop: WorktopInfo;
    } | {
        oneofKind: "clientGadget";
        /**
         * @generated from protobuf field: ClientGadgetInfo client_gadget = 15;
         */
        clientGadget: ClientGadgetInfo;
    } | {
        oneofKind: "weather";
        /**
         * @generated from protobuf field: WeatherInfo weather = 17;
         */
        weather: WeatherInfo;
    } | {
        oneofKind: "abilityGadget";
        /**
         * @generated from protobuf field: AbilityGadgetInfo ability_gadget = 18;
         */
        abilityGadget: AbilityGadgetInfo;
    } | {
        oneofKind: "statueGadget";
        /**
         * @generated from protobuf field: StatueGadgetInfo statue_gadget = 19;
         */
        statueGadget: StatueGadgetInfo;
    } | {
        oneofKind: "bossChest";
        /**
         * @generated from protobuf field: BossChestInfo boss_chest = 20;
         */
        bossChest: BossChestInfo;
    } | {
        oneofKind: "blossomChest";
        /**
         * @generated from protobuf field: BlossomChestInfo blossom_chest = 41;
         */
        blossomChest: BlossomChestInfo;
    } | {
        oneofKind: "mpPlayReward";
        /**
         * @generated from protobuf field: MpPlayRewardInfo mp_play_reward = 42;
         */
        mpPlayReward: MpPlayRewardInfo;
    } | {
        oneofKind: "generalReward";
        /**
         * @generated from protobuf field: GadgetGeneralRewardInfo general_reward = 43;
         */
        generalReward: GadgetGeneralRewardInfo;
    } | {
        oneofKind: "offeringInfo";
        /**
         * @generated from protobuf field: OfferingInfo offering_info = 44;
         */
        offeringInfo: OfferingInfo;
    } | {
        oneofKind: "foundationInfo";
        /**
         * @generated from protobuf field: FoundationInfo foundation_info = 45;
         */
        foundationInfo: FoundationInfo;
    } | {
        oneofKind: "vehicleInfo";
        /**
         * @generated from protobuf field: VehicleInfo vehicle_info = 46;
         */
        vehicleInfo: VehicleInfo;
    } | {
        oneofKind: "shellInfo";
        /**
         * @generated from protobuf field: EchoShellInfo shell_info = 47;
         */
        shellInfo: EchoShellInfo;
    } | {
        oneofKind: "screenInfo";
        /**
         * @generated from protobuf field: ScreenInfo screen_info = 48;
         */
        screenInfo: ScreenInfo;
    } | {
        oneofKind: "fishPoolInfo";
        /**
         * @generated from protobuf field: FishPoolInfo fish_pool_info = 59;
         */
        fishPoolInfo: FishPoolInfo;
    } | {
        oneofKind: "customGadgetTreeInfo";
        /**
         * @generated from protobuf field: CustomGadgetTreeInfo custom_gadget_tree_info = 60;
         */
        customGadgetTreeInfo: CustomGadgetTreeInfo;
    } | {
        oneofKind: "roguelikeGadgetInfo";
        /**
         * @generated from protobuf field: RoguelikeGadgetInfo roguelike_gadget_info = 61;
         */
        roguelikeGadgetInfo: RoguelikeGadgetInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 232;
 * }
 *
 * @generated from protobuf message SceneInitFinishRsp
 */
export interface SceneInitFinishRsp {
    /**
     * @generated from protobuf field: int32 retcode = 10;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 enter_scene_token = 15;
     */
    enterSceneToken: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 292;
 * }
 *
 * @generated from protobuf message SceneKickPlayerNotify
 */
export interface SceneKickPlayerNotify {
    /**
     * @generated from protobuf field: uint32 kicker_uid = 9;
     */
    kickerUid: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 13;
     */
    targetUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 295;
 * }
 *
 * @generated from protobuf message SceneKickPlayerReq
 */
export interface SceneKickPlayerReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 12;
     */
    targetUid: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 215;
 * }
 *
 * @generated from protobuf message SceneKickPlayerRsp
 */
export interface SceneKickPlayerRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 12;
     */
    targetUid: number;
}
/**
 * @generated from protobuf message SceneMonsterInfo
 */
export interface SceneMonsterInfo {
    /**
     * @generated from protobuf oneof: Content
     */
    content: {
        oneofKind: "fishInfo";
        /**
         * @generated from protobuf field: SceneFishInfo fish_info = 50;
         */
        fishInfo: SceneFishInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 monster_id = 1;
     */
    monsterId: number;
    /**
     * @generated from protobuf field: uint32 group_id = 2;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 3;
     */
    configId: number;
    /**
     * @generated from protobuf field: repeated SceneWeaponInfo weapon_list = 4;
     */
    weaponList: SceneWeaponInfo[];
    /**
     * @generated from protobuf field: uint32 authority_peer_id = 5;
     */
    authorityPeerId: number;
    /**
     * @generated from protobuf field: repeated uint32 affix_list = 6;
     */
    affixList: number[];
    /**
     * @generated from protobuf field: bool is_elite = 7;
     */
    isElite: boolean;
    /**
     * @generated from protobuf field: uint32 owner_entity_id = 8;
     */
    ownerEntityId: number;
    /**
     * @generated from protobuf field: uint32 summoned_tag = 9;
     */
    summonedTag: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> summon_tag_map = 10;
     */
    summonTagMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 pose_id = 11;
     */
    poseId: number;
    /**
     * @generated from protobuf field: MonsterBornType born_type = 12;
     */
    bornType: MonsterBornType;
    /**
     * @generated from protobuf field: uint32 block_id = 13;
     */
    blockId: number;
    /**
     * @generated from protobuf field: uint32 mark_flag = 14;
     */
    markFlag: number;
    /**
     * @generated from protobuf field: uint32 title_id = 15;
     */
    titleId: number;
    /**
     * @generated from protobuf field: uint32 special_name_id = 16;
     */
    specialNameId: number;
    /**
     * @generated from protobuf field: uint32 attack_target_id = 17;
     */
    attackTargetId: number;
    /**
     * @generated from protobuf field: MonsterRoute monster_route = 18;
     */
    monsterRoute?: MonsterRoute;
    /**
     * @generated from protobuf field: uint32 ai_config_id = 19;
     */
    aiConfigId: number;
    /**
     * @generated from protobuf field: uint32 level_route_id = 20;
     */
    levelRouteId: number;
    /**
     * @generated from protobuf field: uint32 init_pose_id = 21;
     */
    initPoseId: number;
}
/**
 * @generated from protobuf message SceneNpcInfo
 */
export interface SceneNpcInfo {
    /**
     * @generated from protobuf field: uint32 npc_id = 1;
     */
    npcId: number;
    /**
     * @generated from protobuf field: uint32 room_id = 2;
     */
    roomId: number;
    /**
     * @generated from protobuf field: uint32 parent_quest_id = 3;
     */
    parentQuestId: number;
    /**
     * @generated from protobuf field: uint32 block_id = 4;
     */
    blockId: number;
}
/**
 * @generated from protobuf message ScenePlayerInfo
 */
export interface ScenePlayerInfo {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint32 peer_id = 2;
     */
    peerId: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_connected = 4;
     */
    isConnected: boolean;
    /**
     * @generated from protobuf field: uint32 scene_id = 5;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: OnlinePlayerInfo online_player_info = 6;
     */
    onlinePlayerInfo?: OnlinePlayerInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 225;
 * }
 *
 * @generated from protobuf message ScenePlayerInfoNotify
 */
export interface ScenePlayerInfoNotify {
    /**
     * @generated from protobuf field: repeated ScenePlayerInfo player_info_list = 11;
     */
    playerInfoList: ScenePlayerInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 1;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 207;
 * }
 *
 * @generated from protobuf message ScenePlayerLocationNotify
 */
export interface ScenePlayerLocationNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 1;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated PlayerLocationInfo player_loc_list = 8;
     */
    playerLocList: PlayerLocationInfo[];
    /**
     * @generated from protobuf field: repeated VehicleLocationInfo vehicle_loc_list = 5;
     */
    vehicleLocList: VehicleLocationInfo[];
}
/**
 * @generated from protobuf message SceneReliquaryInfo
 */
export interface SceneReliquaryInfo {
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint64 guid = 2;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 promote_level = 4;
     */
    promoteLevel: number;
}
/**
 * @generated from protobuf message SceneTeamAvatar
 */
export interface SceneTeamAvatar {
    /**
     * @generated from protobuf field: uint32 player_uid = 7;
     */
    playerUid: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 5;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 scene_id = 2;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
    /**
     * @generated from protobuf field: AvatarInfo avatar_info = 1;
     */
    avatarInfo?: AvatarInfo;
    /**
     * @generated from protobuf field: SceneAvatarInfo scene_avatar_info = 4;
     */
    sceneAvatarInfo?: SceneAvatarInfo;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo avatar_ability_info = 9;
     */
    avatarAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: repeated ServerBuff server_buff_list = 14;
     */
    serverBuffList: ServerBuff[];
    /**
     * @generated from protobuf field: SceneEntityInfo scene_entity_info = 11;
     */
    sceneEntityInfo?: SceneEntityInfo;
    /**
     * @generated from protobuf field: uint64 weapon_guid = 15;
     */
    weaponGuid: bigint;
    /**
     * @generated from protobuf field: uint32 weapon_entity_id = 6;
     */
    weaponEntityId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo weapon_ability_info = 3;
     */
    weaponAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: AbilityControlBlock ability_control_block = 10;
     */
    abilityControlBlock?: AbilityControlBlock;
    /**
     * @generated from protobuf field: bool is_reconnect = 12;
     */
    isReconnect: boolean;
    /**
     * @generated from protobuf field: bool is_player_cur_avatar = 13;
     */
    isPlayerCurAvatar: boolean;
    /**
     * @generated from protobuf field: bool is_on_scene = 311;
     */
    isOnScene: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1699;
 * }
 *
 * @generated from protobuf message SceneTeamUpdateNotify
 */
export interface SceneTeamUpdateNotify {
    /**
     * @generated from protobuf field: repeated SceneTeamAvatar scene_team_avatar_list = 11;
     */
    sceneTeamAvatarList: SceneTeamAvatar[];
    /**
     * @generated from protobuf field: bool is_in_mp = 1;
     */
    isInMp: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 262;
 * }
 *
 * @generated from protobuf message SceneTimeNotify
 */
export interface SceneTimeNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 3;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: bool is_paused = 5;
     */
    isPaused: boolean;
    /**
     * @generated from protobuf field: uint64 scene_time = 14;
     */
    sceneTime: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 286;
 * }
 *
 * @generated from protobuf message SceneTransToPointReq
 */
export interface SceneTransToPointReq {
    /**
     * @generated from protobuf field: uint32 scene_id = 12;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 point_id = 4;
     */
    pointId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 263;
 * }
 *
 * @generated from protobuf message SceneTransToPointRsp
 */
export interface SceneTransToPointRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 scene_id = 11;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 point_id = 13;
     */
    pointId: number;
}
/**
 * @generated from protobuf message SceneUnlockInfo
 */
export interface SceneUnlockInfo {
    /**
     * @generated from protobuf field: uint32 sceneId = 1;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: bool isLocked = 2;
     */
    isLocked: boolean;
    /**
     * @generated from protobuf field: repeated uint32 sceneTagIdList = 3;
     */
    sceneTagIdList: number[];
}
/**
 * @generated from protobuf message SceneWeaponInfo
 */
export interface SceneWeaponInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 gadget_id = 2;
     */
    gadgetId: number;
    /**
     * @generated from protobuf field: uint32 item_id = 3;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint64 guid = 4;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 level = 5;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 promote_level = 6;
     */
    promoteLevel: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo ability_info = 7;
     */
    abilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: map<uint32, uint32> affix_map = 8;
     */
    affixMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: EntityRendererChangedInfo renderer_changed_info = 9;
     */
    rendererChangedInfo?: EntityRendererChangedInfo;
}
/**
 * @generated from protobuf message ScreenInfo
 */
export interface ScreenInfo {
    /**
     * @generated from protobuf field: uint32 live_id = 1;
     */
    liveId: number;
    /**
     * @generated from protobuf field: uint32 projector_entity_id = 2;
     */
    projectorEntityId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 832;
 * }
 *
 * @generated from protobuf message SelectWorktopOptionReq
 */
export interface SelectWorktopOptionReq {
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 2;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: uint32 option_id = 5;
     */
    optionId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 817;
 * }
 *
 * @generated from protobuf message SelectWorktopOptionRsp
 */
export interface SelectWorktopOptionRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 12;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: uint32 option_id = 10;
     */
    optionId: number;
}
/**
 * @generated from protobuf message ServantInfo
 */
export interface ServantInfo {
    /**
     * @generated from protobuf field: uint32 master_entity_id = 1;
     */
    masterEntityId: number;
    /**
     * @generated from protobuf field: uint32 born_slot_index = 2;
     */
    bornSlotIndex: number;
}
/**
 * @generated from protobuf message ServerAnnounceNotify
 */
export interface ServerAnnounceNotify {
    /**
     * @generated from protobuf field: repeated AnnounceData announce_data_list = 8;
     */
    announceDataList: AnnounceData[];
}
/**
 * @generated from protobuf message ServerAnnounceRevokeNotify
 */
export interface ServerAnnounceRevokeNotify {
    /**
     * @generated from protobuf field: repeated uint32 config_id_list = 15;
     */
    configIdList: number[];
}
/**
 * @generated from protobuf message ServerBuff
 */
export interface ServerBuff {
    /**
     * @generated from protobuf field: uint32 server_buff_uid = 1;
     */
    serverBuffUid: number;
    /**
     * @generated from protobuf field: uint32 server_buff_id = 2;
     */
    serverBuffId: number;
    /**
     * @generated from protobuf field: uint32 server_buff_type = 3;
     */
    serverBuffType: number;
    /**
     * @generated from protobuf field: uint32 instanced_modifier_id = 4;
     */
    instancedModifierId: number;
    /**
     * @generated from protobuf field: bool is_modifier_added = 5;
     */
    isModifierAdded: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 401;
 * }
 *
 * @generated from protobuf message ServerCondMeetQuestListUpdateNotify
 */
export interface ServerCondMeetQuestListUpdateNotify {
    /**
     * @generated from protobuf field: repeated uint32 add_quest_id_list = 9;
     */
    addQuestIdList: number[];
    /**
     * @generated from protobuf field: repeated uint32 del_quest_id_list = 6;
     */
    delQuestIdList: number[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 1;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 82;
 * }
 *
 * @generated from protobuf message ServerTimeNotify
 */
export interface ServerTimeNotify {
    /**
     * @generated from protobuf field: uint64 server_time = 15;
     */
    serverTime: bigint;
}
/**
 * @generated from protobuf message SetBattlePassViewedReq
 */
export interface SetBattlePassViewedReq {
    /**
     * @generated from protobuf field: uint32 schedule_id = 6;
     */
    scheduleId: number;
}
/**
 * @generated from protobuf message SetBattlePassViewedRsp
 */
export interface SetBattlePassViewedRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 schedule_id = 10;
     */
    scheduleId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 3375;
 * }
 *
 * @generated from protobuf message SetEntityClientDataNotify
 */
export interface SetEntityClientDataNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 13;
     */
    entityId: number;
    /**
     * @generated from protobuf field: EntityClientData entity_client_data = 1;
     */
    entityClientData?: EntityClientData;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 604;
 * }
 *
 * @generated from protobuf message SetEquipLockStateReq
 */
export interface SetEquipLockStateReq {
    /**
     * @generated from protobuf field: uint64 target_equip_guid = 10;
     */
    targetEquipGuid: bigint;
    /**
     * @generated from protobuf field: bool is_locked = 11;
     */
    isLocked: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 605;
 * }
 *
 * @generated from protobuf message SetEquipLockStateRsp
 */
export interface SetEquipLockStateRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_equip_guid = 13;
     */
    targetEquipGuid: bigint;
    /**
     * @generated from protobuf field: bool is_locked = 5;
     */
    isLocked: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4006;
 * }
 *
 * @generated from protobuf message SetNameCardReq
 */
export interface SetNameCardReq {
    /**
     * @generated from protobuf field: uint32 name_card_id = 4;
     */
    nameCardId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4019;
 * }
 *
 * @generated from protobuf message SetNameCardRsp
 */
export interface SetNameCardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 name_card_id = 2;
     */
    nameCardId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4007;
 * }
 *
 * @generated from protobuf message SetPlayerBirthdayReq
 */
export interface SetPlayerBirthdayReq {
    /**
     * @generated from protobuf field: Birthday birthday = 10;
     */
    birthday?: Birthday;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4030;
 * }
 *
 * @generated from protobuf message SetPlayerBirthdayRsp
 */
export interface SetPlayerBirthdayRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: Birthday birthday = 14;
     */
    birthday?: Birthday;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 198;
 * }
 *
 * @generated from protobuf message SetPlayerBornDataReq
 */
export interface SetPlayerBornDataReq {
    /**
     * @generated from protobuf field: uint32 avatar_id = 3;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: string nick_name = 12;
     */
    nickName: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 145;
 * }
 *
 * @generated from protobuf message SetPlayerBornDataRsp
 */
export interface SetPlayerBornDataRsp {
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4045;
 * }
 *
 * @generated from protobuf message SetPlayerHeadImageReq
 */
export interface SetPlayerHeadImageReq {
    /**
     * @generated from protobuf field: uint32 avatar_id = 4;
     */
    avatarId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4090;
 * }
 *
 * @generated from protobuf message SetPlayerHeadImageRsp
 */
export interface SetPlayerHeadImageRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 3;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: ProfilePicture profile_picture = 5;
     */
    profilePicture?: ProfilePicture;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 163;
 * }
 *
 * @generated from protobuf message SetPlayerNameReq
 */
export interface SetPlayerNameReq {
    /**
     * @generated from protobuf field: string nick_name = 8;
     */
    nickName: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 124;
 * }
 *
 * @generated from protobuf message SetPlayerNameRsp
 */
export interface SetPlayerNameRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: string nick_name = 6;
     */
    nickName: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 130;
 * }
 *
 * @generated from protobuf message SetPlayerPropReq
 */
export interface SetPlayerPropReq {
    /**
     * @generated from protobuf field: repeated PropValue prop_list = 14;
     */
    propList: PropValue[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 197;
 * }
 *
 * @generated from protobuf message SetPlayerPropRsp
 */
export interface SetPlayerPropRsp {
    /**
     * @generated from protobuf field: int32 retcode = 5;
     */
    retcode: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4097;
 * }
 *
 * @generated from protobuf message SetPlayerSignatureReq
 */
export interface SetPlayerSignatureReq {
    /**
     * @generated from protobuf field: string signature = 15;
     */
    signature: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4098;
 * }
 *
 * @generated from protobuf message SetPlayerSignatureRsp
 */
export interface SetPlayerSignatureRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: string signature = 6;
     */
    signature: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 1753;
 * }
 *
 * @generated from protobuf message SetUpAvatarTeamReq
 */
export interface SetUpAvatarTeamReq {
    /**
     * @generated from protobuf field: uint32 team_id = 10;
     */
    teamId: number;
    /**
     * @generated from protobuf field: repeated uint64 avatar_team_guid_list = 1;
     */
    avatarTeamGuidList: bigint[];
    /**
     * @generated from protobuf field: uint64 cur_avatar_guid = 2;
     */
    curAvatarGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1664;
 * }
 *
 * @generated from protobuf message SetUpAvatarTeamRsp
 */
export interface SetUpAvatarTeamRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 team_id = 5;
     */
    teamId: number;
    /**
     * @generated from protobuf field: repeated uint64 avatar_team_guid_list = 12;
     */
    avatarTeamGuidList: bigint[];
    /**
     * @generated from protobuf field: uint64 cur_avatar_guid = 3;
     */
    curAvatarGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4297;
 * }
 *
 * @generated from protobuf message SetUpLunchBoxWidgetReq
 */
export interface SetUpLunchBoxWidgetReq {
    /**
     * @generated from protobuf field: LunchBoxData lunch_box_data = 12;
     */
    lunchBoxData?: LunchBoxData;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4266;
 * }
 *
 * @generated from protobuf message SetUpLunchBoxWidgetRsp
 */
export interface SetUpLunchBoxWidgetRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: LunchBoxData lunch_box_data = 3;
     */
    lunchBoxData?: LunchBoxData;
}
/**
 * @generated from protobuf message SetWidgetSlotReq
 */
export interface SetWidgetSlotReq {
    /**
     * @generated from protobuf field: WidgetSlotOp op = 4;
     */
    op: WidgetSlotOp;
    /**
     * @generated from protobuf field: repeated WidgetSlotTag tag_list = 11;
     */
    tagList: WidgetSlotTag[];
    /**
     * @generated from protobuf field: uint32 material_id = 9;
     */
    materialId: number;
}
/**
 * @generated from protobuf message SetWidgetSlotRsp
 */
export interface SetWidgetSlotRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: WidgetSlotOp op = 14;
     */
    op: WidgetSlotOp;
    /**
     * @generated from protobuf field: repeated WidgetSlotTag tag_list = 4;
     */
    tagList: WidgetSlotTag[];
    /**
     * @generated from protobuf field: uint32 material_id = 9;
     */
    materialId: number;
}
/**
 * @generated from protobuf message Shop
 */
export interface Shop {
    /**
     * @generated from protobuf field: uint32 shop_type = 13;
     */
    shopType: number;
    /**
     * @generated from protobuf field: repeated ShopGoods goods_list = 1;
     */
    goodsList: ShopGoods[];
    /**
     * @generated from protobuf field: repeated ShopMcoinProduct mcoin_product_list = 2;
     */
    mcoinProductList: ShopMcoinProduct[];
    /**
     * @generated from protobuf field: repeated ShopCardProduct card_product_list = 10;
     */
    cardProductList: ShopCardProduct[];
    /**
     * @generated from protobuf field: uint32 next_refresh_time = 6;
     */
    nextRefreshTime: number;
    /**
     * @generated from protobuf field: uint32 city_id = 7;
     */
    cityId: number;
    /**
     * @generated from protobuf field: uint32 city_reputation_level = 14;
     */
    cityReputationLevel: number;
    /**
     * @generated from protobuf field: repeated ShopConcertProduct concert_product_list = 3;
     */
    concertProductList: ShopConcertProduct[];
}
/**
 * @generated from protobuf message ShopCardProduct
 */
export interface ShopCardProduct {
    /**
     * @generated from protobuf oneof: ExtraCardData
     */
    extraCardData: {
        oneofKind: "resinCard";
        /**
         * @generated from protobuf field: ShopCardProduct.ResinCard resin_card = 101;
         */
        resinCard: ShopCardProduct_ResinCard;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string product_id = 1;
     */
    productId: string;
    /**
     * @generated from protobuf field: string price_tier = 2;
     */
    priceTier: string;
    /**
     * @generated from protobuf field: uint32 mcoin_base = 3;
     */
    mcoinBase: number;
    /**
     * @generated from protobuf field: uint32 hcoin_per_day = 4;
     */
    hcoinPerDay: number;
    /**
     * @generated from protobuf field: uint32 days = 5;
     */
    days: number;
    /**
     * @generated from protobuf field: uint32 remain_reward_days = 6;
     */
    remainRewardDays: number;
    /**
     * @generated from protobuf field: uint32 card_product_type = 7;
     */
    cardProductType: number;
}
/**
 * @generated from protobuf message ShopCardProduct.ResinCard
 */
export interface ShopCardProduct_ResinCard {
    /**
     * @generated from protobuf field: repeated ItemParam base_item_list = 1;
     */
    baseItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam per_day_item_list = 2;
     */
    perDayItemList: ItemParam[];
}
/**
 * @generated from protobuf message ShopConcertProduct
 */
export interface ShopConcertProduct {
    /**
     * @generated from protobuf field: string product_id = 1;
     */
    productId: string;
    /**
     * @generated from protobuf field: string price_tier = 2;
     */
    priceTier: string;
    /**
     * @generated from protobuf field: uint32 obtain_count = 3;
     */
    obtainCount: number;
    /**
     * @generated from protobuf field: uint32 obtain_limit = 4;
     */
    obtainLimit: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 5;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 6;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 buy_times = 7;
     */
    buyTimes: number;
}
/**
 * @generated from protobuf message ShopGoods
 */
export interface ShopGoods {
    /**
     * @generated from protobuf field: uint32 goods_id = 2;
     */
    goodsId: number;
    /**
     * @generated from protobuf field: ItemParam goods_item = 15;
     */
    goodsItem?: ItemParam;
    /**
     * @generated from protobuf field: uint32 scoin = 6;
     */
    scoin: number;
    /**
     * @generated from protobuf field: uint32 hcoin = 10;
     */
    hcoin: number;
    /**
     * @generated from protobuf field: repeated ItemParam cost_item_list = 14;
     */
    costItemList: ItemParam[];
    /**
     * @generated from protobuf field: uint32 bought_num = 5;
     */
    boughtNum: number;
    /**
     * @generated from protobuf field: uint32 buy_limit = 13;
     */
    buyLimit: number;
    /**
     * @generated from protobuf field: uint32 begin_time = 1;
     */
    beginTime: number;
    /**
     * @generated from protobuf field: uint32 end_time = 4;
     */
    endTime: number;
    /**
     * @generated from protobuf field: uint32 next_refresh_time = 8;
     */
    nextRefreshTime: number;
    /**
     * @generated from protobuf field: uint32 min_level = 3;
     */
    minLevel: number;
    /**
     * @generated from protobuf field: uint32 max_level = 11;
     */
    maxLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 pre_goods_id_list = 12;
     */
    preGoodsIdList: number[];
    /**
     * @generated from protobuf field: uint32 mcoin = 7;
     */
    mcoin: number;
    /**
     * @generated from protobuf field: uint32 disable_type = 9;
     */
    disableType: number;
    /**
     * @generated from protobuf field: uint32 secondary_sheet_id = 320;
     */
    secondarySheetId: number;
    /**
     * @generated from protobuf field: uint32 discount_id = 868;
     */
    discountId: number;
    /**
     * @generated from protobuf field: uint32 discount_begin_time = 922;
     */
    discountBeginTime: number;
    /**
     * @generated from protobuf field: uint32 discount_end_time = 1847;
     */
    discountEndTime: number;
    /**
     * @generated from protobuf field: uint32 single_limit = 1654;
     */
    singleLimit: number;
}
/**
 * @generated from protobuf message ShopMcoinProduct
 */
export interface ShopMcoinProduct {
    /**
     * @generated from protobuf field: string product_id = 1;
     */
    productId: string;
    /**
     * @generated from protobuf field: string price_tier = 2;
     */
    priceTier: string;
    /**
     * @generated from protobuf field: uint32 mcoin_base = 3;
     */
    mcoinBase: number;
    /**
     * @generated from protobuf field: uint32 mcoin_non_first = 4;
     */
    mcoinNonFirst: number;
    /**
     * @generated from protobuf field: uint32 mcoin_first = 5;
     */
    mcoinFirst: number;
    /**
     * @generated from protobuf field: uint32 bought_num = 6;
     */
    boughtNum: number;
    /**
     * @generated from protobuf field: bool is_audit = 7;
     */
    isAudit: boolean;
}
/**
 * @generated from protobuf message ShortAbilityHashPair
 */
export interface ShortAbilityHashPair {
    /**
     * @generated from protobuf field: int32 ability_name_hash = 1;
     */
    abilityNameHash: number;
    /**
     * @generated from protobuf field: int32 ability_config_hash = 2;
     */
    abilityConfigHash: number;
}
/**
 * @generated from protobuf message ShowAvatarInfo
 */
export interface ShowAvatarInfo {
    /**
     * @generated from protobuf field: uint32 avatar_id = 1;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: map<uint32, PropValue> prop_map = 2;
     */
    propMap: {
        [key: number]: PropValue;
    };
    /**
     * @generated from protobuf field: repeated uint32 talent_id_list = 3;
     */
    talentIdList: number[];
    /**
     * @generated from protobuf field: map<uint32, float> fight_prop_map = 4;
     */
    fightPropMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 skill_depot_id = 5;
     */
    skillDepotId: number;
    /**
     * @generated from protobuf field: uint32 core_proud_skill_level = 6;
     */
    coreProudSkillLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 inherent_proud_skill_list = 7;
     */
    inherentProudSkillList: number[];
    /**
     * @generated from protobuf field: map<uint32, uint32> skill_level_map = 8;
     */
    skillLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> proud_skill_extra_level_map = 9;
     */
    proudSkillExtraLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: repeated ShowEquip equip_list = 10;
     */
    equipList: ShowEquip[];
    /**
     * @generated from protobuf field: AvatarFetterInfo fetter_info = 11;
     */
    fetterInfo?: AvatarFetterInfo;
    /**
     * @generated from protobuf field: uint32 costume_id = 12;
     */
    costumeId: number;
    /**
     * @generated from protobuf field: AvatarExcelInfo excel_info = 13;
     */
    excelInfo?: AvatarExcelInfo;
}
/**
 * @generated from protobuf message ShowEquip
 */
export interface ShowEquip {
    /**
     * @generated from protobuf oneof: detail
     */
    detail: {
        oneofKind: "reliquary";
        /**
         * @generated from protobuf field: Reliquary reliquary = 2;
         */
        reliquary: Reliquary;
    } | {
        oneofKind: "weapon";
        /**
         * @generated from protobuf field: Weapon weapon = 3;
         */
        weapon: Weapon;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 item_id = 1;
     */
    itemId: number;
}
/**
 * @generated from protobuf message SkyCrystalDetectorQuickUseResult
 */
export interface SkyCrystalDetectorQuickUseResult {
    /**
     * @generated from protobuf field: Unk2700_CCEOEOHLAPK Unk2700_COIELIGEACL = 9 [json_name = "Unk2700COIELIGEACL"];
     */
    unk2700COIELIGEACL?: Unk2700_CCEOEOHLAPK;
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
}
/**
 * @generated from protobuf message SocialDetail
 */
export interface SocialDetail {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: string nickname = 2;
     */
    nickname: string;
    /**
     * @generated from protobuf field: uint32 level = 3;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 avatar_id = 4;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: string signature = 5;
     */
    signature: string;
    /**
     * @generated from protobuf field: Birthday birthday = 6;
     */
    birthday?: Birthday;
    /**
     * @generated from protobuf field: uint32 world_level = 7;
     */
    worldLevel: number;
    /**
     * @generated from protobuf field: repeated uint32 reserved_list = 8;
     */
    reservedList: number[];
    /**
     * @generated from protobuf field: FriendOnlineState online_state = 9;
     */
    onlineState: FriendOnlineState;
    /**
     * @generated from protobuf field: uint32 param = 10;
     */
    param: number;
    /**
     * @generated from protobuf field: bool is_friend = 11;
     */
    isFriend: boolean;
    /**
     * @generated from protobuf field: bool is_mp_mode_available = 12;
     */
    isMpModeAvailable: boolean;
    /**
     * @generated from protobuf field: string online_id = 13;
     */
    onlineId: string;
    /**
     * @generated from protobuf field: uint32 name_card_id = 14;
     */
    nameCardId: number;
    /**
     * @generated from protobuf field: bool is_in_blacklist = 15;
     */
    isInBlacklist: boolean;
    /**
     * @generated from protobuf field: bool is_chat_no_disturb = 16;
     */
    isChatNoDisturb: boolean;
    /**
     * @generated from protobuf field: string remark_name = 17;
     */
    remarkName: string;
    /**
     * @generated from protobuf field: uint32 finish_achievement_num = 18;
     */
    finishAchievementNum: number;
    /**
     * @generated from protobuf field: uint32 tower_floor_index = 19;
     */
    towerFloorIndex: number;
    /**
     * @generated from protobuf field: uint32 tower_level_index = 20;
     */
    towerLevelIndex: number;
    /**
     * @generated from protobuf field: bool is_show_avatar = 21;
     */
    isShowAvatar: boolean;
    /**
     * @generated from protobuf field: repeated SocialShowAvatarInfo show_avatar_info_list = 22;
     */
    showAvatarInfoList: SocialShowAvatarInfo[];
    /**
     * @generated from protobuf field: repeated uint32 show_name_card_id_list = 23;
     */
    showNameCardIdList: number[];
    /**
     * @generated from protobuf field: FriendEnterHomeOption friend_enter_home_option = 24;
     */
    friendEnterHomeOption: FriendEnterHomeOption;
    /**
     * @generated from protobuf field: ProfilePicture profile_picture = 25;
     */
    profilePicture?: ProfilePicture;
}
/**
 * @generated from protobuf message SocialShowAvatarInfo
 */
export interface SocialShowAvatarInfo {
    /**
     * @generated from protobuf field: uint32 avatar_id = 1;
     */
    avatarId: number;
    /**
     * @generated from protobuf field: uint32 level = 2;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 costume_id = 3;
     */
    costumeId: number;
}
/**
 * @generated from protobuf message StatueGadgetInfo
 */
export interface StatueGadgetInfo {
    /**
     * @generated from protobuf field: repeated uint32 opened_statue_uid_list = 1;
     */
    openedStatueUidList: number[];
}
/**
 * @generated from protobuf message StopServerInfo
 */
export interface StopServerInfo {
    /**
     * @generated from protobuf field: uint32 stop_begin_time = 1;
     */
    stopBeginTime: number;
    /**
     * @generated from protobuf field: uint32 stop_end_time = 2;
     */
    stopEndTime: number;
    /**
     * @generated from protobuf field: string url = 3;
     */
    url: string;
    /**
     * @generated from protobuf field: string content_msg = 4;
     */
    contentMsg: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 641;
 * }
 *
 * @generated from protobuf message StoreItemChangeNotify
 */
export interface StoreItemChangeNotify {
    /**
     * @generated from protobuf field: StoreType store_type = 9;
     */
    storeType: StoreType;
    /**
     * @generated from protobuf field: repeated Item item_list = 3;
     */
    itemList: Item[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 637;
 * }
 *
 * @generated from protobuf message StoreItemDelNotify
 */
export interface StoreItemDelNotify {
    /**
     * @generated from protobuf field: StoreType store_type = 14;
     */
    storeType: StoreType;
    /**
     * @generated from protobuf field: repeated uint64 guid_list = 10;
     */
    guidList: bigint[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 631;
 * }
 *
 * @generated from protobuf message StoreWeightLimitNotify
 */
export interface StoreWeightLimitNotify {
    /**
     * @generated from protobuf field: StoreType store_type = 4;
     */
    storeType: StoreType;
    /**
     * @generated from protobuf field: uint32 weight_limit = 2;
     */
    weightLimit: number;
    /**
     * @generated from protobuf field: uint32 material_count_limit = 1;
     */
    materialCountLimit: number;
    /**
     * @generated from protobuf field: uint32 weapon_count_limit = 5;
     */
    weaponCountLimit: number;
    /**
     * @generated from protobuf field: uint32 reliquary_count_limit = 6;
     */
    reliquaryCountLimit: number;
    /**
     * @generated from protobuf field: uint32 furniture_count_limit = 8;
     */
    furnitureCountLimit: number;
}
/**
 * @generated from protobuf message StrengthenPointData
 */
export interface StrengthenPointData {
    /**
     * @generated from protobuf field: uint32 base_point = 1;
     */
    basePoint: number;
    /**
     * @generated from protobuf field: uint32 cur_point = 2;
     */
    curPoint: number;
}
/**
 * @generated from protobuf message SummerTimeV2DungeonSettleInfo
 */
export interface SummerTimeV2DungeonSettleInfo {
    /**
     * @generated from protobuf field: bool is_success = 5;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: uint32 Unk2800_ELHBCNPKOJG = 2 [json_name = "Unk2800ELHBCNPKOJG"];
     */
    unk2800ELHBCNPKOJG: number;
    /**
     * @generated from protobuf field: uint32 Unk2800_HDEFJKGDNEH = 11 [json_name = "Unk2800HDEFJKGDNEH"];
     */
    unk2800HDEFJKGDNEH: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 3096;
 * }
 *
 * @generated from protobuf message SyncScenePlayTeamEntityNotify
 */
export interface SyncScenePlayTeamEntityNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 13;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated PlayTeamEntityInfo entity_info_list = 2;
     */
    entityInfoList: PlayTeamEntityInfo[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 334;
 * }
 *
 * @generated from protobuf message SyncTeamEntityNotify
 */
export interface SyncTeamEntityNotify {
    /**
     * @generated from protobuf field: uint32 scene_id = 13;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: repeated TeamEntityInfo team_entity_info_list = 2;
     */
    teamEntityInfoList: TeamEntityInfo[];
}
/**
 * @generated from protobuf message SystemHint
 */
export interface SystemHint {
    /**
     * @generated from protobuf field: uint32 type = 1;
     */
    type: number;
}
/**
 * @generated from protobuf message TakeAchievementRewardReq
 */
export interface TakeAchievementRewardReq {
    /**
     * @generated from protobuf field: repeated uint32 id_list = 2;
     */
    idList: number[];
}
/**
 * @generated from protobuf message TakeBattlePassMissionPointReq
 */
export interface TakeBattlePassMissionPointReq {
    /**
     * @generated from protobuf field: repeated uint32 mission_id_list = 7;
     */
    missionIdList: number[];
}
/**
 * @generated from protobuf message TakeBattlePassMissionPointRsp
 */
export interface TakeBattlePassMissionPointRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 mission_id_list = 2;
     */
    missionIdList: number[];
}
/**
 * @generated from protobuf message TakeBattlePassRewardReq
 */
export interface TakeBattlePassRewardReq {
    /**
     * @generated from protobuf field: repeated BattlePassRewardTakeOption take_option_list = 4;
     */
    takeOptionList: BattlePassRewardTakeOption[];
}
/**
 * @generated from protobuf message TakeBattlePassRewardRsp
 */
export interface TakeBattlePassRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated BattlePassRewardTakeOption take_option_list = 1;
     */
    takeOptionList: BattlePassRewardTakeOption[];
    /**
     * @generated from protobuf field: repeated ItemParam item_list = 5;
     */
    itemList: ItemParam[];
}
/**
 * @generated from protobuf message TakeFurnitureMakeReq
 */
export interface TakeFurnitureMakeReq {
    /**
     * @generated from protobuf field: uint32 index = 9;
     */
    index: number;
    /**
     * @generated from protobuf field: uint32 make_id = 4;
     */
    makeId: number;
    /**
     * @generated from protobuf field: bool is_fast_finish = 2;
     */
    isFastFinish: boolean;
}
/**
 * @generated from protobuf message TakeFurnitureMakeRsp
 */
export interface TakeFurnitureMakeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 make_id = 2;
     */
    makeId: number;
    /**
     * @generated from protobuf field: FurnitureMakeSlot furniture_make_slot = 15;
     */
    furnitureMakeSlot?: FurnitureMakeSlot;
    /**
     * @generated from protobuf field: repeated ItemParam output_item_list = 10;
     */
    outputItemList: ItemParam[];
    /**
     * @generated from protobuf field: repeated ItemParam return_item_list = 5;
     */
    returnItemList: ItemParam[];
}
/**
 * @generated from protobuf message TakeoffEquipReq
 */
export interface TakeoffEquipReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 15;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 slot = 9;
     */
    slot: number;
}
/**
 * @generated from protobuf message TakeoffEquipRsp
 */
export interface TakeoffEquipRsp {
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 3;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 slot = 4;
     */
    slot: number;
}
/**
 * @generated from protobuf message TakePlayerLevelRewardReq
 */
export interface TakePlayerLevelRewardReq {
    /**
     * @generated from protobuf field: uint32 level = 5;
     */
    level: number;
}
/**
 * @generated from protobuf message TakePlayerLevelRewardRsp
 */
export interface TakePlayerLevelRewardRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 level = 13;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 reward_id = 12;
     */
    rewardId: number;
}
/**
 * @generated from protobuf message TeamEnterSceneInfo
 */
export interface TeamEnterSceneInfo {
    /**
     * @generated from protobuf field: uint32 team_entity_id = 14;
     */
    teamEntityId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo team_ability_info = 4;
     */
    teamAbilityInfo?: AbilitySyncStateInfo;
    /**
     * @generated from protobuf field: AbilityControlBlock ability_control_block = 10;
     */
    abilityControlBlock?: AbilityControlBlock;
}
/**
 * @generated from protobuf message TeamEntityInfo
 */
export interface TeamEntityInfo {
    /**
     * @generated from protobuf field: uint32 team_entity_id = 1;
     */
    teamEntityId: number;
    /**
     * @generated from protobuf field: uint32 authority_peer_id = 2;
     */
    authorityPeerId: number;
    /**
     * @generated from protobuf field: AbilitySyncStateInfo team_ability_info = 3;
     */
    teamAbilityInfo?: AbilitySyncStateInfo;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 1045;
 * }
 *
 * @generated from protobuf message TeamResonanceChangeNotify
 */
export interface TeamResonanceChangeNotify {
    /**
     * @generated from protobuf field: repeated AvatarTeamResonanceInfo info_list = 15;
     */
    infoList: AvatarTeamResonanceInfo[];
}
/**
 * @generated from protobuf message TowerAllDataRsp
 */
export interface TowerAllDataRsp {
    /**
     * @generated from protobuf field: uint32 tower_schedule_id = 13;
     */
    towerScheduleId: number;
    /**
     * @generated from protobuf field: repeated TowerFloorRecord tower_floor_record_list = 12;
     */
    towerFloorRecordList: TowerFloorRecord[];
    /**
     * @generated from protobuf field: uint32 daily_floor_id = 9;
     */
    dailyFloorId: number;
    /**
     * @generated from protobuf field: uint32 daily_level_index = 6;
     */
    dailyLevelIndex: number;
    /**
     * @generated from protobuf field: TowerCurLevelRecord cur_level_record = 2;
     */
    curLevelRecord?: TowerCurLevelRecord;
    /**
     * @generated from protobuf field: uint32 next_schedule_change_time = 8;
     */
    nextScheduleChangeTime: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> floor_open_time_map = 11;
     */
    floorOpenTimeMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: bool is_first_interact = 14;
     */
    isFirstInteract: boolean;
    /**
     * @generated from protobuf field: TowerMonthlyBrief monthly_brief = 1;
     */
    monthlyBrief?: TowerMonthlyBrief;
    /**
     * @generated from protobuf field: uint32 skip_to_floor_index = 3;
     */
    skipToFloorIndex: number;
    /**
     * @generated from protobuf field: uint32 commemorative_reward_id = 15;
     */
    commemorativeRewardId: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> skip_floor_granted_reward_item_map = 5;
     */
    skipFloorGrantedRewardItemMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 valid_tower_record_num = 10;
     */
    validTowerRecordNum: number;
    /**
     * @generated from protobuf field: int32 retcode = 4;
     */
    retcode: number;
    /**
     * @generated from protobuf field: bool is_finished_entrance_floor = 7;
     */
    isFinishedEntranceFloor: boolean;
    /**
     * @generated from protobuf field: uint32 schedule_start_time = 490;
     */
    scheduleStartTime: number;
    /**
     * @generated from protobuf field: TowerMonthlyBrief last_schedule_monthly_brief = 395;
     */
    lastScheduleMonthlyBrief?: TowerMonthlyBrief;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 2407;
 * }
 *
 * @generated from protobuf message TowerBuffSelectReq
 */
export interface TowerBuffSelectReq {
    /**
     * @generated from protobuf field: uint32 tower_buff_id = 2;
     */
    towerBuffId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2430;
 * }
 *
 * @generated from protobuf message TowerBuffSelectRsp
 */
export interface TowerBuffSelectRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 tower_buff_id = 6;
     */
    towerBuffId: number;
}
/**
 * @generated from protobuf message TowerCurLevelRecord
 */
export interface TowerCurLevelRecord {
    /**
     * @generated from protobuf field: uint32 cur_floor_id = 13;
     */
    curFloorId: number;
    /**
     * @generated from protobuf field: uint32 cur_level_index = 9;
     */
    curLevelIndex: number;
    /**
     * @generated from protobuf field: repeated TowerTeam tower_team_list = 14;
     */
    towerTeamList: TowerTeam[];
    /**
     * @generated from protobuf field: repeated uint32 buff_id_list = 15;
     */
    buffIdList: number[];
    /**
     * @generated from protobuf field: bool is_empty = 5;
     */
    isEmpty: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2441;
 * }
 *
 * @generated from protobuf message TowerCurLevelRecordChangeNotify
 */
export interface TowerCurLevelRecordChangeNotify {
    /**
     * @generated from protobuf field: TowerCurLevelRecord cur_level_record = 10;
     */
    curLevelRecord?: TowerCurLevelRecord;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 2455;
 * }
 *
 * @generated from protobuf message TowerEnterLevelReq
 */
export interface TowerEnterLevelReq {
    /**
     * @generated from protobuf field: uint32 enter_point_id = 4;
     */
    enterPointId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2427;
 * }
 *
 * @generated from protobuf message TowerEnterLevelRsp
 */
export interface TowerEnterLevelRsp {
    /**
     * @generated from protobuf field: int32 retcode = 14;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 floor_id = 6;
     */
    floorId: number;
    /**
     * @generated from protobuf field: uint32 level_index = 8;
     */
    levelIndex: number;
    /**
     * @generated from protobuf field: repeated uint32 tower_buff_id_list = 7;
     */
    towerBuffIdList: number[];
}
/**
 * @generated from protobuf message TowerFloorRecord
 */
export interface TowerFloorRecord {
    /**
     * @generated from protobuf field: uint32 floor_id = 1;
     */
    floorId: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> passed_level_map = 2;
     */
    passedLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint32 floor_star_reward_progress = 3;
     */
    floorStarRewardProgress: number;
    /**
     * @generated from protobuf field: repeated TowerLevelRecord passed_level_record_list = 4;
     */
    passedLevelRecordList: TowerLevelRecord[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2431;
 * }
 *
 * @generated from protobuf message TowerFloorRecordChangeNotify
 */
export interface TowerFloorRecordChangeNotify {
    /**
     * @generated from protobuf field: repeated TowerFloorRecord tower_floor_record_list = 9;
     */
    towerFloorRecordList: TowerFloorRecord[];
    /**
     * @generated from protobuf field: bool is_finished_entrance_floor = 1;
     */
    isFinishedEntranceFloor: boolean;
}
/**
 * @generated from protobuf message TowerLevelEndNotify
 */
export interface TowerLevelEndNotify {
    /**
     * @generated from protobuf field: bool is_success = 14;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: repeated uint32 finished_star_cond_list = 1;
     */
    finishedStarCondList: number[];
    /**
     * @generated from protobuf field: repeated ItemParam reward_item_list = 9;
     */
    rewardItemList: ItemParam[];
    /**
     * @generated from protobuf field: uint32 continue_state = 2;
     */
    continueState: number;
    /**
     * @generated from protobuf field: uint32 next_floor_id = 8;
     */
    nextFloorId: number;
}
/**
 * @generated from protobuf enum TowerLevelEndNotify.ContinueStateType
 */
export enum TowerLevelEndNotify_ContinueStateType {
    /**
     * @generated from protobuf enum value: CONTINUE_STATE_TYPE_CAN_NOT_CONTINUE = 0;
     */
    CAN_NOT_CONTINUE = 0,
    /**
     * @generated from protobuf enum value: CONTINUE_STATE_TYPE_CAN_ENTER_NEXT_LEVEL = 1;
     */
    CAN_ENTER_NEXT_LEVEL = 1,
    /**
     * @generated from protobuf enum value: CONTINUE_STATE_TYPE_CAN_ENTER_NEXT_FLOOR = 2;
     */
    CAN_ENTER_NEXT_FLOOR = 2
}
/**
 * @generated from protobuf message TowerLevelRecord
 */
export interface TowerLevelRecord {
    /**
     * @generated from protobuf field: uint32 level_id = 1;
     */
    levelId: number;
    /**
     * @generated from protobuf field: repeated uint32 satisfied_cond_list = 2;
     */
    satisfiedCondList: number[];
}
/**
 * @generated from protobuf message TowerLevelStarCondData
 */
export interface TowerLevelStarCondData {
    /**
     * @generated from protobuf field: uint32 star_cond_index = 3;
     */
    starCondIndex: number;
    /**
     * @generated from protobuf field: uint32 cond_value = 4;
     */
    condValue: number;
    /**
     * @generated from protobuf field: bool is_pause = 5;
     */
    isPause: boolean;
    /**
     * @generated from protobuf field: bool OAFMGGMJPIL = 6 [json_name = "OAFMGGMJPIL"];
     */
    oAFMGGMJPIL: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2401;
 * }
 *
 * @generated from protobuf message TowerLevelStarCondNotify
 */
export interface TowerLevelStarCondNotify {
    /**
     * @generated from protobuf field: uint32 floor_id = 3;
     */
    floorId: number;
    /**
     * @generated from protobuf field: uint32 level_index = 6;
     */
    levelIndex: number;
    /**
     * @generated from protobuf field: repeated TowerLevelStarCondData cond_data_list = 12;
     */
    condDataList: TowerLevelStarCondData[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2411;
 * }
 *
 * @generated from protobuf message TowerMiddleLevelChangeTeamNotify
 */
export interface TowerMiddleLevelChangeTeamNotify {
}
/**
 * @generated from protobuf message TowerMonthlyBrief
 */
export interface TowerMonthlyBrief {
    /**
     * @generated from protobuf field: uint32 tower_schedule_id = 4;
     */
    towerScheduleId: number;
    /**
     * @generated from protobuf field: uint32 best_floor_index = 5;
     */
    bestFloorIndex: number;
    /**
     * @generated from protobuf field: uint32 best_level_index = 12;
     */
    bestLevelIndex: number;
    /**
     * @generated from protobuf field: uint32 total_star_count = 2;
     */
    totalStarCount: number;
}
/**
 * @generated from protobuf message TowerTeam
 */
export interface TowerTeam {
    /**
     * @generated from protobuf field: uint32 tower_team_id = 1;
     */
    towerTeamId: number;
    /**
     * @generated from protobuf field: repeated uint64 avatar_guid_list = 2;
     */
    avatarGuidList: bigint[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 2417;
 * }
 *
 * @generated from protobuf message TowerTeamSelectReq
 */
export interface TowerTeamSelectReq {
    /**
     * @generated from protobuf field: uint32 floor_id = 15;
     */
    floorId: number;
    /**
     * @generated from protobuf field: repeated TowerTeam tower_team_list = 2;
     */
    towerTeamList: TowerTeam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2485;
 * }
 *
 * @generated from protobuf message TowerTeamSelectRsp
 */
export interface TowerTeamSelectRsp {
    /**
     * @generated from protobuf field: int32 retcode = 1;
     */
    retcode: number;
}
/**
 * @generated from protobuf message TrackingIOInfo
 */
export interface TrackingIOInfo {
    /**
     * @generated from protobuf field: string appid = 3;
     */
    appid: string;
    /**
     * @generated from protobuf field: string deviceid = 9;
     */
    deviceid: string;
    /**
     * @generated from protobuf field: string mac = 6;
     */
    mac: string;
    /**
     * @generated from protobuf field: string rydevicetype = 2;
     */
    rydevicetype: string;
    /**
     * @generated from protobuf field: string client_tz = 1;
     */
    clientTz: string;
    /**
     * @generated from protobuf field: string current_caid = 5;
     */
    currentCaid: string;
    /**
     * @generated from protobuf field: string cached_caid = 12;
     */
    cachedCaid: string;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 2021;
 * }
 *
 * @generated from protobuf message TrialAvatarFirstPassDungeonNotify
 */
export interface TrialAvatarFirstPassDungeonNotify {
    /**
     * @generated from protobuf field: uint32 trial_avatar_index_id = 2;
     */
    trialAvatarIndexId: number;
}
/**
 * @generated from protobuf message TrialAvatarGrantRecord
 */
export interface TrialAvatarGrantRecord {
    /**
     * @generated from protobuf field: uint32 grant_reason = 1;
     */
    grantReason: number;
    /**
     * @generated from protobuf field: uint32 from_parent_quest_id = 2;
     */
    fromParentQuestId: number;
}
/**
 * @generated from protobuf enum TrialAvatarGrantRecord.GrantReason
 */
export enum TrialAvatarGrantRecord_GrantReason {
    /**
     * @generated from protobuf enum value: GRANT_REASON_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: GRANT_REASON_BY_QUEST = 1;
     */
    BY_QUEST = 1,
    /**
     * @generated from protobuf enum value: GRANT_REASON_BY_TRIAL_AVATAR_ACTIVITY = 2;
     */
    BY_TRIAL_AVATAR_ACTIVITY = 2,
    /**
     * @generated from protobuf enum value: GRANT_REASON_BY_DUNGEON_ELEMENT_CHALLENGE = 3;
     */
    BY_DUNGEON_ELEMENT_CHALLENGE = 3,
    /**
     * @generated from protobuf enum value: GRANT_REASON_BY_MIST_TRIAL_ACTIVITY = 4;
     */
    BY_MIST_TRIAL_ACTIVITY = 4,
    /**
     * @generated from protobuf enum value: GRANT_REASON_BY_SUMO_ACTIVITY = 5;
     */
    BY_SUMO_ACTIVITY = 5,
    /**
     * @generated from protobuf enum value: GRANT_REASON_ELPMDIEIOHP = 6;
     */
    ELPMDIEIOHP = 6,
    /**
     * @generated from protobuf enum value: GRANT_REASON_FALPDBLGHJB = 7;
     */
    FALPDBLGHJB = 7,
    /**
     * @generated from protobuf enum value: GRANT_REASON_GAMADMGGMBC = 8;
     */
    GAMADMGGMBC = 8
}
/**
 * @generated from protobuf message TrialAvatarInfo
 */
export interface TrialAvatarInfo {
    /**
     * @generated from protobuf field: uint32 trial_avatar_id = 1;
     */
    trialAvatarId: number;
    /**
     * @generated from protobuf field: repeated Item trial_equip_list = 2;
     */
    trialEquipList: Item[];
    /**
     * @generated from protobuf field: TrialAvatarGrantRecord grant_record = 3;
     */
    grantRecord?: TrialAvatarGrantRecord;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4553;
 * }
 *
 * @generated from protobuf message TryEnterHomeReq
 */
export interface TryEnterHomeReq {
    /**
     * @generated from protobuf field: uint32 target_uid = 10;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: uint32 target_point = 13;
     */
    targetPoint: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4610;
 * }
 *
 * @generated from protobuf message TryEnterHomeRsp
 */
export interface TryEnterHomeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 target_uid = 2;
     */
    targetUid: number;
    /**
     * @generated from protobuf field: repeated uint32 param_list = 11;
     */
    paramList: number[];
}
/**
 * @generated from protobuf message Uint32Pair
 */
export interface Uint32Pair {
    /**
     * @generated from protobuf field: uint32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: uint32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message UnionCmd
 */
export interface UnionCmd {
    /**
     * @generated from protobuf field: uint32 message_id = 9;
     */
    messageId: number;
    /**
     * @generated from protobuf field: bytes body = 13;
     */
    body: Uint8Array;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 98;
 * }
 *
 * @generated from protobuf message UnionCmdNotify
 */
export interface UnionCmdNotify {
    /**
     * @generated from protobuf field: repeated UnionCmd cmd_list = 13;
     */
    cmdList: UnionCmd[];
}
/**
 * @generated from protobuf message Unk2700_BIEMCDLIFOD
 */
export interface Unk2700_BIEMCDLIFOD {
    /**
     * @generated from protobuf field: uint32 guid = 11;
     */
    guid: number;
    /**
     * @generated from protobuf field: Vector spawn_pos = 14;
     */
    spawnPos?: Vector;
    /**
     * @generated from protobuf field: repeated int32 included_furniture_index_list = 12;
     */
    includedFurnitureIndexList: number[];
}
/**
 * @generated from protobuf message Unk2700_CCEOEOHLAPK
 */
export interface Unk2700_CCEOEOHLAPK {
    /**
     * @generated from protobuf field: bool is_hint_valid = 3;
     */
    isHintValid: boolean;
    /**
     * @generated from protobuf field: Vector hint_center_pos = 8;
     */
    hintCenterPos?: Vector;
    /**
     * @generated from protobuf field: uint32 group_id = 6;
     */
    groupId: number;
    /**
     * @generated from protobuf field: uint32 config_id = 9;
     */
    configId: number;
}
/**
 * @generated from protobuf message Unk2700_FDEGJOCDDGH
 */
export interface Unk2700_FDEGJOCDDGH {
    /**
     * @generated from protobuf field: uint32 cur_progress = 9;
     */
    curProgress: number;
    /**
     * @generated from protobuf field: uint32 challenge_index = 10;
     */
    challengeIndex: number;
    /**
     * @generated from protobuf field: bool is_success = 4;
     */
    isSuccess: boolean;
    /**
     * @generated from protobuf field: uint32 challenge_id = 8;
     */
    challengeId: number;
}
/**
 * @generated from protobuf message Unk2700_GOHMLAFNBGF
 */
export interface Unk2700_GOHMLAFNBGF {
    /**
     * @generated from protobuf field: uint32 Unk2700_OALCFEGIBOL = 8 [json_name = "Unk2700OALCFEGIBOL"];
     */
    unk2700OALCFEGIBOL: number;
    /**
     * @generated from protobuf field: repeated HomeFurnitureData Unk2700_CKPNCKDIJMB = 3 [json_name = "Unk2700CKPNCKDIJMB"];
     */
    unk2700CKPNCKDIJMB: HomeFurnitureData[];
}
/**
 * @generated from protobuf message Unk2700_HFMDKDHCJCM
 */
export interface Unk2700_HFMDKDHCJCM {
    /**
     * @generated from protobuf field: Vector Unk2700_CMOMNFNGCGB = 1 [json_name = "Unk2700CMOMNFNGCGB"];
     */
    unk2700CMOMNFNGCGB?: Vector;
}
/**
 * @generated from protobuf message Unk2800_FHMOLALLEEN
 */
export interface Unk2800_FHMOLALLEEN {
    /**
     * @generated from protobuf field: repeated uint32 argument_list = 1;
     */
    argumentList: number[];
}
/**
 * @generated from protobuf message Unk2800_JKLFAJKDLDG
 */
export interface Unk2800_JKLFAJKDLDG {
    /**
     * @generated from protobuf field: uint32 quest_id = 13;
     */
    questId: number;
    /**
     * @generated from protobuf field: uint32 point_id = 6;
     */
    pointId: number;
}
/**
 * @generated from protobuf message Unk2800_MHCFAGCKGIB
 */
export interface Unk2800_MHCFAGCKGIB {
    /**
     * @generated from protobuf field: uint32 scene_id = 12;
     */
    sceneId: number;
    /**
     * @generated from protobuf field: uint32 point_id = 6;
     */
    pointId: number;
    /**
     * @generated from protobuf field: repeated DungeonEntryInfo dungeon_entry_list = 1;
     */
    dungeonEntryList: DungeonEntryInfo[];
    /**
     * @generated from protobuf field: uint32 recommend_dungeon_id = 8;
     */
    recommendDungeonId: number;
}
/**
 * @generated from protobuf message Unk2800_PHPHMILPOLC
 */
export interface Unk2800_PHPHMILPOLC {
    /**
     * @generated from protobuf field: Unk2800_FDLKPKFOIIK state = 10;
     */
    state: Unk2800_FDLKPKFOIIK;
    /**
     * @generated from protobuf field: uint32 Unk2800_CLOCMPFBGMD = 4 [json_name = "Unk2800CLOCMPFBGMD"];
     */
    unk2800CLOCMPFBGMD: number;
}
/**
 * @generated from protobuf message UnlockAvatarTalentReq
 */
export interface UnlockAvatarTalentReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 13;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 talent_id = 9;
     */
    talentId: number;
}
/**
 * @generated from protobuf message UnlockAvatarTalentRsp
 */
export interface UnlockAvatarTalentRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 14;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 talent_id = 12;
     */
    talentId: number;
}
/**
 * @generated from protobuf message UnlockedFurnitureFormulaDataNotify
 */
export interface UnlockedFurnitureFormulaDataNotify {
    /**
     * @generated from protobuf field: bool is_all = 14;
     */
    isAll: boolean;
    /**
     * @generated from protobuf field: repeated uint32 furniture_id_list = 7;
     */
    furnitureIdList: number[];
}
/**
 * @generated from protobuf message UnlockedFurnitureSuiteDataNotify
 */
export interface UnlockedFurnitureSuiteDataNotify {
    /**
     * @generated from protobuf field: bool is_all = 10;
     */
    isAll: boolean;
    /**
     * @generated from protobuf field: repeated uint32 furniture_suite_id_list = 15;
     */
    furnitureSuiteIdList: number[];
}
/**
 * @generated from protobuf message UnlockNameCardNotify
 */
export interface UnlockNameCardNotify {
    /**
     * @generated from protobuf field: uint32 name_card_id = 14;
     */
    nameCardId: number;
}
/**
 * @generated from protobuf message UnlockPersonalLineReq
 */
export interface UnlockPersonalLineReq {
    /**
     * @generated from protobuf field: uint32 personal_line_id = 8;
     */
    personalLineId: number;
}
/**
 * @generated from protobuf message UnlockPersonalLineRsp
 */
export interface UnlockPersonalLineRsp {
    /**
     * @generated from protobuf field: int32 retcode = 7;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 personal_line_id = 8;
     */
    personalLineId: number;
    /**
     * @generated from protobuf oneof: param
     */
    param: {
        oneofKind: "level";
        /**
         * @generated from protobuf field: uint32 level = 1;
         */
        level: number;
    } | {
        oneofKind: "chapterId";
        /**
         * @generated from protobuf field: uint32 chapter_id = 15;
         */
        chapterId: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message UpdatePlayerShowAvatarListReq
 */
export interface UpdatePlayerShowAvatarListReq {
    /**
     * @generated from protobuf field: repeated uint32 show_avatar_id_list = 13;
     */
    showAvatarIdList: number[];
    /**
     * @generated from protobuf field: bool is_show_avatar = 2;
     */
    isShowAvatar: boolean;
}
/**
 * @generated from protobuf message UpdatePlayerShowAvatarListRsp
 */
export interface UpdatePlayerShowAvatarListRsp {
    /**
     * @generated from protobuf field: int32 retcode = 2;
     */
    retcode: number;
    /**
     * @generated from protobuf field: repeated uint32 show_avatar_id_list = 1;
     */
    showAvatarIdList: number[];
    /**
     * @generated from protobuf field: bool is_show_avatar = 8;
     */
    isShowAvatar: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 635;
 * }
 *
 * @generated from protobuf message UseItemReq
 */
export interface UseItemReq {
    /**
     * @generated from protobuf field: uint64 guid = 1;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 count = 12;
     */
    count: number;
    /**
     * @generated from protobuf field: uint64 target_guid = 14;
     */
    targetGuid: bigint;
    /**
     * @generated from protobuf field: uint32 option_idx = 10;
     */
    optionIdx: number;
    /**
     * @generated from protobuf field: bool is_enter_mp_dungeon_team = 3;
     */
    isEnterMpDungeonTeam: boolean;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 649;
 * }
 *
 * @generated from protobuf message UseItemRsp
 */
export interface UseItemRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 guid = 8;
     */
    guid: bigint;
    /**
     * @generated from protobuf field: uint32 item_id = 11;
     */
    itemId: number;
    /**
     * @generated from protobuf field: uint64 target_guid = 12;
     */
    targetGuid: bigint;
    /**
     * @generated from protobuf field: uint32 option_idx = 13;
     */
    optionIdx: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4273;
 * }
 *
 * @generated from protobuf message UseWidgetCreateGadgetReq
 */
export interface UseWidgetCreateGadgetReq {
    /**
     * @generated from protobuf field: uint32 material_id = 1;
     */
    materialId: number;
    /**
     * @generated from protobuf field: Vector pos = 10;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 4;
     */
    rot?: Vector;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 4283;
 * }
 *
 * @generated from protobuf message UseWidgetCreateGadgetRsp
 */
export interface UseWidgetCreateGadgetRsp {
    /**
     * @generated from protobuf field: int32 retcode = 13;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 material_id = 2;
     */
    materialId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4279;
 * }
 *
 * @generated from protobuf message UseWidgetRetractGadgetReq
 */
export interface UseWidgetRetractGadgetReq {
    /**
     * @generated from protobuf field: uint32 entity_id = 7;
     */
    entityId: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 4290;
 * }
 *
 * @generated from protobuf message UseWidgetRetractGadgetRsp
 */
export interface UseWidgetRetractGadgetRsp {
    /**
     * @generated from protobuf field: int32 retcode = 9;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 15;
     */
    entityId: number;
}
/**
 * @generated from protobuf message Vector
 */
export interface Vector {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message Vector3Int
 */
export interface Vector3Int {
    /**
     * @generated from protobuf field: int32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: int32 z = 3;
     */
    z: number;
}
/**
 * @generated from protobuf message VehicleInfo
 */
export interface VehicleInfo {
    /**
     * @generated from protobuf field: repeated VehicleMember member_list = 1;
     */
    memberList: VehicleMember[];
    /**
     * @generated from protobuf field: uint32 owner_uid = 2;
     */
    ownerUid: number;
    /**
     * @generated from protobuf field: float cur_stamina = 3;
     */
    curStamina: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 838;
 * }
 *
 * @generated from protobuf message VehicleInteractReq
 */
export interface VehicleInteractReq {
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
    /**
     * @generated from protobuf field: VehicleInteractType interact_type = 3;
     */
    interactType: VehicleInteractType;
    /**
     * @generated from protobuf field: uint32 pos = 10;
     */
    pos: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 806;
 * }
 *
 * @generated from protobuf message VehicleInteractRsp
 */
export interface VehicleInteractRsp {
    /**
     * @generated from protobuf field: int32 retcode = 15;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 entity_id = 14;
     */
    entityId: number;
    /**
     * @generated from protobuf field: VehicleInteractType interact_type = 3;
     */
    interactType: VehicleInteractType;
    /**
     * @generated from protobuf field: VehicleMember member = 1;
     */
    member?: VehicleMember;
}
/**
 * @generated from protobuf message VehicleLocationInfo
 */
export interface VehicleLocationInfo {
    /**
     * @generated from protobuf field: uint32 entity_id = 1;
     */
    entityId: number;
    /**
     * @generated from protobuf field: uint32 gadget_id = 2;
     */
    gadgetId: number;
    /**
     * @generated from protobuf field: uint32 owner_uid = 3;
     */
    ownerUid: number;
    /**
     * @generated from protobuf field: Vector pos = 4;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 5;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: float cur_hp = 6;
     */
    curHp: number;
    /**
     * @generated from protobuf field: float max_hp = 7;
     */
    maxHp: number;
    /**
     * @generated from protobuf field: repeated uint32 uid_list = 8;
     */
    uidList: number[];
}
/**
 * @generated from protobuf message VehicleMember
 */
export interface VehicleMember {
    /**
     * @generated from protobuf field: uint32 uid = 1;
     */
    uid: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 2;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint32 pos = 3;
     */
    pos: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 811;
 * }
 *
 * @generated from protobuf message VehicleStaminaNotify
 */
export interface VehicleStaminaNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
    /**
     * @generated from protobuf field: float cur_stamina = 4;
     */
    curStamina: number;
}
/**
 * @generated from protobuf message Weapon
 */
export interface Weapon {
    /**
     * @generated from protobuf field: uint32 level = 1;
     */
    level: number;
    /**
     * @generated from protobuf field: uint32 exp = 2;
     */
    exp: number;
    /**
     * @generated from protobuf field: uint32 promote_level = 3;
     */
    promoteLevel: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> affix_map = 4;
     */
    affixMap: {
        [key: number]: number;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 642;
 * }
 *
 * @generated from protobuf message WeaponAwakenReq
 */
export interface WeaponAwakenReq {
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 9;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: uint64 item_guid = 3;
     */
    itemGuid: bigint;
    /**
     * @generated from protobuf field: map<uint32, uint32> affix_level_map = 2;
     */
    affixLevelMap: {
        [key: number]: number;
    };
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 601;
 * }
 *
 * @generated from protobuf message WeaponAwakenRsp
 */
export interface WeaponAwakenRsp {
    /**
     * @generated from protobuf field: int32 retcode = 3;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 1;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: uint32 target_weapon_awaken_level = 13;
     */
    targetWeaponAwakenLevel: number;
    /**
     * @generated from protobuf field: map<uint32, uint32> old_affix_level_map = 7;
     */
    oldAffixLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: map<uint32, uint32> cur_affix_level_map = 14;
     */
    curAffixLevelMap: {
        [key: number]: number;
    };
    /**
     * @generated from protobuf field: uint64 avatar_guid = 10;
     */
    avatarGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 624;
 * }
 *
 * @generated from protobuf message WeaponPromoteReq
 */
export interface WeaponPromoteReq {
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 6;
     */
    targetWeaponGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 638;
 * }
 *
 * @generated from protobuf message WeaponPromoteRsp
 */
export interface WeaponPromoteRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 15;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: uint32 old_promote_level = 5;
     */
    oldPromoteLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_promote_level = 2;
     */
    curPromoteLevel: number;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 686;
 * }
 *
 * @generated from protobuf message WeaponUpgradeReq
 */
export interface WeaponUpgradeReq {
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 3;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: repeated uint64 food_weapon_guid_list = 8;
     */
    foodWeaponGuidList: bigint[];
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 14;
     */
    itemParamList: ItemParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 663;
 * }
 *
 * @generated from protobuf message WeaponUpgradeRsp
 */
export interface WeaponUpgradeRsp {
    /**
     * @generated from protobuf field: int32 retcode = 11;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 target_weapon_guid = 8;
     */
    targetWeaponGuid: bigint;
    /**
     * @generated from protobuf field: uint32 old_level = 4;
     */
    oldLevel: number;
    /**
     * @generated from protobuf field: uint32 cur_level = 7;
     */
    curLevel: number;
    /**
     * @generated from protobuf field: repeated ItemParam item_param_list = 2;
     */
    itemParamList: ItemParam[];
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * IS_ALLOW_CLIENT = 1;
 * CMD_ID = 630;
 * }
 *
 * @generated from protobuf message WearEquipReq
 */
export interface WearEquipReq {
    /**
     * @generated from protobuf field: uint64 avatar_guid = 14;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint64 equip_guid = 2;
     */
    equipGuid: bigint;
}
/**
 * enum CmdId {
 * option allow_alias = true;
 * NONE = 0;
 * ENET_CHANNEL_ID = 0;
 * ENET_IS_RELIABLE = 1;
 * CMD_ID = 697;
 * }
 *
 * @generated from protobuf message WearEquipRsp
 */
export interface WearEquipRsp {
    /**
     * @generated from protobuf field: int32 retcode = 6;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint64 avatar_guid = 10;
     */
    avatarGuid: bigint;
    /**
     * @generated from protobuf field: uint64 equip_guid = 5;
     */
    equipGuid: bigint;
}
/**
 * @generated from protobuf message WeatherInfo
 */
export interface WeatherInfo {
    /**
     * @generated from protobuf field: uint32 weather_area_id = 1;
     */
    weatherAreaId: number;
}
/**
 * @generated from protobuf message WeekendDjinnInfo
 */
export interface WeekendDjinnInfo {
    /**
     * @generated from protobuf field: Vector rot = 14;
     */
    rot?: Vector;
    /**
     * @generated from protobuf field: Vector pos = 10;
     */
    pos?: Vector;
}
/**
 * @generated from protobuf message WeeklyBossResinDiscountInfo
 */
export interface WeeklyBossResinDiscountInfo {
    /**
     * @generated from protobuf field: uint32 discount_num = 1;
     */
    discountNum: number;
    /**
     * @generated from protobuf field: uint32 discount_num_limit = 2;
     */
    discountNumLimit: number;
    /**
     * @generated from protobuf field: uint32 resin_cost = 3;
     */
    resinCost: number;
    /**
     * @generated from protobuf field: uint32 original_resin_cost = 4;
     */
    originalResinCost: number;
}
/**
 * @generated from protobuf message WidgetActiveChangeNotify
 */
export interface WidgetActiveChangeNotify {
    /**
     * @generated from protobuf field: repeated WidgetSlotData widget_data_list = 4;
     */
    widgetDataList: WidgetSlotData[];
}
/**
 * @generated from protobuf message WidgetCameraInfo
 */
export interface WidgetCameraInfo {
    /**
     * @generated from protobuf field: uint32 target_entity_id = 14;
     */
    targetEntityId: number;
}
/**
 * @generated from protobuf message WidgetCoolDownData
 */
export interface WidgetCoolDownData {
    /**
     * @generated from protobuf field: uint32 id = 2;
     */
    id: number;
    /**
     * @generated from protobuf field: uint64 cool_down_time = 9;
     */
    coolDownTime: bigint;
    /**
     * @generated from protobuf field: bool is_success = 10;
     */
    isSuccess: boolean;
}
/**
 * @generated from protobuf message WidgetCoolDownNotify
 */
export interface WidgetCoolDownNotify {
    /**
     * @generated from protobuf field: repeated WidgetCoolDownData group_cool_down_data_list = 4;
     */
    groupCoolDownDataList: WidgetCoolDownData[];
    /**
     * @generated from protobuf field: repeated WidgetCoolDownData normal_cool_down_data_list = 8;
     */
    normalCoolDownDataList: WidgetCoolDownData[];
}
/**
 * @generated from protobuf message WidgetCreateLocationInfo
 */
export interface WidgetCreateLocationInfo {
    /**
     * @generated from protobuf field: Vector pos = 14;
     */
    pos?: Vector;
    /**
     * @generated from protobuf field: Vector rot = 4;
     */
    rot?: Vector;
}
/**
 * @generated from protobuf message WidgetCreatorInfo
 */
export interface WidgetCreatorInfo {
    /**
     * @generated from protobuf field: WidgetCreatorOpType op_type = 11;
     */
    opType: WidgetCreatorOpType;
    /**
     * @generated from protobuf field: uint32 entity_id = 8;
     */
    entityId: number;
    /**
     * @generated from protobuf field: WidgetCreateLocationInfo location_info = 10;
     */
    locationInfo?: WidgetCreateLocationInfo;
}
/**
 * @generated from protobuf message WidgetDoBagReq
 */
export interface WidgetDoBagReq {
    /**
     * @generated from protobuf field: uint32 material_id = 15;
     */
    materialId: number;
    /**
     * @generated from protobuf oneof: op_info
     */
    opInfo: {
        oneofKind: "locationInfo";
        /**
         * @generated from protobuf field: WidgetCreateLocationInfo location_info = 351;
         */
        locationInfo: WidgetCreateLocationInfo;
    } | {
        oneofKind: "widgetCreatorInfo";
        /**
         * @generated from protobuf field: WidgetCreatorInfo widget_creator_info = 46;
         */
        widgetCreatorInfo: WidgetCreatorInfo;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message WidgetDoBagRsp
 */
export interface WidgetDoBagRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 material_id = 9;
     */
    materialId: number;
}
/**
 * @generated from protobuf message WidgetGadgetAllDataNotify
 */
export interface WidgetGadgetAllDataNotify {
    /**
     * @generated from protobuf field: repeated WidgetGadgetData widget_gadget_data = 8;
     */
    widgetGadgetData: WidgetGadgetData[];
}
/**
 * @generated from protobuf message WidgetGadgetData
 */
export interface WidgetGadgetData {
    /**
     * @generated from protobuf field: uint32 gadget_id = 13;
     */
    gadgetId: number;
    /**
     * @generated from protobuf field: repeated uint32 gadget_entity_id_list = 5;
     */
    gadgetEntityIdList: number[];
}
/**
 * @generated from protobuf message WidgetGadgetDataNotify
 */
export interface WidgetGadgetDataNotify {
    /**
     * @generated from protobuf field: WidgetGadgetData widget_gadget_data = 13;
     */
    widgetGadgetData?: WidgetGadgetData;
}
/**
 * @generated from protobuf message WidgetGadgetDestroyNotify
 */
export interface WidgetGadgetDestroyNotify {
    /**
     * @generated from protobuf field: uint32 entity_id = 7;
     */
    entityId: number;
}
/**
 * @generated from protobuf message WidgetReportReq
 */
export interface WidgetReportReq {
    /**
     * @generated from protobuf field: uint32 material_id = 7;
     */
    materialId: number;
    /**
     * @generated from protobuf field: bool is_clear_hint = 13;
     */
    isClearHint: boolean;
    /**
     * @generated from protobuf field: bool is_client_collect = 9;
     */
    isClientCollect: boolean;
    /**
     * @generated from protobuf field: bool ICBFJGOLNOL = 1 [json_name = "ICBFJGOLNOL"];
     */
    iCBFJGOLNOL: boolean;
}
/**
 * @generated from protobuf message WidgetReportRsp
 */
export interface WidgetReportRsp {
    /**
     * @generated from protobuf field: int32 retcode = 12;
     */
    retcode: number;
    /**
     * @generated from protobuf field: uint32 material_id = 7;
     */
    materialId: number;
}
/**
 * @generated from protobuf message WidgetSlotChangeNotify
 */
export interface WidgetSlotChangeNotify {
    /**
     * @generated from protobuf field: WidgetSlotOp op = 6;
     */
    op: WidgetSlotOp;
    /**
     * @generated from protobuf field: WidgetSlotData slot = 8;
     */
    slot?: WidgetSlotData;
}
/**
 * @generated from protobuf message WidgetSlotData
 */
export interface WidgetSlotData {
    /**
     * @generated from protobuf field: WidgetSlotTag tag = 3;
     */
    tag: WidgetSlotTag;
    /**
     * @generated from protobuf field: uint32 material_id = 10;
     */
    materialId: number;
    /**
     * @generated from protobuf field: uint32 cd_over_time = 11;
     */
    cdOverTime: number;
    /**
     * @generated from protobuf field: bool is_active = 5;
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message WidgetSlotTagComparer
 */
export interface WidgetSlotTagComparer {
}
/**
 * @generated from protobuf message WidgetThunderBirdFeatherInfo
 */
export interface WidgetThunderBirdFeatherInfo {
    /**
     * @generated from protobuf field: repeated uint32 entity_id_list = 12;
     */
    entityIdList: number[];
}
/**
 * @generated from protobuf message WidgetUseAttachAbilityGroupChangeNotify
 */
export interface WidgetUseAttachAbilityGroupChangeNotify {
    /**
     * @generated from protobuf field: uint32 material_id = 4;
     */
    materialId: number;
    /**
     * @generated from protobuf field: bool is_attach = 11;
     */
    isAttach: boolean;
}
/**
 * @generated from protobuf message WindSeedClientNotify
 */
export interface WindSeedClientNotify {
    /**
     * @generated from protobuf oneof: Notify
     */
    notify: {
        oneofKind: "addWindBulletNotify";
        /**
         * @generated from protobuf field: WindSeedClientNotify.AddWindBulletNotify add_wind_bullet_notify = 1;
         */
        addWindBulletNotify: WindSeedClientNotify_AddWindBulletNotify;
    } | {
        oneofKind: "refreshNotify";
        /**
         * @generated from protobuf field: WindSeedClientNotify.RefreshNotify refresh_notify = 9;
         */
        refreshNotify: WindSeedClientNotify_RefreshNotify;
    } | {
        oneofKind: "areaNotify";
        /**
         * @generated from protobuf field: WindSeedClientNotify.AreaNotify area_notify = 15;
         */
        areaNotify: WindSeedClientNotify_AreaNotify;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message WindSeedClientNotify.RefreshNotify
 */
export interface WindSeedClientNotify_RefreshNotify {
    /**
     * @generated from protobuf field: uint32 refresh_num = 14;
     */
    refreshNum: number;
}
/**
 * @generated from protobuf message WindSeedClientNotify.AddWindBulletNotify
 */
export interface WindSeedClientNotify_AddWindBulletNotify {
    /**
     * @generated from protobuf field: uint32 seed_entity_id = 15;
     */
    seedEntityId: number;
    /**
     * @generated from protobuf field: Vector seed_pos = 13;
     */
    seedPos?: Vector;
    /**
     * @generated from protobuf field: uint32 catch_player_uid = 14;
     */
    catchPlayerUid: number;
}
/**
 * @generated from protobuf message WindSeedClientNotify.AreaNotify
 */
export interface WindSeedClientNotify_AreaNotify {
    /**
     * @generated from protobuf field: uint32 area_id = 1;
     */
    areaId: number;
    /**
     * @generated from protobuf field: bytes area_code = 4;
     */
    areaCode: Uint8Array;
    /**
     * @generated from protobuf field: uint32 area_type = 8;
     */
    areaType: number;
}
/**
 * @generated from protobuf message WorktopInfo
 */
export interface WorktopInfo {
    /**
     * @generated from protobuf field: repeated uint32 option_list = 1;
     */
    optionList: number[];
    /**
     * @generated from protobuf field: bool is_guest_can_operate = 2;
     */
    isGuestCanOperate: boolean;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 837;
 * }
 *
 * @generated from protobuf message WorktopOptionNotify
 */
export interface WorktopOptionNotify {
    /**
     * @generated from protobuf field: uint32 gadget_entity_id = 12;
     */
    gadgetEntityId: number;
    /**
     * @generated from protobuf field: repeated uint32 option_list = 5;
     */
    optionList: number[];
}
/**
 * enum DataType {
 * 	DATA_TYPE_// NONE = 0;
 * 	DATA_TYPE_WORLD_LEVEL = 1;
 * 	DATA_TYPE_IS_IN_MP_MODE = 2;
 * }
 *
 * @generated from protobuf message WorldDataNotify
 */
export interface WorldDataNotify {
    /**
     * @generated from protobuf field: map<uint32, PropValue> world_prop_map = 3;
     */
    worldPropMap: {
        [key: number]: PropValue;
    };
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 296;
 * }
 *
 * @generated from protobuf message WorldPlayerDieNotify
 */
export interface WorldPlayerDieNotify {
    /**
     * @generated from protobuf oneof: Entity
     */
    entity: {
        oneofKind: "monsterId";
        /**
         * @generated from protobuf field: uint32 monster_id = 10;
         */
        monsterId: number;
    } | {
        oneofKind: "gadgetId";
        /**
         * @generated from protobuf field: uint32 gadget_id = 11;
         */
        gadgetId: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: PlayerDieType die_type = 9;
     */
    dieType: PlayerDieType;
    /**
     * @generated from protobuf field: uint32 murderer_entity_id = 14;
     */
    murdererEntityId: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 3304;
 * }
 *
 * @generated from protobuf message WorldPlayerInfoNotify
 */
export interface WorldPlayerInfoNotify {
    /**
     * @generated from protobuf field: repeated OnlinePlayerInfo player_info_list = 6;
     */
    playerInfoList: OnlinePlayerInfo[];
    /**
     * @generated from protobuf field: repeated uint32 player_uid_list = 5;
     */
    playerUidList: number[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 283;
 * }
 *
 * @generated from protobuf message WorldPlayerLocationNotify
 */
export interface WorldPlayerLocationNotify {
    /**
     * @generated from protobuf field: repeated PlayerLocationInfo player_loc_list = 6;
     */
    playerLocList: PlayerLocationInfo[];
    /**
     * @generated from protobuf field: repeated PlayerWorldLocationInfo player_world_loc_list = 15;
     */
    playerWorldLocList: PlayerWorldLocationInfo[];
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// IS_ALLOW_CLIENT = 1;
 * 	// CMD_ID = 247;
 * }
 *
 * @generated from protobuf message WorldPlayerReviveReq
 */
export interface WorldPlayerReviveReq {
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 280;
 * }
 *
 * @generated from protobuf message WorldPlayerReviveRsp
 */
export interface WorldPlayerReviveRsp {
    /**
     * @generated from protobuf field: int32 retcode = 8;
     */
    retcode: number;
}
/**
 * enum CmdId {
 * 	//option allow_alias = true;
 * 	// NONE = 0;
 * 	// ENET_CHANNEL_ID = 0;
 * 	// ENET_IS_RELIABLE = 1;
 * 	// CMD_ID = 24;
 * }
 *
 * @generated from protobuf message WorldPlayerRTTNotify
 */
export interface WorldPlayerRTTNotify {
    /**
     * @generated from protobuf field: repeated PlayerRTTInfo player_rtt_list = 14;
     */
    playerRttList: PlayerRTTInfo[];
}
/**
 * @generated from protobuf enum AbilityInvokeArgument
 */
export enum AbilityInvokeArgument {
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_MODIFIER_CHANGE = 1;
     */
    META_MODIFIER_CHANGE = 1,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_COMMAND_MODIFIER_CHANGE_REQUEST = 2;
     */
    META_COMMAND_MODIFIER_CHANGE_REQUEST = 2,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_SPECIAL_FLOAT_ARGUMENT = 3;
     */
    META_SPECIAL_FLOAT_ARGUMENT = 3,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_OVERRIDE_PARAM = 4;
     */
    META_OVERRIDE_PARAM = 4,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_CLEAR_OVERRIDE_PARAM = 5;
     */
    META_CLEAR_OVERRIDE_PARAM = 5,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_REINIT_OVERRIDEMAP = 6;
     */
    META_REINIT_OVERRIDEMAP = 6,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_GLOBAL_FLOAT_VALUE = 7;
     */
    META_GLOBAL_FLOAT_VALUE = 7,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_CLEAR_GLOBAL_FLOAT_VALUE = 8;
     */
    META_CLEAR_GLOBAL_FLOAT_VALUE = 8,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_ABILITY_ELEMENT_STRENGTH = 9;
     */
    META_ABILITY_ELEMENT_STRENGTH = 9,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_ADD_OR_GET_ABILITY_AND_TRIGGER = 10;
     */
    META_ADD_OR_GET_ABILITY_AND_TRIGGER = 10,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_SET_KILLED_SETATE = 11;
     */
    META_SET_KILLED_SETATE = 11,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_SET_ABILITY_TRIGGER = 12;
     */
    META_SET_ABILITY_TRIGGER = 12,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_ADD_NEW_ABILITY = 13;
     */
    META_ADD_NEW_ABILITY = 13,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_REMOVE_ABILITY = 14;
     */
    META_REMOVE_ABILITY = 14,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_SET_MODIFIER_APPLY_ENTITY = 15;
     */
    META_SET_MODIFIER_APPLY_ENTITY = 15,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_MODIFIER_DURABILITY_CHANGE = 16;
     */
    META_MODIFIER_DURABILITY_CHANGE = 16,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_ELEMENT_REACTION_VISUAL = 17;
     */
    META_ELEMENT_REACTION_VISUAL = 17,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_SET_POSE_PARAMETER = 18;
     */
    META_SET_POSE_PARAMETER = 18,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_UPDATE_BASE_REACTION_DAMAGE = 19;
     */
    META_UPDATE_BASE_REACTION_DAMAGE = 19,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_TRIGGER_ELEMENT_REACTION = 20;
     */
    META_TRIGGER_ELEMENT_REACTION = 20,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_META_LOSE_HP = 21;
     */
    META_LOSE_HP = 21,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_JDDDLJELBLJ = 22;
     */
    JDDDLJELBLJ = 22,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_TRIGGER_ABILITY = 50;
     */
    ACTION_TRIGGER_ABILITY = 50,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_SET_CRASH_DAMAGE = 51;
     */
    ACTION_SET_CRASH_DAMAGE = 51,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_EFFECT = 52;
     */
    ACTION_EFFECT = 52,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_SUMMON = 53;
     */
    ACTION_SUMMON = 53,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_BLINK = 54;
     */
    ACTION_BLINK = 54,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_CREATE_GADGET = 55;
     */
    ACTION_CREATE_GADGET = 55,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_APPLY_LEVEL_MODIFIER = 56;
     */
    ACTION_APPLY_LEVEL_MODIFIER = 56,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_GENERATE_ELEM_BALL = 57;
     */
    ACTION_GENERATE_ELEM_BALL = 57,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_SET_RANDOM_OVERRIDE_MAP_VALUE = 58;
     */
    ACTION_SET_RANDOM_OVERRIDE_MAP_VALUE = 58,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_SERVER_MONSTER_LOG = 59;
     */
    ACTION_SERVER_MONSTER_LOG = 59,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_CREATE_TILE = 60;
     */
    ACTION_CREATE_TILE = 60,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_DESTROY_TILE = 61;
     */
    ACTION_DESTROY_TILE = 61,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_ACTION_FIRE_AFTER_IMAGE = 62;
     */
    ACTION_FIRE_AFTER_IMAGE = 62,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_FNANDDPDLOL = 63;
     */
    FNANDDPDLOL = 63,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_AVATAR_STEER_BY_CAMERA = 100;
     */
    MIXIN_AVATAR_STEER_BY_CAMERA = 100,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_MONSTER_DEFEND = 101;
     */
    MIXIN_MONSTER_DEFEND = 101,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_WIND_ZONE = 102;
     */
    MIXIN_WIND_ZONE = 102,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_COST_STAMINA = 103;
     */
    MIXIN_COST_STAMINA = 103,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_ELITE_SHIELD = 104;
     */
    MIXIN_ELITE_SHIELD = 104,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_ELEMENT_SHIELD = 105;
     */
    MIXIN_ELEMENT_SHIELD = 105,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_GLOBAL_SHIELD = 106;
     */
    MIXIN_GLOBAL_SHIELD = 106,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_SHIELD_BAR = 107;
     */
    MIXIN_SHIELD_BAR = 107,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_WIND_SEED_SPAWNER = 108;
     */
    MIXIN_WIND_SEED_SPAWNER = 108,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_DO_ACTION_BY_ELEMENT_REACTION = 109;
     */
    MIXIN_DO_ACTION_BY_ELEMENT_REACTION = 109,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_FIELD_ENTITY_COUNT_CHANGE = 110;
     */
    MIXIN_FIELD_ENTITY_COUNT_CHANGE = 110,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_SCENE_PROP_SYNC = 111;
     */
    MIXIN_SCENE_PROP_SYNC = 111,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_MIXIN_WIDGET_MP_SUPPORT = 112;
     */
    MIXIN_WIDGET_MP_SUPPORT = 112,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_NJHBFADEOON = 113;
     */
    NJHBFADEOON = 113,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_EGCIFFFLLBG = 114;
     */
    EGCIFFFLLBG = 114,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_OFDGFACOLDI = 115;
     */
    OFDGFACOLDI = 115,
    /**
     * @generated from protobuf enum value: ABILITY_INVOKE_ARGUMENT_KDPKJGJNGFB = 116;
     */
    KDPKJGJNGFB = 116
}
/**
 * @generated from protobuf enum AbilityScalarType
 */
export enum AbilityScalarType {
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_UNKNOW = 0;
     */
    UNKNOW = 0,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_FLOAT = 1;
     */
    FLOAT = 1,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_INT = 2;
     */
    INT = 2,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_BOOL = 3;
     */
    BOOL = 3,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_TRIGGER = 4;
     */
    TRIGGER = 4,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_STRING = 5;
     */
    STRING = 5,
    /**
     * @generated from protobuf enum value: ABILITY_SCALAR_TYPE_UINT = 6;
     */
    UINT = 6
}
/**
 * @generated from protobuf enum ActionReasonType
 */
export enum ActionReasonType {
    /**
     * @generated from protobuf enum value: ACTION_REASON_NONE = 0;
     */
    ACTION_REASON_NONE = 0,
    /**
     * @generated from protobuf enum value: ACTION_REASON_QUEST_ITEM = 1;
     */
    ACTION_REASON_QUEST_ITEM = 1,
    /**
     * @generated from protobuf enum value: ACTION_REASON_QUEST_REWARD = 2;
     */
    ACTION_REASON_QUEST_REWARD = 2,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TRIFLE = 3;
     */
    ACTION_REASON_TRIFLE = 3,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SHOP = 4;
     */
    ACTION_REASON_SHOP = 4,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLAYER_UPGRADE_REWARD = 5;
     */
    ACTION_REASON_PLAYER_UPGRADE_REWARD = 5,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ADD_AVATAR = 6;
     */
    ACTION_REASON_ADD_AVATAR = 6,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GADGET_ENV_ANIMAL = 7;
     */
    ACTION_REASON_GADGET_ENV_ANIMAL = 7,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MONSTER_ENV_ANIMAL = 8;
     */
    ACTION_REASON_MONSTER_ENV_ANIMAL = 8,
    /**
     * @generated from protobuf enum value: ACTION_REASON_COMPOUND = 9;
     */
    ACTION_REASON_COMPOUND = 9,
    /**
     * @generated from protobuf enum value: ACTION_REASON_COOK = 10;
     */
    ACTION_REASON_COOK = 10,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GATHER = 11;
     */
    ACTION_REASON_GATHER = 11,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MAIL_ATTACHMENT = 12;
     */
    ACTION_REASON_MAIL_ATTACHMENT = 12,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_LEVELUP_RETURN = 15;
     */
    ACTION_REASON_CITY_LEVELUP_RETURN = 15,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_LEVELUP_REWARD = 17;
     */
    ACTION_REASON_CITY_LEVELUP_REWARD = 17,
    /**
     * @generated from protobuf enum value: ACTION_REASON_AREA_EXPLORE_REWARD = 18;
     */
    ACTION_REASON_AREA_EXPLORE_REWARD = 18,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UNLOCK_POINT_REWARD = 19;
     */
    ACTION_REASON_UNLOCK_POINT_REWARD = 19,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DUNGEON_FIRST_PASS = 20;
     */
    ACTION_REASON_DUNGEON_FIRST_PASS = 20,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DUNGEON_PASS = 21;
     */
    ACTION_REASON_DUNGEON_PASS = 21,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CHANGE_ELEM_TYPE = 23;
     */
    ACTION_REASON_CHANGE_ELEM_TYPE = 23,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FETTER_OPEN = 25;
     */
    ACTION_REASON_FETTER_OPEN = 25,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DAILY_TASK_SCORE = 26;
     */
    ACTION_REASON_DAILY_TASK_SCORE = 26,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DAILY_TASK_HOST = 27;
     */
    ACTION_REASON_DAILY_TASK_HOST = 27,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RAND_TASK_HOST = 28;
     */
    ACTION_REASON_RAND_TASK_HOST = 28,
    /**
     * @generated from protobuf enum value: ACTION_REASON_EXPEDITION = 29;
     */
    ACTION_REASON_EXPEDITION = 29,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GACHA = 30;
     */
    ACTION_REASON_GACHA = 30,
    /**
     * @generated from protobuf enum value: ACTION_REASON_COMBINE = 31;
     */
    ACTION_REASON_COMBINE = 31,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RAND_TASK_GUEST = 32;
     */
    ACTION_REASON_RAND_TASK_GUEST = 32,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DAILY_TASK_GUEST = 33;
     */
    ACTION_REASON_DAILY_TASK_GUEST = 33,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FORGE_OUTPUT = 34;
     */
    ACTION_REASON_FORGE_OUTPUT = 34,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FORGE_RETURN = 35;
     */
    ACTION_REASON_FORGE_RETURN = 35,
    /**
     * @generated from protobuf enum value: ACTION_REASON_INIT_AVATAR = 36;
     */
    ACTION_REASON_INIT_AVATAR = 36,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MONSTER_DIE = 37;
     */
    ACTION_REASON_MONSTER_DIE = 37,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GM = 38;
     */
    ACTION_REASON_GM = 38,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OPEN_CHEST = 39;
     */
    ACTION_REASON_OPEN_CHEST = 39,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GADGET_DIE = 40;
     */
    ACTION_REASON_GADGET_DIE = 40,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MONSTER_CHANGE_HP = 41;
     */
    ACTION_REASON_MONSTER_CHANGE_HP = 41,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUBFIELD_DROP = 42;
     */
    ACTION_REASON_SUBFIELD_DROP = 42,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PUSH_TIPS_REWARD = 43;
     */
    ACTION_REASON_PUSH_TIPS_REWARD = 43,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_MONSTER_DROP = 44;
     */
    ACTION_REASON_ACTIVITY_MONSTER_DROP = 44,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_GATHER = 45;
     */
    ACTION_REASON_ACTIVITY_GATHER = 45,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_SUBFIELD_DROP = 46;
     */
    ACTION_REASON_ACTIVITY_SUBFIELD_DROP = 46,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_SCHEDULE_REWARD = 47;
     */
    ACTION_REASON_TOWER_SCHEDULE_REWARD = 47,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_FLOOR_STAR_REWARD = 48;
     */
    ACTION_REASON_TOWER_FLOOR_STAR_REWARD = 48,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_FIRST_PASS_REWARD = 49;
     */
    ACTION_REASON_TOWER_FIRST_PASS_REWARD = 49,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_DAILY_REWARD = 50;
     */
    ACTION_REASON_TOWER_DAILY_REWARD = 50,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HIT_CLIENT_TRIVIAL_ENTITY = 51;
     */
    ACTION_REASON_HIT_CLIENT_TRIVIAL_ENTITY = 51,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OPEN_WORLD_BOSS_CHEST = 52;
     */
    ACTION_REASON_OPEN_WORLD_BOSS_CHEST = 52,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MATERIAL_DELETE_RETURN = 53;
     */
    ACTION_REASON_MATERIAL_DELETE_RETURN = 53,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SIGN_IN_REWARD = 54;
     */
    ACTION_REASON_SIGN_IN_REWARD = 54,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OPEN_BLOSSOM_CHEST = 55;
     */
    ACTION_REASON_OPEN_BLOSSOM_CHEST = 55,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE = 56;
     */
    ACTION_REASON_RECHARGE = 56,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BONUS_ACTIVITY_REWARD = 57;
     */
    ACTION_REASON_BONUS_ACTIVITY_REWARD = 57,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_COMMEMORATIVE_REWARD = 58;
     */
    ACTION_REASON_TOWER_COMMEMORATIVE_REWARD = 58,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TOWER_SKIP_FLOOR_REWARD = 59;
     */
    ACTION_REASON_TOWER_SKIP_FLOOR_REWARD = 59,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_BONUS = 60;
     */
    ACTION_REASON_RECHARGE_BONUS = 60,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CARD = 61;
     */
    ACTION_REASON_RECHARGE_CARD = 61,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CARD_DAILY = 62;
     */
    ACTION_REASON_RECHARGE_CARD_DAILY = 62,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CARD_REPLACE = 63;
     */
    ACTION_REASON_RECHARGE_CARD_REPLACE = 63,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CARD_REPLACE_FREE = 64;
     */
    ACTION_REASON_RECHARGE_CARD_REPLACE_FREE = 64,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_PLAY_REPLACE = 65;
     */
    ACTION_REASON_RECHARGE_PLAY_REPLACE = 65,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MP_PLAY_TAKE_REWARD = 66;
     */
    ACTION_REASON_MP_PLAY_TAKE_REWARD = 66,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_WATCHER = 67;
     */
    ACTION_REASON_ACTIVITY_WATCHER = 67,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SALESMAN_DELIVER_ITEM = 68;
     */
    ACTION_REASON_SALESMAN_DELIVER_ITEM = 68,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SALESMAN_REWARD = 69;
     */
    ACTION_REASON_SALESMAN_REWARD = 69,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REBATE = 70;
     */
    ACTION_REASON_REBATE = 70,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MCOIN_EXCHANGE_HCOIN = 71;
     */
    ACTION_REASON_MCOIN_EXCHANGE_HCOIN = 71,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DAILY_TASK_EXCHANGE_LEGENDARY_KEY = 72;
     */
    ACTION_REASON_DAILY_TASK_EXCHANGE_LEGENDARY_KEY = 72,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UNLOCK_PERSON_LINE = 73;
     */
    ACTION_REASON_UNLOCK_PERSON_LINE = 73,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FETTER_LEVEL_REWARD = 74;
     */
    ACTION_REASON_FETTER_LEVEL_REWARD = 74,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BUY_RESIN = 75;
     */
    ACTION_REASON_BUY_RESIN = 75,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_PACKAGE = 76;
     */
    ACTION_REASON_RECHARGE_PACKAGE = 76,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DELIVERY_DAILY_REWARD = 77;
     */
    ACTION_REASON_DELIVERY_DAILY_REWARD = 77,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_REPUTATION_LEVEL = 78;
     */
    ACTION_REASON_CITY_REPUTATION_LEVEL = 78,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_REPUTATION_QUEST = 79;
     */
    ACTION_REASON_CITY_REPUTATION_QUEST = 79,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_REPUTATION_REQUEST = 80;
     */
    ACTION_REASON_CITY_REPUTATION_REQUEST = 80,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_REPUTATION_EXPLORE = 81;
     */
    ACTION_REASON_CITY_REPUTATION_EXPLORE = 81,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OFFERGING_LEVEL = 82;
     */
    ACTION_REASON_OFFERGING_LEVEL = 82,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROUTINE_HOST = 83;
     */
    ACTION_REASON_ROUTINE_HOST = 83,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROUTINE_GUEST = 84;
     */
    ACTION_REASON_ROUTINE_GUEST = 84,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TREASURE_MAP_SPOT_TOKEN = 89;
     */
    ACTION_REASON_TREASURE_MAP_SPOT_TOKEN = 89,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TREASURE_MAP_BONUS_LEVEL_REWARD = 90;
     */
    ACTION_REASON_TREASURE_MAP_BONUS_LEVEL_REWARD = 90,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TREASURE_MAP_MP_REWARD = 91;
     */
    ACTION_REASON_TREASURE_MAP_MP_REWARD = 91,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CONVERT = 92;
     */
    ACTION_REASON_CONVERT = 92,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OVERFLOW_TRANSFORM = 93;
     */
    ACTION_REASON_OVERFLOW_TRANSFORM = 93,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_AVATAR_SELECTION_REWARD = 96;
     */
    ACTION_REASON_ACTIVITY_AVATAR_SELECTION_REWARD = 96,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_WATCHER_BATCH = 97;
     */
    ACTION_REASON_ACTIVITY_WATCHER_BATCH = 97,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HIT_TREE_DROP = 98;
     */
    ACTION_REASON_HIT_TREE_DROP = 98,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GET_HOME_LEVELUP_REWARD = 99;
     */
    ACTION_REASON_GET_HOME_LEVELUP_REWARD = 99,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_DEFAULT_FURNITURE = 100;
     */
    ACTION_REASON_HOME_DEFAULT_FURNITURE = 100,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_COND = 101;
     */
    ACTION_REASON_ACTIVITY_COND = 101,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BATTLE_PASS_NOTIFY = 102;
     */
    ACTION_REASON_BATTLE_PASS_NOTIFY = 102,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RELIQUARY_DECOMPOSE = 103;
     */
    ACTION_REASON_RELIQUARY_DECOMPOSE = 103,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_GOOGLE_GIFT_GARD = 104;
     */
    ACTION_REASON_RECHARGE_GOOGLE_GIFT_GARD = 104,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CONCERT_PRODUCT = 105;
     */
    ACTION_REASON_RECHARGE_CONCERT_PRODUCT = 105,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_CONCERT_PRODUCT_REPLACE = 106;
     */
    ACTION_REASON_RECHARGE_CONCERT_PRODUCT_REPLACE = 106,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SEND_CONCERT_PRODUCT_BY_MUIP = 107;
     */
    ACTION_REASON_SEND_CONCERT_PRODUCT_BY_MUIP = 107,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RECHARGE_APPLE_GIFT_GARD = 108;
     */
    ACTION_REASON_RECHARGE_APPLE_GIFT_GARD = 108,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLAYER_USE_ITEM = 1001;
     */
    ACTION_REASON_PLAYER_USE_ITEM = 1001,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DROP_ITEM = 1002;
     */
    ACTION_REASON_DROP_ITEM = 1002,
    /**
     * @generated from protobuf enum value: ACTION_REASON_WEAPON_UPGRADE = 1011;
     */
    ACTION_REASON_WEAPON_UPGRADE = 1011,
    /**
     * @generated from protobuf enum value: ACTION_REASON_WEAPON_PROMOTE = 1012;
     */
    ACTION_REASON_WEAPON_PROMOTE = 1012,
    /**
     * @generated from protobuf enum value: ACTION_REASON_WEAPON_AWAKEN = 1013;
     */
    ACTION_REASON_WEAPON_AWAKEN = 1013,
    /**
     * @generated from protobuf enum value: ACTION_REASON_RELIC_UPGRADE = 1014;
     */
    ACTION_REASON_RELIC_UPGRADE = 1014,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ABILITY = 1015;
     */
    ACTION_REASON_ABILITY = 1015,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DUNGEON_STATUE_DROP = 1016;
     */
    ACTION_REASON_DUNGEON_STATUE_DROP = 1016,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OFFLINE_MSG = 1017;
     */
    ACTION_REASON_OFFLINE_MSG = 1017,
    /**
     * @generated from protobuf enum value: ACTION_REASON_AVATAR_UPGRADE = 1018;
     */
    ACTION_REASON_AVATAR_UPGRADE = 1018,
    /**
     * @generated from protobuf enum value: ACTION_REASON_AVATAR_PROMOTE = 1019;
     */
    ACTION_REASON_AVATAR_PROMOTE = 1019,
    /**
     * @generated from protobuf enum value: ACTION_REASON_QUEST_ACTION = 1021;
     */
    ACTION_REASON_QUEST_ACTION = 1021,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CITY_LEVELUP = 1022;
     */
    ACTION_REASON_CITY_LEVELUP = 1022,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UPGRADE_SKILL = 1024;
     */
    ACTION_REASON_UPGRADE_SKILL = 1024,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UNLOCK_TALENT = 1025;
     */
    ACTION_REASON_UNLOCK_TALENT = 1025,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UPGRADE_PROUD_SKILL = 1026;
     */
    ACTION_REASON_UPGRADE_PROUD_SKILL = 1026,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLAYER_LEVEL_LIMIT_UP = 1027;
     */
    ACTION_REASON_PLAYER_LEVEL_LIMIT_UP = 1027,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DUNGEON_DAILY = 1028;
     */
    ACTION_REASON_DUNGEON_DAILY = 1028,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ITEM_GIVING = 1030;
     */
    ACTION_REASON_ITEM_GIVING = 1030,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FORGE_COST = 1031;
     */
    ACTION_REASON_FORGE_COST = 1031,
    /**
     * @generated from protobuf enum value: ACTION_REASON_INVESTIGATION_REWARD = 1032;
     */
    ACTION_REASON_INVESTIGATION_REWARD = 1032,
    /**
     * @generated from protobuf enum value: ACTION_REASON_INVESTIGATION_TARGET_REWARD = 1033;
     */
    ACTION_REASON_INVESTIGATION_TARGET_REWARD = 1033,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GADGET_INTERACT = 1034;
     */
    ACTION_REASON_GADGET_INTERACT = 1034,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SEA_LAMP_CI_MATERIAL = 1036;
     */
    ACTION_REASON_SEA_LAMP_CI_MATERIAL = 1036,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SEA_LAMP_CONTRIBUTION_REWARD = 1037;
     */
    ACTION_REASON_SEA_LAMP_CONTRIBUTION_REWARD = 1037,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SEA_LAMP_PHASE_REWARD = 1038;
     */
    ACTION_REASON_SEA_LAMP_PHASE_REWARD = 1038,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SEA_LAMP_FLY_LAMP = 1039;
     */
    ACTION_REASON_SEA_LAMP_FLY_LAMP = 1039,
    /**
     * @generated from protobuf enum value: ACTION_REASON_AUTO_RECOVER = 1040;
     */
    ACTION_REASON_AUTO_RECOVER = 1040,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_EXPIRE_ITEM = 1041;
     */
    ACTION_REASON_ACTIVITY_EXPIRE_ITEM = 1041,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUB_COIN_NEGATIVE = 1042;
     */
    ACTION_REASON_SUB_COIN_NEGATIVE = 1042,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BARGAIN_DEDUCT = 1043;
     */
    ACTION_REASON_BARGAIN_DEDUCT = 1043,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BATTLE_PASS_PAID_REWARD = 1044;
     */
    ACTION_REASON_BATTLE_PASS_PAID_REWARD = 1044,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BATTLE_PASS_LEVEL_REWARD = 1045;
     */
    ACTION_REASON_BATTLE_PASS_LEVEL_REWARD = 1045,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TRIAL_AVATAR_ACTIVITY_FIRST_PASS_REWARD = 1046;
     */
    ACTION_REASON_TRIAL_AVATAR_ACTIVITY_FIRST_PASS_REWARD = 1046,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BUY_BATTLE_PASS_LEVEL = 1047;
     */
    ACTION_REASON_BUY_BATTLE_PASS_LEVEL = 1047,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GRANT_BIRTHDAY_BENEFIT = 1048;
     */
    ACTION_REASON_GRANT_BIRTHDAY_BENEFIT = 1048,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACHIEVEMENT_REWARD = 1049;
     */
    ACTION_REASON_ACHIEVEMENT_REWARD = 1049,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACHIEVEMENT_GOAL_REWARD = 1050;
     */
    ACTION_REASON_ACHIEVEMENT_GOAL_REWARD = 1050,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FIRST_SHARE_TO_SOCIAL_NETWORK = 1051;
     */
    ACTION_REASON_FIRST_SHARE_TO_SOCIAL_NETWORK = 1051,
    /**
     * @generated from protobuf enum value: ACTION_REASON_DESTROY_MATERIAL = 1052;
     */
    ACTION_REASON_DESTROY_MATERIAL = 1052,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CODEX_LEVELUP_REWARD = 1053;
     */
    ACTION_REASON_CODEX_LEVELUP_REWARD = 1053,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HUNTING_OFFER_REWARD = 1054;
     */
    ACTION_REASON_HUNTING_OFFER_REWARD = 1054,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_ANCHOR_POINT = 1055;
     */
    ACTION_REASON_USE_WIDGET_ANCHOR_POINT = 1055,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_BONFIRE = 1056;
     */
    ACTION_REASON_USE_WIDGET_BONFIRE = 1056,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL = 1057;
     */
    ACTION_REASON_UNGRADE_WEAPON_RETURN_MATERIAL = 1057,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_ONEOFF_GATHER_POINT_DETECTOR = 1058;
     */
    ACTION_REASON_USE_WIDGET_ONEOFF_GATHER_POINT_DETECTOR = 1058,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_CLIENT_COLLECTOR = 1059;
     */
    ACTION_REASON_USE_WIDGET_CLIENT_COLLECTOR = 1059,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_CLIENT_DETECTOR = 1060;
     */
    ACTION_REASON_USE_WIDGET_CLIENT_DETECTOR = 1060,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TAKE_GENERAL_REWARD = 1061;
     */
    ACTION_REASON_TAKE_GENERAL_REWARD = 1061,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ASTER_TAKE_SPECIAL_REWARD = 1062;
     */
    ACTION_REASON_ASTER_TAKE_SPECIAL_REWARD = 1062,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REMOVE_CODEX_BOOK = 1063;
     */
    ACTION_REASON_REMOVE_CODEX_BOOK = 1063,
    /**
     * @generated from protobuf enum value: ACTION_REASON_OFFERING_ITEM = 1064;
     */
    ACTION_REASON_OFFERING_ITEM = 1064,
    /**
     * @generated from protobuf enum value: ACTION_REASON_USE_WIDGET_GADGET_BUILDER = 1065;
     */
    ACTION_REASON_USE_WIDGET_GADGET_BUILDER = 1065,
    /**
     * @generated from protobuf enum value: ACTION_REASON_EFFIGY_FIRST_PASS_REWARD = 1066;
     */
    ACTION_REASON_EFFIGY_FIRST_PASS_REWARD = 1066,
    /**
     * @generated from protobuf enum value: ACTION_REASON_EFFIGY_REWARD = 1067;
     */
    ACTION_REASON_EFFIGY_REWARD = 1067,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REUNION_FIRST_GIFT_REWARD = 1068;
     */
    ACTION_REASON_REUNION_FIRST_GIFT_REWARD = 1068,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REUNION_SIGN_IN_REWARD = 1069;
     */
    ACTION_REASON_REUNION_SIGN_IN_REWARD = 1069,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REUNION_WATCHER_REWARD = 1070;
     */
    ACTION_REASON_REUNION_WATCHER_REWARD = 1070,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SALESMAN_MP_REWARD = 1071;
     */
    ACTION_REASON_SALESMAN_MP_REWARD = 1071,
    /**
     * @generated from protobuf enum value: ACTION_REASION_AVATAR_PROMOTE_REWARD = 1072;
     */
    ACTION_REASION_AVATAR_PROMOTE_REWARD = 1072,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BLESSING_REDEEM_REWARD = 1073;
     */
    ACTION_REASON_BLESSING_REDEEM_REWARD = 1073,
    /**
     * @generated from protobuf enum value: ACTION_MIRACLE_RING_REWARD = 1074;
     */
    ACTION_MIRACLE_RING_REWARD = 1074,
    /**
     * @generated from protobuf enum value: ACTION_REASON_EXPEDITION_REWARD = 1075;
     */
    ACTION_REASON_EXPEDITION_REWARD = 1075,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TREASURE_MAP_REMOVE_DETECTOR = 1076;
     */
    ACTION_REASON_TREASURE_MAP_REMOVE_DETECTOR = 1076,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MECHANICUS_DUNGEON_TICKET = 1077;
     */
    ACTION_REASON_MECHANICUS_DUNGEON_TICKET = 1077,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MECHANICUS_LEVELUP_GEAR = 1078;
     */
    ACTION_REASON_MECHANICUS_LEVELUP_GEAR = 1078,
    /**
     * @generated from protobuf enum value: ACTION_REASON_MECHANICUS_BATTLE_SETTLE = 1079;
     */
    ACTION_REASON_MECHANICUS_BATTLE_SETTLE = 1079,
    /**
     * @generated from protobuf enum value: ACTION_REASON_REGION_SEARCH_REWARD = 1080;
     */
    ACTION_REASON_REGION_SEARCH_REWARD = 1080,
    /**
     * @generated from protobuf enum value: ACTION_REASON_UNLOCK_COOP_CHAPTER = 1081;
     */
    ACTION_REASON_UNLOCK_COOP_CHAPTER = 1081,
    /**
     * @generated from protobuf enum value: ACTION_REASON_TAKE_COOP_REWARD = 1082;
     */
    ACTION_REASON_TAKE_COOP_REWARD = 1082,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FLEUR_FAIR_DUNGEON_REWARD = 1083;
     */
    ACTION_REASON_FLEUR_FAIR_DUNGEON_REWARD = 1083,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ACTIVITY_SCORE = 1084;
     */
    ACTION_REASON_ACTIVITY_SCORE = 1084,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CHANNELLER_SLAB_ONEOFF_DUNGEON_REWARD = 1085;
     */
    ACTION_REASON_CHANNELLER_SLAB_ONEOFF_DUNGEON_REWARD = 1085,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FURNITURE_MAKE_START = 1086;
     */
    ACTION_REASON_FURNITURE_MAKE_START = 1086,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FURNITURE_MAKE_TAKE = 1087;
     */
    ACTION_REASON_FURNITURE_MAKE_TAKE = 1087,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FURNITURE_MAKE_CANCEL = 1088;
     */
    ACTION_REASON_FURNITURE_MAKE_CANCEL = 1088,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FURNITURE_MAKE_FAST_FINISH = 1089;
     */
    ACTION_REASON_FURNITURE_MAKE_FAST_FINISH = 1089,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD = 1090;
     */
    ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD = 1090,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD = 1091;
     */
    ACTION_REASON_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD = 1091,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_LIMITED_SHOP_BUY = 1092;
     */
    ACTION_REASON_HOME_LIMITED_SHOP_BUY = 1092,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_COIN_COLLECT = 1093;
     */
    ACTION_REASON_HOME_COIN_COLLECT = 1093,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUMMER_TIME_SENTRY_TOWER_REWARD = 1094;
     */
    ACTION_REASON_SUMMER_TIME_SENTRY_TOWER_REWARD = 1094,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUMMER_TIME_SPRINT_BOAT_REWARD = 1095;
     */
    ACTION_REASON_SUMMER_TIME_SPRINT_BOAT_REWARD = 1095,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUMMER_TIME_BOSS_REWARD = 1096;
     */
    ACTION_REASON_SUMMER_TIME_BOSS_REWARD = 1096,
    /**
     * @generated from protobuf enum value: ACTION_REASON_SUMMER_TIME_BOMB_REWARD = 1097;
     */
    ACTION_REASON_SUMMER_TIME_BOMB_REWARD = 1097,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_FETTER_COLLECT = 1098;
     */
    ACTION_REASON_HOME_FETTER_COLLECT = 1098,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ECHO_SHELL_REWARD = 1099;
     */
    ACTION_REASON_ECHO_SHELL_REWARD = 1099,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_EVENT_REWARD = 1100;
     */
    ACTION_REASON_HOME_EVENT_REWARD = 1100,
    /**
     * @generated from protobuf enum value: ACTION_REASON_BLITZ_RUSH_DUNGEON_REWARD = 1101;
     */
    ACTION_REASON_BLITZ_RUSH_DUNGEON_REWARD = 1101,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FURNITURE_MAKE_RETURN = 1102;
     */
    ACTION_REASON_FURNITURE_MAKE_RETURN = 1102,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_PLANT_BOX_GATHER = 1103;
     */
    ACTION_REASON_HOME_PLANT_BOX_GATHER = 1103,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_PLANT_SEED = 1104;
     */
    ACTION_REASON_HOME_PLANT_SEED = 1104,
    /**
     * @generated from protobuf enum value: ACTION_REASON_HOME_PLANT_GATHER = 1105;
     */
    ACTION_REASON_HOME_PLANT_GATHER = 1105,
    /**
     * @generated from protobuf enum value: ACTION_REASON_CHESS_DUNGEON_REWARD = 1106;
     */
    ACTION_REASON_CHESS_DUNGEON_REWARD = 1106,
    /**
     * @generated from protobuf enum value: ACTION_REASON_GROUP_LINK_BUNDLE_FINISH = 1107;
     */
    ACTION_REASON_GROUP_LINK_BUNDLE_FINISH = 1107,
    /**
     * @generated from protobuf enum value: ACTION_REASON_LUNA_RITE_SACRIFICE = 1108;
     */
    ACTION_REASON_LUNA_RITE_SACRIFICE = 1108,
    /**
     * @generated from protobuf enum value: ACTION_REASON_LUNA_RITE_TAKE_SACRIFICE_REWARD = 1109;
     */
    ACTION_REASON_LUNA_RITE_TAKE_SACRIFICE_REWARD = 1109,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FISH_BITE = 1110;
     */
    ACTION_REASON_FISH_BITE = 1110,
    /**
     * @generated from protobuf enum value: ACTION_REASON_FISH_SUCC = 1111;
     */
    ACTION_REASON_FISH_SUCC = 1111,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLANT_FLOWER_REWARD = 1112;
     */
    ACTION_REASON_PLANT_FLOWER_REWARD = 1112,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLANT_FLOWER_DELIVER_ITEM = 1113;
     */
    ACTION_REASON_PLANT_FLOWER_DELIVER_ITEM = 1113,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLANT_FLOWER_GIVE_FLOWER = 1114;
     */
    ACTION_REASON_PLANT_FLOWER_GIVE_FLOWER = 1114,
    /**
     * @generated from protobuf enum value: ACTION_REASON_PLANT_FLOWER_RECV_FLOWER = 1115;
     */
    ACTION_REASON_PLANT_FLOWER_RECV_FLOWER = 1115,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROGUE_CHALLENGE_SETTLE = 1116;
     */
    ACTION_REASON_ROGUE_CHALLENGE_SETTLE = 1116,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROGUE_TAKE_FIRST_PASS_REWARD = 1117;
     */
    ACTION_REASON_ROGUE_TAKE_FIRST_PASS_REWARD = 1117,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROGUE_UPGRADE_SHIKIGAMI = 1118;
     */
    ACTION_REASON_ROGUE_UPGRADE_SHIKIGAMI = 1118,
    /**
     * @generated from protobuf enum value: ACTION_REASON_ROGUE_REFRESH_CARD = 1119;
     */
    ACTION_REASON_ROGUE_REFRESH_CARD = 1119
}
/**
 * @generated from protobuf enum AvatarExpeditionState
 */
export enum AvatarExpeditionState {
    /**
     * @generated from protobuf enum value: AVATAR_EXPEDITION_STATE_ = 0;
     */
    AVATAR_EXPEDITION_STATE_ = 0,
    /**
     * @generated from protobuf enum value: AVATAR_EXPEDITION_STATE_DOING = 1;
     */
    AVATAR_EXPEDITION_STATE_DOING = 1,
    /**
     * @generated from protobuf enum value: AVATAR_EXPEDITION_STATE_FINISH_WAIT_REWARD = 2;
     */
    AVATAR_EXPEDITION_STATE_FINISH_WAIT_REWARD = 2,
    /**
     * @generated from protobuf enum value: AVATAR_EXPEDITION_STATE_CALLBACK_WAIT_REWARD = 3;
     */
    AVATAR_EXPEDITION_STATE_CALLBACK_WAIT_REWARD = 3,
    /**
     * @generated from protobuf enum value: AVATAR_EXPEDITION_STATE_LOCKED = 4;
     */
    AVATAR_EXPEDITION_STATE_LOCKED = 4
}
/**
 * @generated from protobuf enum BattlePassUnlockStatus
 */
export enum BattlePassUnlockStatus {
    /**
     * @generated from protobuf enum value: BATTLE_PASS_UNLOCK_STATUS_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: BATTLE_PASS_UNLOCK_STATUS_FREE = 1;
     */
    FREE = 1,
    /**
     * @generated from protobuf enum value: BATTLE_PASS_UNLOCK_STATUS_PAID = 2;
     */
    PAID = 2
}
/**
 * @generated from protobuf enum CBJEDMGOBPL
 */
export enum CBJEDMGOBPL {
    /**
     * @generated from protobuf enum value: CBJEDMGOBPL_MBLDLJOKLBL = 0;
     */
    CBJEDMGOBPL_MBLDLJOKLBL = 0,
    /**
     * @generated from protobuf enum value: CBJEDMGOBPL_ILOMIKADKGD = 1;
     */
    CBJEDMGOBPL_ILOMIKADKGD = 1,
    /**
     * @generated from protobuf enum value: CBJEDMGOBPL_HGHOEJGHMDH = 2;
     */
    CBJEDMGOBPL_HGHOEJGHMDH = 2,
    /**
     * @generated from protobuf enum value: CBJEDMGOBPL_PJCONIDJGOD = 3;
     */
    CBJEDMGOBPL_PJCONIDJGOD = 3
}
/**
 * @generated from protobuf enum ChangeEnergyReason
 */
export enum ChangeEnergyReason {
    /**
     * @generated from protobuf enum value: CHANGE_ENERGY_REASON_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CHANGE_ENERGY_REASON_SKILL_START = 1;
     */
    SKILL_START = 1
}
/**
 * @generated from protobuf enum ChangeHpReason
 */
export enum ChangeHpReason {
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_NONE = 0;
     */
    CHANGE_HP_NONE = 0,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_AVATAR = 1;
     */
    CHANGE_HP_SUB_AVATAR = 1,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_MONSTER = 2;
     */
    CHANGE_HP_SUB_MONSTER = 2,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_GEAR = 3;
     */
    CHANGE_HP_SUB_GEAR = 3,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_ENVIR = 4;
     */
    CHANGE_HP_SUB_ENVIR = 4,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_FALL = 5;
     */
    CHANGE_HP_SUB_FALL = 5,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_DRAWN = 6;
     */
    CHANGE_HP_SUB_DRAWN = 6,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_ABYSS = 7;
     */
    CHANGE_HP_SUB_ABYSS = 7,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_ABILITY = 8;
     */
    CHANGE_HP_SUB_ABILITY = 8,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_SUMMON = 9;
     */
    CHANGE_HP_SUB_SUMMON = 9,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_SCRIPT = 10;
     */
    CHANGE_HP_SUB_SCRIPT = 10,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_GM = 11;
     */
    CHANGE_HP_SUB_GM = 11,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_KILL_SELF = 12;
     */
    CHANGE_HP_SUB_KILL_SELF = 12,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_CLIMATE_COLD = 13;
     */
    CHANGE_HP_SUB_CLIMATE_COLD = 13,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_STORM_LIGHTNING = 14;
     */
    CHANGE_HP_SUB_STORM_LIGHTNING = 14,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_KILL_SERVER_GADGET = 15;
     */
    CHANGE_HP_SUB_KILL_SERVER_GADGET = 15,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_REPLACE = 16;
     */
    CHANGE_HP_SUB_REPLACE = 16,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_SUB_PLAYER_LEAVE = 17;
     */
    CHANGE_HP_SUB_PLAYER_LEAVE = 17,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CIKCDBOJGDK = 18;
     */
    CIKCDBOJGDK = 18,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_HEKLBLFBJJK = 19;
     */
    HEKLBLFBJJK = 19,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_BY_LUA = 51;
     */
    CHANGE_HP_BY_LUA = 51,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_ABILITY = 101;
     */
    CHANGE_HP_ADD_ABILITY = 101,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_ITEM = 102;
     */
    CHANGE_HP_ADD_ITEM = 102,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_REVIVE = 103;
     */
    CHANGE_HP_ADD_REVIVE = 103,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_UPGRADE = 104;
     */
    CHANGE_HP_ADD_UPGRADE = 104,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_STATUE = 105;
     */
    CHANGE_HP_ADD_STATUE = 105,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_BACKGROUND = 106;
     */
    CHANGE_HP_ADD_BACKGROUND = 106,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_GM = 107;
     */
    CHANGE_HP_ADD_GM = 107,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_TRIAL_AVATAR_ACTIVITY = 108;
     */
    CHANGE_HP_ADD_TRIAL_AVATAR_ACTIVITY = 108,
    /**
     * @generated from protobuf enum value: CHANGE_HP_REASON_CHANGE_HP_ADD_ROUGUELIKE_SPRING = 109;
     */
    CHANGE_HP_ADD_ROUGUELIKE_SPRING = 109
}
/**
 * @generated from protobuf enum ChapterState
 */
export enum ChapterState {
    /**
     * @generated from protobuf enum value: CHAPTER_STATE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CHAPTER_STATE_UNABLE_TO_BEGIN = 1;
     */
    UNABLE_TO_BEGIN = 1,
    /**
     * @generated from protobuf enum value: CHAPTER_STATE_BEGIN = 2;
     */
    BEGIN = 2,
    /**
     * @generated from protobuf enum value: CHAPTER_STATE_END = 3;
     */
    END = 3
}
/**
 * @generated from protobuf enum CodexType
 */
export enum CodexType {
    /**
     * @generated from protobuf enum value: CODEX_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_QUEST = 1;
     */
    QUEST = 1,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_WEAPON = 2;
     */
    WEAPON = 2,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_ANIMAL = 3;
     */
    ANIMAL = 3,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_MATERIAL = 4;
     */
    MATERIAL = 4,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_BOOKS = 5;
     */
    BOOKS = 5,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_PUSHTIPS = 6;
     */
    PUSHTIPS = 6,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_VIEW = 7;
     */
    VIEW = 7,
    /**
     * @generated from protobuf enum value: CODEX_TYPE_RELIQUARY = 8;
     */
    RELIQUARY = 8
}
/**
 * @generated from protobuf enum CombatTypeArgument
 */
export enum CombatTypeArgument {
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_EVT_BEING_HIT = 1;
     */
    EVT_BEING_HIT = 1,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_ANIMATOR_STATE_CHANGED = 2;
     */
    ANIMATOR_STATE_CHANGED = 2,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_FACE_TO_DIR = 3;
     */
    FACE_TO_DIR = 3,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_SET_ATTACK_TARGET = 4;
     */
    SET_ATTACK_TARGET = 4,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_RUSH_MOVE = 5;
     */
    RUSH_MOVE = 5,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_ANIMATOR_PARAMETER_CHANGED = 6;
     */
    ANIMATOR_PARAMETER_CHANGED = 6,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_ENTITY_MOVE = 7;
     */
    ENTITY_MOVE = 7,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_SYNC_ENTITY_POSITION = 8;
     */
    SYNC_ENTITY_POSITION = 8,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_STEER_MOTION_INFO = 9;
     */
    STEER_MOTION_INFO = 9,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_FORCE_SET_POS_INFO = 10;
     */
    FORCE_SET_POS_INFO = 10,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_COMPENSATE_POS_DIFF = 11;
     */
    COMPENSATE_POS_DIFF = 11,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_MONSTER_DO_BLINK = 12;
     */
    MONSTER_DO_BLINK = 12,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_FIXED_RUSH_MOVE = 13;
     */
    FIXED_RUSH_MOVE = 13,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_SYNC_TRANSFORM = 14;
     */
    SYNC_TRANSFORM = 14,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_LIGHT_CORE_MOVE = 15;
     */
    LIGHT_CORE_MOVE = 15,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_KPDNFKCMKPG = 16;
     */
    KPDNFKCMKPG = 16,
    /**
     * @generated from protobuf enum value: COMBAT_TYPE_ARGUMENT_KPLOMOIALGF = 17;
     */
    KPLOMOIALGF = 17
}
/**
 * @generated from protobuf enum CoopChapterState
 */
export enum CoopChapterState {
    /**
     * @generated from protobuf enum value: Close = 0;
     */
    Close = 0,
    /**
     * @generated from protobuf enum value: CondNotMeet = 1;
     */
    CondNotMeet = 1,
    /**
     * @generated from protobuf enum value: CondMeet = 2;
     */
    CondMeet = 2,
    /**
     * @generated from protobuf enum value: Accept = 3;
     */
    Accept = 3
}
/**
 * @generated from protobuf enum CoopPointState
 */
export enum CoopPointState {
    /**
     * @generated from protobuf enum value: Unstarted = 0;
     */
    Unstarted = 0,
    /**
     * @generated from protobuf enum value: Started = 1;
     */
    Started = 1,
    /**
     * @generated from protobuf enum value: Finished = 2;
     */
    Finished = 2
}
/**
 * @generated from protobuf enum CoopRewardState
 */
export enum CoopRewardState {
    /**
     * @generated from protobuf enum value: Unlock = 0;
     */
    Unlock = 0,
    /**
     * @generated from protobuf enum value: Lock = 1;
     */
    Lock = 1,
    /**
     * @generated from protobuf enum value: Taken = 2;
     */
    Taken = 2
}
/**
 * @generated from protobuf enum DealAddFriendResultType
 */
export enum DealAddFriendResultType {
    /**
     * @generated from protobuf enum value: DEAL_ADD_FRIEND_RESULT_TYPE_REJECT = 0;
     */
    REJECT = 0,
    /**
     * @generated from protobuf enum value: DEAL_ADD_FRIEND_RESULT_TYPE_ACCEPT = 1;
     */
    ACCEPT = 1
}
/**
 * @generated from protobuf enum EnterType
 */
export enum EnterType {
    /**
     * @generated from protobuf enum value: ENTER_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_SELF = 1;
     */
    SELF = 1,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_GOTO = 2;
     */
    GOTO = 2,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_JUMP = 3;
     */
    JUMP = 3,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_OTHER = 4;
     */
    OTHER = 4,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_BACK = 5;
     */
    BACK = 5,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_DUNGEON = 6;
     */
    DUNGEON = 6,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_DUNGEON_REPLAY = 7;
     */
    DUNGEON_REPLAY = 7,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_GOTO_BY_PORTAL = 8;
     */
    GOTO_BY_PORTAL = 8,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_SELF_HOME = 9;
     */
    SELF_HOME = 9,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_OTHER_HOME = 10;
     */
    OTHER_HOME = 10,
    /**
     * @generated from protobuf enum value: ENTER_TYPE_GOTO_RECREATE = 11;
     */
    GOTO_RECREATE = 11
}
/**
 * @generated from protobuf enum FireWorkType
 */
export enum FireWorkType {
    /**
     * @generated from protobuf enum value: FireWorkType_ODJKANKMPPJ = 0;
     */
    FireWorkType_ODJKANKMPPJ = 0,
    /**
     * @generated from protobuf enum value: FireWorkType_EFGLHEIODFN = 1;
     */
    FireWorkType_EFGLHEIODFN = 1,
    /**
     * @generated from protobuf enum value: FireWorkType_JPBBBCFGHAK = 2;
     */
    FireWorkType_JPBBBCFGHAK = 2,
    /**
     * @generated from protobuf enum value: FireWorkType_IDCMGHBHBFH = 3;
     */
    FireWorkType_IDCMGHBHBFH = 3,
    /**
     * @generated from protobuf enum value: FireWorkType_ODDBNNDFMBO = 4;
     */
    FireWorkType_ODDBNNDFMBO = 4,
    /**
     * @generated from protobuf enum value: FireWorkType_AGIDMOGJOBD = 5;
     */
    FireWorkType_AGIDMOGJOBD = 5
}
/**
 * @generated from protobuf enum ForgeQueueManipulateType
 */
export enum ForgeQueueManipulateType {
    /**
     * @generated from protobuf enum value: FORGE_QUEUE_MANIPULATE_TYPE_RECEIVE_OUTPUT = 0;
     */
    RECEIVE_OUTPUT = 0,
    /**
     * @generated from protobuf enum value: FORGE_QUEUE_MANIPULATE_TYPE_STOP_FORGE = 1;
     */
    STOP_FORGE = 1
}
/**
 * @generated from protobuf enum ForwardType
 */
export enum ForwardType {
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_LOCAL = 0;
     */
    LOCAL = 0,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_ALL = 1;
     */
    TO_ALL = 1,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_ALL_EXCEPT_CUR = 2;
     */
    TO_ALL_EXCEPT_CUR = 2,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_HOST = 3;
     */
    TO_HOST = 3,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_ALL_GUEST = 4;
     */
    TO_ALL_GUEST = 4,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_PEER = 5;
     */
    TO_PEER = 5,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_PEERS = 6;
     */
    TO_PEERS = 6,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_ONLY_SERVER = 7;
     */
    ONLY_SERVER = 7,
    /**
     * @generated from protobuf enum value: FORWARD_TYPE_TO_ALL_EXIST_EXCEPT_CUR = 8;
     */
    TO_ALL_EXIST_EXCEPT_CUR = 8
}
/**
 * @generated from protobuf enum FoundationStatus
 */
export enum FoundationStatus {
    /**
     * @generated from protobuf enum value: FOUNDATION_STATUS_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: FOUNDATION_STATUS_INIT = 1;
     */
    INIT = 1,
    /**
     * @generated from protobuf enum value: FOUNDATION_STATUS_BUILDING = 2;
     */
    BUILDING = 2,
    /**
     * @generated from protobuf enum value: FOUNDATION_STATUS_BUILT = 3;
     */
    BUILT = 3
}
/**
 * @generated from protobuf enum FriendEnterHomeOption
 */
export enum FriendEnterHomeOption {
    /**
     * @generated from protobuf enum value: FRIEND_ENTER_HOME_OPTION_NEED_CONFIRM = 0;
     */
    NEED_CONFIRM = 0,
    /**
     * @generated from protobuf enum value: FRIEND_ENTER_HOME_OPTION_REFUSE = 1;
     */
    REFUSE = 1,
    /**
     * @generated from protobuf enum value: FRIEND_ENTER_HOME_OPTION_DIRECT = 2;
     */
    DIRECT = 2
}
/**
 * @generated from protobuf enum FriendOnlineState
 */
export enum FriendOnlineState {
    /**
     * @generated from protobuf enum value: FRIEND_ONLINE_STATE_FREIEND_DISCONNECT = 0;
     */
    FREIEND_DISCONNECT = 0,
    /**
     * @generated from protobuf enum value: FRIEND_ONLINE_STATE_ONLINE = 1;
     */
    ONLINE = 1
}
/**
 * @generated from protobuf enum GadgetBornType
 */
export enum GadgetBornType {
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_IN_AIR = 1;
     */
    IN_AIR = 1,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_PLAYER = 2;
     */
    PLAYER = 2,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_MONSTER_HIT = 3;
     */
    MONSTER_HIT = 3,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_MONSTER_DIE = 4;
     */
    MONSTER_DIE = 4,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_GADGET = 5;
     */
    GADGET = 5,
    /**
     * @generated from protobuf enum value: GADGET_BORN_TYPE_GROUND = 6;
     */
    GROUND = 6
}
/**
 * @generated from protobuf enum HitColliderType
 */
export enum HitColliderType {
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_TYPE_INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_TYPE_HIT_BOX = 1;
     */
    HIT_BOX = 1,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_TYPE_WET_HIT_BOX = 2;
     */
    WET_HIT_BOX = 2,
    /**
     * @generated from protobuf enum value: HIT_COLLIDER_TYPE_HEAD_BOX = 3;
     */
    HEAD_BOX = 3
}
/**
 * @generated from protobuf enum InteractType
 */
export enum InteractType {
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_PICK_ITEM = 1;
     */
    PICK_ITEM = 1,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_GATHER = 2;
     */
    GATHER = 2,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_OPEN_CHEST = 3;
     */
    OPEN_CHEST = 3,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_OPEN_STATUE = 4;
     */
    OPEN_STATUE = 4,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_CONSUM = 5;
     */
    CONSUM = 5,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_MP_PLAY_REWARD = 6;
     */
    MP_PLAY_REWARD = 6,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_VIEW = 7;
     */
    VIEW = 7,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_GENERAL_REWARD = 8;
     */
    GENERAL_REWARD = 8,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_MIRACLE_RING = 9;
     */
    MIRACLE_RING = 9,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_FOUNDATION = 10;
     */
    FOUNDATION = 10,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_ECHO_SHELL = 11;
     */
    ECHO_SHELL = 11,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_HOME_GATHER = 12;
     */
    HOME_GATHER = 12,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_ENV_ANIMAL = 13;
     */
    ENV_ANIMAL = 13,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_QUEST_GADGET = 14;
     */
    QUEST_GADGET = 14,
    /**
     * @generated from protobuf enum value: INTERACT_TYPE_LIEIKFDFMGF = 15;
     */
    LIEIKFDFMGF = 15
}
/**
 * @generated from protobuf enum InterOpType
 */
export enum InterOpType {
    /**
     * @generated from protobuf enum value: INTER_OP_TYPE_FINISH = 0;
     */
    FINISH = 0,
    /**
     * @generated from protobuf enum value: INTER_OP_TYPE_START = 1;
     */
    START = 1
}
/**
 * @generated from protobuf enum LunchBoxSlotType
 */
export enum LunchBoxSlotType {
    /**
     * @generated from protobuf enum value: LUNCH_BOX_SLOT_NONE = 0;
     */
    LUNCH_BOX_SLOT_NONE = 0,
    /**
     * @generated from protobuf enum value: LUNCH_BOX_SLOT_REVIVE = 1;
     */
    LUNCH_BOX_SLOT_REVIVE = 1,
    /**
     * @generated from protobuf enum value: LUNCH_BOX_SLOT_HEAL = 2;
     */
    LUNCH_BOX_SLOT_HEAL = 2
}
/**
 * @generated from protobuf enum MapMarkFromType
 */
export enum MapMarkFromType {
    /**
     * @generated from protobuf enum value: MAP_MARK_FROM_TYPE_NOE = 0;
     */
    NOE = 0,
    /**
     * @generated from protobuf enum value: MAP_MARK_FROM_TYPE_MONSTER = 1;
     */
    MONSTER = 1,
    /**
     * @generated from protobuf enum value: MAP_MARK_FROM_TYPE_QUEST = 2;
     */
    QUEST = 2
}
/**
 * @generated from protobuf enum MapMarkPointType
 */
export enum MapMarkPointType {
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_NPC = 0;
     */
    NPC = 0,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_QUEST = 1;
     */
    QUEST = 1,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_SPECIAL = 2;
     */
    SPECIAL = 2,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_MINE = 3;
     */
    MINE = 3,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_COLLECTION = 4;
     */
    COLLECTION = 4,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_MONSTER = 5;
     */
    MONSTER = 5,
    /**
     * @generated from protobuf enum value: MAP_MARK_POINT_TYPE_FISH_POOL = 6;
     */
    FISH_POOL = 6
}
/**
 * @generated from protobuf enum MapMarkTipsType
 */
export enum MapMarkTipsType {
    /**
     * @generated from protobuf enum value: MAP_MARK_TIPS_TYPE_DUNGEON_ELEMENT_TRIAL = 0;
     */
    DUNGEON_ELEMENT_TRIAL = 0
}
/**
 * @generated from protobuf enum MarkNewType
 */
export enum MarkNewType {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: COMBINE = 1;
     */
    COMBINE = 1,
    /**
     * @generated from protobuf enum value: FORGE = 2;
     */
    FORGE = 2
}
/**
 * @generated from protobuf enum ModifierAction
 */
export enum ModifierAction {
    /**
     * @generated from protobuf enum value: ADDED = 0;
     */
    ADDED = 0,
    /**
     * @generated from protobuf enum value: REMOVED = 1;
     */
    REMOVED = 1
}
/**
 * @generated from protobuf enum MonsterBornType
 */
export enum MonsterBornType {
    /**
     * @generated from protobuf enum value: MONSTER_BORN_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: MONSTER_BORN_TYPE_DEFAULT = 1;
     */
    DEFAULT = 1,
    /**
     * @generated from protobuf enum value: MONSTER_BORN_TYPE_RANDOM = 2;
     */
    RANDOM = 2
}
/**
 * @generated from protobuf enum MotionState
 */
export enum MotionState {
    /**
     * @generated from protobuf enum value: MOTION_STATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: MOTION_STATE_RESET = 1;
     */
    RESET = 1,
    /**
     * @generated from protobuf enum value: MOTION_STATE_STANDBY = 2;
     */
    STANDBY = 2,
    /**
     * @generated from protobuf enum value: MOTION_STATE_STANDBY_MOVE = 3;
     */
    STANDBY_MOVE = 3,
    /**
     * @generated from protobuf enum value: MOTION_STATE_WALK = 4;
     */
    WALK = 4,
    /**
     * @generated from protobuf enum value: MOTION_STATE_RUN = 5;
     */
    RUN = 5,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DASH = 6;
     */
    DASH = 6,
    /**
     * @generated from protobuf enum value: MOTION_STATE_CLIMB = 7;
     */
    CLIMB = 7,
    /**
     * @generated from protobuf enum value: MOTION_STATE_CLIMB_JUMP = 8;
     */
    CLIMB_JUMP = 8,
    /**
     * @generated from protobuf enum value: MOTION_STATE_STANDBY_TO_CLIMB = 9;
     */
    STANDBY_TO_CLIMB = 9,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FIGHT = 10;
     */
    FIGHT = 10,
    /**
     * @generated from protobuf enum value: MOTION_STATE_JUMP = 11;
     */
    JUMP = 11,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DROP = 12;
     */
    DROP = 12,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FLY = 13;
     */
    FLY = 13,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SWIM_MOVE = 14;
     */
    SWIM_MOVE = 14,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SWIM_IDLE = 15;
     */
    SWIM_IDLE = 15,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SWIM_DASH = 16;
     */
    SWIM_DASH = 16,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SWIM_JUMP = 17;
     */
    SWIM_JUMP = 17,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SLIP = 18;
     */
    SLIP = 18,
    /**
     * @generated from protobuf enum value: MOTION_STATE_GO_UPSTAIRS = 19;
     */
    GO_UPSTAIRS = 19,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FALL_ON_GROUND = 20;
     */
    FALL_ON_GROUND = 20,
    /**
     * @generated from protobuf enum value: MOTION_STATE_JUMP_UP_WALL_FOR_STANDBY = 21;
     */
    JUMP_UP_WALL_FOR_STANDBY = 21,
    /**
     * @generated from protobuf enum value: MOTION_STATE_JUMP_OFF_WALL = 22;
     */
    JUMP_OFF_WALL = 22,
    /**
     * @generated from protobuf enum value: MOTION_STATE_POWERED_FLY = 23;
     */
    POWERED_FLY = 23,
    /**
     * @generated from protobuf enum value: MOTION_STATE_LADDER_IDLE = 24;
     */
    LADDER_IDLE = 24,
    /**
     * @generated from protobuf enum value: MOTION_STATE_LADDER_MOVE = 25;
     */
    LADDER_MOVE = 25,
    /**
     * @generated from protobuf enum value: MOTION_STATE_LADDER_SLIP = 26;
     */
    LADDER_SLIP = 26,
    /**
     * @generated from protobuf enum value: MOTION_STATE_STANDBY_TO_LADDER = 27;
     */
    STANDBY_TO_LADDER = 27,
    /**
     * @generated from protobuf enum value: MOTION_STATE_LADDER_TO_STANDBY = 28;
     */
    LADDER_TO_STANDBY = 28,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DANGER_STANDBY = 29;
     */
    DANGER_STANDBY = 29,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DANGER_STANDBY_MOVE = 30;
     */
    DANGER_STANDBY_MOVE = 30,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DANGER_WALK = 31;
     */
    DANGER_WALK = 31,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DANGER_RUN = 32;
     */
    DANGER_RUN = 32,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DANGER_DASH = 33;
     */
    DANGER_DASH = 33,
    /**
     * @generated from protobuf enum value: MOTION_STATE_CROUCH_IDLE = 34;
     */
    CROUCH_IDLE = 34,
    /**
     * @generated from protobuf enum value: MOTION_STATE_CROUCH_MOVE = 35;
     */
    CROUCH_MOVE = 35,
    /**
     * @generated from protobuf enum value: MOTION_STATE_CROUCH_ROLL = 36;
     */
    CROUCH_ROLL = 36,
    /**
     * @generated from protobuf enum value: MOTION_STATE_NOTIFY = 37;
     */
    NOTIFY = 37,
    /**
     * @generated from protobuf enum value: MOTION_STATE_LAND_SPEED = 38;
     */
    LAND_SPEED = 38,
    /**
     * @generated from protobuf enum value: MOTION_STATE_MOVE_FAIL_ACK = 39;
     */
    MOVE_FAIL_ACK = 39,
    /**
     * @generated from protobuf enum value: MOTION_STATE_WATERFALL = 40;
     */
    WATERFALL = 40,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DASH_BEFORE_SHAKE = 41;
     */
    DASH_BEFORE_SHAKE = 41,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SIT_IDLE = 42;
     */
    SIT_IDLE = 42,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FORCE_SET_POS = 43;
     */
    FORCE_SET_POS = 43,
    /**
     * @generated from protobuf enum value: MOTION_STATE_QUEST_FORCE_DRAG = 44;
     */
    QUEST_FORCE_DRAG = 44,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FOLLOW_ROUTE = 45;
     */
    FOLLOW_ROUTE = 45,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SKIFF_BOARDING = 46;
     */
    SKIFF_BOARDING = 46,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SKIFF_NORMAL = 47;
     */
    SKIFF_NORMAL = 47,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SKIFF_DASH = 48;
     */
    SKIFF_DASH = 48,
    /**
     * @generated from protobuf enum value: MOTION_STATE_SKIFF_POWERED_DASH = 49;
     */
    SKIFF_POWERED_DASH = 49,
    /**
     * @generated from protobuf enum value: MOTION_STATE_DESTROY_VEHICLE = 50;
     */
    DESTROY_VEHICLE = 50,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FLY_IDLE = 51;
     */
    FLY_IDLE = 51,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FLY_SLOW = 52;
     */
    FLY_SLOW = 52,
    /**
     * @generated from protobuf enum value: MOTION_STATE_FLY_FAST = 53;
     */
    FLY_FAST = 53,
    /**
     * @generated from protobuf enum value: MOTION_STATE_NUM = 54;
     */
    NUM = 54
}
/**
 * @generated from protobuf enum MovingPlatformType
 */
export enum MovingPlatformType {
    /**
     * @generated from protobuf enum value: MOVING_PLATFORM_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: MOVING_PLATFORM_TYPE_USE_CONFIG = 1;
     */
    USE_CONFIG = 1,
    /**
     * @generated from protobuf enum value: MOVING_PLATFORM_TYPE_ABILITY = 2;
     */
    ABILITY = 2,
    /**
     * @generated from protobuf enum value: MOVING_PLATFORM_TYPE_ROUTE = 3;
     */
    ROUTE = 3
}
/**
 * @generated from protobuf enum MpSettingType
 */
export enum MpSettingType {
    /**
     * @generated from protobuf enum value: MP_SETTING_TYPE_NO_ENTER = 0;
     */
    NO_ENTER = 0,
    /**
     * @generated from protobuf enum value: MP_SETTING_TYPE_ENTER_FREELY = 1;
     */
    ENTER_FREELY = 1,
    /**
     * @generated from protobuf enum value: MP_SETTING_TYPE_ENTER_AFTER_APPLY = 2;
     */
    ENTER_AFTER_APPLY = 2
}
/**
 * @generated from protobuf enum MusicGameGetBeatmapReqType
 */
export enum MusicGameGetBeatmapReqType {
    /**
     * @generated from protobuf enum value: MusicGameGetBeatmapReqType_u1 = 0;
     */
    MusicGameGetBeatmapReqType_u1 = 0,
    /**
     * edit_beatmap
     *
     * @generated from protobuf enum value: MusicGameGetBeatmapReqType_u2 = 1;
     */
    MusicGameGetBeatmapReqType_u2 = 1,
    /**
     * play_others
     *
     * @generated from protobuf enum value: MusicGameGetBeatmapReqType_u3 = 2;
     */
    MusicGameGetBeatmapReqType_u3 = 2,
    /**
     * try
     *
     * @generated from protobuf enum value: MusicGameGetBeatmapReqType_u4 = 3;
     */
    MusicGameGetBeatmapReqType_u4 = 3,
    /**
     * @generated from protobuf enum value: MusicGameGetBeatmapReqType_u5 = 4;
     */
    MusicGameGetBeatmapReqType_u5 = 4
}
/**
 * @generated from protobuf enum MusicGameUnknown1Enum
 */
export enum MusicGameUnknown1Enum {
    /**
     * @generated from protobuf enum value: MusicGameUnknown1Enum_NONE = 0;
     */
    MusicGameUnknown1Enum_NONE = 0,
    /**
     * @generated from protobuf enum value: MusicGameUnknown1Enum_u2 = 1;
     */
    MusicGameUnknown1Enum_u2 = 1
}
/**
 * @generated from protobuf enum MusicGameUnknown2Enum
 */
export enum MusicGameUnknown2Enum {
    /**
     * @generated from protobuf enum value: MusicGameUnknown2Enum_u1 = 0;
     */
    MusicGameUnknown2Enum_u1 = 0,
    /**
     * @generated from protobuf enum value: MusicGameUnknown2Enum_MINE = 1;
     */
    MusicGameUnknown2Enum_MINE = 1,
    /**
     * @generated from protobuf enum value: MusicGameUnknown2Enum_u3 = 2;
     */
    MusicGameUnknown2Enum_u3 = 2
}
/**
 * @generated from protobuf enum Operation
 */
export enum Operation {
    /**
     * @generated from protobuf enum value: Add = 0;
     */
    Add = 0,
    /**
     * @generated from protobuf enum value: Mod = 1;
     */
    Mod = 1,
    /**
     * @generated from protobuf enum value: Del = 2;
     */
    Del = 2,
    /**
     * @generated from protobuf enum value: Get = 3;
     */
    Get = 3
}
/**
 * @generated from protobuf enum PlatformType
 */
export enum PlatformType {
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_EDITOR = 0;
     */
    EDITOR = 0,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_IOS = 1;
     */
    IOS = 1,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_ANDROID = 2;
     */
    ANDROID = 2,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_PC = 3;
     */
    PC = 3,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_PS_4 = 4;
     */
    PS_4 = 4,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_SERVER = 5;
     */
    SERVER = 5,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_CLOUD_ANDROID = 6;
     */
    CLOUD_ANDROID = 6,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_CLOUD_IOS = 7;
     */
    CLOUD_IOS = 7,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_PS_5 = 8;
     */
    PS_5 = 8,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_CLOUD_WEB = 9;
     */
    CLOUD_WEB = 9,
    /**
     * @generated from protobuf enum value: PLATFORM_TYPE_CLOUD_TV = 10;
     */
    CLOUD_TV = 10
}
/**
 * @generated from protobuf enum PlayerApplyEnterMpReason
 */
export enum PlayerApplyEnterMpReason {
    /**
     * @generated from protobuf enum value: PlayerJudge = 0;
     */
    PlayerJudge = 0,
    /**
     * @generated from protobuf enum value: SceneCannotEnter = 1;
     */
    SceneCannotEnter = 1,
    /**
     * @generated from protobuf enum value: PlayerCannotEnterMp = 2;
     */
    PlayerCannotEnterMp = 2,
    /**
     * @generated from protobuf enum value: SystemJudge = 3;
     */
    SystemJudge = 3,
    /**
     * @generated from protobuf enum value: AllowEnterPlayerFull = 4;
     */
    AllowEnterPlayerFull = 4,
    /**
     * @generated from protobuf enum value: WorldLevelLowerThanHost = 5;
     */
    WorldLevelLowerThanHost = 5,
    /**
     * @generated from protobuf enum value: HostInMatch = 6;
     */
    HostInMatch = 6,
    /**
     * @generated from protobuf enum value: PlayerInBlacklist = 7;
     */
    PlayerInBlacklist = 7,
    /**
     * @generated from protobuf enum value: PsPlayerNotAcceptOthers = 8;
     */
    PsPlayerNotAcceptOthers = 8,
    /**
     * @generated from protobuf enum value: HostIsBlocked = 9;
     */
    HostIsBlocked = 9,
    /**
     * @generated from protobuf enum value: OtherDataVersionNotLatest = 10;
     */
    OtherDataVersionNotLatest = 10,
    /**
     * @generated from protobuf enum value: DataVersionNotLatest = 11;
     */
    DataVersionNotLatest = 11,
    /**
     * @generated from protobuf enum value: PlayerNotInPlayerWorld = 12;
     */
    PlayerNotInPlayerWorld = 12
}
/**
 * @generated from protobuf enum PlayerDieType
 */
export enum PlayerDieType {
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_KILL_BY_MONSTER = 1;
     */
    KILL_BY_MONSTER = 1,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_KILL_BY_GEAR = 2;
     */
    KILL_BY_GEAR = 2,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_FALL = 3;
     */
    FALL = 3,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_DRAWN = 4;
     */
    DRAWN = 4,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_ABYSS = 5;
     */
    ABYSS = 5,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_GM = 6;
     */
    GM = 6,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_CLIMATE_COLD = 7;
     */
    CLIMATE_COLD = 7,
    /**
     * @generated from protobuf enum value: PLAYER_DIE_TYPE_STORM_LIGHTING = 8;
     */
    STORM_LIGHTING = 8
}
/**
 * @generated from protobuf enum PropChangeReason
 */
export enum PropChangeReason {
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_STATUE_RECOVER = 1;
     */
    STATUE_RECOVER = 1,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_ENERGY_BALL = 2;
     */
    ENERGY_BALL = 2,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_ABILITY = 3;
     */
    ABILITY = 3,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_LEVELUP = 4;
     */
    LEVELUP = 4,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_ITEM = 5;
     */
    ITEM = 5,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_AVATAR_CARD = 6;
     */
    AVATAR_CARD = 6,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_CITY_LEVELUP = 7;
     */
    CITY_LEVELUP = 7,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_AVATAR_UPGRADE = 8;
     */
    AVATAR_UPGRADE = 8,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_AVATAR_PROMOTE = 9;
     */
    AVATAR_PROMOTE = 9,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_PLAYER_ADD_EXP = 10;
     */
    PLAYER_ADD_EXP = 10,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_FINISH_QUEST = 11;
     */
    FINISH_QUEST = 11,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_GM = 12;
     */
    GM = 12,
    /**
     * @generated from protobuf enum value: PROP_CHANGE_REASON_MANUAL_ADJUST_WORLD_LEVEL = 13;
     */
    MANUAL_ADJUST_WORLD_LEVEL = 13
}
/**
 * @generated from protobuf enum ProtEntityType
 */
export enum ProtEntityType {
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_AVATAR = 1;
     */
    AVATAR = 1,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_MONSTER = 2;
     */
    MONSTER = 2,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_NPC = 3;
     */
    NPC = 3,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_GADGET = 4;
     */
    GADGET = 4,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_REGION = 5;
     */
    REGION = 5,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_WEAPON = 6;
     */
    WEAPON = 6,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_WEATHER = 7;
     */
    WEATHER = 7,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_SCENE = 8;
     */
    SCENE = 8,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_TEAM = 9;
     */
    TEAM = 9,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_MASSIVE_ENTITY = 10;
     */
    MASSIVE_ENTITY = 10,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_MP_LEVEL = 11;
     */
    MP_LEVEL = 11,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_PLAY_TEAM_ENTITY = 12;
     */
    PLAY_TEAM_ENTITY = 12,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_EYE_POINT = 13;
     */
    EYE_POINT = 13,
    /**
     * @generated from protobuf enum value: PROT_ENTITY_TYPE_MAX = 14;
     */
    MAX = 14
}
/**
 * @generated from protobuf enum ResinCostType
 */
export enum ResinCostType {
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_NORMAL = 1;
     */
    NORMAL = 1,
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_CONDENSE = 2;
     */
    CONDENSE = 2,
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_REUNION_PRIVILEGE = 3;
     */
    REUNION_PRIVILEGE = 3,
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_OP_ACTIVITY = 4;
     */
    OP_ACTIVITY = 4,
    /**
     * @generated from protobuf enum value: RESIN_COST_TYPE_MATERIAL = 5;
     */
    MATERIAL = 5
}
/**
 * @generated from protobuf enum Retcode
 */
export enum Retcode {
    /**
     * @generated from protobuf enum value: RET_SUCC = 0;
     */
    RET_SUCC = 0,
    /**
     * @generated from protobuf enum value: RET_SVR_ERROR = 1;
     */
    RET_SVR_ERROR = 1,
    /**
     * @generated from protobuf enum value: RET_UNKNOWN_ERROR = 2;
     */
    RET_UNKNOWN_ERROR = 2,
    /**
     * @generated from protobuf enum value: RET_FREQUENT = 3;
     */
    RET_FREQUENT = 3,
    /**
     * @generated from protobuf enum value: RET_NODE_FORWARD_ERROR = 4;
     */
    RET_NODE_FORWARD_ERROR = 4,
    /**
     * @generated from protobuf enum value: RET_NOT_FOUND_CONFIG = 5;
     */
    RET_NOT_FOUND_CONFIG = 5,
    /**
     * @generated from protobuf enum value: RET_SYSTEM_BUSY = 6;
     */
    RET_SYSTEM_BUSY = 6,
    /**
     * @generated from protobuf enum value: RET_GM_UID_BIND = 7;
     */
    RET_GM_UID_BIND = 7,
    /**
     * @generated from protobuf enum value: RET_STOP_REGISTER = 10;
     */
    RET_STOP_REGISTER = 10,
    /**
     * @generated from protobuf enum value: RET_STOP_SERVER = 11;
     */
    RET_STOP_SERVER = 11,
    /**
     * @generated from protobuf enum value: RET_ACCOUNT_VEIRFY_ERROR = 12;
     */
    RET_ACCOUNT_VEIRFY_ERROR = 12,
    /**
     * @generated from protobuf enum value: RET_ACCOUNT_FREEZE = 13;
     */
    RET_ACCOUNT_FREEZE = 13,
    /**
     * @generated from protobuf enum value: RET_REPEAT_LOGIN = 14;
     */
    RET_REPEAT_LOGIN = 14,
    /**
     * @generated from protobuf enum value: RET_CLIENT_VERSION_ERROR = 15;
     */
    RET_CLIENT_VERSION_ERROR = 15,
    /**
     * @generated from protobuf enum value: RET_TOKEN_ERROR = 16;
     */
    RET_TOKEN_ERROR = 16,
    /**
     * @generated from protobuf enum value: RET_ACCOUNT_NOT_EXIST = 17;
     */
    RET_ACCOUNT_NOT_EXIST = 17,
    /**
     * @generated from protobuf enum value: RET_WAIT_OTHER_LOGIN = 18;
     */
    RET_WAIT_OTHER_LOGIN = 18,
    /**
     * @generated from protobuf enum value: RET_ANOTHER_LOGIN = 19;
     */
    RET_ANOTHER_LOGIN = 19,
    /**
     * @generated from protobuf enum value: RET_CLIENT_FORCE_UPDATE = 20;
     */
    RET_CLIENT_FORCE_UPDATE = 20,
    /**
     * @generated from protobuf enum value: RET_BLACK_UID = 21;
     */
    RET_BLACK_UID = 21,
    /**
     * @generated from protobuf enum value: RET_LOGIN_DB_FAIL = 22;
     */
    RET_LOGIN_DB_FAIL = 22,
    /**
     * @generated from protobuf enum value: RET_LOGIN_INIT_FAIL = 23;
     */
    RET_LOGIN_INIT_FAIL = 23,
    /**
     * @generated from protobuf enum value: RET_MYSQL_DUPLICATE = 24;
     */
    RET_MYSQL_DUPLICATE = 24,
    /**
     * @generated from protobuf enum value: RET_MAX_PLAYER = 25;
     */
    RET_MAX_PLAYER = 25,
    /**
     * @generated from protobuf enum value: RET_ANTI_ADDICT = 26;
     */
    RET_ANTI_ADDICT = 26,
    /**
     * @generated from protobuf enum value: RET_PS_PLAYER_WITHOUT_ONLINE_ID = 27;
     */
    RET_PS_PLAYER_WITHOUT_ONLINE_ID = 27,
    /**
     * @generated from protobuf enum value: RET_ONLINE_ID_NOT_FOUND = 28;
     */
    RET_ONLINE_ID_NOT_FOUND = 28,
    /**
     * @generated from protobuf enum value: RET_ONLNE_ID_NOT_MATCH = 29;
     */
    RET_ONLNE_ID_NOT_MATCH = 29,
    /**
     * @generated from protobuf enum value: RET_REGISTER_IS_FULL = 30;
     */
    RET_REGISTER_IS_FULL = 30,
    /**
     * @generated from protobuf enum value: RET_CHECKSUM_INVALID = 31;
     */
    RET_CHECKSUM_INVALID = 31,
    /**
     * @generated from protobuf enum value: RET_BLACK_REGISTER_IP = 32;
     */
    RET_BLACK_REGISTER_IP = 32,
    /**
     * @generated from protobuf enum value: RET_EXCEED_REGISTER_RATE = 33;
     */
    RET_EXCEED_REGISTER_RATE = 33,
    /**
     * @generated from protobuf enum value: RET_UNKNOWN_PLATFORM = 34;
     */
    RET_UNKNOWN_PLATFORM = 34,
    /**
     * @generated from protobuf enum value: RET_TOKEN_PARAM_ERROR = 35;
     */
    RET_TOKEN_PARAM_ERROR = 35,
    /**
     * @generated from protobuf enum value: RET_ANTI_OFFLINE_ERROR = 36;
     */
    RET_ANTI_OFFLINE_ERROR = 36,
    /**
     * @generated from protobuf enum value: RET_BLACK_LOGIN_IP = 37;
     */
    RET_BLACK_LOGIN_IP = 37,
    /**
     * @generated from protobuf enum value: RET_GET_TOKEN_SESSION_HAS_UID = 38;
     */
    RET_GET_TOKEN_SESSION_HAS_UID = 38,
    /**
     * @generated from protobuf enum value: RET_ENVIRONMENT_ERROR = 39;
     */
    RET_ENVIRONMENT_ERROR = 39,
    /**
     * @generated from protobuf enum value: RET_CHECK_CLIENT_VERSION_HASH_FAIL = 40;
     */
    RET_CHECK_CLIENT_VERSION_HASH_FAIL = 40,
    /**
     * @generated from protobuf enum value: RET_AVATAR_IN_CD = 101;
     */
    RET_AVATAR_IN_CD = 101,
    /**
     * @generated from protobuf enum value: RET_AVATAR_NOT_ALIVE = 102;
     */
    RET_AVATAR_NOT_ALIVE = 102,
    /**
     * @generated from protobuf enum value: RET_AVATAR_NOT_ON_SCENE = 103;
     */
    RET_AVATAR_NOT_ON_SCENE = 103,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_FIND_AVATAR = 104;
     */
    RET_CAN_NOT_FIND_AVATAR = 104,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_DEL_CUR_AVATAR = 105;
     */
    RET_CAN_NOT_DEL_CUR_AVATAR = 105,
    /**
     * @generated from protobuf enum value: RET_DUPLICATE_AVATAR = 106;
     */
    RET_DUPLICATE_AVATAR = 106,
    /**
     * @generated from protobuf enum value: RET_AVATAR_IS_SAME_ONE = 107;
     */
    RET_AVATAR_IS_SAME_ONE = 107,
    /**
     * @generated from protobuf enum value: RET_AVATAR_LEVEL_LESS_THAN = 108;
     */
    RET_AVATAR_LEVEL_LESS_THAN = 108,
    /**
     * @generated from protobuf enum value: RET_AVATAR_CAN_NOT_CHANGE_ELEMENT = 109;
     */
    RET_AVATAR_CAN_NOT_CHANGE_ELEMENT = 109,
    /**
     * @generated from protobuf enum value: RET_AVATAR_BREAK_LEVEL_LESS_THAN = 110;
     */
    RET_AVATAR_BREAK_LEVEL_LESS_THAN = 110,
    /**
     * @generated from protobuf enum value: RET_AVATAR_ON_MAX_BREAK_LEVEL = 111;
     */
    RET_AVATAR_ON_MAX_BREAK_LEVEL = 111,
    /**
     * @generated from protobuf enum value: RET_AVATAR_ID_ALREADY_EXIST = 112;
     */
    RET_AVATAR_ID_ALREADY_EXIST = 112,
    /**
     * @generated from protobuf enum value: RET_AVATAR_NOT_DEAD = 113;
     */
    RET_AVATAR_NOT_DEAD = 113,
    /**
     * @generated from protobuf enum value: RET_AVATAR_IS_REVIVING = 114;
     */
    RET_AVATAR_IS_REVIVING = 114,
    /**
     * @generated from protobuf enum value: RET_AVATAR_ID_ERROR = 115;
     */
    RET_AVATAR_ID_ERROR = 115,
    /**
     * @generated from protobuf enum value: RET_REPEAT_SET_PLAYER_BORN_DATA = 116;
     */
    RET_REPEAT_SET_PLAYER_BORN_DATA = 116,
    /**
     * @generated from protobuf enum value: RET_PLAYER_LEVEL_LESS_THAN = 117;
     */
    RET_PLAYER_LEVEL_LESS_THAN = 117,
    /**
     * @generated from protobuf enum value: RET_AVATAR_LIMIT_LEVEL_ERROR = 118;
     */
    RET_AVATAR_LIMIT_LEVEL_ERROR = 118,
    /**
     * @generated from protobuf enum value: RET_CUR_AVATAR_NOT_ALIVE = 119;
     */
    RET_CUR_AVATAR_NOT_ALIVE = 119,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_FIND_TEAM = 120;
     */
    RET_CAN_NOT_FIND_TEAM = 120,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_FIND_CUR_TEAM = 121;
     */
    RET_CAN_NOT_FIND_CUR_TEAM = 121,
    /**
     * @generated from protobuf enum value: RET_AVATAR_NOT_EXIST_IN_TEAM = 122;
     */
    RET_AVATAR_NOT_EXIST_IN_TEAM = 122,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_REMOVE_CUR_AVATAR_FROM_TEAM = 123;
     */
    RET_CAN_NOT_REMOVE_CUR_AVATAR_FROM_TEAM = 123,
    /**
     * @generated from protobuf enum value: RET_CAN_NOT_USE_REVIVE_ITEM_FOR_CUR_AVATAR = 124;
     */
    RET_CAN_NOT_USE_REVIVE_ITEM_FOR_CUR_AVATAR = 124,
    /**
     * @generated from protobuf enum value: RET_TEAM_COST_EXCEED_LIMIT = 125;
     */
    RET_TEAM_COST_EXCEED_LIMIT = 125,
    /**
     * @generated from protobuf enum value: RET_TEAM_AVATAR_IN_EXPEDITION = 126;
     */
    RET_TEAM_AVATAR_IN_EXPEDITION = 126,
    /**
     * @generated from protobuf enum value: RET_TEAM_CAN_NOT_CHOSE_REPLACE_USE = 127;
     */
    RET_TEAM_CAN_NOT_CHOSE_REPLACE_USE = 127,
    /**
     * @generated from protobuf enum value: RET_AVATAR_IN_COMBAT = 128;
     */
    RET_AVATAR_IN_COMBAT = 128,
    /**
     * @generated from protobuf enum value: RET_NICKNAME_UTF8_ERROR = 130;
     */
    RET_NICKNAME_UTF8_ERROR = 130,
    /**
     * @generated from protobuf enum value: RET_NICKNAME_TOO_LONG = 131;
     */
    RET_NICKNAME_TOO_LONG = 131,
    /**
     * @generated from protobuf enum value: RET_NICKNAME_WORD_ILLEGAL = 132;
     */
    RET_NICKNAME_WORD_ILLEGAL = 132,
    /**
     * @generated from protobuf enum value: RET_NICKNAME_TOO_MANY_DIGITS = 133;
     */
    RET_NICKNAME_TOO_MANY_DIGITS = 133,
    /**
     * @generated from protobuf enum value: RET_NICKNAME_IS_EMPTY = 134;
     */
    RET_NICKNAME_IS_EMPTY = 134,
    /**
     * @generated from protobuf enum value: RET_PLAYER_NOT_ONLINE = 140;
     */
    RET_PLAYER_NOT_ONLINE = 140,
    /**
     * @generated from protobuf enum value: RET_OPEN_STATE_NOT_OPEN = 141;
     */
    RET_OPEN_STATE_NOT_OPEN = 141,
    /**
     * @generated from protobuf enum value: RET_FEATURE_CLOSED = 142;
     */
    RET_FEATURE_CLOSED = 142,
    /**
     * @generated from protobuf enum value: RET_AVATAR_EXPEDITION_AVATAR_DIE = 152;
     */
    RET_AVATAR_EXPEDITION_AVATAR_DIE = 152,
    /**
     * @generated from protobuf enum value: RET_AVATAR_EXPEDITION_COUNT_LIMIT = 153;
     */
    RET_AVATAR_EXPEDITION_COUNT_LIMIT = 153,
    /**
     * @generated from protobuf enum value: RET_AVATAR_EXPEDITION_MAIN_FORBID = 154;
     */
    RET_AVATAR_EXPEDITION_MAIN_FORBID = 154,
    /**
     * @generated from protobuf enum value: RET_AVATAR_EXPEDITION_TRIAL_FORBID = 155;
     */
    RET_AVATAR_EXPEDITION_TRIAL_FORBID = 155,
    /**
     * @generated from protobuf enum value: RET_TEAM_NAME_ILLEGAL = 156;
     */
    RET_TEAM_NAME_ILLEGAL = 156,
    /**
     * @generated from protobuf enum value: RET_IS_NOT_IN_STANDBY = 157;
     */
    RET_IS_NOT_IN_STANDBY = 157,
    /**
     * @generated from protobuf enum value: RET_IS_IN_DUNGEON = 158;
     */
    RET_IS_IN_DUNGEON = 158,
    /**
     * @generated from protobuf enum value: RET_IS_IN_LOCK_AVATAR_QUEST = 159;
     */
    RET_IS_IN_LOCK_AVATAR_QUEST = 159,
    /**
     * @generated from protobuf enum value: RET_IS_USING_TRIAL_AVATAR = 160;
     */
    RET_IS_USING_TRIAL_AVATAR = 160,
    /**
     * @generated from protobuf enum value: RET_IS_USING_TEMP_AVATAR = 161;
     */
    RET_IS_USING_TEMP_AVATAR = 161,
    /**
     * @generated from protobuf enum value: RET_NOT_HAS_FLYCLOAK = 162;
     */
    RET_NOT_HAS_FLYCLOAK = 162,
    /**
     * @generated from protobuf enum value: RET_FETTER_REWARD_ALREADY_GOT = 163;
     */
    RET_FETTER_REWARD_ALREADY_GOT = 163,
    /**
     * @generated from protobuf enum value: RET_FETTER_REWARD_LEVEL_NOT_ENOUGH = 164;
     */
    RET_FETTER_REWARD_LEVEL_NOT_ENOUGH = 164,
    /**
     * @generated from protobuf enum value: RET_WORLD_LEVEL_ADJUST_MIN_LEVEL = 165;
     */
    RET_WORLD_LEVEL_ADJUST_MIN_LEVEL = 165,
    /**
     * @generated from protobuf enum value: RET_WORLD_LEVEL_ADJUST_CD = 166;
     */
    RET_WORLD_LEVEL_ADJUST_CD = 166,
    /**
     * @generated from protobuf enum value: RET_NOT_HAS_COSTUME = 167;
     */
    RET_NOT_HAS_COSTUME = 167,
    /**
     * @generated from protobuf enum value: RET_COSTUME_AVATAR_ERROR = 168;
     */
    RET_COSTUME_AVATAR_ERROR = 168,
    /**
     * @generated from protobuf enum value: RET_FLYCLOAK_PLATFORM_TYPE_ERR = 169;
     */
    RET_FLYCLOAK_PLATFORM_TYPE_ERR = 169,
    /**
     * @generated from protobuf enum value: RET_FLOAT_ERROR = 201;
     */
    RET_FLOAT_ERROR = 201,
    /**
     * @generated from protobuf enum value: RET_NPC_NOT_EXIST = 301;
     */
    RET_NPC_NOT_EXIST = 301,
    /**
     * @generated from protobuf enum value: RET_NPC_TOO_FAR = 302;
     */
    RET_NPC_TOO_FAR = 302,
    /**
     * @generated from protobuf enum value: RET_NOT_CURRENT_TALK = 303;
     */
    RET_NOT_CURRENT_TALK = 303,
    /**
     * @generated from protobuf enum value: RET_NPC_CREATE_FAIL = 304;
     */
    RET_NPC_CREATE_FAIL = 304,
    /**
     * @generated from protobuf enum value: RET_NPC_MOVE_FAIL = 305;
     */
    RET_NPC_MOVE_FAIL = 305,
    /**
     * @generated from protobuf enum value: RET_QUEST_NOT_EXIST = 401;
     */
    RET_QUEST_NOT_EXIST = 401,
    /**
     * @generated from protobuf enum value: RET_QUEST_IS_FAIL = 402;
     */
    RET_QUEST_IS_FAIL = 402,
    /**
     * @generated from protobuf enum value: RET_QUEST_CONTENT_ERROR = 403;
     */
    RET_QUEST_CONTENT_ERROR = 403,
    /**
     * @generated from protobuf enum value: RET_BARGAIN_NOT_ACTIVATED = 404;
     */
    RET_BARGAIN_NOT_ACTIVATED = 404,
    /**
     * @generated from protobuf enum value: RET_BARGAIN_FINISHED = 405;
     */
    RET_BARGAIN_FINISHED = 405,
    /**
     * @generated from protobuf enum value: RET_POINT_NOT_UNLOCKED = 501;
     */
    RET_POINT_NOT_UNLOCKED = 501,
    /**
     * @generated from protobuf enum value: RET_POINT_TOO_FAR = 502;
     */
    RET_POINT_TOO_FAR = 502,
    /**
     * @generated from protobuf enum value: RET_POINT_ALREAY_UNLOCKED = 503;
     */
    RET_POINT_ALREAY_UNLOCKED = 503,
    /**
     * @generated from protobuf enum value: RET_ENTITY_NOT_EXIST = 504;
     */
    RET_ENTITY_NOT_EXIST = 504,
    /**
     * @generated from protobuf enum value: RET_ENTER_SCENE_FAIL = 505;
     */
    RET_ENTER_SCENE_FAIL = 505,
    /**
     * @generated from protobuf enum value: RET_PLAYER_IS_ENTER_SCENE = 506;
     */
    RET_PLAYER_IS_ENTER_SCENE = 506,
    /**
     * @generated from protobuf enum value: RET_CITY_MAX_LEVEL = 507;
     */
    RET_CITY_MAX_LEVEL = 507,
    /**
     * @generated from protobuf enum value: RET_AREA_LOCKED = 508;
     */
    RET_AREA_LOCKED = 508,
    /**
     * @generated from protobuf enum value: RET_JOIN_OTHER_WAIT = 509;
     */
    RET_JOIN_OTHER_WAIT = 509,
    /**
     * @generated from protobuf enum value: RET_WEATHER_AREA_NOT_FOUND = 510;
     */
    RET_WEATHER_AREA_NOT_FOUND = 510,
    /**
     * @generated from protobuf enum value: RET_WEATHER_IS_LOCKED = 511;
     */
    RET_WEATHER_IS_LOCKED = 511,
    /**
     * @generated from protobuf enum value: RET_NOT_IN_SELF_SCENE = 512;
     */
    RET_NOT_IN_SELF_SCENE = 512,
    /**
     * @generated from protobuf enum value: RET_GROUP_NOT_EXIST = 513;
     */
    RET_GROUP_NOT_EXIST = 513,
    /**
     * @generated from protobuf enum value: RET_MARK_NAME_ILLEGAL = 514;
     */
    RET_MARK_NAME_ILLEGAL = 514,
    /**
     * @generated from protobuf enum value: RET_MARK_ALREADY_EXISTS = 515;
     */
    RET_MARK_ALREADY_EXISTS = 515,
    /**
     * @generated from protobuf enum value: RET_MARK_OVERFLOW = 516;
     */
    RET_MARK_OVERFLOW = 516,
    /**
     * @generated from protobuf enum value: RET_MARK_NOT_EXISTS = 517;
     */
    RET_MARK_NOT_EXISTS = 517,
    /**
     * @generated from protobuf enum value: RET_MARK_UNKNOWN_TYPE = 518;
     */
    RET_MARK_UNKNOWN_TYPE = 518,
    /**
     * @generated from protobuf enum value: RET_MARK_NAME_TOO_LONG = 519;
     */
    RET_MARK_NAME_TOO_LONG = 519,
    /**
     * @generated from protobuf enum value: RET_DISTANCE_LONG = 520;
     */
    RET_DISTANCE_LONG = 520,
    /**
     * @generated from protobuf enum value: RET_ENTER_SCENE_TOKEN_INVALID = 521;
     */
    RET_ENTER_SCENE_TOKEN_INVALID = 521,
    /**
     * @generated from protobuf enum value: RET_NOT_IN_WORLD_SCENE = 522;
     */
    RET_NOT_IN_WORLD_SCENE = 522,
    /**
     * @generated from protobuf enum value: RET_ANY_GALLERY_STARTED = 523;
     */
    RET_ANY_GALLERY_STARTED = 523,
    /**
     * @generated from protobuf enum value: RET_GALLERY_NOT_START = 524;
     */
    RET_GALLERY_NOT_START = 524,
    /**
     * @generated from protobuf enum value: RET_GALLERY_INTERRUPT_ONLY_ON_SINGLE_MODE = 525;
     */
    RET_GALLERY_INTERRUPT_ONLY_ON_SINGLE_MODE = 525,
    /**
     * @generated from protobuf enum value: RET_GALLERY_CANNOT_INTERRUPT = 526;
     */
    RET_GALLERY_CANNOT_INTERRUPT = 526,
    /**
     * @generated from protobuf enum value: RET_GALLERY_WORLD_NOT_MEET = 527;
     */
    RET_GALLERY_WORLD_NOT_MEET = 527,
    /**
     * @generated from protobuf enum value: RET_GALLERY_SCENE_NOT_MEET = 528;
     */
    RET_GALLERY_SCENE_NOT_MEET = 528,
    /**
     * @generated from protobuf enum value: RET_CUR_PLAY_CANNOT_TRANSFER = 529;
     */
    RET_CUR_PLAY_CANNOT_TRANSFER = 529,
    /**
     * @generated from protobuf enum value: RET_CANT_USE_WIDGET_IN_HOME_SCENE = 530;
     */
    RET_CANT_USE_WIDGET_IN_HOME_SCENE = 530,
    /**
     * @generated from protobuf enum value: RET_SCENE_GROUP_NOT_MATCH = 531;
     */
    RET_SCENE_GROUP_NOT_MATCH = 531,
    /**
     * @generated from protobuf enum value: RET_POS_ROT_INVALID = 551;
     */
    RET_POS_ROT_INVALID = 551,
    /**
     * @generated from protobuf enum value: RET_MARK_INVALID_SCENE_ID = 552;
     */
    RET_MARK_INVALID_SCENE_ID = 552,
    /**
     * @generated from protobuf enum value: RET_INVALID_SCENE_TO_USE_ANCHOR_POINT = 553;
     */
    RET_INVALID_SCENE_TO_USE_ANCHOR_POINT = 553,
    /**
     * @generated from protobuf enum value: RET_ENTER_HOME_SCENE_FAIL = 554;
     */
    RET_ENTER_HOME_SCENE_FAIL = 554,
    /**
     * @generated from protobuf enum value: RET_CUR_SCENE_IS_NULL = 555;
     */
    RET_CUR_SCENE_IS_NULL = 555,
    /**
     * @generated from protobuf enum value: RET_GROUP_ID_ERROR = 556;
     */
    RET_GROUP_ID_ERROR = 556,
    /**
     * @generated from protobuf enum value: RET_ITEM_NOT_EXIST = 601;
     */
    RET_ITEM_NOT_EXIST = 601,
    /**
     * @generated from protobuf enum value: RET_PACK_EXCEED_MAX_WEIGHT = 602;
     */
    RET_PACK_EXCEED_MAX_WEIGHT = 602,
    /**
     * @generated from protobuf enum value: RET_ITEM_NOT_DROPABLE = 603;
     */
    RET_ITEM_NOT_DROPABLE = 603,
    /**
     * @generated from protobuf enum value: RET_ITEM_NOT_USABLE = 604;
     */
    RET_ITEM_NOT_USABLE = 604,
    /**
     * @generated from protobuf enum value: RET_ITEM_INVALID_USE_COUNT = 605;
     */
    RET_ITEM_INVALID_USE_COUNT = 605,
    /**
     * @generated from protobuf enum value: RET_ITEM_INVALID_DROP_COUNT = 606;
     */
    RET_ITEM_INVALID_DROP_COUNT = 606,
    /**
     * @generated from protobuf enum value: RET_ITEM_ALREADY_EXIST = 607;
     */
    RET_ITEM_ALREADY_EXIST = 607,
    /**
     * @generated from protobuf enum value: RET_ITEM_IN_COOLDOWN = 608;
     */
    RET_ITEM_IN_COOLDOWN = 608,
    /**
     * @generated from protobuf enum value: RET_ITEM_COUNT_NOT_ENOUGH = 609;
     */
    RET_ITEM_COUNT_NOT_ENOUGH = 609,
    /**
     * @generated from protobuf enum value: RET_ITEM_INVALID_TARGET = 610;
     */
    RET_ITEM_INVALID_TARGET = 610,
    /**
     * @generated from protobuf enum value: RET_RECIPE_NOT_EXIST = 611;
     */
    RET_RECIPE_NOT_EXIST = 611,
    /**
     * @generated from protobuf enum value: RET_RECIPE_LOCKED = 612;
     */
    RET_RECIPE_LOCKED = 612,
    /**
     * @generated from protobuf enum value: RET_RECIPE_UNLOCKED = 613;
     */
    RET_RECIPE_UNLOCKED = 613,
    /**
     * @generated from protobuf enum value: RET_COMPOUND_QUEUE_FULL = 614;
     */
    RET_COMPOUND_QUEUE_FULL = 614,
    /**
     * @generated from protobuf enum value: RET_COMPOUND_NOT_FINISH = 615;
     */
    RET_COMPOUND_NOT_FINISH = 615,
    /**
     * @generated from protobuf enum value: RET_MAIL_ITEM_NOT_GET = 616;
     */
    RET_MAIL_ITEM_NOT_GET = 616,
    /**
     * @generated from protobuf enum value: RET_ITEM_EXCEED_LIMIT = 617;
     */
    RET_ITEM_EXCEED_LIMIT = 617,
    /**
     * @generated from protobuf enum value: RET_AVATAR_CAN_NOT_USE = 618;
     */
    RET_AVATAR_CAN_NOT_USE = 618,
    /**
     * @generated from protobuf enum value: RET_ITEM_NEED_PLAYER_LEVEL = 619;
     */
    RET_ITEM_NEED_PLAYER_LEVEL = 619,
    /**
     * @generated from protobuf enum value: RET_RECIPE_NOT_AUTO_QTE = 620;
     */
    RET_RECIPE_NOT_AUTO_QTE = 620,
    /**
     * @generated from protobuf enum value: RET_COMPOUND_BUSY_QUEUE = 621;
     */
    RET_COMPOUND_BUSY_QUEUE = 621,
    /**
     * @generated from protobuf enum value: RET_NEED_MORE_SCOIN = 622;
     */
    RET_NEED_MORE_SCOIN = 622,
    /**
     * @generated from protobuf enum value: RET_SKILL_DEPOT_NOT_FOUND = 623;
     */
    RET_SKILL_DEPOT_NOT_FOUND = 623,
    /**
     * @generated from protobuf enum value: RET_HCOIN_NOT_ENOUGH = 624;
     */
    RET_HCOIN_NOT_ENOUGH = 624,
    /**
     * @generated from protobuf enum value: RET_SCOIN_NOT_ENOUGH = 625;
     */
    RET_SCOIN_NOT_ENOUGH = 625,
    /**
     * @generated from protobuf enum value: RET_HCOIN_EXCEED_LIMIT = 626;
     */
    RET_HCOIN_EXCEED_LIMIT = 626,
    /**
     * @generated from protobuf enum value: RET_SCOIN_EXCEED_LIMIT = 627;
     */
    RET_SCOIN_EXCEED_LIMIT = 627,
    /**
     * @generated from protobuf enum value: RET_MAIL_EXPIRED = 628;
     */
    RET_MAIL_EXPIRED = 628,
    /**
     * @generated from protobuf enum value: RET_REWARD_HAS_TAKEN = 629;
     */
    RET_REWARD_HAS_TAKEN = 629,
    /**
     * @generated from protobuf enum value: RET_COMBINE_COUNT_TOO_LARGE = 630;
     */
    RET_COMBINE_COUNT_TOO_LARGE = 630,
    /**
     * @generated from protobuf enum value: RET_GIVING_ITEM_WRONG = 631;
     */
    RET_GIVING_ITEM_WRONG = 631,
    /**
     * @generated from protobuf enum value: RET_GIVING_IS_FINISHED = 632;
     */
    RET_GIVING_IS_FINISHED = 632,
    /**
     * @generated from protobuf enum value: RET_GIVING_NOT_ACTIVED = 633;
     */
    RET_GIVING_NOT_ACTIVED = 633,
    /**
     * @generated from protobuf enum value: RET_FORGE_QUEUE_FULL = 634;
     */
    RET_FORGE_QUEUE_FULL = 634,
    /**
     * @generated from protobuf enum value: RET_FORGE_QUEUE_CAPACITY = 635;
     */
    RET_FORGE_QUEUE_CAPACITY = 635,
    /**
     * @generated from protobuf enum value: RET_FORGE_QUEUE_NOT_FOUND = 636;
     */
    RET_FORGE_QUEUE_NOT_FOUND = 636,
    /**
     * @generated from protobuf enum value: RET_FORGE_QUEUE_EMPTY = 637;
     */
    RET_FORGE_QUEUE_EMPTY = 637,
    /**
     * @generated from protobuf enum value: RET_NOT_SUPPORT_ITEM = 638;
     */
    RET_NOT_SUPPORT_ITEM = 638,
    /**
     * @generated from protobuf enum value: RET_ITEM_EMPTY = 639;
     */
    RET_ITEM_EMPTY = 639,
    /**
     * @generated from protobuf enum value: RET_VIRTUAL_EXCEED_LIMIT = 640;
     */
    RET_VIRTUAL_EXCEED_LIMIT = 640,
    /**
     * @generated from protobuf enum value: RET_MATERIAL_EXCEED_LIMIT = 641;
     */
    RET_MATERIAL_EXCEED_LIMIT = 641,
    /**
     * @generated from protobuf enum value: RET_EQUIP_EXCEED_LIMIT = 642;
     */
    RET_EQUIP_EXCEED_LIMIT = 642,
    /**
     * @generated from protobuf enum value: RET_ITEM_SHOULD_HAVE_NO_LEVEL = 643;
     */
    RET_ITEM_SHOULD_HAVE_NO_LEVEL = 643,
    /**
     * @generated from protobuf enum value: RET_WEAPON_PROMOTE_LEVEL_EXCEED_LIMIT = 644;
     */
    RET_WEAPON_PROMOTE_LEVEL_EXCEED_LIMIT = 644,
    /**
     * @generated from protobuf enum value: RET_WEAPON_LEVEL_INVALID = 645;
     */
    RET_WEAPON_LEVEL_INVALID = 645,
    /**
     * @generated from protobuf enum value: RET_UNKNOW_ITEM_TYPE = 646;
     */
    RET_UNKNOW_ITEM_TYPE = 646,
    /**
     * @generated from protobuf enum value: RET_ITEM_COUNT_IS_ZERO = 647;
     */
    RET_ITEM_COUNT_IS_ZERO = 647,
    /**
     * @generated from protobuf enum value: RET_ITEM_IS_EXPIRED = 648;
     */
    RET_ITEM_IS_EXPIRED = 648,
    /**
     * @generated from protobuf enum value: RET_ITEM_EXCEED_OUTPUT_LIMIT = 649;
     */
    RET_ITEM_EXCEED_OUTPUT_LIMIT = 649,
    /**
     * @generated from protobuf enum value: RET_EQUIP_LEVEL_HIGHER = 650;
     */
    RET_EQUIP_LEVEL_HIGHER = 650,
    /**
     * @generated from protobuf enum value: RET_EQUIP_CAN_NOT_WAKE_OFF_WEAPON = 651;
     */
    RET_EQUIP_CAN_NOT_WAKE_OFF_WEAPON = 651,
    /**
     * @generated from protobuf enum value: RET_EQUIP_HAS_BEEN_WEARED = 652;
     */
    RET_EQUIP_HAS_BEEN_WEARED = 652,
    /**
     * @generated from protobuf enum value: RET_EQUIP_WEARED_CANNOT_DROP = 653;
     */
    RET_EQUIP_WEARED_CANNOT_DROP = 653,
    /**
     * @generated from protobuf enum value: RET_AWAKEN_LEVEL_MAX = 654;
     */
    RET_AWAKEN_LEVEL_MAX = 654,
    /**
     * @generated from protobuf enum value: RET_MCOIN_NOT_ENOUGH = 655;
     */
    RET_MCOIN_NOT_ENOUGH = 655,
    /**
     * @generated from protobuf enum value: RET_MCOIN_EXCEED_LIMIT = 656;
     */
    RET_MCOIN_EXCEED_LIMIT = 656,
    /**
     * @generated from protobuf enum value: RET_RESIN_NOT_ENOUGH = 660;
     */
    RET_RESIN_NOT_ENOUGH = 660,
    /**
     * @generated from protobuf enum value: RET_RESIN_EXCEED_LIMIT = 661;
     */
    RET_RESIN_EXCEED_LIMIT = 661,
    /**
     * @generated from protobuf enum value: RET_RESIN_OPENSTATE_OFF = 662;
     */
    RET_RESIN_OPENSTATE_OFF = 662,
    /**
     * @generated from protobuf enum value: RET_RESIN_BOUGHT_COUNT_EXCEEDED = 663;
     */
    RET_RESIN_BOUGHT_COUNT_EXCEEDED = 663,
    /**
     * @generated from protobuf enum value: RET_RESIN_CARD_DAILY_REWARD_HAS_TAKEN = 664;
     */
    RET_RESIN_CARD_DAILY_REWARD_HAS_TAKEN = 664,
    /**
     * @generated from protobuf enum value: RET_RESIN_CARD_EXPIRED = 665;
     */
    RET_RESIN_CARD_EXPIRED = 665,
    /**
     * @generated from protobuf enum value: RET_AVATAR_CAN_NOT_COOK = 666;
     */
    RET_AVATAR_CAN_NOT_COOK = 666,
    /**
     * @generated from protobuf enum value: RET_ATTACH_AVATAR_CD = 667;
     */
    RET_ATTACH_AVATAR_CD = 667,
    /**
     * @generated from protobuf enum value: RET_AUTO_RECOVER_OPENSTATE_OFF = 668;
     */
    RET_AUTO_RECOVER_OPENSTATE_OFF = 668,
    /**
     * @generated from protobuf enum value: RET_AUTO_RECOVER_BOUGHT_COUNT_EXCEEDED = 669;
     */
    RET_AUTO_RECOVER_BOUGHT_COUNT_EXCEEDED = 669,
    /**
     * @generated from protobuf enum value: RET_RESIN_GAIN_FAILED = 670;
     */
    RET_RESIN_GAIN_FAILED = 670,
    /**
     * @generated from protobuf enum value: RET_WIDGET_ORNAMENTS_TYPE_ERROR = 671;
     */
    RET_WIDGET_ORNAMENTS_TYPE_ERROR = 671,
    /**
     * @generated from protobuf enum value: RET_ALL_TARGET_SATIATION_FULL = 672;
     */
    RET_ALL_TARGET_SATIATION_FULL = 672,
    /**
     * @generated from protobuf enum value: RET_FORGE_WORLD_LEVEL_NOT_MATCH = 673;
     */
    RET_FORGE_WORLD_LEVEL_NOT_MATCH = 673,
    /**
     * @generated from protobuf enum value: RET_FORGE_POINT_NOT_ENOUGH = 674;
     */
    RET_FORGE_POINT_NOT_ENOUGH = 674,
    /**
     * @generated from protobuf enum value: RET_WIDGET_ANCHOR_POINT_FULL = 675;
     */
    RET_WIDGET_ANCHOR_POINT_FULL = 675,
    /**
     * @generated from protobuf enum value: RET_WIDGET_ANCHOR_POINT_NOT_FOUND = 676;
     */
    RET_WIDGET_ANCHOR_POINT_NOT_FOUND = 676,
    /**
     * @generated from protobuf enum value: RET_ALL_BONFIRE_EXCEED_MAX_COUNT = 677;
     */
    RET_ALL_BONFIRE_EXCEED_MAX_COUNT = 677,
    /**
     * @generated from protobuf enum value: RET_BONFIRE_EXCEED_MAX_COUNT = 678;
     */
    RET_BONFIRE_EXCEED_MAX_COUNT = 678,
    /**
     * @generated from protobuf enum value: RET_LUNCH_BOX_DATA_ERROR = 679;
     */
    RET_LUNCH_BOX_DATA_ERROR = 679,
    /**
     * @generated from protobuf enum value: RET_INVALID_QUICK_USE_WIDGET = 680;
     */
    RET_INVALID_QUICK_USE_WIDGET = 680,
    /**
     * @generated from protobuf enum value: RET_INVALID_REPLACE_RESIN_COUNT = 681;
     */
    RET_INVALID_REPLACE_RESIN_COUNT = 681,
    /**
     * @generated from protobuf enum value: RET_PREV_DETECTED_GATHER_NOT_FOUND = 682;
     */
    RET_PREV_DETECTED_GATHER_NOT_FOUND = 682,
    /**
     * @generated from protobuf enum value: RET_GOT_ALL_ONEOFF_GAHTER = 683;
     */
    RET_GOT_ALL_ONEOFF_GAHTER = 683,
    /**
     * @generated from protobuf enum value: RET_INVALID_WIDGET_MATERIAL_ID = 684;
     */
    RET_INVALID_WIDGET_MATERIAL_ID = 684,
    /**
     * @generated from protobuf enum value: RET_WIDGET_DETECTOR_NO_HINT_TO_CLEAR = 685;
     */
    RET_WIDGET_DETECTOR_NO_HINT_TO_CLEAR = 685,
    /**
     * @generated from protobuf enum value: RET_WIDGET_ALREADY_WITHIN_NEARBY_RADIUS = 686;
     */
    RET_WIDGET_ALREADY_WITHIN_NEARBY_RADIUS = 686,
    /**
     * @generated from protobuf enum value: RET_WIDGET_CLIENT_COLLECTOR_NEED_POINTS = 687;
     */
    RET_WIDGET_CLIENT_COLLECTOR_NEED_POINTS = 687,
    /**
     * @generated from protobuf enum value: RET_WIDGET_IN_COMBAT = 688;
     */
    RET_WIDGET_IN_COMBAT = 688,
    /**
     * @generated from protobuf enum value: RET_WIDGET_NOT_SET_QUICK_USE = 689;
     */
    RET_WIDGET_NOT_SET_QUICK_USE = 689,
    /**
     * @generated from protobuf enum value: RET_ALREADY_ATTACH_WIDGET = 690;
     */
    RET_ALREADY_ATTACH_WIDGET = 690,
    /**
     * @generated from protobuf enum value: RET_EQUIP_IS_LOCKED = 691;
     */
    RET_EQUIP_IS_LOCKED = 691,
    /**
     * @generated from protobuf enum value: RET_FORGE_IS_LOCKED = 692;
     */
    RET_FORGE_IS_LOCKED = 692,
    /**
     * @generated from protobuf enum value: RET_COMBINE_IS_LOCKED = 693;
     */
    RET_COMBINE_IS_LOCKED = 693,
    /**
     * @generated from protobuf enum value: RET_FORGE_OUTPUT_STACK_LIMIT = 694;
     */
    RET_FORGE_OUTPUT_STACK_LIMIT = 694,
    /**
     * @generated from protobuf enum value: RET_ALREADY_DETTACH_WIDGET = 695;
     */
    RET_ALREADY_DETTACH_WIDGET = 695,
    /**
     * @generated from protobuf enum value: RET_GADGET_BUILDER_EXCEED_MAX_COUNT = 696;
     */
    RET_GADGET_BUILDER_EXCEED_MAX_COUNT = 696,
    /**
     * @generated from protobuf enum value: RET_REUNION_PRIVILEGE_RESIN_TYPE_IS_NORMAL = 697;
     */
    RET_REUNION_PRIVILEGE_RESIN_TYPE_IS_NORMAL = 697,
    /**
     * @generated from protobuf enum value: RET_BONUS_COUNT_EXCEED_DOUBLE_LIMIT = 698;
     */
    RET_BONUS_COUNT_EXCEED_DOUBLE_LIMIT = 698,
    /**
     * @generated from protobuf enum value: RET_RELIQUARY_DECOMPOSE_PARAM_ERROR = 699;
     */
    RET_RELIQUARY_DECOMPOSE_PARAM_ERROR = 699,
    /**
     * @generated from protobuf enum value: RET_ITEM_COMBINE_COUNT_NOT_ENOUGH = 700;
     */
    RET_ITEM_COMBINE_COUNT_NOT_ENOUGH = 700,
    /**
     * @generated from protobuf enum value: RET_GOODS_NOT_EXIST = 701;
     */
    RET_GOODS_NOT_EXIST = 701,
    /**
     * @generated from protobuf enum value: RET_GOODS_MATERIAL_NOT_ENOUGH = 702;
     */
    RET_GOODS_MATERIAL_NOT_ENOUGH = 702,
    /**
     * @generated from protobuf enum value: RET_GOODS_NOT_IN_TIME = 703;
     */
    RET_GOODS_NOT_IN_TIME = 703,
    /**
     * @generated from protobuf enum value: RET_GOODS_BUY_NUM_NOT_ENOUGH = 704;
     */
    RET_GOODS_BUY_NUM_NOT_ENOUGH = 704,
    /**
     * @generated from protobuf enum value: RET_GOODS_BUY_NUM_ERROR = 705;
     */
    RET_GOODS_BUY_NUM_ERROR = 705,
    /**
     * @generated from protobuf enum value: RET_SHOP_NOT_OPEN = 706;
     */
    RET_SHOP_NOT_OPEN = 706,
    /**
     * @generated from protobuf enum value: RET_SHOP_CONTENT_NOT_MATCH = 707;
     */
    RET_SHOP_CONTENT_NOT_MATCH = 707,
    /**
     * @generated from protobuf enum value: RET_CHAT_FORBIDDEN = 798;
     */
    RET_CHAT_FORBIDDEN = 798,
    /**
     * @generated from protobuf enum value: RET_CHAT_CD = 799;
     */
    RET_CHAT_CD = 799,
    /**
     * @generated from protobuf enum value: RET_CHAT_FREQUENTLY = 800;
     */
    RET_CHAT_FREQUENTLY = 800,
    /**
     * @generated from protobuf enum value: RET_GADGET_NOT_EXIST = 801;
     */
    RET_GADGET_NOT_EXIST = 801,
    /**
     * @generated from protobuf enum value: RET_GADGET_NOT_INTERACTIVE = 802;
     */
    RET_GADGET_NOT_INTERACTIVE = 802,
    /**
     * @generated from protobuf enum value: RET_GADGET_NOT_GATHERABLE = 803;
     */
    RET_GADGET_NOT_GATHERABLE = 803,
    /**
     * @generated from protobuf enum value: RET_CHEST_IS_LOCKED = 804;
     */
    RET_CHEST_IS_LOCKED = 804,
    /**
     * @generated from protobuf enum value: RET_GADGET_CREATE_FAIL = 805;
     */
    RET_GADGET_CREATE_FAIL = 805,
    /**
     * @generated from protobuf enum value: RET_WORKTOP_OPTION_NOT_EXIST = 806;
     */
    RET_WORKTOP_OPTION_NOT_EXIST = 806,
    /**
     * @generated from protobuf enum value: RET_GADGET_STATUE_NOT_ACTIVE = 807;
     */
    RET_GADGET_STATUE_NOT_ACTIVE = 807,
    /**
     * @generated from protobuf enum value: RET_GADGET_STATUE_OPENED = 808;
     */
    RET_GADGET_STATUE_OPENED = 808,
    /**
     * @generated from protobuf enum value: RET_BOSS_CHEST_NO_QUALIFICATION = 809;
     */
    RET_BOSS_CHEST_NO_QUALIFICATION = 809,
    /**
     * @generated from protobuf enum value: RET_BOSS_CHEST_LIFE_TIME_OVER = 810;
     */
    RET_BOSS_CHEST_LIFE_TIME_OVER = 810,
    /**
     * @generated from protobuf enum value: RET_BOSS_CHEST_WEEK_NUM_LIMIT = 811;
     */
    RET_BOSS_CHEST_WEEK_NUM_LIMIT = 811,
    /**
     * @generated from protobuf enum value: RET_BOSS_CHEST_GUEST_WORLD_LEVEL = 812;
     */
    RET_BOSS_CHEST_GUEST_WORLD_LEVEL = 812,
    /**
     * @generated from protobuf enum value: RET_BOSS_CHEST_HAS_TAKEN = 813;
     */
    RET_BOSS_CHEST_HAS_TAKEN = 813,
    /**
     * @generated from protobuf enum value: RET_BLOSSOM_CHEST_NO_QUALIFICATION = 814;
     */
    RET_BLOSSOM_CHEST_NO_QUALIFICATION = 814,
    /**
     * @generated from protobuf enum value: RET_BLOSSOM_CHEST_LIFE_TIME_OVER = 815;
     */
    RET_BLOSSOM_CHEST_LIFE_TIME_OVER = 815,
    /**
     * @generated from protobuf enum value: RET_BLOSSOM_CHEST_HAS_TAKEN = 816;
     */
    RET_BLOSSOM_CHEST_HAS_TAKEN = 816,
    /**
     * @generated from protobuf enum value: RET_BLOSSOM_CHEST_GUEST_WORLD_LEVEL = 817;
     */
    RET_BLOSSOM_CHEST_GUEST_WORLD_LEVEL = 817,
    /**
     * @generated from protobuf enum value: RET_MP_PLAY_REWARD_NO_QUALIFICATION = 818;
     */
    RET_MP_PLAY_REWARD_NO_QUALIFICATION = 818,
    /**
     * @generated from protobuf enum value: RET_MP_PLAY_REWARD_HAS_TAKEN = 819;
     */
    RET_MP_PLAY_REWARD_HAS_TAKEN = 819,
    /**
     * @generated from protobuf enum value: RET_GENERAL_REWARD_NO_QUALIFICATION = 820;
     */
    RET_GENERAL_REWARD_NO_QUALIFICATION = 820,
    /**
     * @generated from protobuf enum value: RET_GENERAL_REWARD_LIFE_TIME_OVER = 821;
     */
    RET_GENERAL_REWARD_LIFE_TIME_OVER = 821,
    /**
     * @generated from protobuf enum value: RET_GENERAL_REWARD_HAS_TAKEN = 822;
     */
    RET_GENERAL_REWARD_HAS_TAKEN = 822,
    /**
     * @generated from protobuf enum value: RET_GADGET_NOT_VEHICLE = 823;
     */
    RET_GADGET_NOT_VEHICLE = 823,
    /**
     * @generated from protobuf enum value: RET_VEHICLE_SLOT_OCCUPIED = 824;
     */
    RET_VEHICLE_SLOT_OCCUPIED = 824,
    /**
     * @generated from protobuf enum value: RET_NOT_IN_VEHICLE = 825;
     */
    RET_NOT_IN_VEHICLE = 825,
    /**
     * @generated from protobuf enum value: RET_CREATE_VEHICLE_IN_CD = 826;
     */
    RET_CREATE_VEHICLE_IN_CD = 826,
    /**
     * @generated from protobuf enum value: RET_CREATE_VEHICLE_POS_INVALID = 827;
     */
    RET_CREATE_VEHICLE_POS_INVALID = 827,
    /**
     * @generated from protobuf enum value: RET_VEHICLE_POINT_NOT_UNLOCK = 828;
     */
    RET_VEHICLE_POINT_NOT_UNLOCK = 828,
    /**
     * @generated from protobuf enum value: RET_GADGET_INTERACT_COND_NOT_MEET = 829;
     */
    RET_GADGET_INTERACT_COND_NOT_MEET = 829,
    /**
     * @generated from protobuf enum value: RET_GADGET_INTERACT_PARAM_ERROR = 830;
     */
    RET_GADGET_INTERACT_PARAM_ERROR = 830,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_CLOSE = 860;
     */
    RET_ACTIVITY_CLOSE = 860,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_ITEM_ERROR = 861;
     */
    RET_ACTIVITY_ITEM_ERROR = 861,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_CONTRIBUTION_NOT_ENOUGH = 862;
     */
    RET_ACTIVITY_CONTRIBUTION_NOT_ENOUGH = 862,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_PHASE_NOT_FINISH = 863;
     */
    RET_SEA_LAMP_PHASE_NOT_FINISH = 863,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_FLY_NUM_LIMIT = 864;
     */
    RET_SEA_LAMP_FLY_NUM_LIMIT = 864,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_FLY_LAMP_WORD_ILLEGAL = 865;
     */
    RET_SEA_LAMP_FLY_LAMP_WORD_ILLEGAL = 865,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_WATCHER_REWARD_TAKEN = 866;
     */
    RET_ACTIVITY_WATCHER_REWARD_TAKEN = 866,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_WATCHER_REWARD_NOT_FINISHED = 867;
     */
    RET_ACTIVITY_WATCHER_REWARD_NOT_FINISHED = 867,
    /**
     * @generated from protobuf enum value: RET_SALESMAN_ALREADY_DELIVERED = 868;
     */
    RET_SALESMAN_ALREADY_DELIVERED = 868,
    /**
     * @generated from protobuf enum value: RET_SALESMAN_REWARD_COUNT_NOT_ENOUGH = 869;
     */
    RET_SALESMAN_REWARD_COUNT_NOT_ENOUGH = 869,
    /**
     * @generated from protobuf enum value: RET_SALESMAN_POSITION_INVALID = 870;
     */
    RET_SALESMAN_POSITION_INVALID = 870,
    /**
     * @generated from protobuf enum value: RET_DELIVER_NOT_FINISH_ALL_QUEST = 871;
     */
    RET_DELIVER_NOT_FINISH_ALL_QUEST = 871,
    /**
     * @generated from protobuf enum value: RET_DELIVER_ALREADY_TAKE_DAILY_REWARD = 872;
     */
    RET_DELIVER_ALREADY_TAKE_DAILY_REWARD = 872,
    /**
     * @generated from protobuf enum value: RET_ASTER_PROGRESS_EXCEED_LIMIT = 873;
     */
    RET_ASTER_PROGRESS_EXCEED_LIMIT = 873,
    /**
     * @generated from protobuf enum value: RET_ASTER_CREDIT_EXCEED_LIMIT = 874;
     */
    RET_ASTER_CREDIT_EXCEED_LIMIT = 874,
    /**
     * @generated from protobuf enum value: RET_ASTER_TOKEN_EXCEED_LIMIT = 875;
     */
    RET_ASTER_TOKEN_EXCEED_LIMIT = 875,
    /**
     * @generated from protobuf enum value: RET_ASTER_CREDIT_NOT_ENOUGH = 876;
     */
    RET_ASTER_CREDIT_NOT_ENOUGH = 876,
    /**
     * @generated from protobuf enum value: RET_ASTER_TOKEN_NOT_ENOUGH = 877;
     */
    RET_ASTER_TOKEN_NOT_ENOUGH = 877,
    /**
     * @generated from protobuf enum value: RET_ASTER_SPECIAL_REWARD_HAS_TAKEN = 878;
     */
    RET_ASTER_SPECIAL_REWARD_HAS_TAKEN = 878,
    /**
     * @generated from protobuf enum value: RET_FLIGHT_GROUP_ACTIVITY_NOT_STARTED = 879;
     */
    RET_FLIGHT_GROUP_ACTIVITY_NOT_STARTED = 879,
    /**
     * @generated from protobuf enum value: RET_ASTER_MID_PREVIOUS_BATTLE_NOT_FINISHED = 880;
     */
    RET_ASTER_MID_PREVIOUS_BATTLE_NOT_FINISHED = 880,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_SHIMMERING_ESSENCE_EXCEED_LIMIT = 881;
     */
    RET_DRAGON_SPINE_SHIMMERING_ESSENCE_EXCEED_LIMIT = 881,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_WARM_ESSENCE_EXCEED_LIMIT = 882;
     */
    RET_DRAGON_SPINE_WARM_ESSENCE_EXCEED_LIMIT = 882,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_WONDROUS_ESSENCE_EXCEED_LIMIT = 883;
     */
    RET_DRAGON_SPINE_WONDROUS_ESSENCE_EXCEED_LIMIT = 883,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_SHIMMERING_ESSENCE_NOT_ENOUGH = 884;
     */
    RET_DRAGON_SPINE_SHIMMERING_ESSENCE_NOT_ENOUGH = 884,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_WARM_ESSENCE_NOT_ENOUGH = 885;
     */
    RET_DRAGON_SPINE_WARM_ESSENCE_NOT_ENOUGH = 885,
    /**
     * @generated from protobuf enum value: RET_DRAGON_SPINE_WONDROUS_ESSENCE_NOT_ENOUGH = 886;
     */
    RET_DRAGON_SPINE_WONDROUS_ESSENCE_NOT_ENOUGH = 886,
    /**
     * @generated from protobuf enum value: RET_EFFIGY_FIRST_PASS_REWARD_HAS_TAKEN = 891;
     */
    RET_EFFIGY_FIRST_PASS_REWARD_HAS_TAKEN = 891,
    /**
     * @generated from protobuf enum value: RET_EFFIGY_REWARD_HAS_TAKEN = 892;
     */
    RET_EFFIGY_REWARD_HAS_TAKEN = 892,
    /**
     * @generated from protobuf enum value: RET_TREASURE_MAP_ADD_TOKEN_EXCEED_LIMIT = 893;
     */
    RET_TREASURE_MAP_ADD_TOKEN_EXCEED_LIMIT = 893,
    /**
     * @generated from protobuf enum value: RET_TREASURE_MAP_TOKEN_NOT_ENOUGHT = 894;
     */
    RET_TREASURE_MAP_TOKEN_NOT_ENOUGHT = 894,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_COIN_EXCEED_LIMIT = 895;
     */
    RET_SEA_LAMP_COIN_EXCEED_LIMIT = 895,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_COIN_NOT_ENOUGH = 896;
     */
    RET_SEA_LAMP_COIN_NOT_ENOUGH = 896,
    /**
     * @generated from protobuf enum value: RET_SEA_LAMP_POPULARITY_EXCEED_LIMIT = 897;
     */
    RET_SEA_LAMP_POPULARITY_EXCEED_LIMIT = 897,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_AVATAR_REWARD_NOT_OPEN = 898;
     */
    RET_ACTIVITY_AVATAR_REWARD_NOT_OPEN = 898,
    /**
     * @generated from protobuf enum value: RET_ACTIVITY_AVATAR_REWARD_HAS_TAKEN = 899;
     */
    RET_ACTIVITY_AVATAR_REWARD_HAS_TAKEN = 899,
    /**
     * @generated from protobuf enum value: RET_ARENA_ACTIVITY_ALREADY_STARTED = 900;
     */
    RET_ARENA_ACTIVITY_ALREADY_STARTED = 900,
    /**
     * @generated from protobuf enum value: RET_TALENT_ALREAY_UNLOCKED = 901;
     */
    RET_TALENT_ALREAY_UNLOCKED = 901,
    /**
     * @generated from protobuf enum value: RET_PREV_TALENT_NOT_UNLOCKED = 902;
     */
    RET_PREV_TALENT_NOT_UNLOCKED = 902,
    /**
     * @generated from protobuf enum value: RET_BIG_TALENT_POINT_NOT_ENOUGH = 903;
     */
    RET_BIG_TALENT_POINT_NOT_ENOUGH = 903,
    /**
     * @generated from protobuf enum value: RET_SMALL_TALENT_POINT_NOT_ENOUGH = 904;
     */
    RET_SMALL_TALENT_POINT_NOT_ENOUGH = 904,
    /**
     * @generated from protobuf enum value: RET_PROUD_SKILL_ALREADY_GOT = 905;
     */
    RET_PROUD_SKILL_ALREADY_GOT = 905,
    /**
     * @generated from protobuf enum value: RET_PREV_PROUD_SKILL_NOT_GET = 906;
     */
    RET_PREV_PROUD_SKILL_NOT_GET = 906,
    /**
     * @generated from protobuf enum value: RET_PROUD_SKILL_MAX_LEVEL = 907;
     */
    RET_PROUD_SKILL_MAX_LEVEL = 907,
    /**
     * @generated from protobuf enum value: RET_CANDIDATE_SKILL_DEPOT_ID_NOT_FIND = 910;
     */
    RET_CANDIDATE_SKILL_DEPOT_ID_NOT_FIND = 910,
    /**
     * @generated from protobuf enum value: RET_SKILL_DEPOT_IS_THE_SAME = 911;
     */
    RET_SKILL_DEPOT_IS_THE_SAME = 911,
    /**
     * @generated from protobuf enum value: RET_MONSTER_NOT_EXIST = 1001;
     */
    RET_MONSTER_NOT_EXIST = 1001,
    /**
     * @generated from protobuf enum value: RET_MONSTER_CREATE_FAIL = 1002;
     */
    RET_MONSTER_CREATE_FAIL = 1002,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_ENTER_FAIL = 1101;
     */
    RET_DUNGEON_ENTER_FAIL = 1101,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_QUIT_FAIL = 1102;
     */
    RET_DUNGEON_QUIT_FAIL = 1102,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_ENTER_EXCEED_DAY_COUNT = 1103;
     */
    RET_DUNGEON_ENTER_EXCEED_DAY_COUNT = 1103,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_REVIVE_EXCEED_MAX_COUNT = 1104;
     */
    RET_DUNGEON_REVIVE_EXCEED_MAX_COUNT = 1104,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_REVIVE_FAIL = 1105;
     */
    RET_DUNGEON_REVIVE_FAIL = 1105,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_NOT_SUCCEED = 1106;
     */
    RET_DUNGEON_NOT_SUCCEED = 1106,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CAN_NOT_CANCEL = 1107;
     */
    RET_DUNGEON_CAN_NOT_CANCEL = 1107,
    /**
     * @generated from protobuf enum value: RET_DEST_DUNGEON_SETTLED = 1108;
     */
    RET_DEST_DUNGEON_SETTLED = 1108,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_TEAM_IS_FULL = 1109;
     */
    RET_DUNGEON_CANDIDATE_TEAM_IS_FULL = 1109,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_TEAM_IS_DISMISS = 1110;
     */
    RET_DUNGEON_CANDIDATE_TEAM_IS_DISMISS = 1110,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_TEAM_NOT_ALL_READY = 1111;
     */
    RET_DUNGEON_CANDIDATE_TEAM_NOT_ALL_READY = 1111,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_TEAM_HAS_REPEAT_AVATAR = 1112;
     */
    RET_DUNGEON_CANDIDATE_TEAM_HAS_REPEAT_AVATAR = 1112,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_NOT_SINGEL_PASS = 1113;
     */
    RET_DUNGEON_CANDIDATE_NOT_SINGEL_PASS = 1113,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_REPLAY_NEED_ALL_PLAYER_DIE = 1114;
     */
    RET_DUNGEON_REPLAY_NEED_ALL_PLAYER_DIE = 1114,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_REPLAY_HAS_REVIVE_COUNT = 1115;
     */
    RET_DUNGEON_REPLAY_HAS_REVIVE_COUNT = 1115,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_OTHERS_LEAVE = 1116;
     */
    RET_DUNGEON_OTHERS_LEAVE = 1116,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_ENTER_LEVEL_LIMIT = 1117;
     */
    RET_DUNGEON_ENTER_LEVEL_LIMIT = 1117,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANNOT_ENTER_PLOT_IN_MP = 1118;
     */
    RET_DUNGEON_CANNOT_ENTER_PLOT_IN_MP = 1118,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_DROP_SUBFIELD_LIMIT = 1119;
     */
    RET_DUNGEON_DROP_SUBFIELD_LIMIT = 1119,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_BE_INVITE_PLAYER_AVATAR_ALL_DIE = 1120;
     */
    RET_DUNGEON_BE_INVITE_PLAYER_AVATAR_ALL_DIE = 1120,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANNOT_KICK = 1121;
     */
    RET_DUNGEON_CANNOT_KICK = 1121,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_CANDIDATE_TEAM_SOMEONE_LEVEL_LIMIT = 1122;
     */
    RET_DUNGEON_CANDIDATE_TEAM_SOMEONE_LEVEL_LIMIT = 1122,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_IN_FORCE_QUIT = 1123;
     */
    RET_DUNGEON_IN_FORCE_QUIT = 1123,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_GUEST_QUIT_DUNGEON = 1124;
     */
    RET_DUNGEON_GUEST_QUIT_DUNGEON = 1124,
    /**
     * @generated from protobuf enum value: RET_DUNGEON_TICKET_FAIL = 1125;
     */
    RET_DUNGEON_TICKET_FAIL = 1125,
    /**
     * @generated from protobuf enum value: RET_MP_NOT_IN_MY_WORLD = 1201;
     */
    RET_MP_NOT_IN_MY_WORLD = 1201,
    /**
     * @generated from protobuf enum value: RET_MP_IN_MP_MODE = 1202;
     */
    RET_MP_IN_MP_MODE = 1202,
    /**
     * @generated from protobuf enum value: RET_MP_SCENE_IS_FULL = 1203;
     */
    RET_MP_SCENE_IS_FULL = 1203,
    /**
     * @generated from protobuf enum value: RET_MP_MODE_NOT_AVAILABLE = 1204;
     */
    RET_MP_MODE_NOT_AVAILABLE = 1204,
    /**
     * @generated from protobuf enum value: RET_MP_PLAYER_NOT_ENTERABLE = 1205;
     */
    RET_MP_PLAYER_NOT_ENTERABLE = 1205,
    /**
     * @generated from protobuf enum value: RET_MP_QUEST_BLOCK_MP = 1206;
     */
    RET_MP_QUEST_BLOCK_MP = 1206,
    /**
     * @generated from protobuf enum value: RET_MP_IN_ROOM_SCENE = 1207;
     */
    RET_MP_IN_ROOM_SCENE = 1207,
    /**
     * @generated from protobuf enum value: RET_MP_WORLD_IS_FULL = 1208;
     */
    RET_MP_WORLD_IS_FULL = 1208,
    /**
     * @generated from protobuf enum value: RET_MP_PLAYER_NOT_ALLOW_ENTER = 1209;
     */
    RET_MP_PLAYER_NOT_ALLOW_ENTER = 1209,
    /**
     * @generated from protobuf enum value: RET_MP_PLAYER_DISCONNECTED = 1210;
     */
    RET_MP_PLAYER_DISCONNECTED = 1210,
    /**
     * @generated from protobuf enum value: RET_MP_NOT_IN_MP_MODE = 1211;
     */
    RET_MP_NOT_IN_MP_MODE = 1211,
    /**
     * @generated from protobuf enum value: RET_MP_OWNER_NOT_ENTER = 1212;
     */
    RET_MP_OWNER_NOT_ENTER = 1212,
    /**
     * @generated from protobuf enum value: RET_MP_ALLOW_ENTER_PLAYER_FULL = 1213;
     */
    RET_MP_ALLOW_ENTER_PLAYER_FULL = 1213,
    /**
     * @generated from protobuf enum value: RET_MP_TARGET_PLAYER_IN_TRANSFER = 1214;
     */
    RET_MP_TARGET_PLAYER_IN_TRANSFER = 1214,
    /**
     * @generated from protobuf enum value: RET_MP_TARGET_ENTERING_OTHER = 1215;
     */
    RET_MP_TARGET_ENTERING_OTHER = 1215,
    /**
     * @generated from protobuf enum value: RET_MP_OTHER_ENTERING = 1216;
     */
    RET_MP_OTHER_ENTERING = 1216,
    /**
     * @generated from protobuf enum value: RET_MP_ENTER_MAIN_PLAYER_IN_PLOT = 1217;
     */
    RET_MP_ENTER_MAIN_PLAYER_IN_PLOT = 1217,
    /**
     * @generated from protobuf enum value: RET_MP_NOT_PS_PLAYER = 1218;
     */
    RET_MP_NOT_PS_PLAYER = 1218,
    /**
     * @generated from protobuf enum value: RET_MP_PLAY_NOT_ACTIVE = 1219;
     */
    RET_MP_PLAY_NOT_ACTIVE = 1219,
    /**
     * @generated from protobuf enum value: RET_MP_PLAY_REMAIN_REWARDS = 1220;
     */
    RET_MP_PLAY_REMAIN_REWARDS = 1220,
    /**
     * @generated from protobuf enum value: RET_MP_PLAY_NO_REWARD = 1221;
     */
    RET_MP_PLAY_NO_REWARD = 1221,
    /**
     * @generated from protobuf enum value: RET_MP_OPEN_STATE_FAIL = 1223;
     */
    RET_MP_OPEN_STATE_FAIL = 1223,
    /**
     * @generated from protobuf enum value: RET_MP_PLAYER_IN_BLACKLIST = 1224;
     */
    RET_MP_PLAYER_IN_BLACKLIST = 1224,
    /**
     * @generated from protobuf enum value: RET_MP_REPLY_TIMEOUT = 1225;
     */
    RET_MP_REPLY_TIMEOUT = 1225,
    /**
     * @generated from protobuf enum value: RET_MP_IS_BLOCK = 1226;
     */
    RET_MP_IS_BLOCK = 1226,
    /**
     * @generated from protobuf enum value: RET_MP_ENTER_MAIN_PLAYER_IN_MP_PLAY = 1227;
     */
    RET_MP_ENTER_MAIN_PLAYER_IN_MP_PLAY = 1227,
    /**
     * @generated from protobuf enum value: RET_MP_IN_MP_PLAY_BATTLE = 1228;
     */
    RET_MP_IN_MP_PLAY_BATTLE = 1228,
    /**
     * @generated from protobuf enum value: RET_MP_GUEST_HAS_REWARD_REMAINED = 1229;
     */
    RET_MP_GUEST_HAS_REWARD_REMAINED = 1229,
    /**
     * @generated from protobuf enum value: RET_MP_QUIT_MP_INVALID = 1230;
     */
    RET_MP_QUIT_MP_INVALID = 1230,
    /**
     * @generated from protobuf enum value: RET_MP_OTHER_DATA_VERSION_NOT_LATEST = 1231;
     */
    RET_MP_OTHER_DATA_VERSION_NOT_LATEST = 1231,
    /**
     * @generated from protobuf enum value: RET_MP_DATA_VERSION_NOT_LATEST = 1232;
     */
    RET_MP_DATA_VERSION_NOT_LATEST = 1232,
    /**
     * @generated from protobuf enum value: RET_MP_CUR_WORLD_NOT_ENTERABLE = 1233;
     */
    RET_MP_CUR_WORLD_NOT_ENTERABLE = 1233,
    /**
     * @generated from protobuf enum value: RET_MP_ANY_GALLERY_STARTED = 1234;
     */
    RET_MP_ANY_GALLERY_STARTED = 1234,
    /**
     * @generated from protobuf enum value: RET_MP_HAS_ACTIVE_DRAFT = 1235;
     */
    RET_MP_HAS_ACTIVE_DRAFT = 1235,
    /**
     * @generated from protobuf enum value: RET_MP_PLAYER_IN_DUNGEON = 1236;
     */
    RET_MP_PLAYER_IN_DUNGEON = 1236,
    /**
     * @generated from protobuf enum value: RET_MP_MATCH_FULL = 1237;
     */
    RET_MP_MATCH_FULL = 1237,
    /**
     * @generated from protobuf enum value: RET_MP_MATCH_LIMIT = 1238;
     */
    RET_MP_MATCH_LIMIT = 1238,
    /**
     * @generated from protobuf enum value: RET_MP_MATCH_IN_PUNISH = 1239;
     */
    RET_MP_MATCH_IN_PUNISH = 1239,
    /**
     * @generated from protobuf enum value: RET_MP_IS_IN_MULTISTAGE = 1240;
     */
    RET_MP_IS_IN_MULTISTAGE = 1240,
    /**
     * @generated from protobuf enum value: RET_MP_MATCH_PLAY_NOT_OPEN = 1241;
     */
    RET_MP_MATCH_PLAY_NOT_OPEN = 1241,
    /**
     * @generated from protobuf enum value: RET_MP_ONLY_MP_WITH_PS_PLAYER = 1242;
     */
    RET_MP_ONLY_MP_WITH_PS_PLAYER = 1242,
    /**
     * @generated from protobuf enum value: RET_MP_GUEST_LOADING_FIRST_ENTER = 1243;
     */
    RET_MP_GUEST_LOADING_FIRST_ENTER = 1243,
    /**
     * @generated from protobuf enum value: RET_MP_SUMMER_TIME_SPRINT_BOAT_ONGOING = 1244;
     */
    RET_MP_SUMMER_TIME_SPRINT_BOAT_ONGOING = 1244,
    /**
     * @generated from protobuf enum value: RET_MP_BLITZ_RUSH_PARKOUR_CHALLENGE_ONGOING = 1245;
     */
    RET_MP_BLITZ_RUSH_PARKOUR_CHALLENGE_ONGOING = 1245,
    /**
     * @generated from protobuf enum value: RET_MP_MUSIC_GAME_ONGOING = 1246;
     */
    RET_MP_MUSIC_GAME_ONGOING = 1246,
    /**
     * @generated from protobuf enum value: RET_MAIL_PARA_ERR = 1301;
     */
    RET_MAIL_PARA_ERR = 1301,
    /**
     * @generated from protobuf enum value: RET_MAIL_MAX_NUM = 1302;
     */
    RET_MAIL_MAX_NUM = 1302,
    /**
     * @generated from protobuf enum value: RET_MAIL_ITEM_NUM_EXCEED = 1303;
     */
    RET_MAIL_ITEM_NUM_EXCEED = 1303,
    /**
     * @generated from protobuf enum value: RET_MAIL_TITLE_LEN_EXCEED = 1304;
     */
    RET_MAIL_TITLE_LEN_EXCEED = 1304,
    /**
     * @generated from protobuf enum value: RET_MAIL_CONTENT_LEN_EXCEED = 1305;
     */
    RET_MAIL_CONTENT_LEN_EXCEED = 1305,
    /**
     * @generated from protobuf enum value: RET_MAIL_SENDER_LEN_EXCEED = 1306;
     */
    RET_MAIL_SENDER_LEN_EXCEED = 1306,
    /**
     * @generated from protobuf enum value: RET_MAIL_PARSE_PACKET_FAIL = 1307;
     */
    RET_MAIL_PARSE_PACKET_FAIL = 1307,
    /**
     * @generated from protobuf enum value: RET_OFFLINE_MSG_MAX_NUM = 1308;
     */
    RET_OFFLINE_MSG_MAX_NUM = 1308,
    /**
     * @generated from protobuf enum value: RET_OFFLINE_MSG_SAME_TICKET = 1309;
     */
    RET_OFFLINE_MSG_SAME_TICKET = 1309,
    /**
     * @generated from protobuf enum value: RET_MAIL_EXCEL_MAIL_TYPE_ERROR = 1310;
     */
    RET_MAIL_EXCEL_MAIL_TYPE_ERROR = 1310,
    /**
     * @generated from protobuf enum value: RET_MAIL_CANNOT_SEND_MCOIN = 1311;
     */
    RET_MAIL_CANNOT_SEND_MCOIN = 1311,
    /**
     * @generated from protobuf enum value: RET_MAIL_HCOIN_EXCEED_LIMIT = 1312;
     */
    RET_MAIL_HCOIN_EXCEED_LIMIT = 1312,
    /**
     * @generated from protobuf enum value: RET_MAIL_SCOIN_EXCEED_LIMIT = 1313;
     */
    RET_MAIL_SCOIN_EXCEED_LIMIT = 1313,
    /**
     * @generated from protobuf enum value: RET_MAIL_MATERIAL_ID_INVALID = 1314;
     */
    RET_MAIL_MATERIAL_ID_INVALID = 1314,
    /**
     * @generated from protobuf enum value: RET_MAIL_AVATAR_EXCEED_LIMIT = 1315;
     */
    RET_MAIL_AVATAR_EXCEED_LIMIT = 1315,
    /**
     * @generated from protobuf enum value: RET_MAIL_GACHA_TICKET_ETC_EXCEED_LIMIT = 1316;
     */
    RET_MAIL_GACHA_TICKET_ETC_EXCEED_LIMIT = 1316,
    /**
     * @generated from protobuf enum value: RET_MAIL_ITEM_EXCEED_CEHUA_LIMIT = 1317;
     */
    RET_MAIL_ITEM_EXCEED_CEHUA_LIMIT = 1317,
    /**
     * @generated from protobuf enum value: RET_MAIL_SPACE_OR_REST_NUM_NOT_ENOUGH = 1318;
     */
    RET_MAIL_SPACE_OR_REST_NUM_NOT_ENOUGH = 1318,
    /**
     * @generated from protobuf enum value: RET_MAIL_TICKET_IS_EMPTY = 1319;
     */
    RET_MAIL_TICKET_IS_EMPTY = 1319,
    /**
     * @generated from protobuf enum value: RET_MAIL_TRANSACTION_IS_EMPTY = 1320;
     */
    RET_MAIL_TRANSACTION_IS_EMPTY = 1320,
    /**
     * @generated from protobuf enum value: RET_DAILY_TASK_NOT_FINISH = 1330;
     */
    RET_DAILY_TASK_NOT_FINISH = 1330,
    /**
     * @generated from protobuf enum value: RET_DAILY_TAKS_HAS_TAKEN = 1331;
     */
    RET_DAILY_TAKS_HAS_TAKEN = 1331,
    /**
     * @generated from protobuf enum value: RET_SOCIAL_OFFLINE_MSG_NUM_EXCEED = 1332;
     */
    RET_SOCIAL_OFFLINE_MSG_NUM_EXCEED = 1332,
    /**
     * @generated from protobuf enum value: RET_DAILY_TASK_FILTER_CITY_NOT_OPEN = 1333;
     */
    RET_DAILY_TASK_FILTER_CITY_NOT_OPEN = 1333,
    /**
     * @generated from protobuf enum value: RET_GACHA_INAVAILABLE = 1401;
     */
    RET_GACHA_INAVAILABLE = 1401,
    /**
     * @generated from protobuf enum value: RET_GACHA_RANDOM_NOT_MATCH = 1402;
     */
    RET_GACHA_RANDOM_NOT_MATCH = 1402,
    /**
     * @generated from protobuf enum value: RET_GACHA_SCHEDULE_NOT_MATCH = 1403;
     */
    RET_GACHA_SCHEDULE_NOT_MATCH = 1403,
    /**
     * @generated from protobuf enum value: RET_GACHA_INVALID_TIMES = 1404;
     */
    RET_GACHA_INVALID_TIMES = 1404,
    /**
     * @generated from protobuf enum value: RET_GACHA_COST_ITEM_NOT_ENOUGH = 1405;
     */
    RET_GACHA_COST_ITEM_NOT_ENOUGH = 1405,
    /**
     * @generated from protobuf enum value: RET_GACHA_TIMES_LIMIT = 1406;
     */
    RET_GACHA_TIMES_LIMIT = 1406,
    /**
     * @generated from protobuf enum value: RET_GACHA_WISH_SAME_ITEM = 1407;
     */
    RET_GACHA_WISH_SAME_ITEM = 1407,
    /**
     * @generated from protobuf enum value: RET_GACHA_WISH_INVALID_ITEM = 1408;
     */
    RET_GACHA_WISH_INVALID_ITEM = 1408,
    /**
     * @generated from protobuf enum value: RET_INVESTIGAITON_NOT_IN_PROGRESS = 1501;
     */
    RET_INVESTIGAITON_NOT_IN_PROGRESS = 1501,
    /**
     * @generated from protobuf enum value: RET_INVESTIGAITON_UNCOMPLETE = 1502;
     */
    RET_INVESTIGAITON_UNCOMPLETE = 1502,
    /**
     * @generated from protobuf enum value: RET_INVESTIGAITON_REWARD_TAKEN = 1503;
     */
    RET_INVESTIGAITON_REWARD_TAKEN = 1503,
    /**
     * @generated from protobuf enum value: RET_INVESTIGAITON_TARGET_STATE_ERROR = 1504;
     */
    RET_INVESTIGAITON_TARGET_STATE_ERROR = 1504,
    /**
     * @generated from protobuf enum value: RET_PUSH_TIPS_NOT_FOUND = 1505;
     */
    RET_PUSH_TIPS_NOT_FOUND = 1505,
    /**
     * @generated from protobuf enum value: RET_SIGN_IN_RECORD_NOT_FOUND = 1506;
     */
    RET_SIGN_IN_RECORD_NOT_FOUND = 1506,
    /**
     * @generated from protobuf enum value: RET_ALREADY_HAVE_SIGNED_IN = 1507;
     */
    RET_ALREADY_HAVE_SIGNED_IN = 1507,
    /**
     * @generated from protobuf enum value: RET_SIGN_IN_COND_NOT_SATISFIED = 1508;
     */
    RET_SIGN_IN_COND_NOT_SATISFIED = 1508,
    /**
     * @generated from protobuf enum value: RET_BONUS_ACTIVITY_NOT_UNREWARDED = 1509;
     */
    RET_BONUS_ACTIVITY_NOT_UNREWARDED = 1509,
    /**
     * @generated from protobuf enum value: RET_SIGN_IN_REWARDED = 1510;
     */
    RET_SIGN_IN_REWARDED = 1510,
    /**
     * @generated from protobuf enum value: RET_TOWER_NOT_OPEN = 1521;
     */
    RET_TOWER_NOT_OPEN = 1521,
    /**
     * @generated from protobuf enum value: RET_TOWER_HAVE_DAILY_RECORD = 1522;
     */
    RET_TOWER_HAVE_DAILY_RECORD = 1522,
    /**
     * @generated from protobuf enum value: RET_TOWER_NOT_RECORD = 1523;
     */
    RET_TOWER_NOT_RECORD = 1523,
    /**
     * @generated from protobuf enum value: RET_TOWER_HAVE_RECORD = 1524;
     */
    RET_TOWER_HAVE_RECORD = 1524,
    /**
     * @generated from protobuf enum value: RET_TOWER_TEAM_NUM_ERROR = 1525;
     */
    RET_TOWER_TEAM_NUM_ERROR = 1525,
    /**
     * @generated from protobuf enum value: RET_TOWER_FLOOR_NOT_OPEN = 1526;
     */
    RET_TOWER_FLOOR_NOT_OPEN = 1526,
    /**
     * @generated from protobuf enum value: RET_TOWER_NO_FLOOR_STAR_RECORD = 1527;
     */
    RET_TOWER_NO_FLOOR_STAR_RECORD = 1527,
    /**
     * @generated from protobuf enum value: RET_ALREADY_HAS_TOWER_BUFF = 1528;
     */
    RET_ALREADY_HAS_TOWER_BUFF = 1528,
    /**
     * @generated from protobuf enum value: RET_DUPLICATE_ENTER_LEVEL = 1529;
     */
    RET_DUPLICATE_ENTER_LEVEL = 1529,
    /**
     * @generated from protobuf enum value: RET_NOT_IN_TOWER_LEVEL = 1530;
     */
    RET_NOT_IN_TOWER_LEVEL = 1530,
    /**
     * @generated from protobuf enum value: RET_IN_TOWER_LEVEL = 1531;
     */
    RET_IN_TOWER_LEVEL = 1531,
    /**
     * @generated from protobuf enum value: RET_TOWER_PREV_FLOOR_NOT_FINISH = 1532;
     */
    RET_TOWER_PREV_FLOOR_NOT_FINISH = 1532,
    /**
     * @generated from protobuf enum value: RET_TOWER_STAR_NOT_ENOUGH = 1533;
     */
    RET_TOWER_STAR_NOT_ENOUGH = 1533,
    /**
     * @generated from protobuf enum value: RET_BATTLE_PASS_NO_SCHEDULE = 1541;
     */
    RET_BATTLE_PASS_NO_SCHEDULE = 1541,
    /**
     * @generated from protobuf enum value: RET_BATTLE_PASS_HAS_BUYED = 1542;
     */
    RET_BATTLE_PASS_HAS_BUYED = 1542,
    /**
     * @generated from protobuf enum value: RET_BATTLE_PASS_LEVEL_OVERFLOW = 1543;
     */
    RET_BATTLE_PASS_LEVEL_OVERFLOW = 1543,
    /**
     * @generated from protobuf enum value: RET_BATTLE_PASS_PRODUCT_EXPIRED = 1544;
     */
    RET_BATTLE_PASS_PRODUCT_EXPIRED = 1544,
    /**
     * @generated from protobuf enum value: RET_MATCH_HOST_QUIT = 1561;
     */
    RET_MATCH_HOST_QUIT = 1561,
    /**
     * @generated from protobuf enum value: RET_MATCH_ALREADY_IN_MATCH = 1562;
     */
    RET_MATCH_ALREADY_IN_MATCH = 1562,
    /**
     * @generated from protobuf enum value: RET_MATCH_NOT_IN_MATCH = 1563;
     */
    RET_MATCH_NOT_IN_MATCH = 1563,
    /**
     * @generated from protobuf enum value: RET_MATCH_APPLYING_ENTER_MP = 1564;
     */
    RET_MATCH_APPLYING_ENTER_MP = 1564,
    /**
     * @generated from protobuf enum value: RET_WIDGET_TREASURE_SPOT_NOT_FOUND = 1581;
     */
    RET_WIDGET_TREASURE_SPOT_NOT_FOUND = 1581,
    /**
     * @generated from protobuf enum value: RET_WIDGET_TREASURE_ENTITY_EXISTS = 1582;
     */
    RET_WIDGET_TREASURE_ENTITY_EXISTS = 1582,
    /**
     * @generated from protobuf enum value: RET_WIDGET_TREASURE_SPOT_FAR_AWAY = 1583;
     */
    RET_WIDGET_TREASURE_SPOT_FAR_AWAY = 1583,
    /**
     * @generated from protobuf enum value: RET_WIDGET_TREASURE_FINISHED_TODAY = 1584;
     */
    RET_WIDGET_TREASURE_FINISHED_TODAY = 1584,
    /**
     * @generated from protobuf enum value: RET_WIDGET_QUICK_USE_REQ_PARAM_ERROR = 1585;
     */
    RET_WIDGET_QUICK_USE_REQ_PARAM_ERROR = 1585,
    /**
     * @generated from protobuf enum value: RET_WIDGET_CAMERA_SCAN_ID_ERROR = 1586;
     */
    RET_WIDGET_CAMERA_SCAN_ID_ERROR = 1586,
    /**
     * @generated from protobuf enum value: RET_WIDGET_NOT_ACTIVE = 1587;
     */
    RET_WIDGET_NOT_ACTIVE = 1587,
    /**
     * @generated from protobuf enum value: RET_WIDGET_FEATHER_NOT_ACTIVE = 1588;
     */
    RET_WIDGET_FEATHER_NOT_ACTIVE = 1588,
    /**
     * @generated from protobuf enum value: RET_WIDGET_FEATHER_GADGET_TOO_FAR_AWAY = 1589;
     */
    RET_WIDGET_FEATHER_GADGET_TOO_FAR_AWAY = 1589,
    /**
     * @generated from protobuf enum value: RET_UID_NOT_EXIST = 2001;
     */
    RET_UID_NOT_EXIST = 2001,
    /**
     * @generated from protobuf enum value: RET_PARSE_BIN_ERROR = 2002;
     */
    RET_PARSE_BIN_ERROR = 2002,
    /**
     * @generated from protobuf enum value: RET_ACCOUNT_INFO_NOT_EXIST = 2003;
     */
    RET_ACCOUNT_INFO_NOT_EXIST = 2003,
    /**
     * @generated from protobuf enum value: RET_ORDER_INFO_NOT_EXIST = 2004;
     */
    RET_ORDER_INFO_NOT_EXIST = 2004,
    /**
     * @generated from protobuf enum value: RET_SNAPSHOT_INDEX_ERROR = 2005;
     */
    RET_SNAPSHOT_INDEX_ERROR = 2005,
    /**
     * @generated from protobuf enum value: RET_MAIL_HAS_BEEN_SENT = 2006;
     */
    RET_MAIL_HAS_BEEN_SENT = 2006,
    /**
     * @generated from protobuf enum value: RET_PRODUCT_NOT_EXIST = 2007;
     */
    RET_PRODUCT_NOT_EXIST = 2007,
    /**
     * @generated from protobuf enum value: RET_UNFINISH_ORDER = 2008;
     */
    RET_UNFINISH_ORDER = 2008,
    /**
     * @generated from protobuf enum value: RET_ID_NOT_EXIST = 2009;
     */
    RET_ID_NOT_EXIST = 2009,
    /**
     * @generated from protobuf enum value: RET_ORDER_TRADE_EARLY = 2010;
     */
    RET_ORDER_TRADE_EARLY = 2010,
    /**
     * @generated from protobuf enum value: RET_ORDER_FINISHED = 2011;
     */
    RET_ORDER_FINISHED = 2011,
    /**
     * @generated from protobuf enum value: RET_GAMESERVER_VERSION_WRONG = 2012;
     */
    RET_GAMESERVER_VERSION_WRONG = 2012,
    /**
     * @generated from protobuf enum value: RET_OFFLINE_OP_FULL_LENGTH = 2013;
     */
    RET_OFFLINE_OP_FULL_LENGTH = 2013,
    /**
     * @generated from protobuf enum value: RET_CONCERT_PRODUCT_OBTAIN_LIMIT = 2014;
     */
    RET_CONCERT_PRODUCT_OBTAIN_LIMIT = 2014,
    /**
     * @generated from protobuf enum value: RET_CONCERT_PRODUCT_TICKET_DUPLICATED = 2015;
     */
    RET_CONCERT_PRODUCT_TICKET_DUPLICATED = 2015,
    /**
     * @generated from protobuf enum value: RET_CONCERT_PRODUCT_TICKET_EMPTY = 2016;
     */
    RET_CONCERT_PRODUCT_TICKET_EMPTY = 2016,
    /**
     * @generated from protobuf enum value: RET_REDIS_MODIFIED = 5001;
     */
    RET_REDIS_MODIFIED = 5001,
    /**
     * @generated from protobuf enum value: RET_REDIS_UID_NOT_EXIST = 5002;
     */
    RET_REDIS_UID_NOT_EXIST = 5002,
    /**
     * @generated from protobuf enum value: RET_PATHFINDING_DATA_NOT_EXIST = 6001;
     */
    RET_PATHFINDING_DATA_NOT_EXIST = 6001,
    /**
     * @generated from protobuf enum value: RET_PATHFINDING_DESTINATION_NOT_EXIST = 6002;
     */
    RET_PATHFINDING_DESTINATION_NOT_EXIST = 6002,
    /**
     * @generated from protobuf enum value: RET_PATHFINDING_ERROR_SCENE = 6003;
     */
    RET_PATHFINDING_ERROR_SCENE = 6003,
    /**
     * @generated from protobuf enum value: RET_PATHFINDING_SCENE_DATA_LOADING = 6004;
     */
    RET_PATHFINDING_SCENE_DATA_LOADING = 6004,
    /**
     * @generated from protobuf enum value: RET_FRIEND_COUNT_EXCEEDED = 7001;
     */
    RET_FRIEND_COUNT_EXCEEDED = 7001,
    /**
     * @generated from protobuf enum value: RET_PLAYER_NOT_EXIST = 7002;
     */
    RET_PLAYER_NOT_EXIST = 7002,
    /**
     * @generated from protobuf enum value: RET_ALREADY_SENT_ADD_REQUEST = 7003;
     */
    RET_ALREADY_SENT_ADD_REQUEST = 7003,
    /**
     * @generated from protobuf enum value: RET_ASK_FRIEND_LIST_FULL = 7004;
     */
    RET_ASK_FRIEND_LIST_FULL = 7004,
    /**
     * @generated from protobuf enum value: RET_PLAYER_ALREADY_IS_FRIEND = 7005;
     */
    RET_PLAYER_ALREADY_IS_FRIEND = 7005,
    /**
     * @generated from protobuf enum value: RET_PLAYER_NOT_ASK_FRIEND = 7006;
     */
    RET_PLAYER_NOT_ASK_FRIEND = 7006,
    /**
     * @generated from protobuf enum value: RET_TARGET_FRIEND_COUNT_EXCEED = 7007;
     */
    RET_TARGET_FRIEND_COUNT_EXCEED = 7007,
    /**
     * @generated from protobuf enum value: RET_NOT_FRIEND = 7008;
     */
    RET_NOT_FRIEND = 7008,
    /**
     * @generated from protobuf enum value: RET_BIRTHDAY_CANNOT_BE_SET_TWICE = 7009;
     */
    RET_BIRTHDAY_CANNOT_BE_SET_TWICE = 7009,
    /**
     * @generated from protobuf enum value: RET_CANNOT_ADD_SELF_FRIEND = 7010;
     */
    RET_CANNOT_ADD_SELF_FRIEND = 7010,
    /**
     * @generated from protobuf enum value: RET_SIGNATURE_ILLEGAL = 7011;
     */
    RET_SIGNATURE_ILLEGAL = 7011,
    /**
     * @generated from protobuf enum value: RET_PS_PLAYER_CANNOT_ADD_FRIENDS = 7012;
     */
    RET_PS_PLAYER_CANNOT_ADD_FRIENDS = 7012,
    /**
     * @generated from protobuf enum value: RET_PS_PLAYER_CANNOT_REMOVE_FRIENDS = 7013;
     */
    RET_PS_PLAYER_CANNOT_REMOVE_FRIENDS = 7013,
    /**
     * @generated from protobuf enum value: RET_NAME_CARD_NOT_UNLOCKED = 7014;
     */
    RET_NAME_CARD_NOT_UNLOCKED = 7014,
    /**
     * @generated from protobuf enum value: RET_ALREADY_IN_BLACKLIST = 7015;
     */
    RET_ALREADY_IN_BLACKLIST = 7015,
    /**
     * @generated from protobuf enum value: RET_PS_PALEYRS_CANNOT_ADD_BLACKLIST = 7016;
     */
    RET_PS_PALEYRS_CANNOT_ADD_BLACKLIST = 7016,
    /**
     * @generated from protobuf enum value: RET_PLAYER_BLACKLIST_FULL = 7017;
     */
    RET_PLAYER_BLACKLIST_FULL = 7017,
    /**
     * @generated from protobuf enum value: RET_PLAYER_NOT_IN_BLACKLIST = 7018;
     */
    RET_PLAYER_NOT_IN_BLACKLIST = 7018,
    /**
     * @generated from protobuf enum value: RET_BLACKLIST_PLAYER_CANNOT_ADD_FRIEND = 7019;
     */
    RET_BLACKLIST_PLAYER_CANNOT_ADD_FRIEND = 7019,
    /**
     * @generated from protobuf enum value: RET_IN_TARGET_BLACKLIST = 7020;
     */
    RET_IN_TARGET_BLACKLIST = 7020,
    /**
     * @generated from protobuf enum value: RET_CANNOT_ADD_TARGET_FRIEND = 7021;
     */
    RET_CANNOT_ADD_TARGET_FRIEND = 7021,
    /**
     * @generated from protobuf enum value: RET_BIRTHDAY_FORMAT_ERROR = 7022;
     */
    RET_BIRTHDAY_FORMAT_ERROR = 7022,
    /**
     * @generated from protobuf enum value: RET_ONLINE_ID_NOT_EXISTS = 7023;
     */
    RET_ONLINE_ID_NOT_EXISTS = 7023,
    /**
     * @generated from protobuf enum value: RET_FIRST_SHARE_REWARD_HAS_TAKEN = 7024;
     */
    RET_FIRST_SHARE_REWARD_HAS_TAKEN = 7024,
    /**
     * @generated from protobuf enum value: RET_PS_PLAYER_CANNOT_REMOVE_BLACKLIST = 7025;
     */
    RET_PS_PLAYER_CANNOT_REMOVE_BLACKLIST = 7025,
    /**
     * @generated from protobuf enum value: RET_REPORT_CD = 7026;
     */
    RET_REPORT_CD = 7026,
    /**
     * @generated from protobuf enum value: RET_REPORT_CONTENT_ILLEGAL = 7027;
     */
    RET_REPORT_CONTENT_ILLEGAL = 7027,
    /**
     * @generated from protobuf enum value: RET_REMARK_WORD_ILLEGAL = 7028;
     */
    RET_REMARK_WORD_ILLEGAL = 7028,
    /**
     * @generated from protobuf enum value: RET_REMARK_TOO_LONG = 7029;
     */
    RET_REMARK_TOO_LONG = 7029,
    /**
     * @generated from protobuf enum value: RET_REMARK_UTF8_ERROR = 7030;
     */
    RET_REMARK_UTF8_ERROR = 7030,
    /**
     * @generated from protobuf enum value: RET_REMARK_IS_EMPTY = 7031;
     */
    RET_REMARK_IS_EMPTY = 7031,
    /**
     * @generated from protobuf enum value: RET_ASK_ADD_FRIEND_CD = 7032;
     */
    RET_ASK_ADD_FRIEND_CD = 7032,
    /**
     * @generated from protobuf enum value: RET_SHOW_AVATAR_INFO_NOT_EXIST = 7033;
     */
    RET_SHOW_AVATAR_INFO_NOT_EXIST = 7033,
    /**
     * @generated from protobuf enum value: RET_PLAYER_NOT_SHOW_AVATAR = 7034;
     */
    RET_PLAYER_NOT_SHOW_AVATAR = 7034,
    /**
     * @generated from protobuf enum value: RET_SOCIAL_UPDATE_SHOW_LIST_REPEAT_ID = 7035;
     */
    RET_SOCIAL_UPDATE_SHOW_LIST_REPEAT_ID = 7035,
    /**
     * @generated from protobuf enum value: RET_PSN_ID_NOT_FOUND = 7036;
     */
    RET_PSN_ID_NOT_FOUND = 7036,
    /**
     * @generated from protobuf enum value: RET_EMOJI_COLLECTION_NUM_EXCEED_LIMIT = 7037;
     */
    RET_EMOJI_COLLECTION_NUM_EXCEED_LIMIT = 7037,
    /**
     * @generated from protobuf enum value: RET_REMARK_EMPTY = 7038;
     */
    RET_REMARK_EMPTY = 7038,
    /**
     * @generated from protobuf enum value: RET_OFFERING_NOT_OPEN = 7081;
     */
    RET_OFFERING_NOT_OPEN = 7081,
    /**
     * @generated from protobuf enum value: RET_OFFERING_LEVEL_LIMIT = 7082;
     */
    RET_OFFERING_LEVEL_LIMIT = 7082,
    /**
     * @generated from protobuf enum value: RET_OFFERING_LEVEL_NOT_REACH = 7083;
     */
    RET_OFFERING_LEVEL_NOT_REACH = 7083,
    /**
     * @generated from protobuf enum value: RET_OFFERING_LEVEL_HAS_TAKEN = 7084;
     */
    RET_OFFERING_LEVEL_HAS_TAKEN = 7084,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_NOT_OPEN = 7101;
     */
    RET_CITY_REPUTATION_NOT_OPEN = 7101,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_LEVEL_TAKEN = 7102;
     */
    RET_CITY_REPUTATION_LEVEL_TAKEN = 7102,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_LEVEL_NOT_REACH = 7103;
     */
    RET_CITY_REPUTATION_LEVEL_NOT_REACH = 7103,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_PARENT_QUEST_TAKEN = 7104;
     */
    RET_CITY_REPUTATION_PARENT_QUEST_TAKEN = 7104,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_PARENT_QUEST_UNFINISH = 7105;
     */
    RET_CITY_REPUTATION_PARENT_QUEST_UNFINISH = 7105,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_ACCEPT_REQUEST = 7106;
     */
    RET_CITY_REPUTATION_ACCEPT_REQUEST = 7106,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_NOT_ACCEPT_REQUEST = 7107;
     */
    RET_CITY_REPUTATION_NOT_ACCEPT_REQUEST = 7107,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_ACCEPT_REQUEST_LIMIT = 7108;
     */
    RET_CITY_REPUTATION_ACCEPT_REQUEST_LIMIT = 7108,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_ENTRANCE_NOT_OPEN = 7109;
     */
    RET_CITY_REPUTATION_ENTRANCE_NOT_OPEN = 7109,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_TAKEN_REQUEST_REWARD = 7110;
     */
    RET_CITY_REPUTATION_TAKEN_REQUEST_REWARD = 7110,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_SWITCH_CLOSE = 7111;
     */
    RET_CITY_REPUTATION_SWITCH_CLOSE = 7111,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_ENTRACE_SWITCH_CLOSE = 7112;
     */
    RET_CITY_REPUTATION_ENTRACE_SWITCH_CLOSE = 7112,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_TAKEN_EXPLORE_REWARD = 7113;
     */
    RET_CITY_REPUTATION_TAKEN_EXPLORE_REWARD = 7113,
    /**
     * @generated from protobuf enum value: RET_CITY_REPUTATION_EXPLORE_NOT_REACH = 7114;
     */
    RET_CITY_REPUTATION_EXPLORE_NOT_REACH = 7114,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_NOT_OPEN = 7120;
     */
    RET_MECHANICUS_NOT_OPEN = 7120,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_GEAR_UNLOCK = 7121;
     */
    RET_MECHANICUS_GEAR_UNLOCK = 7121,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_GEAR_LOCK = 7122;
     */
    RET_MECHANICUS_GEAR_LOCK = 7122,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_GEAR_LEVEL_LIMIT = 7123;
     */
    RET_MECHANICUS_GEAR_LEVEL_LIMIT = 7123,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_COIN_NOT_ENOUGH = 7124;
     */
    RET_MECHANICUS_COIN_NOT_ENOUGH = 7124,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_NO_SEQUENCE = 7125;
     */
    RET_MECHANICUS_NO_SEQUENCE = 7125,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_SEQUENCE_LIMIT_LEVEL = 7126;
     */
    RET_MECHANICUS_SEQUENCE_LIMIT_LEVEL = 7126,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_SEQUENCE_LIMIT_OPEN = 7127;
     */
    RET_MECHANICUS_SEQUENCE_LIMIT_OPEN = 7127,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_DIFFICULT_NOT_SUPPORT = 7128;
     */
    RET_MECHANICUS_DIFFICULT_NOT_SUPPORT = 7128,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_TICKET_NOT_ENOUGH = 7129;
     */
    RET_MECHANICUS_TICKET_NOT_ENOUGH = 7129,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_TEACH_NOT_FINISH = 7130;
     */
    RET_MECHANICUS_TEACH_NOT_FINISH = 7130,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_TEACH_FINISHED = 7131;
     */
    RET_MECHANICUS_TEACH_FINISHED = 7131,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_PREV_DIFFICULT_LEVEL_BLOCK = 7132;
     */
    RET_MECHANICUS_PREV_DIFFICULT_LEVEL_BLOCK = 7132,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_PLAYER_LIMIT = 7133;
     */
    RET_MECHANICUS_PLAYER_LIMIT = 7133,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_PUNISH_TIME = 7134;
     */
    RET_MECHANICUS_PUNISH_TIME = 7134,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_SWITCH_CLOSE = 7135;
     */
    RET_MECHANICUS_SWITCH_CLOSE = 7135,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_NOT_IN_DUNGEON = 7150;
     */
    RET_MECHANICUS_BATTLE_NOT_IN_DUNGEON = 7150,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_PLAY_NOT_FOUND = 7151;
     */
    RET_MECHANICUS_BATTLE_PLAY_NOT_FOUND = 7151,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_DUPLICATE_PICK_CARD = 7152;
     */
    RET_MECHANICUS_BATTLE_DUPLICATE_PICK_CARD = 7152,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_PLAYER_NOT_IN_PLAY = 7153;
     */
    RET_MECHANICUS_BATTLE_PLAYER_NOT_IN_PLAY = 7153,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_NOT_AVAILABLE = 7154;
     */
    RET_MECHANICUS_BATTLE_CARD_NOT_AVAILABLE = 7154,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_NOT_IN_CARD_STAGE = 7155;
     */
    RET_MECHANICUS_BATTLE_NOT_IN_CARD_STAGE = 7155,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_IS_WAITING = 7156;
     */
    RET_MECHANICUS_BATTLE_CARD_IS_WAITING = 7156,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_ALL_CONFIRMED = 7157;
     */
    RET_MECHANICUS_BATTLE_CARD_ALL_CONFIRMED = 7157,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_ALREADY_CONFIRMED = 7158;
     */
    RET_MECHANICUS_BATTLE_CARD_ALREADY_CONFIRMED = 7158,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_CONFIRMED_BY_OTHER = 7159;
     */
    RET_MECHANICUS_BATTLE_CARD_CONFIRMED_BY_OTHER = 7159,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_NOT_ENOUGH_POINTS = 7160;
     */
    RET_MECHANICUS_BATTLE_CARD_NOT_ENOUGH_POINTS = 7160,
    /**
     * @generated from protobuf enum value: RET_MECHANICUS_BATTLE_CARD_ALREADY_SKIPPED = 7161;
     */
    RET_MECHANICUS_BATTLE_CARD_ALREADY_SKIPPED = 7161,
    /**
     * @generated from protobuf enum value: RET_LEGENDARY_KEY_NOT_ENOUGH = 8001;
     */
    RET_LEGENDARY_KEY_NOT_ENOUGH = 8001,
    /**
     * @generated from protobuf enum value: RET_LEGENDARY_KEY_EXCEED_LIMIT = 8002;
     */
    RET_LEGENDARY_KEY_EXCEED_LIMIT = 8002,
    /**
     * @generated from protobuf enum value: RET_DAILY_TASK_NOT_ENOUGH_TO_REDEEM = 8003;
     */
    RET_DAILY_TASK_NOT_ENOUGH_TO_REDEEM = 8003,
    /**
     * @generated from protobuf enum value: RET_PERSONAL_LINE_OPEN_STATE_OFF = 8004;
     */
    RET_PERSONAL_LINE_OPEN_STATE_OFF = 8004,
    /**
     * @generated from protobuf enum value: RET_PERSONAL_LINE_LEVEL_NOT_ENOUGH = 8005;
     */
    RET_PERSONAL_LINE_LEVEL_NOT_ENOUGH = 8005,
    /**
     * @generated from protobuf enum value: RET_PERSONAL_LINE_NOT_OPEN = 8006;
     */
    RET_PERSONAL_LINE_NOT_OPEN = 8006,
    /**
     * @generated from protobuf enum value: RET_PERSONAL_LINE_PRE_QUEST_NOT_FINISH = 8007;
     */
    RET_PERSONAL_LINE_PRE_QUEST_NOT_FINISH = 8007,
    /**
     * @generated from protobuf enum value: RET_HUNTING_ALREADY_FINISH_OFFER_LIMIT = 8201;
     */
    RET_HUNTING_ALREADY_FINISH_OFFER_LIMIT = 8201,
    /**
     * @generated from protobuf enum value: RET_HUNTING_HAS_UNFINISHED_OFFER = 8202;
     */
    RET_HUNTING_HAS_UNFINISHED_OFFER = 8202,
    /**
     * @generated from protobuf enum value: RET_HUNTING_FAILED_OFFER_NOT_CD_READY = 8203;
     */
    RET_HUNTING_FAILED_OFFER_NOT_CD_READY = 8203,
    /**
     * @generated from protobuf enum value: RET_HUNTING_NOT_TAKE_OFFER = 8204;
     */
    RET_HUNTING_NOT_TAKE_OFFER = 8204,
    /**
     * @generated from protobuf enum value: RET_HUNTING_CANNOT_TAKE_TWICE = 8205;
     */
    RET_HUNTING_CANNOT_TAKE_TWICE = 8205,
    /**
     * @generated from protobuf enum value: RET_RPIVATE_CHAT_INVALID_CONTENT_TYPE = 8901;
     */
    RET_RPIVATE_CHAT_INVALID_CONTENT_TYPE = 8901,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_TARGET_IS_NOT_FRIEND = 8902;
     */
    RET_PRIVATE_CHAT_TARGET_IS_NOT_FRIEND = 8902,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_CONTENT_NOT_SUPPORTED = 8903;
     */
    RET_PRIVATE_CHAT_CONTENT_NOT_SUPPORTED = 8903,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_CONTENT_TOO_LONG = 8904;
     */
    RET_PRIVATE_CHAT_CONTENT_TOO_LONG = 8904,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_PULL_TOO_FAST = 8905;
     */
    RET_PRIVATE_CHAT_PULL_TOO_FAST = 8905,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_REPEAT_READ = 8906;
     */
    RET_PRIVATE_CHAT_REPEAT_READ = 8906,
    /**
     * @generated from protobuf enum value: RET_PRIVATE_CHAT_READ_NOT_FRIEND = 8907;
     */
    RET_PRIVATE_CHAT_READ_NOT_FRIEND = 8907,
    /**
     * @generated from protobuf enum value: RET_REUNION_FINISHED = 9001;
     */
    RET_REUNION_FINISHED = 9001,
    /**
     * @generated from protobuf enum value: RET_REUNION_NOT_ACTIVATED = 9002;
     */
    RET_REUNION_NOT_ACTIVATED = 9002,
    /**
     * @generated from protobuf enum value: RET_REUNION_ALREADY_TAKE_FIRST_REWARD = 9003;
     */
    RET_REUNION_ALREADY_TAKE_FIRST_REWARD = 9003,
    /**
     * @generated from protobuf enum value: RET_REUNION_SIGN_IN_REWARDED = 9004;
     */
    RET_REUNION_SIGN_IN_REWARDED = 9004,
    /**
     * @generated from protobuf enum value: RET_REUNION_WATCHER_REWARDED = 9005;
     */
    RET_REUNION_WATCHER_REWARDED = 9005,
    /**
     * @generated from protobuf enum value: RET_REUNION_WATCHER_NOT_FINISH = 9006;
     */
    RET_REUNION_WATCHER_NOT_FINISH = 9006,
    /**
     * @generated from protobuf enum value: RET_REUNION_MISSION_REWARDED = 9007;
     */
    RET_REUNION_MISSION_REWARDED = 9007,
    /**
     * @generated from protobuf enum value: RET_REUNION_MISSION_NOT_FINISH = 9008;
     */
    RET_REUNION_MISSION_NOT_FINISH = 9008,
    /**
     * @generated from protobuf enum value: RET_REUNION_WATCHER_REWARD_NOT_UNLOCKED = 9009;
     */
    RET_REUNION_WATCHER_REWARD_NOT_UNLOCKED = 9009,
    /**
     * @generated from protobuf enum value: RET_BLESSING_CONTENT_CLOSED = 9101;
     */
    RET_BLESSING_CONTENT_CLOSED = 9101,
    /**
     * @generated from protobuf enum value: RET_BLESSING_NOT_ACTIVE = 9102;
     */
    RET_BLESSING_NOT_ACTIVE = 9102,
    /**
     * @generated from protobuf enum value: RET_BLESSING_NOT_TODAY_ENTITY = 9103;
     */
    RET_BLESSING_NOT_TODAY_ENTITY = 9103,
    /**
     * @generated from protobuf enum value: RET_BLESSING_ENTITY_EXCEED_SCAN_NUM_LIMIT = 9104;
     */
    RET_BLESSING_ENTITY_EXCEED_SCAN_NUM_LIMIT = 9104,
    /**
     * @generated from protobuf enum value: RET_BLESSING_DAILY_SCAN_NUM_EXCEED_LIMIT = 9105;
     */
    RET_BLESSING_DAILY_SCAN_NUM_EXCEED_LIMIT = 9105,
    /**
     * @generated from protobuf enum value: RET_BLESSING_REDEEM_REWARD_NUM_EXCEED_LIMIT = 9106;
     */
    RET_BLESSING_REDEEM_REWARD_NUM_EXCEED_LIMIT = 9106,
    /**
     * @generated from protobuf enum value: RET_BLESSING_REDEEM_PIC_NUM_NOT_ENOUGH = 9107;
     */
    RET_BLESSING_REDEEM_PIC_NUM_NOT_ENOUGH = 9107,
    /**
     * @generated from protobuf enum value: RET_BLESSING_PIC_NOT_ENOUGH = 9108;
     */
    RET_BLESSING_PIC_NOT_ENOUGH = 9108,
    /**
     * @generated from protobuf enum value: RET_BLESSING_PIC_HAS_RECEIVED = 9109;
     */
    RET_BLESSING_PIC_HAS_RECEIVED = 9109,
    /**
     * @generated from protobuf enum value: RET_BLESSING_TARGET_RECV_NUM_EXCEED = 9110;
     */
    RET_BLESSING_TARGET_RECV_NUM_EXCEED = 9110,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_CREDIT_EXCEED_LIMIT = 9111;
     */
    RET_FLEUR_FAIR_CREDIT_EXCEED_LIMIT = 9111,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_CREDIT_NOT_ENOUGH = 9112;
     */
    RET_FLEUR_FAIR_CREDIT_NOT_ENOUGH = 9112,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_TOKEN_EXCEED_LIMIT = 9113;
     */
    RET_FLEUR_FAIR_TOKEN_EXCEED_LIMIT = 9113,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_TOKEN_NOT_ENOUGH = 9114;
     */
    RET_FLEUR_FAIR_TOKEN_NOT_ENOUGH = 9114,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_MINIGAME_NOT_OPEN = 9115;
     */
    RET_FLEUR_FAIR_MINIGAME_NOT_OPEN = 9115,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_MUSIC_GAME_DIFFICULTY_NOT_UNLOCK = 9116;
     */
    RET_FLEUR_FAIR_MUSIC_GAME_DIFFICULTY_NOT_UNLOCK = 9116,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_DUNGEON_LOCKED = 9117;
     */
    RET_FLEUR_FAIR_DUNGEON_LOCKED = 9117,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_DUNGEON_PUNISH_TIME = 9118;
     */
    RET_FLEUR_FAIR_DUNGEON_PUNISH_TIME = 9118,
    /**
     * @generated from protobuf enum value: RET_FLEUR_FAIR_ONLY_OWNER_CAN_RESTART_MINIGAM = 9119;
     */
    RET_FLEUR_FAIR_ONLY_OWNER_CAN_RESTART_MINIGAM = 9119,
    /**
     * @generated from protobuf enum value: RET_WATER_SPIRIT_COIN_EXCEED_LIMIT = 9120;
     */
    RET_WATER_SPIRIT_COIN_EXCEED_LIMIT = 9120,
    /**
     * @generated from protobuf enum value: RET_WATER_SPIRIT_COIN_NOT_ENOUGH = 9121;
     */
    RET_WATER_SPIRIT_COIN_NOT_ENOUGH = 9121,
    /**
     * @generated from protobuf enum value: RET_REGION_SEARCH_NO_SEARCH = 9122;
     */
    RET_REGION_SEARCH_NO_SEARCH = 9122,
    /**
     * @generated from protobuf enum value: RET_REGION_SEARCH_STATE_ERROR = 9123;
     */
    RET_REGION_SEARCH_STATE_ERROR = 9123,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_LOOP_DUNGEON_STAGE_NOT_OPEN = 9130;
     */
    RET_CHANNELLER_SLAB_LOOP_DUNGEON_STAGE_NOT_OPEN = 9130,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_LOOP_DUNGEON_NOT_OPEN = 9131;
     */
    RET_CHANNELLER_SLAB_LOOP_DUNGEON_NOT_OPEN = 9131,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD_HAS_TAKEN = 9132;
     */
    RET_CHANNELLER_SLAB_LOOP_DUNGEON_FIRST_PASS_REWARD_HAS_TAKEN = 9132,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD_HAS_TAKEN = 9133;
     */
    RET_CHANNELLER_SLAB_LOOP_DUNGEON_SCORE_REWARD_HAS_TAKEN = 9133,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_INVALID_ONE_OFF_DUNGEON = 9134;
     */
    RET_CHANNELLER_SLAB_INVALID_ONE_OFF_DUNGEON = 9134,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_ONE_OFF_DUNGEON_DONE = 9135;
     */
    RET_CHANNELLER_SLAB_ONE_OFF_DUNGEON_DONE = 9135,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_ONE_OFF_DUNGEON_STAGE_NOT_OPEN = 9136;
     */
    RET_CHANNELLER_SLAB_ONE_OFF_DUNGEON_STAGE_NOT_OPEN = 9136,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_TOKEN_EXCEED_LIMIT = 9137;
     */
    RET_CHANNELLER_SLAB_TOKEN_EXCEED_LIMIT = 9137,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_TOKEN_NOT_ENOUGH = 9138;
     */
    RET_CHANNELLER_SLAB_TOKEN_NOT_ENOUGH = 9138,
    /**
     * @generated from protobuf enum value: RET_CHANNELLER_SLAB_PLAYER_NOT_IN_ONE_OFF_DUNGEON = 9139;
     */
    RET_CHANNELLER_SLAB_PLAYER_NOT_IN_ONE_OFF_DUNGEON = 9139,
    /**
     * @generated from protobuf enum value: RET_MIST_TRIAL_SELECT_CHARACTER_NUM_NOT_ENOUGH = 9150;
     */
    RET_MIST_TRIAL_SELECT_CHARACTER_NUM_NOT_ENOUGH = 9150,
    /**
     * @generated from protobuf enum value: RET_HIDE_AND_SEEK_PLAY_NOT_OPEN = 9160;
     */
    RET_HIDE_AND_SEEK_PLAY_NOT_OPEN = 9160,
    /**
     * @generated from protobuf enum value: RET_HIDE_AND_SEEK_PLAY_MAP_NOT_OPEN = 9161;
     */
    RET_HIDE_AND_SEEK_PLAY_MAP_NOT_OPEN = 9161,
    /**
     * @generated from protobuf enum value: RET_SUMMER_TIME_DRAFT_WOORD_EXCEED_LIMIT = 9170;
     */
    RET_SUMMER_TIME_DRAFT_WOORD_EXCEED_LIMIT = 9170,
    /**
     * @generated from protobuf enum value: RET_SUMMER_TIME_DRAFT_WOORD_NOT_ENOUGH = 9171;
     */
    RET_SUMMER_TIME_DRAFT_WOORD_NOT_ENOUGH = 9171,
    /**
     * @generated from protobuf enum value: RET_SUMMER_TIME_MINI_HARPASTUM_EXCEED_LIMIT = 9172;
     */
    RET_SUMMER_TIME_MINI_HARPASTUM_EXCEED_LIMIT = 9172,
    /**
     * @generated from protobuf enum value: RET_SUMMER_TIME_MINI_HARPASTUMNOT_ENOUGH = 9173;
     */
    RET_SUMMER_TIME_MINI_HARPASTUMNOT_ENOUGH = 9173,
    /**
     * @generated from protobuf enum value: RET_BOUNCE_CONJURING_COIN_EXCEED_LIMIT = 9180;
     */
    RET_BOUNCE_CONJURING_COIN_EXCEED_LIMIT = 9180,
    /**
     * @generated from protobuf enum value: RET_BOUNCE_CONJURING_COIN_NOT_ENOUGH = 9181;
     */
    RET_BOUNCE_CONJURING_COIN_NOT_ENOUGH = 9181,
    /**
     * @generated from protobuf enum value: RET_CHESS_TEACH_MAP_FINISHED = 9183;
     */
    RET_CHESS_TEACH_MAP_FINISHED = 9183,
    /**
     * @generated from protobuf enum value: RET_CHESS_TEACH_MAP_UNFINISHED = 9184;
     */
    RET_CHESS_TEACH_MAP_UNFINISHED = 9184,
    /**
     * @generated from protobuf enum value: RET_CHESS_COIN_EXCEED_LIMIT = 9185;
     */
    RET_CHESS_COIN_EXCEED_LIMIT = 9185,
    /**
     * @generated from protobuf enum value: RET_CHESS_COIN_NOT_ENOUGH = 9186;
     */
    RET_CHESS_COIN_NOT_ENOUGH = 9186,
    /**
     * @generated from protobuf enum value: RET_CHESS_IN_PUNISH_TIME = 9187;
     */
    RET_CHESS_IN_PUNISH_TIME = 9187,
    /**
     * @generated from protobuf enum value: RET_CHESS_PREV_MAP_UNFINISHED = 9188;
     */
    RET_CHESS_PREV_MAP_UNFINISHED = 9188,
    /**
     * @generated from protobuf enum value: RET_CHESS_MAP_LOCKED = 9189;
     */
    RET_CHESS_MAP_LOCKED = 9189,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_NOT_OPEN = 9192;
     */
    RET_BLITZ_RUSH_NOT_OPEN = 9192,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_DUNGEON_NOT_OPEN = 9193;
     */
    RET_BLITZ_RUSH_DUNGEON_NOT_OPEN = 9193,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_COIN_A_EXCEED_LIMIT = 9194;
     */
    RET_BLITZ_RUSH_COIN_A_EXCEED_LIMIT = 9194,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_COIN_B_EXCEED_LIMIT = 9195;
     */
    RET_BLITZ_RUSH_COIN_B_EXCEED_LIMIT = 9195,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_COIN_A_NOT_ENOUGH = 9196;
     */
    RET_BLITZ_RUSH_COIN_A_NOT_ENOUGH = 9196,
    /**
     * @generated from protobuf enum value: RET_BLITZ_RUSH_COIN_B_NOT_ENOUGH = 9197;
     */
    RET_BLITZ_RUSH_COIN_B_NOT_ENOUGH = 9197,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_VALUE_NOT_ENOUGH = 9201;
     */
    RET_MIRACLE_RING_VALUE_NOT_ENOUGH = 9201,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_CD = 9202;
     */
    RET_MIRACLE_RING_CD = 9202,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_REWARD_NOT_TAKEN = 9203;
     */
    RET_MIRACLE_RING_REWARD_NOT_TAKEN = 9203,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_NOT_DELIVER = 9204;
     */
    RET_MIRACLE_RING_NOT_DELIVER = 9204,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_DELIVER_EXCEED = 9205;
     */
    RET_MIRACLE_RING_DELIVER_EXCEED = 9205,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_HAS_CREATED = 9206;
     */
    RET_MIRACLE_RING_HAS_CREATED = 9206,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_HAS_NOT_CREATED = 9207;
     */
    RET_MIRACLE_RING_HAS_NOT_CREATED = 9207,
    /**
     * @generated from protobuf enum value: RET_MIRACLE_RING_NOT_YOURS = 9208;
     */
    RET_MIRACLE_RING_NOT_YOURS = 9208,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_UNAUTHORIZED = 9251;
     */
    RET_GADGET_FOUNDATION_UNAUTHORIZED = 9251,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_SCENE_NOT_FOUND = 9252;
     */
    RET_GADGET_FOUNDATION_SCENE_NOT_FOUND = 9252,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_NOT_IN_INIT_STATE = 9253;
     */
    RET_GADGET_FOUNDATION_NOT_IN_INIT_STATE = 9253,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_BILDING_POINT_NOT_ENOUGHT = 9254;
     */
    RET_GADGET_FOUNDATION_BILDING_POINT_NOT_ENOUGHT = 9254,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_NOT_IN_BUILT_STATE = 9255;
     */
    RET_GADGET_FOUNDATION_NOT_IN_BUILT_STATE = 9255,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_OP_NOT_SUPPORTED = 9256;
     */
    RET_GADGET_FOUNDATION_OP_NOT_SUPPORTED = 9256,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_REQ_PLAYER_NOT_IN_SCENE = 9257;
     */
    RET_GADGET_FOUNDATION_REQ_PLAYER_NOT_IN_SCENE = 9257,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_LOCKED_BY_ANOTHER_PLAYER = 9258;
     */
    RET_GADGET_FOUNDATION_LOCKED_BY_ANOTHER_PLAYER = 9258,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_NOT_LOCKED = 9259;
     */
    RET_GADGET_FOUNDATION_NOT_LOCKED = 9259,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_DUPLICATE_LOCK = 9260;
     */
    RET_GADGET_FOUNDATION_DUPLICATE_LOCK = 9260,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_PLAYER_NOT_FOUND = 9261;
     */
    RET_GADGET_FOUNDATION_PLAYER_NOT_FOUND = 9261,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_PLAYER_GEAR_NOT_FOUND = 9262;
     */
    RET_GADGET_FOUNDATION_PLAYER_GEAR_NOT_FOUND = 9262,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_ROTAION_DISABLED = 9263;
     */
    RET_GADGET_FOUNDATION_ROTAION_DISABLED = 9263,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_REACH_DUNGEON_GEAR_LIMIT = 9264;
     */
    RET_GADGET_FOUNDATION_REACH_DUNGEON_GEAR_LIMIT = 9264,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_REACH_SINGLE_GEAR_LIMIT = 9265;
     */
    RET_GADGET_FOUNDATION_REACH_SINGLE_GEAR_LIMIT = 9265,
    /**
     * @generated from protobuf enum value: RET_GADGET_FOUNDATION_ROTATION_ON_GOING = 9266;
     */
    RET_GADGET_FOUNDATION_ROTATION_ON_GOING = 9266,
    /**
     * @generated from protobuf enum value: RET_OP_ACTIVITY_BONUS_NOT_FOUND = 9301;
     */
    RET_OP_ACTIVITY_BONUS_NOT_FOUND = 9301,
    /**
     * @generated from protobuf enum value: RET_OP_ACTIVITY_NOT_OPEN = 9302;
     */
    RET_OP_ACTIVITY_NOT_OPEN = 9302,
    /**
     * @generated from protobuf enum value: RET_MULTISTAGE_PLAY_PLAYER_NOT_IN_SCENE = 9501;
     */
    RET_MULTISTAGE_PLAY_PLAYER_NOT_IN_SCENE = 9501,
    /**
     * @generated from protobuf enum value: RET_MULTISTAGE_PLAY_NOT_FOUND = 9502;
     */
    RET_MULTISTAGE_PLAY_NOT_FOUND = 9502,
    /**
     * @generated from protobuf enum value: RET_COOP_CHAPTER_NOT_OPEN = 9601;
     */
    RET_COOP_CHAPTER_NOT_OPEN = 9601,
    /**
     * @generated from protobuf enum value: RET_COOP_COND_NOT_MEET = 9602;
     */
    RET_COOP_COND_NOT_MEET = 9602,
    /**
     * @generated from protobuf enum value: RET_COOP_POINT_LOCKED = 9603;
     */
    RET_COOP_POINT_LOCKED = 9603,
    /**
     * @generated from protobuf enum value: RET_COOP_NOT_HAVE_PROGRESS = 9604;
     */
    RET_COOP_NOT_HAVE_PROGRESS = 9604,
    /**
     * @generated from protobuf enum value: RET_COOP_REWARD_HAS_TAKEN = 9605;
     */
    RET_COOP_REWARD_HAS_TAKEN = 9605,
    /**
     * @generated from protobuf enum value: RET_DRAFT_HAS_ACTIVE_DRAFT = 9651;
     */
    RET_DRAFT_HAS_ACTIVE_DRAFT = 9651,
    /**
     * @generated from protobuf enum value: RET_DRAFT_NOT_IN_MY_WORLD = 9652;
     */
    RET_DRAFT_NOT_IN_MY_WORLD = 9652,
    /**
     * @generated from protobuf enum value: RET_DRAFT_NOT_SUPPORT_MP = 9653;
     */
    RET_DRAFT_NOT_SUPPORT_MP = 9653,
    /**
     * @generated from protobuf enum value: RET_DRAFT_PLAYER_NOT_ENOUGH = 9654;
     */
    RET_DRAFT_PLAYER_NOT_ENOUGH = 9654,
    /**
     * @generated from protobuf enum value: RET_DRAFT_INCORRECT_SCENE = 9655;
     */
    RET_DRAFT_INCORRECT_SCENE = 9655,
    /**
     * @generated from protobuf enum value: RET_DRAFT_OTHER_PLAYER_ENTERING = 9656;
     */
    RET_DRAFT_OTHER_PLAYER_ENTERING = 9656,
    /**
     * @generated from protobuf enum value: RET_DRAFT_GUEST_IS_TRANSFERRING = 9657;
     */
    RET_DRAFT_GUEST_IS_TRANSFERRING = 9657,
    /**
     * @generated from protobuf enum value: RET_DRAFT_GUEST_NOT_IN_DRAFT_SCENE = 9658;
     */
    RET_DRAFT_GUEST_NOT_IN_DRAFT_SCENE = 9658,
    /**
     * @generated from protobuf enum value: RET_DRAFT_INVITE_OVER_TIME = 9659;
     */
    RET_DRAFT_INVITE_OVER_TIME = 9659,
    /**
     * @generated from protobuf enum value: RET_DRAFT_TWICE_CONFIRM_OVER_TIMER = 9660;
     */
    RET_DRAFT_TWICE_CONFIRM_OVER_TIMER = 9660,
    /**
     * @generated from protobuf enum value: RET_HOME_UNKOWN = 9701;
     */
    RET_HOME_UNKOWN = 9701,
    /**
     * @generated from protobuf enum value: RET_HOME_INVALID_CLIENT_PARAM = 9702;
     */
    RET_HOME_INVALID_CLIENT_PARAM = 9702,
    /**
     * @generated from protobuf enum value: RET_HOME_TARGE_PLAYER_HAS_NO_HOME = 9703;
     */
    RET_HOME_TARGE_PLAYER_HAS_NO_HOME = 9703,
    /**
     * @generated from protobuf enum value: RET_HOME_NOT_ONLINE = 9704;
     */
    RET_HOME_NOT_ONLINE = 9704,
    /**
     * @generated from protobuf enum value: RET_HOME_PLAYER_FULL = 9705;
     */
    RET_HOME_PLAYER_FULL = 9705,
    /**
     * @generated from protobuf enum value: RET_HOME_BLOCKED = 9706;
     */
    RET_HOME_BLOCKED = 9706,
    /**
     * @generated from protobuf enum value: RET_HOME_ALREADY_IN_TARGET_HOME_WORLD = 9707;
     */
    RET_HOME_ALREADY_IN_TARGET_HOME_WORLD = 9707,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_EDIT_MODE = 9708;
     */
    RET_HOME_IN_EDIT_MODE = 9708,
    /**
     * @generated from protobuf enum value: RET_HOME_NOT_IN_EDIT_MODE = 9709;
     */
    RET_HOME_NOT_IN_EDIT_MODE = 9709,
    /**
     * @generated from protobuf enum value: RET_HOME_HAS_GUEST = 9710;
     */
    RET_HOME_HAS_GUEST = 9710,
    /**
     * @generated from protobuf enum value: RET_HOME_CANT_ENTER_BY_IN_EDIT_MODE = 9711;
     */
    RET_HOME_CANT_ENTER_BY_IN_EDIT_MODE = 9711,
    /**
     * @generated from protobuf enum value: RET_HOME_CLIENT_PARAM_INVALID = 9712;
     */
    RET_HOME_CLIENT_PARAM_INVALID = 9712,
    /**
     * @generated from protobuf enum value: RET_HOME_PLAYER_NOT_IN_HOME_WORLD = 9713;
     */
    RET_HOME_PLAYER_NOT_IN_HOME_WORLD = 9713,
    /**
     * @generated from protobuf enum value: RET_HOME_PLAYER_NOT_IN_SELF_HOME_WORLD = 9714;
     */
    RET_HOME_PLAYER_NOT_IN_SELF_HOME_WORLD = 9714,
    /**
     * @generated from protobuf enum value: RET_HOME_NOT_FOUND_IN_MEM = 9715;
     */
    RET_HOME_NOT_FOUND_IN_MEM = 9715,
    /**
     * @generated from protobuf enum value: RET_HOME_PLAYER_IN_HOME_ROOM_SCENE = 9716;
     */
    RET_HOME_PLAYER_IN_HOME_ROOM_SCENE = 9716,
    /**
     * @generated from protobuf enum value: RET_HOME_HOME_REFUSE_GUEST_ENTER = 9717;
     */
    RET_HOME_HOME_REFUSE_GUEST_ENTER = 9717,
    /**
     * @generated from protobuf enum value: RET_HOME_OWNER_REFUSE_TO_ENTER_HOME = 9718;
     */
    RET_HOME_OWNER_REFUSE_TO_ENTER_HOME = 9718,
    /**
     * @generated from protobuf enum value: RET_HOME_OWNER_OFFLINE = 9719;
     */
    RET_HOME_OWNER_OFFLINE = 9719,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_EXCEED_LIMIT = 9720;
     */
    RET_HOME_FURNITURE_EXCEED_LIMIT = 9720,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_COUNT_NOT_ENOUGH = 9721;
     */
    RET_HOME_FURNITURE_COUNT_NOT_ENOUGH = 9721,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_TRY_ENTER_PROCESS = 9722;
     */
    RET_HOME_IN_TRY_ENTER_PROCESS = 9722,
    /**
     * @generated from protobuf enum value: RET_HOME_ALREADY_IN_TARGET_SCENE = 9723;
     */
    RET_HOME_ALREADY_IN_TARGET_SCENE = 9723,
    /**
     * @generated from protobuf enum value: RET_HOME_COIN_EXCEED_LIMIT = 9724;
     */
    RET_HOME_COIN_EXCEED_LIMIT = 9724,
    /**
     * @generated from protobuf enum value: RET_HOME_COIN_NOT_ENOUGH = 9725;
     */
    RET_HOME_COIN_NOT_ENOUGH = 9725,
    /**
     * @generated from protobuf enum value: RET_HOME_MODULE_NOT_UNLOCKED = 9726;
     */
    RET_HOME_MODULE_NOT_UNLOCKED = 9726,
    /**
     * @generated from protobuf enum value: RET_HOME_CUR_MODULE_CLOSED = 9727;
     */
    RET_HOME_CUR_MODULE_CLOSED = 9727,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_SUITE_NOT_UNLOCKED = 9728;
     */
    RET_HOME_FURNITURE_SUITE_NOT_UNLOCKED = 9728,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_MATCH = 9729;
     */
    RET_HOME_IN_MATCH = 9729,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_COMBAT = 9730;
     */
    RET_HOME_IN_COMBAT = 9730,
    /**
     * @generated from protobuf enum value: RET_HOME_EDIT_MODE_CD = 9731;
     */
    RET_HOME_EDIT_MODE_CD = 9731,
    /**
     * @generated from protobuf enum value: RET_HOME_UPDATE_FURNITURE_CD = 9732;
     */
    RET_HOME_UPDATE_FURNITURE_CD = 9732,
    /**
     * @generated from protobuf enum value: RET_HOME_BLOCK_FURNITURE_LIMIT = 9733;
     */
    RET_HOME_BLOCK_FURNITURE_LIMIT = 9733,
    /**
     * @generated from protobuf enum value: RET_HOME_NOT_SUPPORT = 9734;
     */
    RET_HOME_NOT_SUPPORT = 9734,
    /**
     * @generated from protobuf enum value: RET_HOME_STATE_NOT_OPEN = 9735;
     */
    RET_HOME_STATE_NOT_OPEN = 9735,
    /**
     * @generated from protobuf enum value: RET_HOME_TARGET_STATE_NOT_OPEN = 9736;
     */
    RET_HOME_TARGET_STATE_NOT_OPEN = 9736,
    /**
     * @generated from protobuf enum value: RET_HOME_APPLY_ENTER_OTHER_HOME_FAIL = 9737;
     */
    RET_HOME_APPLY_ENTER_OTHER_HOME_FAIL = 9737,
    /**
     * @generated from protobuf enum value: RET_HOME_SAVE_NO_MAIN_HOUSE = 9738;
     */
    RET_HOME_SAVE_NO_MAIN_HOUSE = 9738,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_DUNGEON = 9739;
     */
    RET_HOME_IN_DUNGEON = 9739,
    /**
     * @generated from protobuf enum value: RET_HOME_ANY_GALLERY_STARTED = 9740;
     */
    RET_HOME_ANY_GALLERY_STARTED = 9740,
    /**
     * @generated from protobuf enum value: RET_HOME_QUEST_BLOCK_HOME = 9741;
     */
    RET_HOME_QUEST_BLOCK_HOME = 9741,
    /**
     * @generated from protobuf enum value: RET_HOME_WAITING_PRIOR_CHECK = 9742;
     */
    RET_HOME_WAITING_PRIOR_CHECK = 9742,
    /**
     * @generated from protobuf enum value: RET_HOME_PERSISTENT_CHECK_FAIL = 9743;
     */
    RET_HOME_PERSISTENT_CHECK_FAIL = 9743,
    /**
     * @generated from protobuf enum value: RET_HOME_FIND_ONLINE_HOME_FAIL = 9744;
     */
    RET_HOME_FIND_ONLINE_HOME_FAIL = 9744,
    /**
     * @generated from protobuf enum value: RET_HOME_JOIN_SCENE_FAIL = 9745;
     */
    RET_HOME_JOIN_SCENE_FAIL = 9745,
    /**
     * @generated from protobuf enum value: RET_HOME_MAX_PLAYER = 9746;
     */
    RET_HOME_MAX_PLAYER = 9746,
    /**
     * @generated from protobuf enum value: RET_HOME_IN_TRANSFER = 9747;
     */
    RET_HOME_IN_TRANSFER = 9747,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_INDEX_ERROR = 9750;
     */
    RET_FURNITURE_MAKE_INDEX_ERROR = 9750,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_LOCKED = 9751;
     */
    RET_FURNITURE_MAKE_LOCKED = 9751,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_CONFIG_ERROR = 9752;
     */
    RET_FURNITURE_MAKE_CONFIG_ERROR = 9752,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_SLOT_FULL = 9753;
     */
    RET_FURNITURE_MAKE_SLOT_FULL = 9753,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_ADD_FURNITURE_FAIL = 9754;
     */
    RET_FURNITURE_MAKE_ADD_FURNITURE_FAIL = 9754,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_UNFINISH = 9755;
     */
    RET_FURNITURE_MAKE_UNFINISH = 9755,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_IS_FINISH = 9756;
     */
    RET_FURNITURE_MAKE_IS_FINISH = 9756,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_NOT_IN_CORRECT_HOME = 9757;
     */
    RET_FURNITURE_MAKE_NOT_IN_CORRECT_HOME = 9757,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_NO_COUNT = 9758;
     */
    RET_FURNITURE_MAKE_NO_COUNT = 9758,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_ACCELERATE_LIMIT = 9759;
     */
    RET_FURNITURE_MAKE_ACCELERATE_LIMIT = 9759,
    /**
     * @generated from protobuf enum value: RET_FURNITURE_MAKE_NO_MAKE_DATA = 9760;
     */
    RET_FURNITURE_MAKE_NO_MAKE_DATA = 9760,
    /**
     * @generated from protobuf enum value: RET_HOME_LIMITED_SHOP_CLOSE = 9761;
     */
    RET_HOME_LIMITED_SHOP_CLOSE = 9761,
    /**
     * @generated from protobuf enum value: RET_HOME_AVATAR_NOT_SHOW = 9762;
     */
    RET_HOME_AVATAR_NOT_SHOW = 9762,
    /**
     * @generated from protobuf enum value: RET_HOME_EVENT_COND_NOT_SATISFIED = 9763;
     */
    RET_HOME_EVENT_COND_NOT_SATISFIED = 9763,
    /**
     * @generated from protobuf enum value: RET_HOME_INVALID_ARRANGE_ANIMAL_PARAM = 9764;
     */
    RET_HOME_INVALID_ARRANGE_ANIMAL_PARAM = 9764,
    /**
     * @generated from protobuf enum value: RET_HOME_INVALID_ARRANGE_NPC_PARAM = 9765;
     */
    RET_HOME_INVALID_ARRANGE_NPC_PARAM = 9765,
    /**
     * @generated from protobuf enum value: RET_HOME_INVALID_ARRANGE_SUITE_PARAM = 9766;
     */
    RET_HOME_INVALID_ARRANGE_SUITE_PARAM = 9766,
    /**
     * @generated from protobuf enum value: RET_HOME_INVALID_ARRANGE_MAIN_HOUSE_PARAM = 9767;
     */
    RET_HOME_INVALID_ARRANGE_MAIN_HOUSE_PARAM = 9767,
    /**
     * @generated from protobuf enum value: RET_HOME_AVATAR_STATE_NOT_OPEN = 9768;
     */
    RET_HOME_AVATAR_STATE_NOT_OPEN = 9768,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_FIELD_NOT_EMPTY = 9769;
     */
    RET_HOME_PLANT_FIELD_NOT_EMPTY = 9769,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_FIELD_EMPTY = 9770;
     */
    RET_HOME_PLANT_FIELD_EMPTY = 9770,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_FIELD_TYPE_ERROR = 9771;
     */
    RET_HOME_PLANT_FIELD_TYPE_ERROR = 9771,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_TIME_NOT_ENOUGH = 9772;
     */
    RET_HOME_PLANT_TIME_NOT_ENOUGH = 9772,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_SUB_FIELD_NUM_NOT_ENOUGH = 9773;
     */
    RET_HOME_PLANT_SUB_FIELD_NUM_NOT_ENOUGH = 9773,
    /**
     * @generated from protobuf enum value: RET_HOME_PLANT_FIELD_PARAM_ERROR = 9774;
     */
    RET_HOME_PLANT_FIELD_PARAM_ERROR = 9774,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_GUID_ERROR = 9775;
     */
    RET_HOME_FURNITURE_GUID_ERROR = 9775,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_ARRANGE_LIMIT = 9776;
     */
    RET_HOME_FURNITURE_ARRANGE_LIMIT = 9776,
    /**
     * @generated from protobuf enum value: RET_HOME_FISH_FARMING_LIMIT = 9777;
     */
    RET_HOME_FISH_FARMING_LIMIT = 9777,
    /**
     * @generated from protobuf enum value: RET_HOME_FISH_COUNT_NOT_ENOUGH = 9778;
     */
    RET_HOME_FISH_COUNT_NOT_ENOUGH = 9778,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_COST_LIMIT = 9779;
     */
    RET_HOME_FURNITURE_COST_LIMIT = 9779,
    /**
     * @generated from protobuf enum value: RET_HOME_CUSTOM_FURNITURE_INVALID = 9780;
     */
    RET_HOME_CUSTOM_FURNITURE_INVALID = 9780,
    /**
     * @generated from protobuf enum value: RET_HOME_FURNITURE_CANNOT_ARRANGE = 9785;
     */
    RET_HOME_FURNITURE_CANNOT_ARRANGE = 9785,
    /**
     * @generated from protobuf enum value: RET_SUMO_ACTIVITY_STAGE_NOT_OPEN = 10000;
     */
    RET_SUMO_ACTIVITY_STAGE_NOT_OPEN = 10000,
    /**
     * @generated from protobuf enum value: RET_SUMO_ACTIVITY_SWITCH_TEAM_IN_CD = 10001;
     */
    RET_SUMO_ACTIVITY_SWITCH_TEAM_IN_CD = 10001,
    /**
     * @generated from protobuf enum value: RET_SUMO_ACTIVITY_TEAM_NUM_INCORRECT = 10002;
     */
    RET_SUMO_ACTIVITY_TEAM_NUM_INCORRECT = 10002,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_AREA_ID_ERROR = 10004;
     */
    RET_LUNA_RITE_ACTIVITY_AREA_ID_ERROR = 10004,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_BATTLE_NOT_FINISH = 10005;
     */
    RET_LUNA_RITE_ACTIVITY_BATTLE_NOT_FINISH = 10005,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_ALREADY_SACRIFICE = 10006;
     */
    RET_LUNA_RITE_ACTIVITY_ALREADY_SACRIFICE = 10006,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_ALREADY_TAKE_REWARD = 10007;
     */
    RET_LUNA_RITE_ACTIVITY_ALREADY_TAKE_REWARD = 10007,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_SACRIFICE_NOT_ENOUGH = 10008;
     */
    RET_LUNA_RITE_ACTIVITY_SACRIFICE_NOT_ENOUGH = 10008,
    /**
     * @generated from protobuf enum value: RET_LUNA_RITE_ACTIVITY_SEARCHING_COND_NOT_MEET = 10009;
     */
    RET_LUNA_RITE_ACTIVITY_SEARCHING_COND_NOT_MEET = 10009,
    /**
     * @generated from protobuf enum value: RET_DIG_GADGET_CONFIG_ID_NOT_MATCH = 10015;
     */
    RET_DIG_GADGET_CONFIG_ID_NOT_MATCH = 10015,
    /**
     * @generated from protobuf enum value: RET_DIG_FIND_NEAREST_POS_FAIL = 10016;
     */
    RET_DIG_FIND_NEAREST_POS_FAIL = 10016,
    /**
     * @generated from protobuf enum value: RET_MUSIC_GAME_LEVEL_NOT_OPEN = 10021;
     */
    RET_MUSIC_GAME_LEVEL_NOT_OPEN = 10021,
    /**
     * @generated from protobuf enum value: RET_MUSIC_GAME_LEVEL_NOT_UNLOCK = 10022;
     */
    RET_MUSIC_GAME_LEVEL_NOT_UNLOCK = 10022,
    /**
     * @generated from protobuf enum value: RET_MUSIC_GAME_LEVEL_NOT_STARTED = 10023;
     */
    RET_MUSIC_GAME_LEVEL_NOT_STARTED = 10023,
    /**
     * @generated from protobuf enum value: RET_MUSIC_GAME_LEVEL_CONFIG_NOT_FOUND = 10024;
     */
    RET_MUSIC_GAME_LEVEL_CONFIG_NOT_FOUND = 10024,
    /**
     * @generated from protobuf enum value: RET_MUSIC_GAME_LEVEL_ID_NOT_MATCH = 10025;
     */
    RET_MUSIC_GAME_LEVEL_ID_NOT_MATCH = 10025,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_A_NOT_ENOUGH = 10031;
     */
    RET_ROGUELIKE_COIN_A_NOT_ENOUGH = 10031,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_B_NOT_ENOUGH = 10032;
     */
    RET_ROGUELIKE_COIN_B_NOT_ENOUGH = 10032,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_C_NOT_ENOUGH = 10033;
     */
    RET_ROGUELIKE_COIN_C_NOT_ENOUGH = 10033,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_A_EXCEED_LIMIT = 10034;
     */
    RET_ROGUELIKE_COIN_A_EXCEED_LIMIT = 10034,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_B_EXCEED_LIMIT = 10035;
     */
    RET_ROGUELIKE_COIN_B_EXCEED_LIMIT = 10035,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_COIN_C_EXCEED_LIMIT = 10036;
     */
    RET_ROGUELIKE_COIN_C_EXCEED_LIMIT = 10036,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_RUNE_COUNT_NOT_ENOUGH = 10037;
     */
    RET_ROGUELIKE_RUNE_COUNT_NOT_ENOUGH = 10037,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_NOT_IN_ROGUE_DUNGEON = 10038;
     */
    RET_ROGUELIKE_NOT_IN_ROGUE_DUNGEON = 10038,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_CELL_NOT_FOUND = 10039;
     */
    RET_ROGUELIKE_CELL_NOT_FOUND = 10039,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_CELL_TYPE_INCORRECT = 10040;
     */
    RET_ROGUELIKE_CELL_TYPE_INCORRECT = 10040,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_CELL_ALREADY_FINISHED = 10041;
     */
    RET_ROGUELIKE_CELL_ALREADY_FINISHED = 10041,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_DUNGEON_HAVE_UNFINISHED_PROGRESS = 10042;
     */
    RET_ROGUELIKE_DUNGEON_HAVE_UNFINISHED_PROGRESS = 10042,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_STAGE_NOT_FINISHED = 10043;
     */
    RET_ROGUELIKE_STAGE_NOT_FINISHED = 10043,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_STAGE_FIRST_PASS_REWARD_HAS_TAKEN = 10045;
     */
    RET_ROGUELIKE_STAGE_FIRST_PASS_REWARD_HAS_TAKEN = 10045,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_ACTIVITY_CONTENT_CLOSED = 10046;
     */
    RET_ROGUELIKE_ACTIVITY_CONTENT_CLOSED = 10046,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_DUNGEON_PRE_QUEST_NOT_FINISHED = 10047;
     */
    RET_ROGUELIKE_DUNGEON_PRE_QUEST_NOT_FINISHED = 10047,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_DUNGEON_NOT_OPEN = 10048;
     */
    RET_ROGUELIKE_DUNGEON_NOT_OPEN = 10048,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_SPRINT_IS_BANNED = 10049;
     */
    RET_ROGUELIKE_SPRINT_IS_BANNED = 10049,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_DUNGEON_PRE_STAGE_NOT_FINISHED = 10050;
     */
    RET_ROGUELIKE_DUNGEON_PRE_STAGE_NOT_FINISHED = 10050,
    /**
     * @generated from protobuf enum value: RET_ROGUELIKE_ALL_AVATAR_DIE_CANNOT_RESUME = 10051;
     */
    RET_ROGUELIKE_ALL_AVATAR_DIE_CANNOT_RESUME = 10051,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_ALREADY_TAKE_SEED = 10056;
     */
    RET_PLANT_FLOWER_ALREADY_TAKE_SEED = 10056,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_FRIEND_HAVE_FLOWER_LIMIT = 10057;
     */
    RET_PLANT_FLOWER_FRIEND_HAVE_FLOWER_LIMIT = 10057,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_CAN_GIVE_FLOWER_NOT_ENOUGH = 10058;
     */
    RET_PLANT_FLOWER_CAN_GIVE_FLOWER_NOT_ENOUGH = 10058,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_WISH_FLOWER_KINDS_LIMIT = 10059;
     */
    RET_PLANT_FLOWER_WISH_FLOWER_KINDS_LIMIT = 10059,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_HAVE_FLOWER_NOT_ENOUGH = 10060;
     */
    RET_PLANT_FLOWER_HAVE_FLOWER_NOT_ENOUGH = 10060,
    /**
     * @generated from protobuf enum value: RET_PLANT_FLOWER_FLOWER_COMBINATION_INVALID = 10061;
     */
    RET_PLANT_FLOWER_FLOWER_COMBINATION_INVALID = 10061,
    /**
     * @generated from protobuf enum value: RET_NOT_IN_FISHING = 11001;
     */
    RET_NOT_IN_FISHING = 11001,
    /**
     * @generated from protobuf enum value: RET_FISH_STATE_ERROR = 11002;
     */
    RET_FISH_STATE_ERROR = 11002,
    /**
     * @generated from protobuf enum value: RET_FISH_BAIT_LIMIT = 11003;
     */
    RET_FISH_BAIT_LIMIT = 11003,
    /**
     * @generated from protobuf enum value: RET_FISHING_MAX_DISTANCE = 11004;
     */
    RET_FISHING_MAX_DISTANCE = 11004,
    /**
     * @generated from protobuf enum value: RET_FISHING_IN_COMBAT = 11005;
     */
    RET_FISHING_IN_COMBAT = 11005,
    /**
     * @generated from protobuf enum value: RET_FISHING_BATTLE_TOO_SHORT = 11006;
     */
    RET_FISHING_BATTLE_TOO_SHORT = 11006,
    /**
     * @generated from protobuf enum value: RET_FISH_GONE_AWAY = 11007;
     */
    RET_FISH_GONE_AWAY = 11007,
    /**
     * @generated from protobuf enum value: RET_FAIL = -1;
     */
    RET_FAIL = -1
}
/**
 * @generated from protobuf enum ShopGoodsDisableType
 */
export enum ShopGoodsDisableType {
    /**
     * @generated from protobuf enum value: SHOP_GOODS_DISABLE_NONE = 0;
     */
    SHOP_GOODS_DISABLE_NONE = 0,
    /**
     * @generated from protobuf enum value: SHOP_GOODS_DISABLE_TALENT_FULL = 1;
     */
    SHOP_GOODS_DISABLE_TALENT_FULL = 1,
    /**
     * @generated from protobuf enum value: SHOP_GOODS_DISABLE_FURNITURE_FORMULA_UNLOCKED = 2;
     */
    SHOP_GOODS_DISABLE_FURNITURE_FORMULA_UNLOCKED = 2,
    /**
     * @generated from protobuf enum value: SHOP_GOODS_DISABLE_COSTUME_UNLOCKED = 3;
     */
    SHOP_GOODS_DISABLE_COSTUME_UNLOCKED = 3
}
/**
 * @generated from protobuf enum StoreType
 */
export enum StoreType {
    /**
     * @generated from protobuf enum value: STORE_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: STORE_TYPE_PACK = 1;
     */
    PACK = 1,
    /**
     * @generated from protobuf enum value: STORE_TYPE_DEPOT = 2;
     */
    DEPOT = 2
}
/**
 * @generated from protobuf enum Unk2700_CBJEDMGOBPL
 */
export enum Unk2700_CBJEDMGOBPL {
    /**
     * @generated from protobuf enum value: Unk2700_CBJEDMGOBPL_Unk2700_MBLDLJOKLBL = 0;
     */
    Unk2700_CBJEDMGOBPL_Unk2700_MBLDLJOKLBL = 0,
    /**
     * @generated from protobuf enum value: Unk2700_CBJEDMGOBPL_Unk2700_ILOMIKADKGD = 1;
     */
    Unk2700_CBJEDMGOBPL_Unk2700_ILOMIKADKGD = 1,
    /**
     * @generated from protobuf enum value: Unk2700_CBJEDMGOBPL_Unk2700_HGHOEJGHMDH = 2;
     */
    Unk2700_CBJEDMGOBPL_Unk2700_HGHOEJGHMDH = 2,
    /**
     * @generated from protobuf enum value: Unk2700_CBJEDMGOBPL_Unk2700_PJCONIDJGOD = 3;
     */
    Unk2700_CBJEDMGOBPL_Unk2700_PJCONIDJGOD = 3
}
/**
 * @generated from protobuf enum Unk2700_FHOKHHBGPEG
 */
export enum Unk2700_FHOKHHBGPEG {
    /**
     * @generated from protobuf enum value: Unk2700_FHOKHHBGPEG_NONE = 0;
     */
    Unk2700_FHOKHHBGPEG_NONE = 0,
    /**
     * @generated from protobuf enum value: Unk2700_FHOKHHBGPEG_FAIL = 1;
     */
    Unk2700_FHOKHHBGPEG_FAIL = 1,
    /**
     * @generated from protobuf enum value: Unk2700_FHOKHHBGPEG_SUCC = 2;
     */
    Unk2700_FHOKHHBGPEG_SUCC = 2,
    /**
     * @generated from protobuf enum value: Unk2700_FHOKHHBGPEG_Unk2700_GGDJFCKGBGE = 3;
     */
    Unk2700_FHOKHHBGPEG_Unk2700_GGDJFCKGBGE = 3
}
/**
 * @generated from protobuf enum Unk2700_OCOKILBJIPJ
 */
export enum Unk2700_OCOKILBJIPJ {
    /**
     * @generated from protobuf enum value: Unk2700_OCOKILBJIPJ_Unk2700_MPGOEMPNCEH = 0;
     */
    Unk2700_OCOKILBJIPJ_Unk2700_MPGOEMPNCEH = 0,
    /**
     * @generated from protobuf enum value: Unk2700_OCOKILBJIPJ_Unk2700_PDKBOLMIHMA = 1;
     */
    Unk2700_OCOKILBJIPJ_Unk2700_PDKBOLMIHMA = 1,
    /**
     * @generated from protobuf enum value: Unk2700_OCOKILBJIPJ_Unk2700_MCEBEJONJGH = 2;
     */
    Unk2700_OCOKILBJIPJ_Unk2700_MCEBEJONJGH = 2,
    /**
     * @generated from protobuf enum value: Unk2700_OCOKILBJIPJ_Unk2700_MCNDLHHBBGJ = 3;
     */
    Unk2700_OCOKILBJIPJ_Unk2700_MCNDLHHBBGJ = 3
}
/**
 * @generated from protobuf enum Unk2800_FDLKPKFOIIK
 */
export enum Unk2800_FDLKPKFOIIK {
    /**
     * @generated from protobuf enum value: Unk2800_FDLKPKFOIIK_NONE = 0;
     */
    Unk2800_FDLKPKFOIIK_NONE = 0,
    /**
     * @generated from protobuf enum value: Unk2800_FDLKPKFOIIK_START = 1;
     */
    Unk2800_FDLKPKFOIIK_START = 1,
    /**
     * @generated from protobuf enum value: Unk2800_FDLKPKFOIIK_Unk2800_FDPBDHDHAKO = 2;
     */
    Unk2800_FDLKPKFOIIK_Unk2800_FDPBDHDHAKO = 2
}
/**
 * @generated from protobuf enum VehicleInteractType
 */
export enum VehicleInteractType {
    /**
     * @generated from protobuf enum value: VEHICLE_INTERACT_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: VEHICLE_INTERACT_TYPE_IN = 1;
     */
    IN = 1,
    /**
     * @generated from protobuf enum value: VEHICLE_INTERACT_TYPE_OUT = 2;
     */
    OUT = 2
}
/**
 * @generated from protobuf enum VisionType
 */
export enum VisionType {
    /**
     * @generated from protobuf enum value: VISION_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: VISION_TYPE_MEET = 1;
     */
    MEET = 1,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REBORN = 2;
     */
    REBORN = 2,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REPLACE = 3;
     */
    REPLACE = 3,
    /**
     * @generated from protobuf enum value: VISION_TYPE_WAYPOINT_REBORN = 4;
     */
    WAYPOINT_REBORN = 4,
    /**
     * @generated from protobuf enum value: VISION_TYPE_MISS = 5;
     */
    MISS = 5,
    /**
     * @generated from protobuf enum value: VISION_TYPE_DIE = 6;
     */
    DIE = 6,
    /**
     * @generated from protobuf enum value: VISION_TYPE_GATHER_ESCAPE = 7;
     */
    GATHER_ESCAPE = 7,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REFRESH = 8;
     */
    REFRESH = 8,
    /**
     * @generated from protobuf enum value: VISION_TYPE_TRANSPORT = 9;
     */
    TRANSPORT = 9,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REPLACE_DIE = 10;
     */
    REPLACE_DIE = 10,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REPLACE_NO_NOTIFY = 11;
     */
    REPLACE_NO_NOTIFY = 11,
    /**
     * @generated from protobuf enum value: VISION_TYPE_BORN = 12;
     */
    BORN = 12,
    /**
     * @generated from protobuf enum value: VISION_TYPE_PICKUP = 13;
     */
    PICKUP = 13,
    /**
     * @generated from protobuf enum value: VISION_TYPE_REMOVE = 14;
     */
    REMOVE = 14,
    /**
     * @generated from protobuf enum value: VISION_TYPE_CHANGE_COSTUME = 15;
     */
    CHANGE_COSTUME = 15,
    /**
     * @generated from protobuf enum value: VISION_TYPE_FISH_REFRESH = 16;
     */
    FISH_REFRESH = 16,
    /**
     * @generated from protobuf enum value: VISION_TYPE_FISH_BIG_SHOCK = 17;
     */
    FISH_BIG_SHOCK = 17,
    /**
     * @generated from protobuf enum value: VISION_TYPE_FISH_QTE_SUCC = 18;
     */
    FISH_QTE_SUCC = 18
}
/**
 * @generated from protobuf enum WidgetCreatorOpType
 */
export enum WidgetCreatorOpType {
    /**
     * @generated from protobuf enum value: WIDGET_CREATOR_OP_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: WIDGET_CREATOR_OP_TYPE_RETRACT = 1;
     */
    RETRACT = 1,
    /**
     * @generated from protobuf enum value: WIDGET_CREATOR_OP_TYPE_RETRACT_AND_CREATE = 2;
     */
    RETRACT_AND_CREATE = 2
}
/**
 * @generated from protobuf enum WidgetSlotOp
 */
export enum WidgetSlotOp {
    /**
     * @generated from protobuf enum value: WIDGET_SLOT_OP_ATTACH = 0;
     */
    ATTACH = 0,
    /**
     * @generated from protobuf enum value: WIDGET_SLOT_OP_DETACH = 1;
     */
    DETACH = 1
}
/**
 * @generated from protobuf enum WidgetSlotTag
 */
export enum WidgetSlotTag {
    /**
     * @generated from protobuf enum value: WIDGET_SLOT_TAG_QUICK_USE = 0;
     */
    QUICK_USE = 0,
    /**
     * @generated from protobuf enum value: WIDGET_SLOT_TAG_ATTACH_AVATAR = 1;
     */
    ATTACH_AVATAR = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class AbilityActionGenerateElemBall$Type extends MessageType<AbilityActionGenerateElemBall> {
    constructor() {
        super("AbilityActionGenerateElemBall", [
            { no: 1, name: "pos", kind: "message", T: () => Vector },
            { no: 2, name: "rot", kind: "message", T: () => Vector },
            { no: 3, name: "room_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityActionGenerateElemBall>): AbilityActionGenerateElemBall {
        const message = { roomId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityActionGenerateElemBall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityActionGenerateElemBall): AbilityActionGenerateElemBall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector pos */ 1:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 2:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* uint32 room_id */ 3:
                    message.roomId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityActionGenerateElemBall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector pos = 1; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 2; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 room_id = 3; */
        if (message.roomId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.roomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityActionGenerateElemBall
 */
export const AbilityActionGenerateElemBall = new AbilityActionGenerateElemBall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityAppliedAbility$Type extends MessageType<AbilityAppliedAbility> {
    constructor() {
        super("AbilityAppliedAbility", [
            { no: 1, name: "ability_name", kind: "message", T: () => AbilityString },
            { no: 2, name: "ability_override", kind: "message", T: () => AbilityString },
            { no: 3, name: "override_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityScalarValueEntry },
            { no: 4, name: "instanced_ability_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityAppliedAbility>): AbilityAppliedAbility {
        const message = { overrideMap: [], instancedAbilityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityAppliedAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityAppliedAbility): AbilityAppliedAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AbilityString ability_name */ 1:
                    message.abilityName = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.abilityName);
                    break;
                case /* AbilityString ability_override */ 2:
                    message.abilityOverride = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.abilityOverride);
                    break;
                case /* repeated AbilityScalarValueEntry override_map */ 3:
                    message.overrideMap.push(AbilityScalarValueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 instanced_ability_id */ 4:
                    message.instancedAbilityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityAppliedAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AbilityString ability_name = 1; */
        if (message.abilityName)
            AbilityString.internalBinaryWrite(message.abilityName, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* AbilityString ability_override = 2; */
        if (message.abilityOverride)
            AbilityString.internalBinaryWrite(message.abilityOverride, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityScalarValueEntry override_map = 3; */
        for (let i = 0; i < message.overrideMap.length; i++)
            AbilityScalarValueEntry.internalBinaryWrite(message.overrideMap[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 instanced_ability_id = 4; */
        if (message.instancedAbilityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.instancedAbilityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityAppliedAbility
 */
export const AbilityAppliedAbility = new AbilityAppliedAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityAppliedModifier$Type extends MessageType<AbilityAppliedModifier> {
    constructor() {
        super("AbilityAppliedModifier", [
            { no: 1, name: "modifier_local_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "parent_ability_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "parent_ability_name", kind: "message", T: () => AbilityString },
            { no: 4, name: "parent_ability_override", kind: "message", T: () => AbilityString },
            { no: 5, name: "instanced_ability_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "instanced_modifier_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "exist_duration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "attached_instanced_modifier", kind: "message", T: () => AbilityAttachedModifier },
            { no: 9, name: "apply_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_attached_parent_ability", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "modifier_durability", kind: "message", T: () => ModifierDurability },
            { no: 12, name: "sbuff_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_serverbuff_modifier", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityAppliedModifier>): AbilityAppliedModifier {
        const message = { modifierLocalId: 0, parentAbilityEntityId: 0, instancedAbilityId: 0, instancedModifierId: 0, existDuration: 0, applyEntityId: 0, isAttachedParentAbility: false, sbuffUid: 0, isServerbuffModifier: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityAppliedModifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityAppliedModifier): AbilityAppliedModifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 modifier_local_id */ 1:
                    message.modifierLocalId = reader.int32();
                    break;
                case /* uint32 parent_ability_entity_id */ 2:
                    message.parentAbilityEntityId = reader.uint32();
                    break;
                case /* AbilityString parent_ability_name */ 3:
                    message.parentAbilityName = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.parentAbilityName);
                    break;
                case /* AbilityString parent_ability_override */ 4:
                    message.parentAbilityOverride = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.parentAbilityOverride);
                    break;
                case /* uint32 instanced_ability_id */ 5:
                    message.instancedAbilityId = reader.uint32();
                    break;
                case /* uint32 instanced_modifier_id */ 6:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* float exist_duration */ 7:
                    message.existDuration = reader.float();
                    break;
                case /* AbilityAttachedModifier attached_instanced_modifier */ 8:
                    message.attachedInstancedModifier = AbilityAttachedModifier.internalBinaryRead(reader, reader.uint32(), options, message.attachedInstancedModifier);
                    break;
                case /* uint32 apply_entity_id */ 9:
                    message.applyEntityId = reader.uint32();
                    break;
                case /* bool is_attached_parent_ability */ 10:
                    message.isAttachedParentAbility = reader.bool();
                    break;
                case /* ModifierDurability modifier_durability */ 11:
                    message.modifierDurability = ModifierDurability.internalBinaryRead(reader, reader.uint32(), options, message.modifierDurability);
                    break;
                case /* uint32 sbuff_uid */ 12:
                    message.sbuffUid = reader.uint32();
                    break;
                case /* bool is_serverbuff_modifier */ 13:
                    message.isServerbuffModifier = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityAppliedModifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 modifier_local_id = 1; */
        if (message.modifierLocalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.modifierLocalId);
        /* uint32 parent_ability_entity_id = 2; */
        if (message.parentAbilityEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.parentAbilityEntityId);
        /* AbilityString parent_ability_name = 3; */
        if (message.parentAbilityName)
            AbilityString.internalBinaryWrite(message.parentAbilityName, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* AbilityString parent_ability_override = 4; */
        if (message.parentAbilityOverride)
            AbilityString.internalBinaryWrite(message.parentAbilityOverride, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 instanced_ability_id = 5; */
        if (message.instancedAbilityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.instancedAbilityId);
        /* uint32 instanced_modifier_id = 6; */
        if (message.instancedModifierId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.instancedModifierId);
        /* float exist_duration = 7; */
        if (message.existDuration !== 0)
            writer.tag(7, WireType.Bit32).float(message.existDuration);
        /* AbilityAttachedModifier attached_instanced_modifier = 8; */
        if (message.attachedInstancedModifier)
            AbilityAttachedModifier.internalBinaryWrite(message.attachedInstancedModifier, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 apply_entity_id = 9; */
        if (message.applyEntityId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.applyEntityId);
        /* bool is_attached_parent_ability = 10; */
        if (message.isAttachedParentAbility !== false)
            writer.tag(10, WireType.Varint).bool(message.isAttachedParentAbility);
        /* ModifierDurability modifier_durability = 11; */
        if (message.modifierDurability)
            ModifierDurability.internalBinaryWrite(message.modifierDurability, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 sbuff_uid = 12; */
        if (message.sbuffUid !== 0)
            writer.tag(12, WireType.Varint).uint32(message.sbuffUid);
        /* bool is_serverbuff_modifier = 13; */
        if (message.isServerbuffModifier !== false)
            writer.tag(13, WireType.Varint).bool(message.isServerbuffModifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityAppliedModifier
 */
export const AbilityAppliedModifier = new AbilityAppliedModifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityAttachedModifier$Type extends MessageType<AbilityAttachedModifier> {
    constructor() {
        super("AbilityAttachedModifier", [
            { no: 1, name: "is_invalid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "instanced_modifier_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_serverbuff_modifier", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "attach_name_hash", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityAttachedModifier>): AbilityAttachedModifier {
        const message = { isInvalid: false, ownerEntityId: 0, instancedModifierId: 0, isServerbuffModifier: false, attachNameHash: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityAttachedModifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityAttachedModifier): AbilityAttachedModifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_invalid */ 1:
                    message.isInvalid = reader.bool();
                    break;
                case /* uint32 owner_entity_id */ 2:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* uint32 instanced_modifier_id */ 3:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* bool is_serverbuff_modifier */ 4:
                    message.isServerbuffModifier = reader.bool();
                    break;
                case /* int32 attach_name_hash */ 5:
                    message.attachNameHash = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityAttachedModifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_invalid = 1; */
        if (message.isInvalid !== false)
            writer.tag(1, WireType.Varint).bool(message.isInvalid);
        /* uint32 owner_entity_id = 2; */
        if (message.ownerEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.ownerEntityId);
        /* uint32 instanced_modifier_id = 3; */
        if (message.instancedModifierId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.instancedModifierId);
        /* bool is_serverbuff_modifier = 4; */
        if (message.isServerbuffModifier !== false)
            writer.tag(4, WireType.Varint).bool(message.isServerbuffModifier);
        /* int32 attach_name_hash = 5; */
        if (message.attachNameHash !== 0)
            writer.tag(5, WireType.Varint).int32(message.attachNameHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityAttachedModifier
 */
export const AbilityAttachedModifier = new AbilityAttachedModifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityChangeNotify$Type extends MessageType<AbilityChangeNotify> {
    constructor() {
        super("AbilityChangeNotify", [
            { no: 3, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "ability_control_block", kind: "message", T: () => AbilityControlBlock }
        ]);
    }
    create(value?: PartialMessage<AbilityChangeNotify>): AbilityChangeNotify {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityChangeNotify): AbilityChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 3:
                    message.entityId = reader.uint32();
                    break;
                case /* AbilityControlBlock ability_control_block */ 10:
                    message.abilityControlBlock = AbilityControlBlock.internalBinaryRead(reader, reader.uint32(), options, message.abilityControlBlock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 3; */
        if (message.entityId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.entityId);
        /* AbilityControlBlock ability_control_block = 10; */
        if (message.abilityControlBlock)
            AbilityControlBlock.internalBinaryWrite(message.abilityControlBlock, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityChangeNotify
 */
export const AbilityChangeNotify = new AbilityChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityControlBlock$Type extends MessageType<AbilityControlBlock> {
    constructor() {
        super("AbilityControlBlock", [
            { no: 1, name: "ability_embryo_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityEmbryo }
        ]);
    }
    create(value?: PartialMessage<AbilityControlBlock>): AbilityControlBlock {
        const message = { abilityEmbryoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityControlBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityControlBlock): AbilityControlBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AbilityEmbryo ability_embryo_list */ 1:
                    message.abilityEmbryoList.push(AbilityEmbryo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityControlBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AbilityEmbryo ability_embryo_list = 1; */
        for (let i = 0; i < message.abilityEmbryoList.length; i++)
            AbilityEmbryo.internalBinaryWrite(message.abilityEmbryoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityControlBlock
 */
export const AbilityControlBlock = new AbilityControlBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityEmbryo$Type extends MessageType<AbilityEmbryo> {
    constructor() {
        super("AbilityEmbryo", [
            { no: 1, name: "ability_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "ability_name_hash", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "ability_override_name_hash", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityEmbryo>): AbilityEmbryo {
        const message = { abilityId: 0, abilityNameHash: 0, abilityOverrideNameHash: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityEmbryo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityEmbryo): AbilityEmbryo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 ability_id */ 1:
                    message.abilityId = reader.uint32();
                    break;
                case /* fixed32 ability_name_hash */ 2:
                    message.abilityNameHash = reader.fixed32();
                    break;
                case /* fixed32 ability_override_name_hash */ 3:
                    message.abilityOverrideNameHash = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityEmbryo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 ability_id = 1; */
        if (message.abilityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.abilityId);
        /* fixed32 ability_name_hash = 2; */
        if (message.abilityNameHash !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.abilityNameHash);
        /* fixed32 ability_override_name_hash = 3; */
        if (message.abilityOverrideNameHash !== 0)
            writer.tag(3, WireType.Bit32).fixed32(message.abilityOverrideNameHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityEmbryo
 */
export const AbilityEmbryo = new AbilityEmbryo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityGadgetInfo$Type extends MessageType<AbilityGadgetInfo> {
    constructor() {
        super("AbilityGadgetInfo", [
            { no: 1, name: "camp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "camp_target_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "target_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityGadgetInfo>): AbilityGadgetInfo {
        const message = { campId: 0, campTargetType: 0, targetEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityGadgetInfo): AbilityGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 camp_id */ 1:
                    message.campId = reader.uint32();
                    break;
                case /* uint32 camp_target_type */ 2:
                    message.campTargetType = reader.uint32();
                    break;
                case /* uint32 target_entity_id */ 3:
                    message.targetEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 camp_id = 1; */
        if (message.campId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.campId);
        /* uint32 camp_target_type = 2; */
        if (message.campTargetType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.campTargetType);
        /* uint32 target_entity_id = 3; */
        if (message.targetEntityId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.targetEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityGadgetInfo
 */
export const AbilityGadgetInfo = new AbilityGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityIdentifier$Type extends MessageType<AbilityIdentifier> {
    constructor() {
        super("AbilityIdentifier", [
            { no: 8, name: "instanced_ability_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "ability_caster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "local_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "instanced_modifier_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "modifier_owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_serverbuff_modifier", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityIdentifier>): AbilityIdentifier {
        const message = { instancedAbilityId: 0, abilityCasterId: 0, localId: 0, instancedModifierId: 0, modifierOwnerId: 0, isServerbuffModifier: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityIdentifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityIdentifier): AbilityIdentifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instanced_ability_id */ 8:
                    message.instancedAbilityId = reader.uint32();
                    break;
                case /* uint32 ability_caster_id */ 14:
                    message.abilityCasterId = reader.uint32();
                    break;
                case /* int32 local_id */ 7:
                    message.localId = reader.int32();
                    break;
                case /* uint32 instanced_modifier_id */ 9:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* uint32 modifier_owner_id */ 11:
                    message.modifierOwnerId = reader.uint32();
                    break;
                case /* bool is_serverbuff_modifier */ 6:
                    message.isServerbuffModifier = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instanced_ability_id = 8; */
        if (message.instancedAbilityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.instancedAbilityId);
        /* uint32 ability_caster_id = 14; */
        if (message.abilityCasterId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.abilityCasterId);
        /* int32 local_id = 7; */
        if (message.localId !== 0)
            writer.tag(7, WireType.Varint).int32(message.localId);
        /* uint32 instanced_modifier_id = 9; */
        if (message.instancedModifierId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.instancedModifierId);
        /* uint32 modifier_owner_id = 11; */
        if (message.modifierOwnerId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.modifierOwnerId);
        /* bool is_serverbuff_modifier = 6; */
        if (message.isServerbuffModifier !== false)
            writer.tag(6, WireType.Varint).bool(message.isServerbuffModifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityIdentifier
 */
export const AbilityIdentifier = new AbilityIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityInvocationsNotify$Type extends MessageType<AbilityInvocationsNotify> {
    constructor() {
        super("AbilityInvocationsNotify", [
            { no: 8, name: "invokes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityInvokeEntry }
        ]);
    }
    create(value?: PartialMessage<AbilityInvocationsNotify>): AbilityInvocationsNotify {
        const message = { invokes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityInvocationsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityInvocationsNotify): AbilityInvocationsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AbilityInvokeEntry invokes */ 8:
                    message.invokes.push(AbilityInvokeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityInvocationsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AbilityInvokeEntry invokes = 8; */
        for (let i = 0; i < message.invokes.length; i++)
            AbilityInvokeEntry.internalBinaryWrite(message.invokes[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityInvocationsNotify
 */
export const AbilityInvocationsNotify = new AbilityInvocationsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityInvokeEntry$Type extends MessageType<AbilityInvokeEntry> {
    constructor() {
        super("AbilityInvokeEntry", [
            { no: 1, name: "head", kind: "message", T: () => AbilityInvokeEntryHead },
            { no: 7, name: "argument_type", kind: "enum", T: () => ["AbilityInvokeArgument", AbilityInvokeArgument, "ABILITY_INVOKE_ARGUMENT_"] },
            { no: 12, name: "ability_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 14, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 4, name: "forward_peer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "event_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "total_tick_time", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityInvokeEntry>): AbilityInvokeEntry {
        const message = { argumentType: 0, abilityData: new Uint8Array(0), entityId: 0, forwardType: 0, forwardPeer: 0, eventId: 0, totalTickTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityInvokeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityInvokeEntry): AbilityInvokeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AbilityInvokeEntryHead head */ 1:
                    message.head = AbilityInvokeEntryHead.internalBinaryRead(reader, reader.uint32(), options, message.head);
                    break;
                case /* AbilityInvokeArgument argument_type */ 7:
                    message.argumentType = reader.int32();
                    break;
                case /* bytes ability_data */ 12:
                    message.abilityData = reader.bytes();
                    break;
                case /* uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                case /* ForwardType forward_type */ 8:
                    message.forwardType = reader.int32();
                    break;
                case /* uint32 forward_peer */ 4:
                    message.forwardPeer = reader.uint32();
                    break;
                case /* uint32 event_id */ 3:
                    message.eventId = reader.uint32();
                    break;
                case /* double total_tick_time */ 9:
                    message.totalTickTime = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityInvokeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AbilityInvokeEntryHead head = 1; */
        if (message.head)
            AbilityInvokeEntryHead.internalBinaryWrite(message.head, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* AbilityInvokeArgument argument_type = 7; */
        if (message.argumentType !== 0)
            writer.tag(7, WireType.Varint).int32(message.argumentType);
        /* bytes ability_data = 12; */
        if (message.abilityData.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.abilityData);
        /* uint32 entity_id = 14; */
        if (message.entityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        /* ForwardType forward_type = 8; */
        if (message.forwardType !== 0)
            writer.tag(8, WireType.Varint).int32(message.forwardType);
        /* uint32 forward_peer = 4; */
        if (message.forwardPeer !== 0)
            writer.tag(4, WireType.Varint).uint32(message.forwardPeer);
        /* uint32 event_id = 3; */
        if (message.eventId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.eventId);
        /* double total_tick_time = 9; */
        if (message.totalTickTime !== 0)
            writer.tag(9, WireType.Bit64).double(message.totalTickTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityInvokeEntry
 */
export const AbilityInvokeEntry = new AbilityInvokeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityInvokeEntryHead$Type extends MessageType<AbilityInvokeEntryHead> {
    constructor() {
        super("AbilityInvokeEntryHead", [
            { no: 6, name: "instanced_ability_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "instanced_modifier_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "local_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "modifier_config_local_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "target_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_serverbuff_modifier", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "server_buff_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityInvokeEntryHead>): AbilityInvokeEntryHead {
        const message = { instancedAbilityId: 0, instancedModifierId: 0, localId: 0, modifierConfigLocalId: 0, targetId: 0, isServerbuffModifier: false, serverBuffUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityInvokeEntryHead>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityInvokeEntryHead): AbilityInvokeEntryHead {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instanced_ability_id */ 6:
                    message.instancedAbilityId = reader.uint32();
                    break;
                case /* uint32 instanced_modifier_id */ 10:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* int32 local_id */ 3:
                    message.localId = reader.int32();
                    break;
                case /* int32 modifier_config_local_id */ 14:
                    message.modifierConfigLocalId = reader.int32();
                    break;
                case /* uint32 target_id */ 11:
                    message.targetId = reader.uint32();
                    break;
                case /* bool is_serverbuff_modifier */ 15:
                    message.isServerbuffModifier = reader.bool();
                    break;
                case /* uint32 server_buff_uid */ 5:
                    message.serverBuffUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityInvokeEntryHead, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instanced_ability_id = 6; */
        if (message.instancedAbilityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.instancedAbilityId);
        /* uint32 instanced_modifier_id = 10; */
        if (message.instancedModifierId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.instancedModifierId);
        /* int32 local_id = 3; */
        if (message.localId !== 0)
            writer.tag(3, WireType.Varint).int32(message.localId);
        /* int32 modifier_config_local_id = 14; */
        if (message.modifierConfigLocalId !== 0)
            writer.tag(14, WireType.Varint).int32(message.modifierConfigLocalId);
        /* uint32 target_id = 11; */
        if (message.targetId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.targetId);
        /* bool is_serverbuff_modifier = 15; */
        if (message.isServerbuffModifier !== false)
            writer.tag(15, WireType.Varint).bool(message.isServerbuffModifier);
        /* uint32 server_buff_uid = 5; */
        if (message.serverBuffUid !== 0)
            writer.tag(5, WireType.Varint).uint32(message.serverBuffUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityInvokeEntryHead
 */
export const AbilityInvokeEntryHead = new AbilityInvokeEntryHead$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityMetaModifierChange$Type extends MessageType<AbilityMetaModifierChange> {
    constructor() {
        super("AbilityMetaModifierChange", [
            { no: 1, name: "action", kind: "enum", T: () => ["ModifierAction", ModifierAction] },
            { no: 2, name: "parent_ability_name", kind: "message", T: () => AbilityString },
            { no: 3, name: "parent_ability_override", kind: "message", T: () => AbilityString },
            { no: 4, name: "attached_instanced_modifier", kind: "message", T: () => AbilityAttachedModifier },
            { no: 5, name: "properties", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModifierProperty },
            { no: 6, name: "modifier_local_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "is_mute_remote", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "apply_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_attached_parent_ability", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "server_buff_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityMetaModifierChange>): AbilityMetaModifierChange {
        const message = { action: 0, properties: [], modifierLocalId: 0, isMuteRemote: false, applyEntityId: 0, isAttachedParentAbility: false, serverBuffUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityMetaModifierChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityMetaModifierChange): AbilityMetaModifierChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ModifierAction action */ 1:
                    message.action = reader.int32();
                    break;
                case /* AbilityString parent_ability_name */ 2:
                    message.parentAbilityName = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.parentAbilityName);
                    break;
                case /* AbilityString parent_ability_override */ 3:
                    message.parentAbilityOverride = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.parentAbilityOverride);
                    break;
                case /* AbilityAttachedModifier attached_instanced_modifier */ 4:
                    message.attachedInstancedModifier = AbilityAttachedModifier.internalBinaryRead(reader, reader.uint32(), options, message.attachedInstancedModifier);
                    break;
                case /* repeated ModifierProperty properties */ 5:
                    message.properties.push(ModifierProperty.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 modifier_local_id */ 6:
                    message.modifierLocalId = reader.int32();
                    break;
                case /* bool is_mute_remote */ 7:
                    message.isMuteRemote = reader.bool();
                    break;
                case /* uint32 apply_entity_id */ 8:
                    message.applyEntityId = reader.uint32();
                    break;
                case /* bool is_attached_parent_ability */ 9:
                    message.isAttachedParentAbility = reader.bool();
                    break;
                case /* uint32 server_buff_uid */ 10:
                    message.serverBuffUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityMetaModifierChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ModifierAction action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* AbilityString parent_ability_name = 2; */
        if (message.parentAbilityName)
            AbilityString.internalBinaryWrite(message.parentAbilityName, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* AbilityString parent_ability_override = 3; */
        if (message.parentAbilityOverride)
            AbilityString.internalBinaryWrite(message.parentAbilityOverride, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* AbilityAttachedModifier attached_instanced_modifier = 4; */
        if (message.attachedInstancedModifier)
            AbilityAttachedModifier.internalBinaryWrite(message.attachedInstancedModifier, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated ModifierProperty properties = 5; */
        for (let i = 0; i < message.properties.length; i++)
            ModifierProperty.internalBinaryWrite(message.properties[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 modifier_local_id = 6; */
        if (message.modifierLocalId !== 0)
            writer.tag(6, WireType.Varint).int32(message.modifierLocalId);
        /* bool is_mute_remote = 7; */
        if (message.isMuteRemote !== false)
            writer.tag(7, WireType.Varint).bool(message.isMuteRemote);
        /* uint32 apply_entity_id = 8; */
        if (message.applyEntityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.applyEntityId);
        /* bool is_attached_parent_ability = 9; */
        if (message.isAttachedParentAbility !== false)
            writer.tag(9, WireType.Varint).bool(message.isAttachedParentAbility);
        /* uint32 server_buff_uid = 10; */
        if (message.serverBuffUid !== 0)
            writer.tag(10, WireType.Varint).uint32(message.serverBuffUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityMetaModifierChange
 */
export const AbilityMetaModifierChange = new AbilityMetaModifierChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityMetaReInitOverrideMap$Type extends MessageType<AbilityMetaReInitOverrideMap> {
    constructor() {
        super("AbilityMetaReInitOverrideMap", [
            { no: 1, name: "override_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityScalarValueEntry }
        ]);
    }
    create(value?: PartialMessage<AbilityMetaReInitOverrideMap>): AbilityMetaReInitOverrideMap {
        const message = { overrideMap: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityMetaReInitOverrideMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityMetaReInitOverrideMap): AbilityMetaReInitOverrideMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AbilityScalarValueEntry override_map */ 1:
                    message.overrideMap.push(AbilityScalarValueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityMetaReInitOverrideMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AbilityScalarValueEntry override_map = 1; */
        for (let i = 0; i < message.overrideMap.length; i++)
            AbilityScalarValueEntry.internalBinaryWrite(message.overrideMap[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityMetaReInitOverrideMap
 */
export const AbilityMetaReInitOverrideMap = new AbilityMetaReInitOverrideMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityMixinCostStamina$Type extends MessageType<AbilityMixinCostStamina> {
    constructor() {
        super("AbilityMixinCostStamina", [
            { no: 1, name: "is_swim", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityMixinCostStamina>): AbilityMixinCostStamina {
        const message = { isSwim: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityMixinCostStamina>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityMixinCostStamina): AbilityMixinCostStamina {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_swim */ 1:
                    message.isSwim = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityMixinCostStamina, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_swim = 1; */
        if (message.isSwim !== false)
            writer.tag(1, WireType.Varint).bool(message.isSwim);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityMixinCostStamina
 */
export const AbilityMixinCostStamina = new AbilityMixinCostStamina$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityMixinRecoverInfo$Type extends MessageType<AbilityMixinRecoverInfo> {
    constructor() {
        super("AbilityMixinRecoverInfo", [
            { no: 3, name: "local_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "data_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_serverbuff_modifier", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "massive_prop_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MassivePropSyncInfo },
            { no: 1, name: "instanced_ability_id", kind: "scalar", oneof: "source", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "instanced_modifier_id", kind: "scalar", oneof: "source", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityMixinRecoverInfo>): AbilityMixinRecoverInfo {
        const message = { localId: 0, dataList: [], isServerbuffModifier: false, massivePropList: [], source: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityMixinRecoverInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityMixinRecoverInfo): AbilityMixinRecoverInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 local_id */ 3:
                    message.localId = reader.uint32();
                    break;
                case /* repeated uint32 data_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataList.push(reader.uint32());
                    else
                        message.dataList.push(reader.uint32());
                    break;
                case /* bool is_serverbuff_modifier */ 5:
                    message.isServerbuffModifier = reader.bool();
                    break;
                case /* repeated MassivePropSyncInfo massive_prop_list */ 6:
                    message.massivePropList.push(MassivePropSyncInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 instanced_ability_id */ 1:
                    message.source = {
                        oneofKind: "instancedAbilityId",
                        instancedAbilityId: reader.uint32()
                    };
                    break;
                case /* uint32 instanced_modifier_id */ 2:
                    message.source = {
                        oneofKind: "instancedModifierId",
                        instancedModifierId: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityMixinRecoverInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 local_id = 3; */
        if (message.localId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.localId);
        /* repeated uint32 data_list = 4; */
        if (message.dataList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dataList.length; i++)
                writer.uint32(message.dataList[i]);
            writer.join();
        }
        /* bool is_serverbuff_modifier = 5; */
        if (message.isServerbuffModifier !== false)
            writer.tag(5, WireType.Varint).bool(message.isServerbuffModifier);
        /* repeated MassivePropSyncInfo massive_prop_list = 6; */
        for (let i = 0; i < message.massivePropList.length; i++)
            MassivePropSyncInfo.internalBinaryWrite(message.massivePropList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 instanced_ability_id = 1; */
        if (message.source.oneofKind === "instancedAbilityId")
            writer.tag(1, WireType.Varint).uint32(message.source.instancedAbilityId);
        /* uint32 instanced_modifier_id = 2; */
        if (message.source.oneofKind === "instancedModifierId")
            writer.tag(2, WireType.Varint).uint32(message.source.instancedModifierId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityMixinRecoverInfo
 */
export const AbilityMixinRecoverInfo = new AbilityMixinRecoverInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityMixinWidgetMpSupport$Type extends MessageType<AbilityMixinWidgetMpSupport> {
    constructor() {
        super("AbilityMixinWidgetMpSupport", [
            { no: 1, name: "target_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityMixinWidgetMpSupport>): AbilityMixinWidgetMpSupport {
        const message = { targetEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityMixinWidgetMpSupport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityMixinWidgetMpSupport): AbilityMixinWidgetMpSupport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_entity_id */ 1:
                    message.targetEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityMixinWidgetMpSupport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_entity_id = 1; */
        if (message.targetEntityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.targetEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityMixinWidgetMpSupport
 */
export const AbilityMixinWidgetMpSupport = new AbilityMixinWidgetMpSupport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityScalarValueEntry$Type extends MessageType<AbilityScalarValueEntry> {
    constructor() {
        super("AbilityScalarValueEntry", [
            { no: 1, name: "key", kind: "message", T: () => AbilityString },
            { no: 2, name: "value_type", kind: "enum", T: () => ["AbilityScalarType", AbilityScalarType, "ABILITY_SCALAR_TYPE_"] },
            { no: 3, name: "float_value", kind: "scalar", oneof: "value", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "string_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "int_value", kind: "scalar", oneof: "value", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "uint_value", kind: "scalar", oneof: "value", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityScalarValueEntry>): AbilityScalarValueEntry {
        const message = { valueType: 0, value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityScalarValueEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityScalarValueEntry): AbilityScalarValueEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AbilityString key */ 1:
                    message.key = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* AbilityScalarType value_type */ 2:
                    message.valueType = reader.int32();
                    break;
                case /* float float_value */ 3:
                    message.value = {
                        oneofKind: "floatValue",
                        floatValue: reader.float()
                    };
                    break;
                case /* string string_value */ 4:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* int32 int_value */ 5:
                    message.value = {
                        oneofKind: "intValue",
                        intValue: reader.int32()
                    };
                    break;
                case /* uint32 uint_value */ 6:
                    message.value = {
                        oneofKind: "uintValue",
                        uintValue: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityScalarValueEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AbilityString key = 1; */
        if (message.key)
            AbilityString.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* AbilityScalarType value_type = 2; */
        if (message.valueType !== 0)
            writer.tag(2, WireType.Varint).int32(message.valueType);
        /* float float_value = 3; */
        if (message.value.oneofKind === "floatValue")
            writer.tag(3, WireType.Bit32).float(message.value.floatValue);
        /* string string_value = 4; */
        if (message.value.oneofKind === "stringValue")
            writer.tag(4, WireType.LengthDelimited).string(message.value.stringValue);
        /* int32 int_value = 5; */
        if (message.value.oneofKind === "intValue")
            writer.tag(5, WireType.Varint).int32(message.value.intValue);
        /* uint32 uint_value = 6; */
        if (message.value.oneofKind === "uintValue")
            writer.tag(6, WireType.Varint).uint32(message.value.uintValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityScalarValueEntry
 */
export const AbilityScalarValueEntry = new AbilityScalarValueEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilityString$Type extends MessageType<AbilityString> {
    constructor() {
        super("AbilityString", [
            { no: 1, name: "str", kind: "scalar", oneof: "type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hash", kind: "scalar", oneof: "type", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbilityString>): AbilityString {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilityString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilityString): AbilityString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string str */ 1:
                    message.type = {
                        oneofKind: "str",
                        str: reader.string()
                    };
                    break;
                case /* uint32 hash */ 2:
                    message.type = {
                        oneofKind: "hash",
                        hash: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilityString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string str = 1; */
        if (message.type.oneofKind === "str")
            writer.tag(1, WireType.LengthDelimited).string(message.type.str);
        /* uint32 hash = 2; */
        if (message.type.oneofKind === "hash")
            writer.tag(2, WireType.Varint).uint32(message.type.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilityString
 */
export const AbilityString = new AbilityString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbilitySyncStateInfo$Type extends MessageType<AbilitySyncStateInfo> {
    constructor() {
        super("AbilitySyncStateInfo", [
            { no: 1, name: "is_inited", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "dynamic_value_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityScalarValueEntry },
            { no: 3, name: "applied_abilities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityAppliedAbility },
            { no: 4, name: "applied_modifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityAppliedModifier },
            { no: 5, name: "mixin_recover_infos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityMixinRecoverInfo },
            { no: 6, name: "sgv_dynamic_value_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityScalarValueEntry }
        ]);
    }
    create(value?: PartialMessage<AbilitySyncStateInfo>): AbilitySyncStateInfo {
        const message = { isInited: false, dynamicValueMap: [], appliedAbilities: [], appliedModifiers: [], mixinRecoverInfos: [], sgvDynamicValueMap: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AbilitySyncStateInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbilitySyncStateInfo): AbilitySyncStateInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_inited */ 1:
                    message.isInited = reader.bool();
                    break;
                case /* repeated AbilityScalarValueEntry dynamic_value_map */ 2:
                    message.dynamicValueMap.push(AbilityScalarValueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AbilityAppliedAbility applied_abilities */ 3:
                    message.appliedAbilities.push(AbilityAppliedAbility.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AbilityAppliedModifier applied_modifiers */ 4:
                    message.appliedModifiers.push(AbilityAppliedModifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AbilityMixinRecoverInfo mixin_recover_infos */ 5:
                    message.mixinRecoverInfos.push(AbilityMixinRecoverInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AbilityScalarValueEntry sgv_dynamic_value_map */ 6:
                    message.sgvDynamicValueMap.push(AbilityScalarValueEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbilitySyncStateInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_inited = 1; */
        if (message.isInited !== false)
            writer.tag(1, WireType.Varint).bool(message.isInited);
        /* repeated AbilityScalarValueEntry dynamic_value_map = 2; */
        for (let i = 0; i < message.dynamicValueMap.length; i++)
            AbilityScalarValueEntry.internalBinaryWrite(message.dynamicValueMap[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityAppliedAbility applied_abilities = 3; */
        for (let i = 0; i < message.appliedAbilities.length; i++)
            AbilityAppliedAbility.internalBinaryWrite(message.appliedAbilities[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityAppliedModifier applied_modifiers = 4; */
        for (let i = 0; i < message.appliedModifiers.length; i++)
            AbilityAppliedModifier.internalBinaryWrite(message.appliedModifiers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityMixinRecoverInfo mixin_recover_infos = 5; */
        for (let i = 0; i < message.mixinRecoverInfos.length; i++)
            AbilityMixinRecoverInfo.internalBinaryWrite(message.mixinRecoverInfos[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated AbilityScalarValueEntry sgv_dynamic_value_map = 6; */
        for (let i = 0; i < message.sgvDynamicValueMap.length; i++)
            AbilityScalarValueEntry.internalBinaryWrite(message.sgvDynamicValueMap[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AbilitySyncStateInfo
 */
export const AbilitySyncStateInfo = new AbilitySyncStateInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AchievementInfo$Type extends MessageType<AchievementInfo> {
    constructor() {
        super("AchievementInfo", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["AchievementInfo.AchievementInfoStatus", AchievementInfo_AchievementInfoStatus] },
            { no: 3, name: "current", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "goal", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "achievedate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AchievementInfo>): AchievementInfo {
        const message = { id: 0, status: 0, current: 0, goal: 0, achievedate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AchievementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementInfo): AchievementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* AchievementInfo.AchievementInfoStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* uint32 current */ 3:
                    message.current = reader.uint32();
                    break;
                case /* uint32 goal */ 4:
                    message.goal = reader.uint32();
                    break;
                case /* uint32 achievedate */ 5:
                    message.achievedate = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AchievementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* AchievementInfo.AchievementInfoStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* uint32 current = 3; */
        if (message.current !== 0)
            writer.tag(3, WireType.Varint).uint32(message.current);
        /* uint32 goal = 4; */
        if (message.goal !== 0)
            writer.tag(4, WireType.Varint).uint32(message.goal);
        /* uint32 achievedate = 5; */
        if (message.achievedate !== 0)
            writer.tag(5, WireType.Varint).uint32(message.achievedate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AchievementInfo
 */
export const AchievementInfo = new AchievementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityInfo$Type extends MessageType<ActivityInfo> {
    constructor() {
        super("ActivityInfo", [
            { no: 6, name: "sam_lamp_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 5, name: "crucible_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 3, name: "salesman_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 2, name: "trial_avatar_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 1673, name: "delivery_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 21, name: "aster_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 25, name: "flight_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 31, name: "dragon_spine_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 32, name: "effigy_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 35, name: "treasure_map_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 41, name: "blessing_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 42, name: "sea_lamp_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 43, name: "expedition_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 44, name: "arena_challenge_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 51, name: "fleur_fair_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 52, name: "water_spirit_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 61, name: "challneler_slab_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 62, name: "mist_trial_activity_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 63, name: "hide_and_seek_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 64, name: "find_hilichurl_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 65, name: "summer_time_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 66, name: "buoyant_combat_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 67, name: "echo_shell_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 68, name: "bounce_conjuring_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 69, name: "blitz_rush_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 70, name: "chess_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 71, name: "sumo_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 72, name: "moonfin_trial_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 73, name: "luna_rite_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 74, name: "plant_flower_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 1612, name: "music_game_info", kind: "message", oneof: "detail", T: () => MusicGameActivityDetailInfo },
            { no: 76, name: "roguelike_dungoen_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 77, name: "dig_info", kind: "message", oneof: "detail", T: () => ActivityNullDetailInfo },
            { no: 12, name: "activity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "activity_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "is_play_open_anim", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_starting", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "watcher_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActivityWatcherInfo },
            { no: 15, name: "meet_cond_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "expire_cond_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1394, name: "selected_avatar_reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1648, name: "activity_coin_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 1187, name: "score_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 527, name: "cur_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1262, name: "taken_reward_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 110, name: "is_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 144, name: "first_day_start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityInfo>): ActivityInfo {
        const message = { detail: { oneofKind: undefined }, activityId: 0, scheduleId: 0, beginTime: 0, endTime: 0, activityType: 0, isPlayOpenAnim: false, isFinished: false, isStarting: false, watcherInfoList: [], meetCondList: [], expireCondList: [], selectedAvatarRewardId: 0, activityCoinMap: {}, scoreLimit: 0, curScore: 0, takenRewardList: [], isHidden: false, firstDayStartTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityInfo): ActivityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ActivityNullDetailInfo sam_lamp_info */ 6:
                    message.detail = {
                        oneofKind: "samLampInfo",
                        samLampInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).samLampInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo crucible_info */ 5:
                    message.detail = {
                        oneofKind: "crucibleInfo",
                        crucibleInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).crucibleInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo salesman_info */ 3:
                    message.detail = {
                        oneofKind: "salesmanInfo",
                        salesmanInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).salesmanInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo trial_avatar_info */ 2:
                    message.detail = {
                        oneofKind: "trialAvatarInfo",
                        trialAvatarInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).trialAvatarInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo delivery_info */ 1673:
                    message.detail = {
                        oneofKind: "deliveryInfo",
                        deliveryInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).deliveryInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo aster_info */ 21:
                    message.detail = {
                        oneofKind: "asterInfo",
                        asterInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).asterInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo flight_info */ 25:
                    message.detail = {
                        oneofKind: "flightInfo",
                        flightInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).flightInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo dragon_spine_info */ 31:
                    message.detail = {
                        oneofKind: "dragonSpineInfo",
                        dragonSpineInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).dragonSpineInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo effigy_info */ 32:
                    message.detail = {
                        oneofKind: "effigyInfo",
                        effigyInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).effigyInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo treasure_map_info */ 35:
                    message.detail = {
                        oneofKind: "treasureMapInfo",
                        treasureMapInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).treasureMapInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo blessing_info */ 41:
                    message.detail = {
                        oneofKind: "blessingInfo",
                        blessingInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).blessingInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo sea_lamp_info */ 42:
                    message.detail = {
                        oneofKind: "seaLampInfo",
                        seaLampInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).seaLampInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo expedition_info */ 43:
                    message.detail = {
                        oneofKind: "expeditionInfo",
                        expeditionInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).expeditionInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo arena_challenge_info */ 44:
                    message.detail = {
                        oneofKind: "arenaChallengeInfo",
                        arenaChallengeInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).arenaChallengeInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo fleur_fair_info */ 51:
                    message.detail = {
                        oneofKind: "fleurFairInfo",
                        fleurFairInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).fleurFairInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo water_spirit_info */ 52:
                    message.detail = {
                        oneofKind: "waterSpiritInfo",
                        waterSpiritInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).waterSpiritInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo challneler_slab_info */ 61:
                    message.detail = {
                        oneofKind: "challnelerSlabInfo",
                        challnelerSlabInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).challnelerSlabInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo mist_trial_activity_info */ 62:
                    message.detail = {
                        oneofKind: "mistTrialActivityInfo",
                        mistTrialActivityInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).mistTrialActivityInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo hide_and_seek_info */ 63:
                    message.detail = {
                        oneofKind: "hideAndSeekInfo",
                        hideAndSeekInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).hideAndSeekInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo find_hilichurl_info */ 64:
                    message.detail = {
                        oneofKind: "findHilichurlInfo",
                        findHilichurlInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).findHilichurlInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo summer_time_info */ 65:
                    message.detail = {
                        oneofKind: "summerTimeInfo",
                        summerTimeInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).summerTimeInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo buoyant_combat_info */ 66:
                    message.detail = {
                        oneofKind: "buoyantCombatInfo",
                        buoyantCombatInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).buoyantCombatInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo echo_shell_info */ 67:
                    message.detail = {
                        oneofKind: "echoShellInfo",
                        echoShellInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).echoShellInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo bounce_conjuring_info */ 68:
                    message.detail = {
                        oneofKind: "bounceConjuringInfo",
                        bounceConjuringInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).bounceConjuringInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo blitz_rush_info */ 69:
                    message.detail = {
                        oneofKind: "blitzRushInfo",
                        blitzRushInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).blitzRushInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo chess_info */ 70:
                    message.detail = {
                        oneofKind: "chessInfo",
                        chessInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).chessInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo sumo_info */ 71:
                    message.detail = {
                        oneofKind: "sumoInfo",
                        sumoInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).sumoInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo moonfin_trial_info */ 72:
                    message.detail = {
                        oneofKind: "moonfinTrialInfo",
                        moonfinTrialInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).moonfinTrialInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo luna_rite_info */ 73:
                    message.detail = {
                        oneofKind: "lunaRiteInfo",
                        lunaRiteInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).lunaRiteInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo plant_flower_info */ 74:
                    message.detail = {
                        oneofKind: "plantFlowerInfo",
                        plantFlowerInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).plantFlowerInfo)
                    };
                    break;
                case /* MusicGameActivityDetailInfo music_game_info */ 1612:
                    message.detail = {
                        oneofKind: "musicGameInfo",
                        musicGameInfo: MusicGameActivityDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).musicGameInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo roguelike_dungoen_info */ 76:
                    message.detail = {
                        oneofKind: "roguelikeDungoenInfo",
                        roguelikeDungoenInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).roguelikeDungoenInfo)
                    };
                    break;
                case /* ActivityNullDetailInfo dig_info */ 77:
                    message.detail = {
                        oneofKind: "digInfo",
                        digInfo: ActivityNullDetailInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).digInfo)
                    };
                    break;
                case /* uint32 activity_id */ 12:
                    message.activityId = reader.uint32();
                    break;
                case /* uint32 schedule_id */ 10:
                    message.scheduleId = reader.uint32();
                    break;
                case /* uint32 begin_time */ 13:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 11:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 activity_type */ 8:
                    message.activityType = reader.uint32();
                    break;
                case /* bool is_play_open_anim */ 14:
                    message.isPlayOpenAnim = reader.bool();
                    break;
                case /* bool is_finished */ 7:
                    message.isFinished = reader.bool();
                    break;
                case /* bool is_starting */ 9:
                    message.isStarting = reader.bool();
                    break;
                case /* repeated ActivityWatcherInfo watcher_info_list */ 4:
                    message.watcherInfoList.push(ActivityWatcherInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 meet_cond_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.meetCondList.push(reader.uint32());
                    else
                        message.meetCondList.push(reader.uint32());
                    break;
                case /* repeated uint32 expire_cond_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.expireCondList.push(reader.uint32());
                    else
                        message.expireCondList.push(reader.uint32());
                    break;
                case /* uint32 selected_avatar_reward_id */ 1394:
                    message.selectedAvatarRewardId = reader.uint32();
                    break;
                case /* map<uint32, uint32> activity_coin_map */ 1648:
                    this.binaryReadMap1648(message.activityCoinMap, reader, options);
                    break;
                case /* uint32 score_limit */ 1187:
                    message.scoreLimit = reader.uint32();
                    break;
                case /* uint32 cur_score */ 527:
                    message.curScore = reader.uint32();
                    break;
                case /* repeated uint32 taken_reward_list */ 1262:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.takenRewardList.push(reader.uint32());
                    else
                        message.takenRewardList.push(reader.uint32());
                    break;
                case /* bool is_hidden */ 110:
                    message.isHidden = reader.bool();
                    break;
                case /* uint32 first_day_start_time */ 144:
                    message.firstDayStartTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1648(map: ActivityInfo["activityCoinMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ActivityInfo["activityCoinMap"] | undefined, val: ActivityInfo["activityCoinMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ActivityInfo.activity_coin_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: ActivityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ActivityNullDetailInfo sam_lamp_info = 6; */
        if (message.detail.oneofKind === "samLampInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.samLampInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo crucible_info = 5; */
        if (message.detail.oneofKind === "crucibleInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.crucibleInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo salesman_info = 3; */
        if (message.detail.oneofKind === "salesmanInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.salesmanInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo trial_avatar_info = 2; */
        if (message.detail.oneofKind === "trialAvatarInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.trialAvatarInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo delivery_info = 1673; */
        if (message.detail.oneofKind === "deliveryInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.deliveryInfo, writer.tag(1673, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo aster_info = 21; */
        if (message.detail.oneofKind === "asterInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.asterInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo flight_info = 25; */
        if (message.detail.oneofKind === "flightInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.flightInfo, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo dragon_spine_info = 31; */
        if (message.detail.oneofKind === "dragonSpineInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.dragonSpineInfo, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo effigy_info = 32; */
        if (message.detail.oneofKind === "effigyInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.effigyInfo, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo treasure_map_info = 35; */
        if (message.detail.oneofKind === "treasureMapInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.treasureMapInfo, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo blessing_info = 41; */
        if (message.detail.oneofKind === "blessingInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.blessingInfo, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo sea_lamp_info = 42; */
        if (message.detail.oneofKind === "seaLampInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.seaLampInfo, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo expedition_info = 43; */
        if (message.detail.oneofKind === "expeditionInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.expeditionInfo, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo arena_challenge_info = 44; */
        if (message.detail.oneofKind === "arenaChallengeInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.arenaChallengeInfo, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo fleur_fair_info = 51; */
        if (message.detail.oneofKind === "fleurFairInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.fleurFairInfo, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo water_spirit_info = 52; */
        if (message.detail.oneofKind === "waterSpiritInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.waterSpiritInfo, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo challneler_slab_info = 61; */
        if (message.detail.oneofKind === "challnelerSlabInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.challnelerSlabInfo, writer.tag(61, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo mist_trial_activity_info = 62; */
        if (message.detail.oneofKind === "mistTrialActivityInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.mistTrialActivityInfo, writer.tag(62, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo hide_and_seek_info = 63; */
        if (message.detail.oneofKind === "hideAndSeekInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.hideAndSeekInfo, writer.tag(63, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo find_hilichurl_info = 64; */
        if (message.detail.oneofKind === "findHilichurlInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.findHilichurlInfo, writer.tag(64, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo summer_time_info = 65; */
        if (message.detail.oneofKind === "summerTimeInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.summerTimeInfo, writer.tag(65, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo buoyant_combat_info = 66; */
        if (message.detail.oneofKind === "buoyantCombatInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.buoyantCombatInfo, writer.tag(66, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo echo_shell_info = 67; */
        if (message.detail.oneofKind === "echoShellInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.echoShellInfo, writer.tag(67, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo bounce_conjuring_info = 68; */
        if (message.detail.oneofKind === "bounceConjuringInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.bounceConjuringInfo, writer.tag(68, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo blitz_rush_info = 69; */
        if (message.detail.oneofKind === "blitzRushInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.blitzRushInfo, writer.tag(69, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo chess_info = 70; */
        if (message.detail.oneofKind === "chessInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.chessInfo, writer.tag(70, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo sumo_info = 71; */
        if (message.detail.oneofKind === "sumoInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.sumoInfo, writer.tag(71, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo moonfin_trial_info = 72; */
        if (message.detail.oneofKind === "moonfinTrialInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.moonfinTrialInfo, writer.tag(72, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo luna_rite_info = 73; */
        if (message.detail.oneofKind === "lunaRiteInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.lunaRiteInfo, writer.tag(73, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo plant_flower_info = 74; */
        if (message.detail.oneofKind === "plantFlowerInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.plantFlowerInfo, writer.tag(74, WireType.LengthDelimited).fork(), options).join();
        /* MusicGameActivityDetailInfo music_game_info = 1612; */
        if (message.detail.oneofKind === "musicGameInfo")
            MusicGameActivityDetailInfo.internalBinaryWrite(message.detail.musicGameInfo, writer.tag(1612, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo roguelike_dungoen_info = 76; */
        if (message.detail.oneofKind === "roguelikeDungoenInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.roguelikeDungoenInfo, writer.tag(76, WireType.LengthDelimited).fork(), options).join();
        /* ActivityNullDetailInfo dig_info = 77; */
        if (message.detail.oneofKind === "digInfo")
            ActivityNullDetailInfo.internalBinaryWrite(message.detail.digInfo, writer.tag(77, WireType.LengthDelimited).fork(), options).join();
        /* uint32 activity_id = 12; */
        if (message.activityId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.activityId);
        /* uint32 schedule_id = 10; */
        if (message.scheduleId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.scheduleId);
        /* uint32 begin_time = 13; */
        if (message.beginTime !== 0)
            writer.tag(13, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 11; */
        if (message.endTime !== 0)
            writer.tag(11, WireType.Varint).uint32(message.endTime);
        /* uint32 activity_type = 8; */
        if (message.activityType !== 0)
            writer.tag(8, WireType.Varint).uint32(message.activityType);
        /* bool is_play_open_anim = 14; */
        if (message.isPlayOpenAnim !== false)
            writer.tag(14, WireType.Varint).bool(message.isPlayOpenAnim);
        /* bool is_finished = 7; */
        if (message.isFinished !== false)
            writer.tag(7, WireType.Varint).bool(message.isFinished);
        /* bool is_starting = 9; */
        if (message.isStarting !== false)
            writer.tag(9, WireType.Varint).bool(message.isStarting);
        /* repeated ActivityWatcherInfo watcher_info_list = 4; */
        for (let i = 0; i < message.watcherInfoList.length; i++)
            ActivityWatcherInfo.internalBinaryWrite(message.watcherInfoList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 meet_cond_list = 15; */
        if (message.meetCondList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.meetCondList.length; i++)
                writer.uint32(message.meetCondList[i]);
            writer.join();
        }
        /* repeated uint32 expire_cond_list = 1; */
        if (message.expireCondList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.expireCondList.length; i++)
                writer.uint32(message.expireCondList[i]);
            writer.join();
        }
        /* uint32 selected_avatar_reward_id = 1394; */
        if (message.selectedAvatarRewardId !== 0)
            writer.tag(1394, WireType.Varint).uint32(message.selectedAvatarRewardId);
        /* map<uint32, uint32> activity_coin_map = 1648; */
        for (let k of Object.keys(message.activityCoinMap))
            writer.tag(1648, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.activityCoinMap[k as any]).join();
        /* uint32 score_limit = 1187; */
        if (message.scoreLimit !== 0)
            writer.tag(1187, WireType.Varint).uint32(message.scoreLimit);
        /* uint32 cur_score = 527; */
        if (message.curScore !== 0)
            writer.tag(527, WireType.Varint).uint32(message.curScore);
        /* repeated uint32 taken_reward_list = 1262; */
        if (message.takenRewardList.length) {
            writer.tag(1262, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.takenRewardList.length; i++)
                writer.uint32(message.takenRewardList[i]);
            writer.join();
        }
        /* bool is_hidden = 110; */
        if (message.isHidden !== false)
            writer.tag(110, WireType.Varint).bool(message.isHidden);
        /* uint32 first_day_start_time = 144; */
        if (message.firstDayStartTime !== 0)
            writer.tag(144, WireType.Varint).uint32(message.firstDayStartTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityInfo
 */
export const ActivityInfo = new ActivityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityInfoNotify$Type extends MessageType<ActivityInfoNotify> {
    constructor() {
        super("ActivityInfoNotify", [
            { no: 11, name: "activity_info", kind: "message", T: () => ActivityInfo }
        ]);
    }
    create(value?: PartialMessage<ActivityInfoNotify>): ActivityInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityInfoNotify): ActivityInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ActivityInfo activity_info */ 11:
                    message.activityInfo = ActivityInfo.internalBinaryRead(reader, reader.uint32(), options, message.activityInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ActivityInfo activity_info = 11; */
        if (message.activityInfo)
            ActivityInfo.internalBinaryWrite(message.activityInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityInfoNotify
 */
export const ActivityInfoNotify = new ActivityInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNullDetailInfo$Type extends MessageType<ActivityNullDetailInfo> {
    constructor() {
        super("ActivityNullDetailInfo", []);
    }
    create(value?: PartialMessage<ActivityNullDetailInfo>): ActivityNullDetailInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityNullDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityNullDetailInfo): ActivityNullDetailInfo {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ActivityNullDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityNullDetailInfo
 */
export const ActivityNullDetailInfo = new ActivityNullDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityScheduleInfo$Type extends MessageType<ActivityScheduleInfo> {
    constructor() {
        super("ActivityScheduleInfo", [
            { no: 13, name: "activity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityScheduleInfo>): ActivityScheduleInfo {
        const message = { activityId: 0, isOpen: false, scheduleId: 0, beginTime: 0, endTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityScheduleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityScheduleInfo): ActivityScheduleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 activity_id */ 13:
                    message.activityId = reader.uint32();
                    break;
                case /* bool is_open */ 9:
                    message.isOpen = reader.bool();
                    break;
                case /* uint32 schedule_id */ 12:
                    message.scheduleId = reader.uint32();
                    break;
                case /* uint32 begin_time */ 11:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 4:
                    message.endTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityScheduleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 activity_id = 13; */
        if (message.activityId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.activityId);
        /* bool is_open = 9; */
        if (message.isOpen !== false)
            writer.tag(9, WireType.Varint).bool(message.isOpen);
        /* uint32 schedule_id = 12; */
        if (message.scheduleId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.scheduleId);
        /* uint32 begin_time = 11; */
        if (message.beginTime !== 0)
            writer.tag(11, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 4; */
        if (message.endTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityScheduleInfo
 */
export const ActivityScheduleInfo = new ActivityScheduleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityScheduleInfoNotify$Type extends MessageType<ActivityScheduleInfoNotify> {
    constructor() {
        super("ActivityScheduleInfoNotify", [
            { no: 8, name: "activity_schedule_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActivityScheduleInfo },
            { no: 12, name: "remain_fly_sea_lamp_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityScheduleInfoNotify>): ActivityScheduleInfoNotify {
        const message = { activityScheduleList: [], remainFlySeaLampNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityScheduleInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityScheduleInfoNotify): ActivityScheduleInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ActivityScheduleInfo activity_schedule_list */ 8:
                    message.activityScheduleList.push(ActivityScheduleInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 remain_fly_sea_lamp_num */ 12:
                    message.remainFlySeaLampNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityScheduleInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ActivityScheduleInfo activity_schedule_list = 8; */
        for (let i = 0; i < message.activityScheduleList.length; i++)
            ActivityScheduleInfo.internalBinaryWrite(message.activityScheduleList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 remain_fly_sea_lamp_num = 12; */
        if (message.remainFlySeaLampNum !== 0)
            writer.tag(12, WireType.Varint).uint32(message.remainFlySeaLampNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityScheduleInfoNotify
 */
export const ActivityScheduleInfoNotify = new ActivityScheduleInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityTakeWatcherRewardReq$Type extends MessageType<ActivityTakeWatcherRewardReq> {
    constructor() {
        super("ActivityTakeWatcherRewardReq", [
            { no: 11, name: "activity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "watcher_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityTakeWatcherRewardReq>): ActivityTakeWatcherRewardReq {
        const message = { activityId: 0, watcherId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityTakeWatcherRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityTakeWatcherRewardReq): ActivityTakeWatcherRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 activity_id */ 11:
                    message.activityId = reader.uint32();
                    break;
                case /* uint32 watcher_id */ 7:
                    message.watcherId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityTakeWatcherRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 activity_id = 11; */
        if (message.activityId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.activityId);
        /* uint32 watcher_id = 7; */
        if (message.watcherId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.watcherId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityTakeWatcherRewardReq
 */
export const ActivityTakeWatcherRewardReq = new ActivityTakeWatcherRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityTakeWatcherRewardRsp$Type extends MessageType<ActivityTakeWatcherRewardRsp> {
    constructor() {
        super("ActivityTakeWatcherRewardRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "activity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "watcher_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityTakeWatcherRewardRsp>): ActivityTakeWatcherRewardRsp {
        const message = { retcode: 0, activityId: 0, watcherId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityTakeWatcherRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityTakeWatcherRewardRsp): ActivityTakeWatcherRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 activity_id */ 8:
                    message.activityId = reader.uint32();
                    break;
                case /* uint32 watcher_id */ 7:
                    message.watcherId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityTakeWatcherRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        /* uint32 activity_id = 8; */
        if (message.activityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.activityId);
        /* uint32 watcher_id = 7; */
        if (message.watcherId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.watcherId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityTakeWatcherRewardRsp
 */
export const ActivityTakeWatcherRewardRsp = new ActivityTakeWatcherRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityUpdateWatcherNotify$Type extends MessageType<ActivityUpdateWatcherNotify> {
    constructor() {
        super("ActivityUpdateWatcherNotify", [
            { no: 10, name: "activity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "watcher_info", kind: "message", T: () => ActivityWatcherInfo }
        ]);
    }
    create(value?: PartialMessage<ActivityUpdateWatcherNotify>): ActivityUpdateWatcherNotify {
        const message = { activityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityUpdateWatcherNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityUpdateWatcherNotify): ActivityUpdateWatcherNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 activity_id */ 10:
                    message.activityId = reader.uint32();
                    break;
                case /* ActivityWatcherInfo watcher_info */ 7:
                    message.watcherInfo = ActivityWatcherInfo.internalBinaryRead(reader, reader.uint32(), options, message.watcherInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityUpdateWatcherNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 activity_id = 10; */
        if (message.activityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.activityId);
        /* ActivityWatcherInfo watcher_info = 7; */
        if (message.watcherInfo)
            ActivityWatcherInfo.internalBinaryWrite(message.watcherInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityUpdateWatcherNotify
 */
export const ActivityUpdateWatcherNotify = new ActivityUpdateWatcherNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityWatcherInfo$Type extends MessageType<ActivityWatcherInfo> {
    constructor() {
        super("ActivityWatcherInfo", [
            { no: 10, name: "watcher_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cur_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "total_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_taken_reward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ActivityWatcherInfo>): ActivityWatcherInfo {
        const message = { watcherId: 0, curProgress: 0, totalProgress: 0, isTakenReward: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivityWatcherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityWatcherInfo): ActivityWatcherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 watcher_id */ 10:
                    message.watcherId = reader.uint32();
                    break;
                case /* uint32 cur_progress */ 4:
                    message.curProgress = reader.uint32();
                    break;
                case /* uint32 total_progress */ 9:
                    message.totalProgress = reader.uint32();
                    break;
                case /* bool is_taken_reward */ 8:
                    message.isTakenReward = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityWatcherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 watcher_id = 10; */
        if (message.watcherId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.watcherId);
        /* uint32 cur_progress = 4; */
        if (message.curProgress !== 0)
            writer.tag(4, WireType.Varint).uint32(message.curProgress);
        /* uint32 total_progress = 9; */
        if (message.totalProgress !== 0)
            writer.tag(9, WireType.Varint).uint32(message.totalProgress);
        /* bool is_taken_reward = 8; */
        if (message.isTakenReward !== false)
            writer.tag(8, WireType.Varint).bool(message.isTakenReward);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivityWatcherInfo
 */
export const ActivityWatcherInfo = new ActivityWatcherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddQuestContentProgressReq$Type extends MessageType<AddQuestContentProgressReq> {
    constructor() {
        super("AddQuestContentProgressReq", [
            { no: 9, name: "content_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "add_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AddQuestContentProgressReq>): AddQuestContentProgressReq {
        const message = { contentType: 0, param: 0, addProgress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddQuestContentProgressReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddQuestContentProgressReq): AddQuestContentProgressReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 content_type */ 9:
                    message.contentType = reader.uint32();
                    break;
                case /* uint32 param */ 13:
                    message.param = reader.uint32();
                    break;
                case /* uint32 add_progress */ 11:
                    message.addProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddQuestContentProgressReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 content_type = 9; */
        if (message.contentType !== 0)
            writer.tag(9, WireType.Varint).uint32(message.contentType);
        /* uint32 param = 13; */
        if (message.param !== 0)
            writer.tag(13, WireType.Varint).uint32(message.param);
        /* uint32 add_progress = 11; */
        if (message.addProgress !== 0)
            writer.tag(11, WireType.Varint).uint32(message.addProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddQuestContentProgressReq
 */
export const AddQuestContentProgressReq = new AddQuestContentProgressReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddQuestContentProgressRsp$Type extends MessageType<AddQuestContentProgressRsp> {
    constructor() {
        super("AddQuestContentProgressRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "content_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AddQuestContentProgressRsp>): AddQuestContentProgressRsp {
        const message = { retcode: 0, contentType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddQuestContentProgressRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddQuestContentProgressRsp): AddQuestContentProgressRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 content_type */ 7:
                    message.contentType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddQuestContentProgressRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        /* uint32 content_type = 7; */
        if (message.contentType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.contentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddQuestContentProgressRsp
 */
export const AddQuestContentProgressRsp = new AddQuestContentProgressRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdjustTrackingInfo$Type extends MessageType<AdjustTrackingInfo> {
    constructor() {
        super("AdjustTrackingInfo", [
            { no: 10, name: "idfa", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "gps_adid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "fire_adid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "adid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "event_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "app_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AdjustTrackingInfo>): AdjustTrackingInfo {
        const message = { idfa: "", gpsAdid: "", fireAdid: "", adid: "", eventToken: "", appToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdjustTrackingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdjustTrackingInfo): AdjustTrackingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string idfa */ 10:
                    message.idfa = reader.string();
                    break;
                case /* string gps_adid */ 6:
                    message.gpsAdid = reader.string();
                    break;
                case /* string fire_adid */ 7:
                    message.fireAdid = reader.string();
                    break;
                case /* string adid */ 9:
                    message.adid = reader.string();
                    break;
                case /* string event_token */ 12:
                    message.eventToken = reader.string();
                    break;
                case /* string app_token */ 13:
                    message.appToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdjustTrackingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string idfa = 10; */
        if (message.idfa !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.idfa);
        /* string gps_adid = 6; */
        if (message.gpsAdid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.gpsAdid);
        /* string fire_adid = 7; */
        if (message.fireAdid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fireAdid);
        /* string adid = 9; */
        if (message.adid !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.adid);
        /* string event_token = 12; */
        if (message.eventToken !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.eventToken);
        /* string app_token = 13; */
        if (message.appToken !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.appToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdjustTrackingInfo
 */
export const AdjustTrackingInfo = new AdjustTrackingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiSkillCdInfo$Type extends MessageType<AiSkillCdInfo> {
    constructor() {
        super("AiSkillCdInfo", [
            { no: 1, name: "skill_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 2, name: "skill_group_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<AiSkillCdInfo>): AiSkillCdInfo {
        const message = { skillCdMap: {}, skillGroupCdMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiSkillCdInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiSkillCdInfo): AiSkillCdInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> skill_cd_map */ 1:
                    this.binaryReadMap1(message.skillCdMap, reader, options);
                    break;
                case /* map<uint32, uint32> skill_group_cd_map */ 2:
                    this.binaryReadMap2(message.skillGroupCdMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AiSkillCdInfo["skillCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiSkillCdInfo["skillCdMap"] | undefined, val: AiSkillCdInfo["skillCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AiSkillCdInfo.skill_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap2(map: AiSkillCdInfo["skillGroupCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiSkillCdInfo["skillGroupCdMap"] | undefined, val: AiSkillCdInfo["skillGroupCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AiSkillCdInfo.skill_group_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AiSkillCdInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> skill_cd_map = 1; */
        for (let k of Object.keys(message.skillCdMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillCdMap[k as any]).join();
        /* map<uint32, uint32> skill_group_cd_map = 2; */
        for (let k of Object.keys(message.skillGroupCdMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillGroupCdMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AiSkillCdInfo
 */
export const AiSkillCdInfo = new AiSkillCdInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiSyncInfo$Type extends MessageType<AiSyncInfo> {
    constructor() {
        super("AiSyncInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "has_path_to_target", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_self_killing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AiSyncInfo>): AiSyncInfo {
        const message = { entityId: 0, hasPathToTarget: false, isSelfKilling: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiSyncInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiSyncInfo): AiSyncInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* bool has_path_to_target */ 2:
                    message.hasPathToTarget = reader.bool();
                    break;
                case /* bool is_self_killing */ 3:
                    message.isSelfKilling = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AiSyncInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* bool has_path_to_target = 2; */
        if (message.hasPathToTarget !== false)
            writer.tag(2, WireType.Varint).bool(message.hasPathToTarget);
        /* bool is_self_killing = 3; */
        if (message.isSelfKilling !== false)
            writer.tag(3, WireType.Varint).bool(message.isSelfKilling);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AiSyncInfo
 */
export const AiSyncInfo = new AiSyncInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AiThreatInfo$Type extends MessageType<AiThreatInfo> {
    constructor() {
        super("AiThreatInfo", [
            { no: 1, name: "ai_threat_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<AiThreatInfo>): AiThreatInfo {
        const message = { aiThreatMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AiThreatInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AiThreatInfo): AiThreatInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> ai_threat_map */ 1:
                    this.binaryReadMap1(message.aiThreatMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AiThreatInfo["aiThreatMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AiThreatInfo["aiThreatMap"] | undefined, val: AiThreatInfo["aiThreatMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AiThreatInfo.ai_threat_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AiThreatInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> ai_threat_map = 1; */
        for (let k of Object.keys(message.aiThreatMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.aiThreatMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AiThreatInfo
 */
export const AiThreatInfo = new AiThreatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllWidgetDataNotify$Type extends MessageType<AllWidgetDataNotify> {
    constructor() {
        super("AllWidgetDataNotify", [
            { no: 12, name: "anchor_point_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnchorPointData },
            { no: 8, name: "next_anchor_point_usable_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "lunch_box_data", kind: "message", T: () => LunchBoxData },
            { no: 6, name: "oneoff_gather_point_detector_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OneoffGatherPointDetectorData },
            { no: 7, name: "client_collector_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientCollectorData },
            { no: 13, name: "cool_down_group_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetCoolDownData },
            { no: 9, name: "normal_cool_down_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetCoolDownData },
            { no: 11, name: "slot_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetSlotData }
        ]);
    }
    create(value?: PartialMessage<AllWidgetDataNotify>): AllWidgetDataNotify {
        const message = { anchorPointList: [], nextAnchorPointUsableTime: 0, oneoffGatherPointDetectorDataList: [], clientCollectorDataList: [], coolDownGroupDataList: [], normalCoolDownDataList: [], slotList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AllWidgetDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllWidgetDataNotify): AllWidgetDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AnchorPointData anchor_point_list */ 12:
                    message.anchorPointList.push(AnchorPointData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 next_anchor_point_usable_time */ 8:
                    message.nextAnchorPointUsableTime = reader.uint32();
                    break;
                case /* LunchBoxData lunch_box_data */ 5:
                    message.lunchBoxData = LunchBoxData.internalBinaryRead(reader, reader.uint32(), options, message.lunchBoxData);
                    break;
                case /* repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list */ 6:
                    message.oneoffGatherPointDetectorDataList.push(OneoffGatherPointDetectorData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ClientCollectorData client_collector_data_list */ 7:
                    message.clientCollectorDataList.push(ClientCollectorData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated WidgetCoolDownData cool_down_group_data_list */ 13:
                    message.coolDownGroupDataList.push(WidgetCoolDownData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated WidgetCoolDownData normal_cool_down_data_list */ 9:
                    message.normalCoolDownDataList.push(WidgetCoolDownData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated WidgetSlotData slot_list */ 11:
                    message.slotList.push(WidgetSlotData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllWidgetDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AnchorPointData anchor_point_list = 12; */
        for (let i = 0; i < message.anchorPointList.length; i++)
            AnchorPointData.internalBinaryWrite(message.anchorPointList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 next_anchor_point_usable_time = 8; */
        if (message.nextAnchorPointUsableTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.nextAnchorPointUsableTime);
        /* LunchBoxData lunch_box_data = 5; */
        if (message.lunchBoxData)
            LunchBoxData.internalBinaryWrite(message.lunchBoxData, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list = 6; */
        for (let i = 0; i < message.oneoffGatherPointDetectorDataList.length; i++)
            OneoffGatherPointDetectorData.internalBinaryWrite(message.oneoffGatherPointDetectorDataList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated ClientCollectorData client_collector_data_list = 7; */
        for (let i = 0; i < message.clientCollectorDataList.length; i++)
            ClientCollectorData.internalBinaryWrite(message.clientCollectorDataList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated WidgetCoolDownData cool_down_group_data_list = 13; */
        for (let i = 0; i < message.coolDownGroupDataList.length; i++)
            WidgetCoolDownData.internalBinaryWrite(message.coolDownGroupDataList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated WidgetCoolDownData normal_cool_down_data_list = 9; */
        for (let i = 0; i < message.normalCoolDownDataList.length; i++)
            WidgetCoolDownData.internalBinaryWrite(message.normalCoolDownDataList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated WidgetSlotData slot_list = 11; */
        for (let i = 0; i < message.slotList.length; i++)
            WidgetSlotData.internalBinaryWrite(message.slotList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AllWidgetDataNotify
 */
export const AllWidgetDataNotify = new AllWidgetDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnchorPointData$Type extends MessageType<AnchorPointData> {
    constructor() {
        super("AnchorPointData", [
            { no: 1, name: "anchor_point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pos", kind: "message", T: () => Vector },
            { no: 3, name: "rot", kind: "message", T: () => Vector },
            { no: 4, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AnchorPointData>): AnchorPointData {
        const message = { anchorPointId: 0, endTime: 0, sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnchorPointData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnchorPointData): AnchorPointData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 anchor_point_id */ 1:
                    message.anchorPointId = reader.uint32();
                    break;
                case /* Vector pos */ 2:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 3:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* uint32 end_time */ 4:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 scene_id */ 5:
                    message.sceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnchorPointData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 anchor_point_id = 1; */
        if (message.anchorPointId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.anchorPointId);
        /* Vector pos = 2; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 3; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 end_time = 4; */
        if (message.endTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.endTime);
        /* uint32 scene_id = 5; */
        if (message.sceneId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.sceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnchorPointData
 */
export const AnchorPointData = new AnchorPointData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnchorPointDataNotify$Type extends MessageType<AnchorPointDataNotify> {
    constructor() {
        super("AnchorPointDataNotify", [
            { no: 14, name: "anchor_point_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnchorPointData },
            { no: 6, name: "next_usable_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AnchorPointDataNotify>): AnchorPointDataNotify {
        const message = { anchorPointList: [], nextUsableTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnchorPointDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnchorPointDataNotify): AnchorPointDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AnchorPointData anchor_point_list */ 14:
                    message.anchorPointList.push(AnchorPointData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 next_usable_time */ 6:
                    message.nextUsableTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnchorPointDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AnchorPointData anchor_point_list = 14; */
        for (let i = 0; i < message.anchorPointList.length; i++)
            AnchorPointData.internalBinaryWrite(message.anchorPointList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 next_usable_time = 6; */
        if (message.nextUsableTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.nextUsableTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnchorPointDataNotify
 */
export const AnchorPointDataNotify = new AnchorPointDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnchorPointOpReq$Type extends MessageType<AnchorPointOpReq> {
    constructor() {
        super("AnchorPointOpReq", [
            { no: 6, name: "anchor_point_op_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "anchor_point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AnchorPointOpReq>): AnchorPointOpReq {
        const message = { anchorPointOpType: 0, anchorPointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnchorPointOpReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnchorPointOpReq): AnchorPointOpReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 anchor_point_op_type */ 6:
                    message.anchorPointOpType = reader.uint32();
                    break;
                case /* uint32 anchor_point_id */ 1:
                    message.anchorPointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnchorPointOpReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 anchor_point_op_type = 6; */
        if (message.anchorPointOpType !== 0)
            writer.tag(6, WireType.Varint).uint32(message.anchorPointOpType);
        /* uint32 anchor_point_id = 1; */
        if (message.anchorPointId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.anchorPointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnchorPointOpReq
 */
export const AnchorPointOpReq = new AnchorPointOpReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnchorPointOpRsp$Type extends MessageType<AnchorPointOpRsp> {
    constructor() {
        super("AnchorPointOpRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "anchor_point_op_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "anchor_point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AnchorPointOpRsp>): AnchorPointOpRsp {
        const message = { retcode: 0, anchorPointOpType: 0, anchorPointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnchorPointOpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnchorPointOpRsp): AnchorPointOpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 anchor_point_op_type */ 3:
                    message.anchorPointOpType = reader.uint32();
                    break;
                case /* uint32 anchor_point_id */ 2:
                    message.anchorPointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnchorPointOpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 anchor_point_op_type = 3; */
        if (message.anchorPointOpType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.anchorPointOpType);
        /* uint32 anchor_point_id = 2; */
        if (message.anchorPointId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.anchorPointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnchorPointOpRsp
 */
export const AnchorPointOpRsp = new AnchorPointOpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnimatorParameterValueInfo$Type extends MessageType<AnimatorParameterValueInfo> {
    constructor() {
        super("AnimatorParameterValueInfo", [
            { no: 1, name: "para_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "int_val", kind: "scalar", oneof: "paraVal", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "float_val", kind: "scalar", oneof: "paraVal", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bool_val", kind: "scalar", oneof: "paraVal", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AnimatorParameterValueInfo>): AnimatorParameterValueInfo {
        const message = { paraType: 0, paraVal: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnimatorParameterValueInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnimatorParameterValueInfo): AnimatorParameterValueInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 para_type */ 1:
                    message.paraType = reader.uint32();
                    break;
                case /* int32 int_val */ 2:
                    message.paraVal = {
                        oneofKind: "intVal",
                        intVal: reader.int32()
                    };
                    break;
                case /* float float_val */ 3:
                    message.paraVal = {
                        oneofKind: "floatVal",
                        floatVal: reader.float()
                    };
                    break;
                case /* bool bool_val */ 4:
                    message.paraVal = {
                        oneofKind: "boolVal",
                        boolVal: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnimatorParameterValueInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 para_type = 1; */
        if (message.paraType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.paraType);
        /* int32 int_val = 2; */
        if (message.paraVal.oneofKind === "intVal")
            writer.tag(2, WireType.Varint).int32(message.paraVal.intVal);
        /* float float_val = 3; */
        if (message.paraVal.oneofKind === "floatVal")
            writer.tag(3, WireType.Bit32).float(message.paraVal.floatVal);
        /* bool bool_val = 4; */
        if (message.paraVal.oneofKind === "boolVal")
            writer.tag(4, WireType.Varint).bool(message.paraVal.boolVal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnimatorParameterValueInfo
 */
export const AnimatorParameterValueInfo = new AnimatorParameterValueInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnimatorParameterValueInfoPair$Type extends MessageType<AnimatorParameterValueInfoPair> {
    constructor() {
        super("AnimatorParameterValueInfoPair", [
            { no: 1, name: "name_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "animator_para", kind: "message", T: () => AnimatorParameterValueInfo }
        ]);
    }
    create(value?: PartialMessage<AnimatorParameterValueInfoPair>): AnimatorParameterValueInfoPair {
        const message = { nameId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnimatorParameterValueInfoPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnimatorParameterValueInfoPair): AnimatorParameterValueInfoPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 name_id */ 1:
                    message.nameId = reader.int32();
                    break;
                case /* AnimatorParameterValueInfo animator_para */ 2:
                    message.animatorPara = AnimatorParameterValueInfo.internalBinaryRead(reader, reader.uint32(), options, message.animatorPara);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnimatorParameterValueInfoPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 name_id = 1; */
        if (message.nameId !== 0)
            writer.tag(1, WireType.Varint).int32(message.nameId);
        /* AnimatorParameterValueInfo animator_para = 2; */
        if (message.animatorPara)
            AnimatorParameterValueInfo.internalBinaryWrite(message.animatorPara, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnimatorParameterValueInfoPair
 */
export const AnimatorParameterValueInfoPair = new AnimatorParameterValueInfoPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnounceData$Type extends MessageType<AnnounceData> {
    constructor() {
        super("AnnounceData", [
            { no: 1, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "center_system_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "count_down_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "dungeon_confirm_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "center_system_frequency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "count_down_frequency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_center_system_last_5_every_minutes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AnnounceData>): AnnounceData {
        const message = { configId: 0, beginTime: 0, endTime: 0, centerSystemText: "", countDownText: "", dungeonConfirmText: "", centerSystemFrequency: 0, countDownFrequency: 0, isCenterSystemLast5EveryMinutes: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnnounceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnnounceData): AnnounceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 config_id */ 1:
                    message.configId = reader.uint32();
                    break;
                case /* uint32 begin_time */ 2:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 3:
                    message.endTime = reader.uint32();
                    break;
                case /* string center_system_text */ 4:
                    message.centerSystemText = reader.string();
                    break;
                case /* string count_down_text */ 5:
                    message.countDownText = reader.string();
                    break;
                case /* string dungeon_confirm_text */ 6:
                    message.dungeonConfirmText = reader.string();
                    break;
                case /* uint32 center_system_frequency */ 7:
                    message.centerSystemFrequency = reader.uint32();
                    break;
                case /* uint32 count_down_frequency */ 8:
                    message.countDownFrequency = reader.uint32();
                    break;
                case /* bool is_center_system_last_5_every_minutes */ 9:
                    message.isCenterSystemLast5EveryMinutes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnnounceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 config_id = 1; */
        if (message.configId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.configId);
        /* uint32 begin_time = 2; */
        if (message.beginTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 3; */
        if (message.endTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.endTime);
        /* string center_system_text = 4; */
        if (message.centerSystemText !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.centerSystemText);
        /* string count_down_text = 5; */
        if (message.countDownText !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.countDownText);
        /* string dungeon_confirm_text = 6; */
        if (message.dungeonConfirmText !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.dungeonConfirmText);
        /* uint32 center_system_frequency = 7; */
        if (message.centerSystemFrequency !== 0)
            writer.tag(7, WireType.Varint).uint32(message.centerSystemFrequency);
        /* uint32 count_down_frequency = 8; */
        if (message.countDownFrequency !== 0)
            writer.tag(8, WireType.Varint).uint32(message.countDownFrequency);
        /* bool is_center_system_last_5_every_minutes = 9; */
        if (message.isCenterSystemLast5EveryMinutes !== false)
            writer.tag(9, WireType.Varint).bool(message.isCenterSystemLast5EveryMinutes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnnounceData
 */
export const AnnounceData = new AnnounceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AskAddFriendNotify$Type extends MessageType<AskAddFriendNotify> {
    constructor() {
        super("AskAddFriendNotify", [
            { no: 13, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "target_friend_brief", kind: "message", T: () => FriendBrief }
        ]);
    }
    create(value?: PartialMessage<AskAddFriendNotify>): AskAddFriendNotify {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AskAddFriendNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AskAddFriendNotify): AskAddFriendNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 13:
                    message.targetUid = reader.uint32();
                    break;
                case /* FriendBrief target_friend_brief */ 10:
                    message.targetFriendBrief = FriendBrief.internalBinaryRead(reader, reader.uint32(), options, message.targetFriendBrief);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AskAddFriendNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 13; */
        if (message.targetUid !== 0)
            writer.tag(13, WireType.Varint).uint32(message.targetUid);
        /* FriendBrief target_friend_brief = 10; */
        if (message.targetFriendBrief)
            FriendBrief.internalBinaryWrite(message.targetFriendBrief, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AskAddFriendNotify
 */
export const AskAddFriendNotify = new AskAddFriendNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AskAddFriendReq$Type extends MessageType<AskAddFriendReq> {
    constructor() {
        super("AskAddFriendReq", [
            { no: 8, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AskAddFriendReq>): AskAddFriendReq {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AskAddFriendReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AskAddFriendReq): AskAddFriendReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 8:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AskAddFriendReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 8; */
        if (message.targetUid !== 0)
            writer.tag(8, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AskAddFriendReq
 */
export const AskAddFriendReq = new AskAddFriendReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AskAddFriendRsp$Type extends MessageType<AskAddFriendRsp> {
    constructor() {
        super("AskAddFriendRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AskAddFriendRsp>): AskAddFriendRsp {
        const message = { retcode: 0, targetUid: 0, param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AskAddFriendRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AskAddFriendRsp): AskAddFriendRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 14:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint32 param */ 13:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AskAddFriendRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 14; */
        if (message.targetUid !== 0)
            writer.tag(14, WireType.Varint).uint32(message.targetUid);
        /* uint32 param = 13; */
        if (message.param !== 0)
            writer.tag(13, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AskAddFriendRsp
 */
export const AskAddFriendRsp = new AskAddFriendRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttackHitEffectResult$Type extends MessageType<AttackHitEffectResult> {
    constructor() {
        super("AttackHitEffectResult", [
            { no: 3, name: "hit_eff_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "retreat_strength", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "air_strength", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "hit_halt_time", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 1, name: "hit_halt_time_scale", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "original_hit_eff_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AttackHitEffectResult>): AttackHitEffectResult {
        const message = { hitEffLevel: 0, retreatStrength: 0, airStrength: 0, hitHaltTime: 0, hitHaltTimeScale: 0, originalHitEffLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttackHitEffectResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttackHitEffectResult): AttackHitEffectResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 hit_eff_level */ 3:
                    message.hitEffLevel = reader.uint32();
                    break;
                case /* float retreat_strength */ 15:
                    message.retreatStrength = reader.float();
                    break;
                case /* float air_strength */ 8:
                    message.airStrength = reader.float();
                    break;
                case /* float hit_halt_time */ 2:
                    message.hitHaltTime = reader.float();
                    break;
                case /* float hit_halt_time_scale */ 1:
                    message.hitHaltTimeScale = reader.float();
                    break;
                case /* uint32 original_hit_eff_level */ 4:
                    message.originalHitEffLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttackHitEffectResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 hit_eff_level = 3; */
        if (message.hitEffLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.hitEffLevel);
        /* float retreat_strength = 15; */
        if (message.retreatStrength !== 0)
            writer.tag(15, WireType.Bit32).float(message.retreatStrength);
        /* float air_strength = 8; */
        if (message.airStrength !== 0)
            writer.tag(8, WireType.Bit32).float(message.airStrength);
        /* float hit_halt_time = 2; */
        if (message.hitHaltTime !== 0)
            writer.tag(2, WireType.Bit32).float(message.hitHaltTime);
        /* float hit_halt_time_scale = 1; */
        if (message.hitHaltTimeScale !== 0)
            writer.tag(1, WireType.Bit32).float(message.hitHaltTimeScale);
        /* uint32 original_hit_eff_level = 4; */
        if (message.originalHitEffLevel !== 0)
            writer.tag(4, WireType.Varint).uint32(message.originalHitEffLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AttackHitEffectResult
 */
export const AttackHitEffectResult = new AttackHitEffectResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttackResult$Type extends MessageType<AttackResult> {
    constructor() {
        super("AttackResult", [
            { no: 5, name: "attacker_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "defense_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "anim_event_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ability_identifier", kind: "message", T: () => AbilityIdentifier },
            { no: 15, name: "damage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "is_crit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "hit_collision", kind: "message", T: () => HitCollision },
            { no: 2, name: "hit_pos_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "endure_break", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "resolved_dir", kind: "message", T: () => Vector },
            { no: 4, name: "hit_retreat_angle_compat", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "hit_eff_result", kind: "message", T: () => AttackHitEffectResult },
            { no: 13, name: "element_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1975, name: "use_gadget_damage_action", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1092, name: "gadget_damage_action_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1855, name: "is_resist_text", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1064, name: "critical_rand", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 180, name: "element_amplify_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 1602, name: "damage_shield", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 1725, name: "mute_element_hurt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1690, name: "amplify_reaction_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 335, name: "addhurt_reaction_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 797, name: "bullet_fly_time_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 819, name: "attack_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 950, name: "hashed_anim_event_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 873, name: "attack_timestamp_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1088, name: "endure_delta", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 531, name: "target_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1994, name: "element_durability_attenuation", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 40, name: "EGPFEACDCLP", kind: "scalar", jsonName: "EGPFEACDCLP", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AttackResult>): AttackResult {
        const message = { attackerId: 0, defenseId: 0, animEventId: "", damage: 0, isCrit: false, hitPosType: 0, endureBreak: 0, hitRetreatAngleCompat: 0, elementType: 0, useGadgetDamageAction: false, gadgetDamageActionIdx: 0, isResistText: false, criticalRand: 0, elementAmplifyRate: 0, damageShield: 0, muteElementHurt: false, amplifyReactionType: 0, addhurtReactionType: 0, bulletFlyTimeMs: 0, attackCount: 0, hashedAnimEventId: 0, attackTimestampMs: 0, endureDelta: 0, targetType: 0, elementDurabilityAttenuation: 0, eGPFEACDCLP: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttackResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttackResult): AttackResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attacker_id */ 5:
                    message.attackerId = reader.uint32();
                    break;
                case /* uint32 defense_id */ 10:
                    message.defenseId = reader.uint32();
                    break;
                case /* string anim_event_id */ 12:
                    message.animEventId = reader.string();
                    break;
                case /* AbilityIdentifier ability_identifier */ 7:
                    message.abilityIdentifier = AbilityIdentifier.internalBinaryRead(reader, reader.uint32(), options, message.abilityIdentifier);
                    break;
                case /* float damage */ 15:
                    message.damage = reader.float();
                    break;
                case /* bool is_crit */ 14:
                    message.isCrit = reader.bool();
                    break;
                case /* HitCollision hit_collision */ 9:
                    message.hitCollision = HitCollision.internalBinaryRead(reader, reader.uint32(), options, message.hitCollision);
                    break;
                case /* uint32 hit_pos_type */ 2:
                    message.hitPosType = reader.uint32();
                    break;
                case /* uint32 endure_break */ 1:
                    message.endureBreak = reader.uint32();
                    break;
                case /* Vector resolved_dir */ 8:
                    message.resolvedDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.resolvedDir);
                    break;
                case /* int32 hit_retreat_angle_compat */ 4:
                    message.hitRetreatAngleCompat = reader.int32();
                    break;
                case /* AttackHitEffectResult hit_eff_result */ 11:
                    message.hitEffResult = AttackHitEffectResult.internalBinaryRead(reader, reader.uint32(), options, message.hitEffResult);
                    break;
                case /* uint32 element_type */ 13:
                    message.elementType = reader.uint32();
                    break;
                case /* bool use_gadget_damage_action */ 1975:
                    message.useGadgetDamageAction = reader.bool();
                    break;
                case /* uint32 gadget_damage_action_idx */ 1092:
                    message.gadgetDamageActionIdx = reader.uint32();
                    break;
                case /* bool is_resist_text */ 1855:
                    message.isResistText = reader.bool();
                    break;
                case /* uint32 critical_rand */ 1064:
                    message.criticalRand = reader.uint32();
                    break;
                case /* float element_amplify_rate */ 180:
                    message.elementAmplifyRate = reader.float();
                    break;
                case /* float damage_shield */ 1602:
                    message.damageShield = reader.float();
                    break;
                case /* bool mute_element_hurt */ 1725:
                    message.muteElementHurt = reader.bool();
                    break;
                case /* uint32 amplify_reaction_type */ 1690:
                    message.amplifyReactionType = reader.uint32();
                    break;
                case /* uint32 addhurt_reaction_type */ 335:
                    message.addhurtReactionType = reader.uint32();
                    break;
                case /* uint32 bullet_fly_time_ms */ 797:
                    message.bulletFlyTimeMs = reader.uint32();
                    break;
                case /* uint32 attack_count */ 819:
                    message.attackCount = reader.uint32();
                    break;
                case /* uint32 hashed_anim_event_id */ 950:
                    message.hashedAnimEventId = reader.uint32();
                    break;
                case /* uint32 attack_timestamp_ms */ 873:
                    message.attackTimestampMs = reader.uint32();
                    break;
                case /* float endure_delta */ 1088:
                    message.endureDelta = reader.float();
                    break;
                case /* uint32 target_type */ 531:
                    message.targetType = reader.uint32();
                    break;
                case /* float element_durability_attenuation */ 1994:
                    message.elementDurabilityAttenuation = reader.float();
                    break;
                case /* uint32 EGPFEACDCLP = 40 [json_name = "EGPFEACDCLP"];*/ 40:
                    message.eGPFEACDCLP = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttackResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 attacker_id = 5; */
        if (message.attackerId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.attackerId);
        /* uint32 defense_id = 10; */
        if (message.defenseId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.defenseId);
        /* string anim_event_id = 12; */
        if (message.animEventId !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.animEventId);
        /* AbilityIdentifier ability_identifier = 7; */
        if (message.abilityIdentifier)
            AbilityIdentifier.internalBinaryWrite(message.abilityIdentifier, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* float damage = 15; */
        if (message.damage !== 0)
            writer.tag(15, WireType.Bit32).float(message.damage);
        /* bool is_crit = 14; */
        if (message.isCrit !== false)
            writer.tag(14, WireType.Varint).bool(message.isCrit);
        /* HitCollision hit_collision = 9; */
        if (message.hitCollision)
            HitCollision.internalBinaryWrite(message.hitCollision, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 hit_pos_type = 2; */
        if (message.hitPosType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.hitPosType);
        /* uint32 endure_break = 1; */
        if (message.endureBreak !== 0)
            writer.tag(1, WireType.Varint).uint32(message.endureBreak);
        /* Vector resolved_dir = 8; */
        if (message.resolvedDir)
            Vector.internalBinaryWrite(message.resolvedDir, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int32 hit_retreat_angle_compat = 4; */
        if (message.hitRetreatAngleCompat !== 0)
            writer.tag(4, WireType.Varint).int32(message.hitRetreatAngleCompat);
        /* AttackHitEffectResult hit_eff_result = 11; */
        if (message.hitEffResult)
            AttackHitEffectResult.internalBinaryWrite(message.hitEffResult, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 element_type = 13; */
        if (message.elementType !== 0)
            writer.tag(13, WireType.Varint).uint32(message.elementType);
        /* bool use_gadget_damage_action = 1975; */
        if (message.useGadgetDamageAction !== false)
            writer.tag(1975, WireType.Varint).bool(message.useGadgetDamageAction);
        /* uint32 gadget_damage_action_idx = 1092; */
        if (message.gadgetDamageActionIdx !== 0)
            writer.tag(1092, WireType.Varint).uint32(message.gadgetDamageActionIdx);
        /* bool is_resist_text = 1855; */
        if (message.isResistText !== false)
            writer.tag(1855, WireType.Varint).bool(message.isResistText);
        /* uint32 critical_rand = 1064; */
        if (message.criticalRand !== 0)
            writer.tag(1064, WireType.Varint).uint32(message.criticalRand);
        /* float element_amplify_rate = 180; */
        if (message.elementAmplifyRate !== 0)
            writer.tag(180, WireType.Bit32).float(message.elementAmplifyRate);
        /* float damage_shield = 1602; */
        if (message.damageShield !== 0)
            writer.tag(1602, WireType.Bit32).float(message.damageShield);
        /* bool mute_element_hurt = 1725; */
        if (message.muteElementHurt !== false)
            writer.tag(1725, WireType.Varint).bool(message.muteElementHurt);
        /* uint32 amplify_reaction_type = 1690; */
        if (message.amplifyReactionType !== 0)
            writer.tag(1690, WireType.Varint).uint32(message.amplifyReactionType);
        /* uint32 addhurt_reaction_type = 335; */
        if (message.addhurtReactionType !== 0)
            writer.tag(335, WireType.Varint).uint32(message.addhurtReactionType);
        /* uint32 bullet_fly_time_ms = 797; */
        if (message.bulletFlyTimeMs !== 0)
            writer.tag(797, WireType.Varint).uint32(message.bulletFlyTimeMs);
        /* uint32 attack_count = 819; */
        if (message.attackCount !== 0)
            writer.tag(819, WireType.Varint).uint32(message.attackCount);
        /* uint32 hashed_anim_event_id = 950; */
        if (message.hashedAnimEventId !== 0)
            writer.tag(950, WireType.Varint).uint32(message.hashedAnimEventId);
        /* uint32 attack_timestamp_ms = 873; */
        if (message.attackTimestampMs !== 0)
            writer.tag(873, WireType.Varint).uint32(message.attackTimestampMs);
        /* float endure_delta = 1088; */
        if (message.endureDelta !== 0)
            writer.tag(1088, WireType.Bit32).float(message.endureDelta);
        /* uint32 target_type = 531; */
        if (message.targetType !== 0)
            writer.tag(531, WireType.Varint).uint32(message.targetType);
        /* float element_durability_attenuation = 1994; */
        if (message.elementDurabilityAttenuation !== 0)
            writer.tag(1994, WireType.Bit32).float(message.elementDurabilityAttenuation);
        /* uint32 EGPFEACDCLP = 40 [json_name = "EGPFEACDCLP"]; */
        if (message.eGPFEACDCLP !== 0)
            writer.tag(40, WireType.Varint).uint32(message.eGPFEACDCLP);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AttackResult
 */
export const AttackResult = new AttackResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarAddNotify$Type extends MessageType<AvatarAddNotify> {
    constructor() {
        super("AvatarAddNotify", [
            { no: 11, name: "avatar", kind: "message", T: () => AvatarInfo },
            { no: 15, name: "is_in_team", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarAddNotify>): AvatarAddNotify {
        const message = { isInTeam: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarAddNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarAddNotify): AvatarAddNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AvatarInfo avatar */ 11:
                    message.avatar = AvatarInfo.internalBinaryRead(reader, reader.uint32(), options, message.avatar);
                    break;
                case /* bool is_in_team */ 15:
                    message.isInTeam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarAddNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AvatarInfo avatar = 11; */
        if (message.avatar)
            AvatarInfo.internalBinaryWrite(message.avatar, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool is_in_team = 15; */
        if (message.isInTeam !== false)
            writer.tag(15, WireType.Varint).bool(message.isInTeam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarAddNotify
 */
export const AvatarAddNotify = new AvatarAddNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarChangeCostumeNotify$Type extends MessageType<AvatarChangeCostumeNotify> {
    constructor() {
        super("AvatarChangeCostumeNotify", [
            { no: 1, name: "entity_info", kind: "message", T: () => SceneEntityInfo }
        ]);
    }
    create(value?: PartialMessage<AvatarChangeCostumeNotify>): AvatarChangeCostumeNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarChangeCostumeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarChangeCostumeNotify): AvatarChangeCostumeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SceneEntityInfo entity_info */ 1:
                    message.entityInfo = SceneEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entityInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarChangeCostumeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SceneEntityInfo entity_info = 1; */
        if (message.entityInfo)
            SceneEntityInfo.internalBinaryWrite(message.entityInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarChangeCostumeNotify
 */
export const AvatarChangeCostumeNotify = new AvatarChangeCostumeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarChangeCostumeReq$Type extends MessageType<AvatarChangeCostumeReq> {
    constructor() {
        super("AvatarChangeCostumeReq", [
            { no: 7, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarChangeCostumeReq>): AvatarChangeCostumeReq {
        const message = { avatarGuid: 0n, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarChangeCostumeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarChangeCostumeReq): AvatarChangeCostumeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 7:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 costume_id */ 8:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarChangeCostumeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 7; */
        if (message.avatarGuid !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 costume_id = 8; */
        if (message.costumeId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarChangeCostumeReq
 */
export const AvatarChangeCostumeReq = new AvatarChangeCostumeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarChangeCostumeRsp$Type extends MessageType<AvatarChangeCostumeRsp> {
    constructor() {
        super("AvatarChangeCostumeRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarChangeCostumeRsp>): AvatarChangeCostumeRsp {
        const message = { retcode: 0, avatarGuid: 0n, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarChangeCostumeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarChangeCostumeRsp): AvatarChangeCostumeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 3:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 costume_id */ 1:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarChangeCostumeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 3; */
        if (message.avatarGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 costume_id = 1; */
        if (message.costumeId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarChangeCostumeRsp
 */
export const AvatarChangeCostumeRsp = new AvatarChangeCostumeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarChangeElementTypeReq$Type extends MessageType<AvatarChangeElementTypeReq> {
    constructor() {
        super("AvatarChangeElementTypeReq", [
            { no: 15, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarChangeElementTypeReq>): AvatarChangeElementTypeReq {
        const message = { sceneId: 0, areaId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarChangeElementTypeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarChangeElementTypeReq): AvatarChangeElementTypeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 15:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 area_id */ 4:
                    message.areaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarChangeElementTypeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 15; */
        if (message.sceneId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.sceneId);
        /* uint32 area_id = 4; */
        if (message.areaId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.areaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarChangeElementTypeReq
 */
export const AvatarChangeElementTypeReq = new AvatarChangeElementTypeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarChangeElementTypeRsp$Type extends MessageType<AvatarChangeElementTypeRsp> {
    constructor() {
        super("AvatarChangeElementTypeRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarChangeElementTypeRsp>): AvatarChangeElementTypeRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarChangeElementTypeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarChangeElementTypeRsp): AvatarChangeElementTypeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarChangeElementTypeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarChangeElementTypeRsp
 */
export const AvatarChangeElementTypeRsp = new AvatarChangeElementTypeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarDataNotify$Type extends MessageType<AvatarDataNotify> {
    constructor() {
        super("AvatarDataNotify", [
            { no: 15, name: "avatar_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AvatarInfo },
            { no: 6, name: "avatar_team_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AvatarTeam } },
            { no: 2, name: "cur_avatar_team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "choose_avatar_guid", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "temp_avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "owned_flycloak_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "owned_costume_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarDataNotify>): AvatarDataNotify {
        const message = { avatarList: [], avatarTeamMap: {}, curAvatarTeamId: 0, chooseAvatarGuid: 0n, tempAvatarGuidList: [], ownedFlycloakList: [], ownedCostumeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarDataNotify): AvatarDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AvatarInfo avatar_list */ 15:
                    message.avatarList.push(AvatarInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint32, AvatarTeam> avatar_team_map */ 6:
                    this.binaryReadMap6(message.avatarTeamMap, reader, options);
                    break;
                case /* uint32 cur_avatar_team_id */ 2:
                    message.curAvatarTeamId = reader.uint32();
                    break;
                case /* fixed64 choose_avatar_guid */ 11:
                    message.chooseAvatarGuid = reader.fixed64().toBigInt();
                    break;
                case /* repeated uint64 temp_avatar_guid_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tempAvatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.tempAvatarGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint32 owned_flycloak_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ownedFlycloakList.push(reader.uint32());
                    else
                        message.ownedFlycloakList.push(reader.uint32());
                    break;
                case /* repeated uint32 owned_costume_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ownedCostumeList.push(reader.uint32());
                    else
                        message.ownedCostumeList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AvatarDataNotify["avatarTeamMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarDataNotify["avatarTeamMap"] | undefined, val: AvatarDataNotify["avatarTeamMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AvatarTeam.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarDataNotify.avatar_team_map");
            }
        }
        map[key ?? 0] = val ?? AvatarTeam.create();
    }
    internalBinaryWrite(message: AvatarDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AvatarInfo avatar_list = 15; */
        for (let i = 0; i < message.avatarList.length; i++)
            AvatarInfo.internalBinaryWrite(message.avatarList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, AvatarTeam> avatar_team_map = 6; */
        for (let k of Object.keys(message.avatarTeamMap)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarTeam.internalBinaryWrite(message.avatarTeamMap[k as any], writer, options);
            writer.join().join();
        }
        /* uint32 cur_avatar_team_id = 2; */
        if (message.curAvatarTeamId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.curAvatarTeamId);
        /* fixed64 choose_avatar_guid = 11; */
        if (message.chooseAvatarGuid !== 0n)
            writer.tag(11, WireType.Bit64).fixed64(message.chooseAvatarGuid);
        /* repeated uint64 temp_avatar_guid_list = 14; */
        if (message.tempAvatarGuidList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tempAvatarGuidList.length; i++)
                writer.uint64(message.tempAvatarGuidList[i]);
            writer.join();
        }
        /* repeated uint32 owned_flycloak_list = 8; */
        if (message.ownedFlycloakList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ownedFlycloakList.length; i++)
                writer.uint32(message.ownedFlycloakList[i]);
            writer.join();
        }
        /* repeated uint32 owned_costume_list = 7; */
        if (message.ownedCostumeList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ownedCostumeList.length; i++)
                writer.uint32(message.ownedCostumeList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarDataNotify
 */
export const AvatarDataNotify = new AvatarDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarDieAnimationEndReq$Type extends MessageType<AvatarDieAnimationEndReq> {
    constructor() {
        super("AvatarDieAnimationEndReq", [
            { no: 14, name: "die_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "reborn_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<AvatarDieAnimationEndReq>): AvatarDieAnimationEndReq {
        const message = { dieGuid: 0n, skillId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarDieAnimationEndReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarDieAnimationEndReq): AvatarDieAnimationEndReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 die_guid */ 14:
                    message.dieGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 skill_id */ 4:
                    message.skillId = reader.uint32();
                    break;
                case /* Vector reborn_pos */ 13:
                    message.rebornPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rebornPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarDieAnimationEndReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 die_guid = 14; */
        if (message.dieGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.dieGuid);
        /* uint32 skill_id = 4; */
        if (message.skillId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.skillId);
        /* Vector reborn_pos = 13; */
        if (message.rebornPos)
            Vector.internalBinaryWrite(message.rebornPos, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarDieAnimationEndReq
 */
export const AvatarDieAnimationEndReq = new AvatarDieAnimationEndReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarDieAnimationEndRsp$Type extends MessageType<AvatarDieAnimationEndRsp> {
    constructor() {
        super("AvatarDieAnimationEndRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "die_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarDieAnimationEndRsp>): AvatarDieAnimationEndRsp {
        const message = { retcode: 0, dieGuid: 0n, skillId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarDieAnimationEndRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarDieAnimationEndRsp): AvatarDieAnimationEndRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 die_guid */ 11:
                    message.dieGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 skill_id */ 13:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarDieAnimationEndRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint64 die_guid = 11; */
        if (message.dieGuid !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.dieGuid);
        /* uint32 skill_id = 13; */
        if (message.skillId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarDieAnimationEndRsp
 */
export const AvatarDieAnimationEndRsp = new AvatarDieAnimationEndRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarEnterSceneInfo$Type extends MessageType<AvatarEnterSceneInfo> {
    constructor() {
        super("AvatarEnterSceneInfo", [
            { no: 1, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "avatar_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "avatar_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 4, name: "buff_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "weapon_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "weapon_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 8, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff }
        ]);
    }
    create(value?: PartialMessage<AvatarEnterSceneInfo>): AvatarEnterSceneInfo {
        const message = { avatarGuid: 0n, avatarEntityId: 0, buffIdList: [], weaponGuid: 0n, weaponEntityId: 0, serverBuffList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarEnterSceneInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarEnterSceneInfo): AvatarEnterSceneInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 1:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 avatar_entity_id */ 2:
                    message.avatarEntityId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo avatar_ability_info */ 3:
                    message.avatarAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.avatarAbilityInfo);
                    break;
                case /* repeated uint32 buff_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.buffIdList.push(reader.uint32());
                    else
                        message.buffIdList.push(reader.uint32());
                    break;
                case /* uint64 weapon_guid */ 5:
                    message.weaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 weapon_entity_id */ 6:
                    message.weaponEntityId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo weapon_ability_info */ 7:
                    message.weaponAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.weaponAbilityInfo);
                    break;
                case /* repeated ServerBuff server_buff_list */ 8:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarEnterSceneInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 1; */
        if (message.avatarGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 avatar_entity_id = 2; */
        if (message.avatarEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.avatarEntityId);
        /* AbilitySyncStateInfo avatar_ability_info = 3; */
        if (message.avatarAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.avatarAbilityInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 buff_id_list = 4; */
        if (message.buffIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.buffIdList.length; i++)
                writer.uint32(message.buffIdList[i]);
            writer.join();
        }
        /* uint64 weapon_guid = 5; */
        if (message.weaponGuid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.weaponGuid);
        /* uint32 weapon_entity_id = 6; */
        if (message.weaponEntityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.weaponEntityId);
        /* AbilitySyncStateInfo weapon_ability_info = 7; */
        if (message.weaponAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.weaponAbilityInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated ServerBuff server_buff_list = 8; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarEnterSceneInfo
 */
export const AvatarEnterSceneInfo = new AvatarEnterSceneInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarEquipAffixInfo$Type extends MessageType<AvatarEquipAffixInfo> {
    constructor() {
        super("AvatarEquipAffixInfo", [
            { no: 1, name: "equip_affix_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "left_cd_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarEquipAffixInfo>): AvatarEquipAffixInfo {
        const message = { equipAffixId: 0, leftCdTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarEquipAffixInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarEquipAffixInfo): AvatarEquipAffixInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 equip_affix_id */ 1:
                    message.equipAffixId = reader.uint32();
                    break;
                case /* uint32 left_cd_time */ 2:
                    message.leftCdTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarEquipAffixInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 equip_affix_id = 1; */
        if (message.equipAffixId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.equipAffixId);
        /* uint32 left_cd_time = 2; */
        if (message.leftCdTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.leftCdTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarEquipAffixInfo
 */
export const AvatarEquipAffixInfo = new AvatarEquipAffixInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarEquipChangeNotify$Type extends MessageType<AvatarEquipChangeNotify> {
    constructor() {
        super("AvatarEquipChangeNotify", [
            { no: 1, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equip_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "equip_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "weapon", kind: "message", T: () => SceneWeaponInfo },
            { no: 11, name: "reliquary", kind: "message", T: () => SceneReliquaryInfo }
        ]);
    }
    create(value?: PartialMessage<AvatarEquipChangeNotify>): AvatarEquipChangeNotify {
        const message = { avatarGuid: 0n, equipType: 0, itemId: 0, equipGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarEquipChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarEquipChangeNotify): AvatarEquipChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 1:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 equip_type */ 2:
                    message.equipType = reader.uint32();
                    break;
                case /* uint32 item_id */ 8:
                    message.itemId = reader.uint32();
                    break;
                case /* uint64 equip_guid */ 4:
                    message.equipGuid = reader.uint64().toBigInt();
                    break;
                case /* SceneWeaponInfo weapon */ 13:
                    message.weapon = SceneWeaponInfo.internalBinaryRead(reader, reader.uint32(), options, message.weapon);
                    break;
                case /* SceneReliquaryInfo reliquary */ 11:
                    message.reliquary = SceneReliquaryInfo.internalBinaryRead(reader, reader.uint32(), options, message.reliquary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarEquipChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 1; */
        if (message.avatarGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 equip_type = 2; */
        if (message.equipType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.equipType);
        /* uint32 item_id = 8; */
        if (message.itemId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.itemId);
        /* uint64 equip_guid = 4; */
        if (message.equipGuid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.equipGuid);
        /* SceneWeaponInfo weapon = 13; */
        if (message.weapon)
            SceneWeaponInfo.internalBinaryWrite(message.weapon, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* SceneReliquaryInfo reliquary = 11; */
        if (message.reliquary)
            SceneReliquaryInfo.internalBinaryWrite(message.reliquary, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarEquipChangeNotify
 */
export const AvatarEquipChangeNotify = new AvatarEquipChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExcelInfo$Type extends MessageType<AvatarExcelInfo> {
    constructor() {
        super("AvatarExcelInfo", [
            { no: 1, name: "prefab_path_hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "prefab_path_remote_hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "controller_path_hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "controller_path_remote_hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "combat_config_hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExcelInfo>): AvatarExcelInfo {
        const message = { prefabPathHash: 0n, prefabPathRemoteHash: 0n, controllerPathHash: 0n, controllerPathRemoteHash: 0n, combatConfigHash: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExcelInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExcelInfo): AvatarExcelInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 prefab_path_hash */ 1:
                    message.prefabPathHash = reader.uint64().toBigInt();
                    break;
                case /* uint64 prefab_path_remote_hash */ 2:
                    message.prefabPathRemoteHash = reader.uint64().toBigInt();
                    break;
                case /* uint64 controller_path_hash */ 3:
                    message.controllerPathHash = reader.uint64().toBigInt();
                    break;
                case /* uint64 controller_path_remote_hash */ 4:
                    message.controllerPathRemoteHash = reader.uint64().toBigInt();
                    break;
                case /* uint64 combat_config_hash */ 5:
                    message.combatConfigHash = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarExcelInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 prefab_path_hash = 1; */
        if (message.prefabPathHash !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.prefabPathHash);
        /* uint64 prefab_path_remote_hash = 2; */
        if (message.prefabPathRemoteHash !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.prefabPathRemoteHash);
        /* uint64 controller_path_hash = 3; */
        if (message.controllerPathHash !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.controllerPathHash);
        /* uint64 controller_path_remote_hash = 4; */
        if (message.controllerPathRemoteHash !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.controllerPathRemoteHash);
        /* uint64 combat_config_hash = 5; */
        if (message.combatConfigHash !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.combatConfigHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExcelInfo
 */
export const AvatarExcelInfo = new AvatarExcelInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionAllDataRsp$Type extends MessageType<AvatarExpeditionAllDataRsp> {
    constructor() {
        super("AvatarExpeditionAllDataRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "expedition_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarExpeditionInfo } },
            { no: 6, name: "open_expedition_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "expedition_count_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionAllDataRsp>): AvatarExpeditionAllDataRsp {
        const message = { retcode: 0, expeditionInfoMap: {}, openExpeditionList: [], expeditionCountLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionAllDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionAllDataRsp): AvatarExpeditionAllDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* map<uint64, AvatarExpeditionInfo> expedition_info_map */ 1:
                    this.binaryReadMap1(message.expeditionInfoMap, reader, options);
                    break;
                case /* repeated uint32 open_expedition_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openExpeditionList.push(reader.uint32());
                    else
                        message.openExpeditionList.push(reader.uint32());
                    break;
                case /* uint32 expedition_count_limit */ 7:
                    message.expeditionCountLimit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AvatarExpeditionAllDataRsp["expeditionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarExpeditionAllDataRsp["expeditionInfoMap"] | undefined, val: AvatarExpeditionAllDataRsp["expeditionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarExpeditionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarExpeditionAllDataRsp.expedition_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarExpeditionInfo.create();
    }
    internalBinaryWrite(message: AvatarExpeditionAllDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* map<uint64, AvatarExpeditionInfo> expedition_info_map = 1; */
        for (let k of Object.keys(message.expeditionInfoMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarExpeditionInfo.internalBinaryWrite(message.expeditionInfoMap[k], writer, options);
            writer.join().join();
        }
        /* repeated uint32 open_expedition_list = 6; */
        if (message.openExpeditionList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.openExpeditionList.length; i++)
                writer.uint32(message.openExpeditionList[i]);
            writer.join();
        }
        /* uint32 expedition_count_limit = 7; */
        if (message.expeditionCountLimit !== 0)
            writer.tag(7, WireType.Varint).uint32(message.expeditionCountLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionAllDataRsp
 */
export const AvatarExpeditionAllDataRsp = new AvatarExpeditionAllDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionCallBackReq$Type extends MessageType<AvatarExpeditionCallBackReq> {
    constructor() {
        super("AvatarExpeditionCallBackReq", [
            { no: 12, name: "avatar_guid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionCallBackReq>): AvatarExpeditionCallBackReq {
        const message = { avatarGuid: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionCallBackReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionCallBackReq): AvatarExpeditionCallBackReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 avatar_guid */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuid.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuid.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarExpeditionCallBackReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 avatar_guid = 12; */
        if (message.avatarGuid.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuid.length; i++)
                writer.uint64(message.avatarGuid[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionCallBackReq
 */
export const AvatarExpeditionCallBackReq = new AvatarExpeditionCallBackReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionCallBackRsp$Type extends MessageType<AvatarExpeditionCallBackRsp> {
    constructor() {
        super("AvatarExpeditionCallBackRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "expedition_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarExpeditionInfo } }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionCallBackRsp>): AvatarExpeditionCallBackRsp {
        const message = { retcode: 0, expeditionInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionCallBackRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionCallBackRsp): AvatarExpeditionCallBackRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* map<uint64, AvatarExpeditionInfo> expedition_info_map */ 14:
                    this.binaryReadMap14(message.expeditionInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap14(map: AvatarExpeditionCallBackRsp["expeditionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarExpeditionCallBackRsp["expeditionInfoMap"] | undefined, val: AvatarExpeditionCallBackRsp["expeditionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarExpeditionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarExpeditionCallBackRsp.expedition_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarExpeditionInfo.create();
    }
    internalBinaryWrite(message: AvatarExpeditionCallBackRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* map<uint64, AvatarExpeditionInfo> expedition_info_map = 14; */
        for (let k of Object.keys(message.expeditionInfoMap)) {
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarExpeditionInfo.internalBinaryWrite(message.expeditionInfoMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionCallBackRsp
 */
export const AvatarExpeditionCallBackRsp = new AvatarExpeditionCallBackRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionDataNotify$Type extends MessageType<AvatarExpeditionDataNotify> {
    constructor() {
        super("AvatarExpeditionDataNotify", [
            { no: 1, name: "expedition_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarExpeditionInfo } }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionDataNotify>): AvatarExpeditionDataNotify {
        const message = { expeditionInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionDataNotify): AvatarExpeditionDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, AvatarExpeditionInfo> expedition_info_map */ 1:
                    this.binaryReadMap1(message.expeditionInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AvatarExpeditionDataNotify["expeditionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarExpeditionDataNotify["expeditionInfoMap"] | undefined, val: AvatarExpeditionDataNotify["expeditionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarExpeditionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarExpeditionDataNotify.expedition_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarExpeditionInfo.create();
    }
    internalBinaryWrite(message: AvatarExpeditionDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, AvatarExpeditionInfo> expedition_info_map = 1; */
        for (let k of Object.keys(message.expeditionInfoMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarExpeditionInfo.internalBinaryWrite(message.expeditionInfoMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionDataNotify
 */
export const AvatarExpeditionDataNotify = new AvatarExpeditionDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionGetRewardReq$Type extends MessageType<AvatarExpeditionGetRewardReq> {
    constructor() {
        super("AvatarExpeditionGetRewardReq", [
            { no: 5, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionGetRewardReq>): AvatarExpeditionGetRewardReq {
        const message = { avatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionGetRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionGetRewardReq): AvatarExpeditionGetRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 5:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarExpeditionGetRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 5; */
        if (message.avatarGuid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.avatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionGetRewardReq
 */
export const AvatarExpeditionGetRewardReq = new AvatarExpeditionGetRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionGetRewardRsp$Type extends MessageType<AvatarExpeditionGetRewardRsp> {
    constructor() {
        super("AvatarExpeditionGetRewardRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "expedition_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarExpeditionInfo } },
            { no: 6, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "BNFDDKNNJJH", kind: "message", jsonName: "BNFDDKNNJJH", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionGetRewardRsp>): AvatarExpeditionGetRewardRsp {
        const message = { retcode: 0, expeditionInfoMap: {}, itemList: [], bNFDDKNNJJH: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionGetRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionGetRewardRsp): AvatarExpeditionGetRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* map<uint64, AvatarExpeditionInfo> expedition_info_map */ 5:
                    this.binaryReadMap5(message.expeditionInfoMap, reader, options);
                    break;
                case /* repeated ItemParam item_list */ 6:
                    message.itemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam BNFDDKNNJJH = 2 [json_name = "BNFDDKNNJJH"];*/ 2:
                    message.bNFDDKNNJJH.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: AvatarExpeditionGetRewardRsp["expeditionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarExpeditionGetRewardRsp["expeditionInfoMap"] | undefined, val: AvatarExpeditionGetRewardRsp["expeditionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarExpeditionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarExpeditionGetRewardRsp.expedition_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarExpeditionInfo.create();
    }
    internalBinaryWrite(message: AvatarExpeditionGetRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* map<uint64, AvatarExpeditionInfo> expedition_info_map = 5; */
        for (let k of Object.keys(message.expeditionInfoMap)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarExpeditionInfo.internalBinaryWrite(message.expeditionInfoMap[k], writer, options);
            writer.join().join();
        }
        /* repeated ItemParam item_list = 6; */
        for (let i = 0; i < message.itemList.length; i++)
            ItemParam.internalBinaryWrite(message.itemList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam BNFDDKNNJJH = 2 [json_name = "BNFDDKNNJJH"]; */
        for (let i = 0; i < message.bNFDDKNNJJH.length; i++)
            ItemParam.internalBinaryWrite(message.bNFDDKNNJJH[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionGetRewardRsp
 */
export const AvatarExpeditionGetRewardRsp = new AvatarExpeditionGetRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionInfo$Type extends MessageType<AvatarExpeditionInfo> {
    constructor() {
        super("AvatarExpeditionInfo", [
            { no: 1, name: "state", kind: "enum", T: () => ["AvatarExpeditionState", AvatarExpeditionState] },
            { no: 2, name: "exp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "hour_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "shorten_ratio", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionInfo>): AvatarExpeditionInfo {
        const message = { state: 0, expId: 0, hourTime: 0, startTime: 0, shortenRatio: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionInfo): AvatarExpeditionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AvatarExpeditionState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* uint32 exp_id */ 2:
                    message.expId = reader.uint32();
                    break;
                case /* uint32 hour_time */ 3:
                    message.hourTime = reader.uint32();
                    break;
                case /* uint32 start_time */ 4:
                    message.startTime = reader.uint32();
                    break;
                case /* float shorten_ratio */ 5:
                    message.shortenRatio = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarExpeditionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AvatarExpeditionState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* uint32 exp_id = 2; */
        if (message.expId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.expId);
        /* uint32 hour_time = 3; */
        if (message.hourTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.hourTime);
        /* uint32 start_time = 4; */
        if (message.startTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.startTime);
        /* float shorten_ratio = 5; */
        if (message.shortenRatio !== 0)
            writer.tag(5, WireType.Bit32).float(message.shortenRatio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionInfo
 */
export const AvatarExpeditionInfo = new AvatarExpeditionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionStartReq$Type extends MessageType<AvatarExpeditionStartReq> {
    constructor() {
        super("AvatarExpeditionStartReq", [
            { no: 8, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "exp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "hour_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionStartReq>): AvatarExpeditionStartReq {
        const message = { avatarGuid: 0n, expId: 0, hourTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionStartReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionStartReq): AvatarExpeditionStartReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 8:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 exp_id */ 2:
                    message.expId = reader.uint32();
                    break;
                case /* uint32 hour_time */ 7:
                    message.hourTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarExpeditionStartReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 8; */
        if (message.avatarGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 exp_id = 2; */
        if (message.expId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.expId);
        /* uint32 hour_time = 7; */
        if (message.hourTime !== 0)
            writer.tag(7, WireType.Varint).uint32(message.hourTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionStartReq
 */
export const AvatarExpeditionStartReq = new AvatarExpeditionStartReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarExpeditionStartRsp$Type extends MessageType<AvatarExpeditionStartRsp> {
    constructor() {
        super("AvatarExpeditionStartRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "expedition_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarExpeditionInfo } }
        ]);
    }
    create(value?: PartialMessage<AvatarExpeditionStartRsp>): AvatarExpeditionStartRsp {
        const message = { retcode: 0, expeditionInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarExpeditionStartRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarExpeditionStartRsp): AvatarExpeditionStartRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* map<uint64, AvatarExpeditionInfo> expedition_info_map */ 1:
                    this.binaryReadMap1(message.expeditionInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AvatarExpeditionStartRsp["expeditionInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarExpeditionStartRsp["expeditionInfoMap"] | undefined, val: AvatarExpeditionStartRsp["expeditionInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarExpeditionInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarExpeditionStartRsp.expedition_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarExpeditionInfo.create();
    }
    internalBinaryWrite(message: AvatarExpeditionStartRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* map<uint64, AvatarExpeditionInfo> expedition_info_map = 1; */
        for (let k of Object.keys(message.expeditionInfoMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarExpeditionInfo.internalBinaryWrite(message.expeditionInfoMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarExpeditionStartRsp
 */
export const AvatarExpeditionStartRsp = new AvatarExpeditionStartRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFetterDataNotify$Type extends MessageType<AvatarFetterDataNotify> {
    constructor() {
        super("AvatarFetterDataNotify", [
            { no: 1, name: "fetter_info_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => AvatarFetterInfo } }
        ]);
    }
    create(value?: PartialMessage<AvatarFetterDataNotify>): AvatarFetterDataNotify {
        const message = { fetterInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFetterDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFetterDataNotify): AvatarFetterDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, AvatarFetterInfo> fetter_info_map */ 1:
                    this.binaryReadMap1(message.fetterInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AvatarFetterDataNotify["fetterInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarFetterDataNotify["fetterInfoMap"] | undefined, val: AvatarFetterDataNotify["fetterInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = AvatarFetterInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarFetterDataNotify.fetter_info_map");
            }
        }
        map[key ?? "0"] = val ?? AvatarFetterInfo.create();
    }
    internalBinaryWrite(message: AvatarFetterDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, AvatarFetterInfo> fetter_info_map = 1; */
        for (let k of Object.keys(message.fetterInfoMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarFetterInfo.internalBinaryWrite(message.fetterInfoMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFetterDataNotify
 */
export const AvatarFetterDataNotify = new AvatarFetterDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFetterInfo$Type extends MessageType<AvatarFetterInfo> {
    constructor() {
        super("AvatarFetterInfo", [
            { no: 1, name: "exp_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "exp_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "open_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "finish_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "rewarded_fetter_level_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "fetter_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FetterData }
        ]);
    }
    create(value?: PartialMessage<AvatarFetterInfo>): AvatarFetterInfo {
        const message = { expNumber: 0, expLevel: 0, openIdList: [], finishIdList: [], rewardedFetterLevelList: [], fetterList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFetterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFetterInfo): AvatarFetterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 exp_number */ 1:
                    message.expNumber = reader.uint32();
                    break;
                case /* uint32 exp_level */ 2:
                    message.expLevel = reader.uint32();
                    break;
                case /* repeated uint32 open_id_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openIdList.push(reader.uint32());
                    else
                        message.openIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 finish_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishIdList.push(reader.uint32());
                    else
                        message.finishIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 rewarded_fetter_level_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rewardedFetterLevelList.push(reader.uint32());
                    else
                        message.rewardedFetterLevelList.push(reader.uint32());
                    break;
                case /* repeated FetterData fetter_list */ 6:
                    message.fetterList.push(FetterData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarFetterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 exp_number = 1; */
        if (message.expNumber !== 0)
            writer.tag(1, WireType.Varint).uint32(message.expNumber);
        /* uint32 exp_level = 2; */
        if (message.expLevel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.expLevel);
        /* repeated uint32 open_id_list = 3; */
        if (message.openIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.openIdList.length; i++)
                writer.uint32(message.openIdList[i]);
            writer.join();
        }
        /* repeated uint32 finish_id_list = 4; */
        if (message.finishIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishIdList.length; i++)
                writer.uint32(message.finishIdList[i]);
            writer.join();
        }
        /* repeated uint32 rewarded_fetter_level_list = 5; */
        if (message.rewardedFetterLevelList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rewardedFetterLevelList.length; i++)
                writer.uint32(message.rewardedFetterLevelList[i]);
            writer.join();
        }
        /* repeated FetterData fetter_list = 6; */
        for (let i = 0; i < message.fetterList.length; i++)
            FetterData.internalBinaryWrite(message.fetterList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFetterInfo
 */
export const AvatarFetterInfo = new AvatarFetterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFetterLevelRewardReq$Type extends MessageType<AvatarFetterLevelRewardReq> {
    constructor() {
        super("AvatarFetterLevelRewardReq", [
            { no: 15, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "fetter_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarFetterLevelRewardReq>): AvatarFetterLevelRewardReq {
        const message = { avatarGuid: 0n, fetterLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFetterLevelRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFetterLevelRewardReq): AvatarFetterLevelRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 15:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 fetter_level */ 2:
                    message.fetterLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarFetterLevelRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 15; */
        if (message.avatarGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 fetter_level = 2; */
        if (message.fetterLevel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fetterLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFetterLevelRewardReq
 */
export const AvatarFetterLevelRewardReq = new AvatarFetterLevelRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFetterLevelRewardRsp$Type extends MessageType<AvatarFetterLevelRewardRsp> {
    constructor() {
        super("AvatarFetterLevelRewardRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fetter_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarFetterLevelRewardRsp>): AvatarFetterLevelRewardRsp {
        const message = { retcode: 0, avatarGuid: 0n, fetterLevel: 0, rewardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFetterLevelRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFetterLevelRewardRsp): AvatarFetterLevelRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 12:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 fetter_level */ 10:
                    message.fetterLevel = reader.uint32();
                    break;
                case /* uint32 reward_id */ 11:
                    message.rewardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarFetterLevelRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 12; */
        if (message.avatarGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 fetter_level = 10; */
        if (message.fetterLevel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.fetterLevel);
        /* uint32 reward_id = 11; */
        if (message.rewardId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.rewardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFetterLevelRewardRsp
 */
export const AvatarFetterLevelRewardRsp = new AvatarFetterLevelRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFightPropNotify$Type extends MessageType<AvatarFightPropNotify> {
    constructor() {
        super("AvatarFightPropNotify", [
            { no: 3, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<AvatarFightPropNotify>): AvatarFightPropNotify {
        const message = { avatarGuid: 0n, fightPropMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFightPropNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFightPropNotify): AvatarFightPropNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 3:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, float> fight_prop_map */ 6:
                    this.binaryReadMap6(message.fightPropMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AvatarFightPropNotify["fightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarFightPropNotify["fightPropMap"] | undefined, val: AvatarFightPropNotify["fightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarFightPropNotify.fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AvatarFightPropNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 3; */
        if (message.avatarGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.avatarGuid);
        /* map<uint32, float> fight_prop_map = 6; */
        for (let k of Object.keys(message.fightPropMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.fightPropMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFightPropNotify
 */
export const AvatarFightPropNotify = new AvatarFightPropNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFightPropUpdateNotify$Type extends MessageType<AvatarFightPropUpdateNotify> {
    constructor() {
        super("AvatarFightPropUpdateNotify", [
            { no: 1, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<AvatarFightPropUpdateNotify>): AvatarFightPropUpdateNotify {
        const message = { avatarGuid: 0n, fightPropMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFightPropUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFightPropUpdateNotify): AvatarFightPropUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 1:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, float> fight_prop_map */ 6:
                    this.binaryReadMap6(message.fightPropMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AvatarFightPropUpdateNotify["fightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarFightPropUpdateNotify["fightPropMap"] | undefined, val: AvatarFightPropUpdateNotify["fightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarFightPropUpdateNotify.fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AvatarFightPropUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 1; */
        if (message.avatarGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.avatarGuid);
        /* map<uint32, float> fight_prop_map = 6; */
        for (let k of Object.keys(message.fightPropMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.fightPropMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFightPropUpdateNotify
 */
export const AvatarFightPropUpdateNotify = new AvatarFightPropUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarFlycloakChangeNotify$Type extends MessageType<AvatarFlycloakChangeNotify> {
    constructor() {
        super("AvatarFlycloakChangeNotify", [
            { no: 12, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarFlycloakChangeNotify>): AvatarFlycloakChangeNotify {
        const message = { avatarGuid: 0n, flycloakId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarFlycloakChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarFlycloakChangeNotify): AvatarFlycloakChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 12:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 flycloak_id */ 14:
                    message.flycloakId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarFlycloakChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 12; */
        if (message.avatarGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 flycloak_id = 14; */
        if (message.flycloakId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.flycloakId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarFlycloakChangeNotify
 */
export const AvatarFlycloakChangeNotify = new AvatarFlycloakChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarGainCostumeNotify$Type extends MessageType<AvatarGainCostumeNotify> {
    constructor() {
        super("AvatarGainCostumeNotify", [
            { no: 15, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarGainCostumeNotify>): AvatarGainCostumeNotify {
        const message = { costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarGainCostumeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarGainCostumeNotify): AvatarGainCostumeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 costume_id */ 15:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarGainCostumeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 costume_id = 15; */
        if (message.costumeId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarGainCostumeNotify
 */
export const AvatarGainCostumeNotify = new AvatarGainCostumeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarGainFlycloakNotify$Type extends MessageType<AvatarGainFlycloakNotify> {
    constructor() {
        super("AvatarGainFlycloakNotify", [
            { no: 2, name: "flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarGainFlycloakNotify>): AvatarGainFlycloakNotify {
        const message = { flycloakId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarGainFlycloakNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarGainFlycloakNotify): AvatarGainFlycloakNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 flycloak_id */ 2:
                    message.flycloakId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarGainFlycloakNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 flycloak_id = 2; */
        if (message.flycloakId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.flycloakId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarGainFlycloakNotify
 */
export const AvatarGainFlycloakNotify = new AvatarGainFlycloakNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarInfo$Type extends MessageType<AvatarInfo> {
    constructor() {
        super("AvatarInfo", [
            { no: 1, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } },
            { no: 4, name: "life_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "equip_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "talent_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 9, name: "trial_avatar_info", kind: "message", T: () => TrialAvatarInfo },
            { no: 10, name: "skill_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AvatarSkillInfo } },
            { no: 11, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "fetter_info", kind: "message", T: () => AvatarFetterInfo },
            { no: 13, name: "core_proud_skill_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "inherent_proud_skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "skill_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 16, name: "expedition_state", kind: "enum", T: () => ["AvatarExpeditionState", AvatarExpeditionState] },
            { no: 17, name: "proud_skill_extra_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 18, name: "is_focus", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "avatar_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "team_resonance_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "wearing_flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "equip_affix_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AvatarEquipAffixInfo },
            { no: 23, name: "born_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "pending_promote_reward_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "excel_info", kind: "message", T: () => AvatarExcelInfo },
            { no: 27, name: "anim_hash", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarInfo>): AvatarInfo {
        const message = { avatarId: 0, guid: 0n, propMap: {}, lifeState: 0, equipGuidList: [], talentIdList: [], fightPropMap: {}, skillMap: {}, skillDepotId: 0, coreProudSkillLevel: 0, inherentProudSkillList: [], skillLevelMap: {}, expeditionState: 0, proudSkillExtraLevelMap: {}, isFocus: false, avatarType: 0, teamResonanceList: [], wearingFlycloakId: 0, equipAffixList: [], bornTime: 0, pendingPromoteRewardList: [], costumeId: 0, animHash: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarInfo): AvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 1:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint64 guid */ 2:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, PropValue> prop_map */ 3:
                    this.binaryReadMap3(message.propMap, reader, options);
                    break;
                case /* uint32 life_state */ 4:
                    message.lifeState = reader.uint32();
                    break;
                case /* repeated uint64 equip_guid_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipGuidList.push(reader.uint64().toBigInt());
                    else
                        message.equipGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint32 talent_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.talentIdList.push(reader.uint32());
                    else
                        message.talentIdList.push(reader.uint32());
                    break;
                case /* map<uint32, float> fight_prop_map */ 7:
                    this.binaryReadMap7(message.fightPropMap, reader, options);
                    break;
                case /* TrialAvatarInfo trial_avatar_info */ 9:
                    message.trialAvatarInfo = TrialAvatarInfo.internalBinaryRead(reader, reader.uint32(), options, message.trialAvatarInfo);
                    break;
                case /* map<uint32, AvatarSkillInfo> skill_map */ 10:
                    this.binaryReadMap10(message.skillMap, reader, options);
                    break;
                case /* uint32 skill_depot_id */ 11:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* AvatarFetterInfo fetter_info */ 12:
                    message.fetterInfo = AvatarFetterInfo.internalBinaryRead(reader, reader.uint32(), options, message.fetterInfo);
                    break;
                case /* uint32 core_proud_skill_level */ 13:
                    message.coreProudSkillLevel = reader.uint32();
                    break;
                case /* repeated uint32 inherent_proud_skill_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inherentProudSkillList.push(reader.uint32());
                    else
                        message.inherentProudSkillList.push(reader.uint32());
                    break;
                case /* map<uint32, uint32> skill_level_map */ 15:
                    this.binaryReadMap15(message.skillLevelMap, reader, options);
                    break;
                case /* AvatarExpeditionState expedition_state */ 16:
                    message.expeditionState = reader.int32();
                    break;
                case /* map<uint32, uint32> proud_skill_extra_level_map */ 17:
                    this.binaryReadMap17(message.proudSkillExtraLevelMap, reader, options);
                    break;
                case /* bool is_focus */ 18:
                    message.isFocus = reader.bool();
                    break;
                case /* uint32 avatar_type */ 19:
                    message.avatarType = reader.uint32();
                    break;
                case /* repeated uint32 team_resonance_list */ 20:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.teamResonanceList.push(reader.uint32());
                    else
                        message.teamResonanceList.push(reader.uint32());
                    break;
                case /* uint32 wearing_flycloak_id */ 21:
                    message.wearingFlycloakId = reader.uint32();
                    break;
                case /* repeated AvatarEquipAffixInfo equip_affix_list */ 22:
                    message.equipAffixList.push(AvatarEquipAffixInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 born_time */ 23:
                    message.bornTime = reader.uint32();
                    break;
                case /* repeated uint32 pending_promote_reward_list */ 24:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pendingPromoteRewardList.push(reader.uint32());
                    else
                        message.pendingPromoteRewardList.push(reader.uint32());
                    break;
                case /* uint32 costume_id */ 25:
                    message.costumeId = reader.uint32();
                    break;
                case /* AvatarExcelInfo excel_info */ 26:
                    message.excelInfo = AvatarExcelInfo.internalBinaryRead(reader, reader.uint32(), options, message.excelInfo);
                    break;
                case /* uint32 anim_hash */ 27:
                    message.animHash = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: AvatarInfo["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarInfo["propMap"] | undefined, val: AvatarInfo["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarInfo.prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    private binaryReadMap7(map: AvatarInfo["fightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarInfo["fightPropMap"] | undefined, val: AvatarInfo["fightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarInfo.fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap10(map: AvatarInfo["skillMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarInfo["skillMap"] | undefined, val: AvatarInfo["skillMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AvatarSkillInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarInfo.skill_map");
            }
        }
        map[key ?? 0] = val ?? AvatarSkillInfo.create();
    }
    private binaryReadMap15(map: AvatarInfo["skillLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarInfo["skillLevelMap"] | undefined, val: AvatarInfo["skillLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarInfo.skill_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap17(map: AvatarInfo["proudSkillExtraLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarInfo["proudSkillExtraLevelMap"] | undefined, val: AvatarInfo["proudSkillExtraLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarInfo.proud_skill_extra_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 1; */
        if (message.avatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.avatarId);
        /* uint64 guid = 2; */
        if (message.guid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.guid);
        /* map<uint32, PropValue> prop_map = 3; */
        for (let k of Object.keys(message.propMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.propMap[k as any], writer, options);
            writer.join().join();
        }
        /* uint32 life_state = 4; */
        if (message.lifeState !== 0)
            writer.tag(4, WireType.Varint).uint32(message.lifeState);
        /* repeated uint64 equip_guid_list = 5; */
        if (message.equipGuidList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.equipGuidList.length; i++)
                writer.uint64(message.equipGuidList[i]);
            writer.join();
        }
        /* repeated uint32 talent_id_list = 6; */
        if (message.talentIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.talentIdList.length; i++)
                writer.uint32(message.talentIdList[i]);
            writer.join();
        }
        /* map<uint32, float> fight_prop_map = 7; */
        for (let k of Object.keys(message.fightPropMap))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.fightPropMap[k as any]).join();
        /* TrialAvatarInfo trial_avatar_info = 9; */
        if (message.trialAvatarInfo)
            TrialAvatarInfo.internalBinaryWrite(message.trialAvatarInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, AvatarSkillInfo> skill_map = 10; */
        for (let k of Object.keys(message.skillMap)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarSkillInfo.internalBinaryWrite(message.skillMap[k as any], writer, options);
            writer.join().join();
        }
        /* uint32 skill_depot_id = 11; */
        if (message.skillDepotId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.skillDepotId);
        /* AvatarFetterInfo fetter_info = 12; */
        if (message.fetterInfo)
            AvatarFetterInfo.internalBinaryWrite(message.fetterInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 core_proud_skill_level = 13; */
        if (message.coreProudSkillLevel !== 0)
            writer.tag(13, WireType.Varint).uint32(message.coreProudSkillLevel);
        /* repeated uint32 inherent_proud_skill_list = 14; */
        if (message.inherentProudSkillList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.inherentProudSkillList.length; i++)
                writer.uint32(message.inherentProudSkillList[i]);
            writer.join();
        }
        /* map<uint32, uint32> skill_level_map = 15; */
        for (let k of Object.keys(message.skillLevelMap))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillLevelMap[k as any]).join();
        /* AvatarExpeditionState expedition_state = 16; */
        if (message.expeditionState !== 0)
            writer.tag(16, WireType.Varint).int32(message.expeditionState);
        /* map<uint32, uint32> proud_skill_extra_level_map = 17; */
        for (let k of Object.keys(message.proudSkillExtraLevelMap))
            writer.tag(17, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.proudSkillExtraLevelMap[k as any]).join();
        /* bool is_focus = 18; */
        if (message.isFocus !== false)
            writer.tag(18, WireType.Varint).bool(message.isFocus);
        /* uint32 avatar_type = 19; */
        if (message.avatarType !== 0)
            writer.tag(19, WireType.Varint).uint32(message.avatarType);
        /* repeated uint32 team_resonance_list = 20; */
        if (message.teamResonanceList.length) {
            writer.tag(20, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.teamResonanceList.length; i++)
                writer.uint32(message.teamResonanceList[i]);
            writer.join();
        }
        /* uint32 wearing_flycloak_id = 21; */
        if (message.wearingFlycloakId !== 0)
            writer.tag(21, WireType.Varint).uint32(message.wearingFlycloakId);
        /* repeated AvatarEquipAffixInfo equip_affix_list = 22; */
        for (let i = 0; i < message.equipAffixList.length; i++)
            AvatarEquipAffixInfo.internalBinaryWrite(message.equipAffixList[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* uint32 born_time = 23; */
        if (message.bornTime !== 0)
            writer.tag(23, WireType.Varint).uint32(message.bornTime);
        /* repeated uint32 pending_promote_reward_list = 24; */
        if (message.pendingPromoteRewardList.length) {
            writer.tag(24, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.pendingPromoteRewardList.length; i++)
                writer.uint32(message.pendingPromoteRewardList[i]);
            writer.join();
        }
        /* uint32 costume_id = 25; */
        if (message.costumeId !== 0)
            writer.tag(25, WireType.Varint).uint32(message.costumeId);
        /* AvatarExcelInfo excel_info = 26; */
        if (message.excelInfo)
            AvatarExcelInfo.internalBinaryWrite(message.excelInfo, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* uint32 anim_hash = 27; */
        if (message.animHash !== 0)
            writer.tag(27, WireType.Varint).uint32(message.animHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarInfo
 */
export const AvatarInfo = new AvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarLifeStateChangeNotify$Type extends MessageType<AvatarLifeStateChangeNotify> {
    constructor() {
        super("AvatarLifeStateChangeNotify", [
            { no: 8, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "life_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "source_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "attack_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "die_type", kind: "enum", T: () => ["PlayerDieType", PlayerDieType, "PLAYER_DIE_TYPE_"] },
            { no: 7, name: "move_reliable_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff }
        ]);
    }
    create(value?: PartialMessage<AvatarLifeStateChangeNotify>): AvatarLifeStateChangeNotify {
        const message = { avatarGuid: 0n, lifeState: 0, sourceEntityId: 0, attackTag: "", dieType: 0, moveReliableSeq: 0, serverBuffList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarLifeStateChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarLifeStateChangeNotify): AvatarLifeStateChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 8:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 life_state */ 15:
                    message.lifeState = reader.uint32();
                    break;
                case /* uint32 source_entity_id */ 1:
                    message.sourceEntityId = reader.uint32();
                    break;
                case /* string attack_tag */ 10:
                    message.attackTag = reader.string();
                    break;
                case /* PlayerDieType die_type */ 11:
                    message.dieType = reader.int32();
                    break;
                case /* uint32 move_reliable_seq */ 7:
                    message.moveReliableSeq = reader.uint32();
                    break;
                case /* repeated ServerBuff server_buff_list */ 6:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarLifeStateChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 8; */
        if (message.avatarGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 life_state = 15; */
        if (message.lifeState !== 0)
            writer.tag(15, WireType.Varint).uint32(message.lifeState);
        /* uint32 source_entity_id = 1; */
        if (message.sourceEntityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sourceEntityId);
        /* string attack_tag = 10; */
        if (message.attackTag !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.attackTag);
        /* PlayerDieType die_type = 11; */
        if (message.dieType !== 0)
            writer.tag(11, WireType.Varint).int32(message.dieType);
        /* uint32 move_reliable_seq = 7; */
        if (message.moveReliableSeq !== 0)
            writer.tag(7, WireType.Varint).uint32(message.moveReliableSeq);
        /* repeated ServerBuff server_buff_list = 6; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarLifeStateChangeNotify
 */
export const AvatarLifeStateChangeNotify = new AvatarLifeStateChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarPromoteGetRewardReq$Type extends MessageType<AvatarPromoteGetRewardReq> {
    constructor() {
        super("AvatarPromoteGetRewardReq", [
            { no: 12, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarPromoteGetRewardReq>): AvatarPromoteGetRewardReq {
        const message = { avatarGuid: 0n, promoteLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarPromoteGetRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarPromoteGetRewardReq): AvatarPromoteGetRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 12:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 promote_level */ 8:
                    message.promoteLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarPromoteGetRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 12; */
        if (message.avatarGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 promote_level = 8; */
        if (message.promoteLevel !== 0)
            writer.tag(8, WireType.Varint).uint32(message.promoteLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarPromoteGetRewardReq
 */
export const AvatarPromoteGetRewardReq = new AvatarPromoteGetRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarPromoteGetRewardRsp$Type extends MessageType<AvatarPromoteGetRewardRsp> {
    constructor() {
        super("AvatarPromoteGetRewardRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarPromoteGetRewardRsp>): AvatarPromoteGetRewardRsp {
        const message = { retcode: 0, avatarGuid: 0n, promoteLevel: 0, rewardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarPromoteGetRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarPromoteGetRewardRsp): AvatarPromoteGetRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 2:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 promote_level */ 14:
                    message.promoteLevel = reader.uint32();
                    break;
                case /* uint32 reward_id */ 1:
                    message.rewardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarPromoteGetRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 2; */
        if (message.avatarGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 promote_level = 14; */
        if (message.promoteLevel !== 0)
            writer.tag(14, WireType.Varint).uint32(message.promoteLevel);
        /* uint32 reward_id = 1; */
        if (message.rewardId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.rewardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarPromoteGetRewardRsp
 */
export const AvatarPromoteGetRewardRsp = new AvatarPromoteGetRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarPromoteReq$Type extends MessageType<AvatarPromoteReq> {
    constructor() {
        super("AvatarPromoteReq", [
            { no: 9, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarPromoteReq>): AvatarPromoteReq {
        const message = { guid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarPromoteReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarPromoteReq): AvatarPromoteReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 guid */ 9:
                    message.guid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarPromoteReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 guid = 9; */
        if (message.guid !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.guid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarPromoteReq
 */
export const AvatarPromoteReq = new AvatarPromoteReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarPromoteRsp$Type extends MessageType<AvatarPromoteRsp> {
    constructor() {
        super("AvatarPromoteRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarPromoteRsp>): AvatarPromoteRsp {
        const message = { retcode: 0, guid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarPromoteRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarPromoteRsp): AvatarPromoteRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 guid */ 7:
                    message.guid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarPromoteRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint64 guid = 7; */
        if (message.guid !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.guid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarPromoteRsp
 */
export const AvatarPromoteRsp = new AvatarPromoteRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarPropNotify$Type extends MessageType<AvatarPropNotify> {
    constructor() {
        super("AvatarPropNotify", [
            { no: 4, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<AvatarPropNotify>): AvatarPropNotify {
        const message = { avatarGuid: 0n, propMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarPropNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarPropNotify): AvatarPropNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 4:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, int64> prop_map */ 1:
                    this.binaryReadMap1(message.propMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AvatarPropNotify["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarPropNotify["propMap"] | undefined, val: AvatarPropNotify["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarPropNotify.prop_map");
            }
        }
        map[key ?? 0] = val ?? 0n;
    }
    internalBinaryWrite(message: AvatarPropNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 4; */
        if (message.avatarGuid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.avatarGuid);
        /* map<uint32, int64> prop_map = 1; */
        for (let k of Object.keys(message.propMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).int64(message.propMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarPropNotify
 */
export const AvatarPropNotify = new AvatarPropNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillChangeNotify$Type extends MessageType<AvatarSkillChangeNotify> {
    constructor() {
        super("AvatarSkillChangeNotify", [
            { no: 4, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avatar_skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillChangeNotify>): AvatarSkillChangeNotify {
        const message = { avatarGuid: 0n, entityId: 0, skillDepotId: 0, avatarSkillId: 0, oldLevel: 0, curLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillChangeNotify): AvatarSkillChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 4:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 skill_depot_id */ 5:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* uint32 avatar_skill_id */ 2:
                    message.avatarSkillId = reader.uint32();
                    break;
                case /* uint32 old_level */ 10:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 cur_level */ 7:
                    message.curLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarSkillChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 4; */
        if (message.avatarGuid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 entity_id = 15; */
        if (message.entityId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* uint32 skill_depot_id = 5; */
        if (message.skillDepotId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.skillDepotId);
        /* uint32 avatar_skill_id = 2; */
        if (message.avatarSkillId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.avatarSkillId);
        /* uint32 old_level = 10; */
        if (message.oldLevel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.oldLevel);
        /* uint32 cur_level = 7; */
        if (message.curLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.curLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillChangeNotify
 */
export const AvatarSkillChangeNotify = new AvatarSkillChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillDepotChangeNotify$Type extends MessageType<AvatarSkillDepotChangeNotify> {
    constructor() {
        super("AvatarSkillDepotChangeNotify", [
            { no: 2, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "talent_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "proud_skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "core_proud_skill_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "skill_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 11, name: "proud_skill_extra_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillDepotChangeNotify>): AvatarSkillDepotChangeNotify {
        const message = { avatarGuid: 0n, entityId: 0, skillDepotId: 0, talentIdList: [], proudSkillList: [], coreProudSkillLevel: 0, skillLevelMap: {}, proudSkillExtraLevelMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillDepotChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillDepotChangeNotify): AvatarSkillDepotChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 2:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 skill_depot_id */ 9:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* repeated uint32 talent_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.talentIdList.push(reader.uint32());
                    else
                        message.talentIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 proud_skill_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.proudSkillList.push(reader.uint32());
                    else
                        message.proudSkillList.push(reader.uint32());
                    break;
                case /* uint32 core_proud_skill_level */ 4:
                    message.coreProudSkillLevel = reader.uint32();
                    break;
                case /* map<uint32, uint32> skill_level_map */ 10:
                    this.binaryReadMap10(message.skillLevelMap, reader, options);
                    break;
                case /* map<uint32, uint32> proud_skill_extra_level_map */ 11:
                    this.binaryReadMap11(message.proudSkillExtraLevelMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: AvatarSkillDepotChangeNotify["skillLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarSkillDepotChangeNotify["skillLevelMap"] | undefined, val: AvatarSkillDepotChangeNotify["skillLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarSkillDepotChangeNotify.skill_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap11(map: AvatarSkillDepotChangeNotify["proudSkillExtraLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarSkillDepotChangeNotify["proudSkillExtraLevelMap"] | undefined, val: AvatarSkillDepotChangeNotify["proudSkillExtraLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarSkillDepotChangeNotify.proud_skill_extra_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AvatarSkillDepotChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 2; */
        if (message.avatarGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* uint32 skill_depot_id = 9; */
        if (message.skillDepotId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.skillDepotId);
        /* repeated uint32 talent_id_list = 1; */
        if (message.talentIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.talentIdList.length; i++)
                writer.uint32(message.talentIdList[i]);
            writer.join();
        }
        /* repeated uint32 proud_skill_list = 5; */
        if (message.proudSkillList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.proudSkillList.length; i++)
                writer.uint32(message.proudSkillList[i]);
            writer.join();
        }
        /* uint32 core_proud_skill_level = 4; */
        if (message.coreProudSkillLevel !== 0)
            writer.tag(4, WireType.Varint).uint32(message.coreProudSkillLevel);
        /* map<uint32, uint32> skill_level_map = 10; */
        for (let k of Object.keys(message.skillLevelMap))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillLevelMap[k as any]).join();
        /* map<uint32, uint32> proud_skill_extra_level_map = 11; */
        for (let k of Object.keys(message.proudSkillExtraLevelMap))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.proudSkillExtraLevelMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillDepotChangeNotify
 */
export const AvatarSkillDepotChangeNotify = new AvatarSkillDepotChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillInfo$Type extends MessageType<AvatarSkillInfo> {
    constructor() {
        super("AvatarSkillInfo", [
            { no: 1, name: "pass_cd_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "full_cd_time_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "max_charge_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillInfo>): AvatarSkillInfo {
        const message = { passCdTime: 0, fullCdTimeList: [], maxChargeCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillInfo): AvatarSkillInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pass_cd_time */ 1:
                    message.passCdTime = reader.uint32();
                    break;
                case /* repeated uint32 full_cd_time_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fullCdTimeList.push(reader.uint32());
                    else
                        message.fullCdTimeList.push(reader.uint32());
                    break;
                case /* uint32 max_charge_count */ 3:
                    message.maxChargeCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarSkillInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pass_cd_time = 1; */
        if (message.passCdTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.passCdTime);
        /* repeated uint32 full_cd_time_list = 2; */
        if (message.fullCdTimeList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fullCdTimeList.length; i++)
                writer.uint32(message.fullCdTimeList[i]);
            writer.join();
        }
        /* uint32 max_charge_count = 3; */
        if (message.maxChargeCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxChargeCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillInfo
 */
export const AvatarSkillInfo = new AvatarSkillInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillInfoNotify$Type extends MessageType<AvatarSkillInfoNotify> {
    constructor() {
        super("AvatarSkillInfoNotify", [
            { no: 4, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "skill_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AvatarSkillInfo } }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillInfoNotify>): AvatarSkillInfoNotify {
        const message = { guid: 0n, skillMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillInfoNotify): AvatarSkillInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 guid */ 4:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, AvatarSkillInfo> skill_map */ 2:
                    this.binaryReadMap2(message.skillMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: AvatarSkillInfoNotify["skillMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarSkillInfoNotify["skillMap"] | undefined, val: AvatarSkillInfoNotify["skillMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AvatarSkillInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarSkillInfoNotify.skill_map");
            }
        }
        map[key ?? 0] = val ?? AvatarSkillInfo.create();
    }
    internalBinaryWrite(message: AvatarSkillInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 guid = 4; */
        if (message.guid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.guid);
        /* map<uint32, AvatarSkillInfo> skill_map = 2; */
        for (let k of Object.keys(message.skillMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarSkillInfo.internalBinaryWrite(message.skillMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillInfoNotify
 */
export const AvatarSkillInfoNotify = new AvatarSkillInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillMaxChargeCountNotify$Type extends MessageType<AvatarSkillMaxChargeCountNotify> {
    constructor() {
        super("AvatarSkillMaxChargeCountNotify", [
            { no: 15, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "max_charge_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillMaxChargeCountNotify>): AvatarSkillMaxChargeCountNotify {
        const message = { avatarGuid: 0n, skillId: 0, maxChargeCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillMaxChargeCountNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillMaxChargeCountNotify): AvatarSkillMaxChargeCountNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 15:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 skill_id */ 2:
                    message.skillId = reader.uint32();
                    break;
                case /* uint32 max_charge_count */ 1:
                    message.maxChargeCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarSkillMaxChargeCountNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 15; */
        if (message.avatarGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 skill_id = 2; */
        if (message.skillId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.skillId);
        /* uint32 max_charge_count = 1; */
        if (message.maxChargeCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxChargeCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillMaxChargeCountNotify
 */
export const AvatarSkillMaxChargeCountNotify = new AvatarSkillMaxChargeCountNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillUpgradeReq$Type extends MessageType<AvatarSkillUpgradeReq> {
    constructor() {
        super("AvatarSkillUpgradeReq", [
            { no: 1, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "avatar_skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillUpgradeReq>): AvatarSkillUpgradeReq {
        const message = { avatarGuid: 0n, avatarSkillId: 0, oldLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillUpgradeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillUpgradeReq): AvatarSkillUpgradeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 1:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 avatar_skill_id */ 5:
                    message.avatarSkillId = reader.uint32();
                    break;
                case /* uint32 old_level */ 10:
                    message.oldLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarSkillUpgradeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 1; */
        if (message.avatarGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 avatar_skill_id = 5; */
        if (message.avatarSkillId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.avatarSkillId);
        /* uint32 old_level = 10; */
        if (message.oldLevel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.oldLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillUpgradeReq
 */
export const AvatarSkillUpgradeReq = new AvatarSkillUpgradeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarSkillUpgradeRsp$Type extends MessageType<AvatarSkillUpgradeRsp> {
    constructor() {
        super("AvatarSkillUpgradeRsp", [
            { no: 3, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "avatar_skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarSkillUpgradeRsp>): AvatarSkillUpgradeRsp {
        const message = { retcode: 0, avatarGuid: 0n, avatarSkillId: 0, oldLevel: 0, curLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarSkillUpgradeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarSkillUpgradeRsp): AvatarSkillUpgradeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 10:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 avatar_skill_id */ 2:
                    message.avatarSkillId = reader.uint32();
                    break;
                case /* uint32 old_level */ 5:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 cur_level */ 7:
                    message.curLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarSkillUpgradeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 3; */
        if (message.retcode !== 0)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 10; */
        if (message.avatarGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 avatar_skill_id = 2; */
        if (message.avatarSkillId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.avatarSkillId);
        /* uint32 old_level = 5; */
        if (message.oldLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oldLevel);
        /* uint32 cur_level = 7; */
        if (message.curLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.curLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarSkillUpgradeRsp
 */
export const AvatarSkillUpgradeRsp = new AvatarSkillUpgradeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarTeam$Type extends MessageType<AvatarTeam> {
    constructor() {
        super("AvatarTeam", [
            { no: 9, name: "avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "team_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarTeam>): AvatarTeam {
        const message = { avatarGuidList: [], teamName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarTeam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarTeam): AvatarTeam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 avatar_guid_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* string team_name */ 13:
                    message.teamName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarTeam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 avatar_guid_list = 9; */
        if (message.avatarGuidList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuidList.length; i++)
                writer.uint64(message.avatarGuidList[i]);
            writer.join();
        }
        /* string team_name = 13; */
        if (message.teamName !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.teamName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarTeam
 */
export const AvatarTeam = new AvatarTeam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarTeamResonanceInfo$Type extends MessageType<AvatarTeamResonanceInfo> {
    constructor() {
        super("AvatarTeamResonanceInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "add_team_resonance_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "del_team_resonance_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarTeamResonanceInfo>): AvatarTeamResonanceInfo {
        const message = { entityId: 0, avatarGuid: 0n, addTeamResonanceIdList: [], delTeamResonanceIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarTeamResonanceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarTeamResonanceInfo): AvatarTeamResonanceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 2:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated uint32 add_team_resonance_id_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.addTeamResonanceIdList.push(reader.uint32());
                    else
                        message.addTeamResonanceIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 del_team_resonance_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delTeamResonanceIdList.push(reader.uint32());
                    else
                        message.delTeamResonanceIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarTeamResonanceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* uint64 avatar_guid = 2; */
        if (message.avatarGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.avatarGuid);
        /* repeated uint32 add_team_resonance_id_list = 3; */
        if (message.addTeamResonanceIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.addTeamResonanceIdList.length; i++)
                writer.uint32(message.addTeamResonanceIdList[i]);
            writer.join();
        }
        /* repeated uint32 del_team_resonance_id_list = 4; */
        if (message.delTeamResonanceIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delTeamResonanceIdList.length; i++)
                writer.uint32(message.delTeamResonanceIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarTeamResonanceInfo
 */
export const AvatarTeamResonanceInfo = new AvatarTeamResonanceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarTeamUpdateNotify$Type extends MessageType<AvatarTeamUpdateNotify> {
    constructor() {
        super("AvatarTeamUpdateNotify", [
            { no: 6, name: "avatar_team_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AvatarTeam } },
            { no: 9, name: "temp_avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarTeamUpdateNotify>): AvatarTeamUpdateNotify {
        const message = { avatarTeamMap: {}, tempAvatarGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarTeamUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarTeamUpdateNotify): AvatarTeamUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, AvatarTeam> avatar_team_map */ 6:
                    this.binaryReadMap6(message.avatarTeamMap, reader, options);
                    break;
                case /* repeated uint64 temp_avatar_guid_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tempAvatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.tempAvatarGuidList.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: AvatarTeamUpdateNotify["avatarTeamMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarTeamUpdateNotify["avatarTeamMap"] | undefined, val: AvatarTeamUpdateNotify["avatarTeamMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AvatarTeam.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarTeamUpdateNotify.avatar_team_map");
            }
        }
        map[key ?? 0] = val ?? AvatarTeam.create();
    }
    internalBinaryWrite(message: AvatarTeamUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, AvatarTeam> avatar_team_map = 6; */
        for (let k of Object.keys(message.avatarTeamMap)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AvatarTeam.internalBinaryWrite(message.avatarTeamMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated uint64 temp_avatar_guid_list = 9; */
        if (message.tempAvatarGuidList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tempAvatarGuidList.length; i++)
                writer.uint64(message.tempAvatarGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarTeamUpdateNotify
 */
export const AvatarTeamUpdateNotify = new AvatarTeamUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarUnlockTalentNotify$Type extends MessageType<AvatarUnlockTalentNotify> {
    constructor() {
        super("AvatarUnlockTalentNotify", [
            { no: 1, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "talent_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarUnlockTalentNotify>): AvatarUnlockTalentNotify {
        const message = { avatarGuid: 0n, entityId: 0, talentId: 0, skillDepotId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarUnlockTalentNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarUnlockTalentNotify): AvatarUnlockTalentNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 1:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 talent_id */ 13:
                    message.talentId = reader.uint32();
                    break;
                case /* uint32 skill_depot_id */ 14:
                    message.skillDepotId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarUnlockTalentNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 1; */
        if (message.avatarGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 entity_id = 15; */
        if (message.entityId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        /* uint32 talent_id = 13; */
        if (message.talentId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.talentId);
        /* uint32 skill_depot_id = 14; */
        if (message.skillDepotId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.skillDepotId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarUnlockTalentNotify
 */
export const AvatarUnlockTalentNotify = new AvatarUnlockTalentNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarUpgradeReq$Type extends MessageType<AvatarUpgradeReq> {
    constructor() {
        super("AvatarUpgradeReq", [
            { no: 9, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarUpgradeReq>): AvatarUpgradeReq {
        const message = { itemId: 0, count: 0, avatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarUpgradeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarUpgradeReq): AvatarUpgradeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 9:
                    message.itemId = reader.uint32();
                    break;
                case /* uint32 count */ 12:
                    message.count = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 14:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarUpgradeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 9; */
        if (message.itemId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.itemId);
        /* uint32 count = 12; */
        if (message.count !== 0)
            writer.tag(12, WireType.Varint).uint32(message.count);
        /* uint64 avatar_guid = 14; */
        if (message.avatarGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.avatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarUpgradeReq
 */
export const AvatarUpgradeReq = new AvatarUpgradeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarUpgradeRsp$Type extends MessageType<AvatarUpgradeRsp> {
    constructor() {
        super("AvatarUpgradeRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "old_fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 4, name: "cur_fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<AvatarUpgradeRsp>): AvatarUpgradeRsp {
        const message = { retcode: 0, avatarGuid: 0n, oldLevel: 0, curLevel: 0, oldFightPropMap: {}, curFightPropMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarUpgradeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarUpgradeRsp): AvatarUpgradeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 15:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 old_level */ 5:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 cur_level */ 7:
                    message.curLevel = reader.uint32();
                    break;
                case /* map<uint32, float> old_fight_prop_map */ 2:
                    this.binaryReadMap2(message.oldFightPropMap, reader, options);
                    break;
                case /* map<uint32, float> cur_fight_prop_map */ 4:
                    this.binaryReadMap4(message.curFightPropMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: AvatarUpgradeRsp["oldFightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarUpgradeRsp["oldFightPropMap"] | undefined, val: AvatarUpgradeRsp["oldFightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarUpgradeRsp.old_fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap4(map: AvatarUpgradeRsp["curFightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AvatarUpgradeRsp["curFightPropMap"] | undefined, val: AvatarUpgradeRsp["curFightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field AvatarUpgradeRsp.cur_fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AvatarUpgradeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 15; */
        if (message.avatarGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 old_level = 5; */
        if (message.oldLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oldLevel);
        /* uint32 cur_level = 7; */
        if (message.curLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.curLevel);
        /* map<uint32, float> old_fight_prop_map = 2; */
        for (let k of Object.keys(message.oldFightPropMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.oldFightPropMap[k as any]).join();
        /* map<uint32, float> cur_fight_prop_map = 4; */
        for (let k of Object.keys(message.curFightPropMap))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.curFightPropMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarUpgradeRsp
 */
export const AvatarUpgradeRsp = new AvatarUpgradeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarWearFlycloakReq$Type extends MessageType<AvatarWearFlycloakReq> {
    constructor() {
        super("AvatarWearFlycloakReq", [
            { no: 11, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarWearFlycloakReq>): AvatarWearFlycloakReq {
        const message = { avatarGuid: 0n, flycloakId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarWearFlycloakReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarWearFlycloakReq): AvatarWearFlycloakReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 11:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 flycloak_id */ 9:
                    message.flycloakId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarWearFlycloakReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 11; */
        if (message.avatarGuid !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 flycloak_id = 9; */
        if (message.flycloakId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.flycloakId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarWearFlycloakReq
 */
export const AvatarWearFlycloakReq = new AvatarWearFlycloakReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AvatarWearFlycloakRsp$Type extends MessageType<AvatarWearFlycloakRsp> {
    constructor() {
        super("AvatarWearFlycloakRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AvatarWearFlycloakRsp>): AvatarWearFlycloakRsp {
        const message = { retcode: 0, avatarGuid: 0n, flycloakId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AvatarWearFlycloakRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AvatarWearFlycloakRsp): AvatarWearFlycloakRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 8:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 flycloak_id */ 2:
                    message.flycloakId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AvatarWearFlycloakRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 8; */
        if (message.avatarGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 flycloak_id = 2; */
        if (message.flycloakId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.flycloakId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AvatarWearFlycloakRsp
 */
export const AvatarWearFlycloakRsp = new AvatarWearFlycloakRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassAllDataNotify$Type extends MessageType<BattlePassAllDataNotify> {
    constructor() {
        super("BattlePassAllDataNotify", [
            { no: 11, name: "have_cur_schedule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "cur_schedule", kind: "message", T: () => BattlePassSchedule },
            { no: 1, name: "mission_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BattlePassMission }
        ]);
    }
    create(value?: PartialMessage<BattlePassAllDataNotify>): BattlePassAllDataNotify {
        const message = { haveCurSchedule: false, missionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassAllDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassAllDataNotify): BattlePassAllDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool have_cur_schedule */ 11:
                    message.haveCurSchedule = reader.bool();
                    break;
                case /* BattlePassSchedule cur_schedule */ 10:
                    message.curSchedule = BattlePassSchedule.internalBinaryRead(reader, reader.uint32(), options, message.curSchedule);
                    break;
                case /* repeated BattlePassMission mission_list */ 1:
                    message.missionList.push(BattlePassMission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassAllDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool have_cur_schedule = 11; */
        if (message.haveCurSchedule !== false)
            writer.tag(11, WireType.Varint).bool(message.haveCurSchedule);
        /* BattlePassSchedule cur_schedule = 10; */
        if (message.curSchedule)
            BattlePassSchedule.internalBinaryWrite(message.curSchedule, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated BattlePassMission mission_list = 1; */
        for (let i = 0; i < message.missionList.length; i++)
            BattlePassMission.internalBinaryWrite(message.missionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassAllDataNotify
 */
export const BattlePassAllDataNotify = new BattlePassAllDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassBuySuccNotify$Type extends MessageType<BattlePassBuySuccNotify> {
    constructor() {
        super("BattlePassBuySuccNotify", [
            { no: 7, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "product_play_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "add_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassBuySuccNotify>): BattlePassBuySuccNotify {
        const message = { scheduleId: 0, productPlayType: 0, itemList: [], addPoint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassBuySuccNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassBuySuccNotify): BattlePassBuySuccNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 schedule_id */ 7:
                    message.scheduleId = reader.uint32();
                    break;
                case /* uint32 product_play_type */ 9:
                    message.productPlayType = reader.uint32();
                    break;
                case /* repeated ItemParam item_list */ 6:
                    message.itemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 add_point */ 2:
                    message.addPoint = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassBuySuccNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 schedule_id = 7; */
        if (message.scheduleId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.scheduleId);
        /* uint32 product_play_type = 9; */
        if (message.productPlayType !== 0)
            writer.tag(9, WireType.Varint).uint32(message.productPlayType);
        /* repeated ItemParam item_list = 6; */
        for (let i = 0; i < message.itemList.length; i++)
            ItemParam.internalBinaryWrite(message.itemList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 add_point = 2; */
        if (message.addPoint !== 0)
            writer.tag(2, WireType.Varint).uint32(message.addPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassBuySuccNotify
 */
export const BattlePassBuySuccNotify = new BattlePassBuySuccNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassCurScheduleUpdateNotify$Type extends MessageType<BattlePassCurScheduleUpdateNotify> {
    constructor() {
        super("BattlePassCurScheduleUpdateNotify", [
            { no: 9, name: "have_cur_schedule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "cur_schedule", kind: "message", T: () => BattlePassSchedule }
        ]);
    }
    create(value?: PartialMessage<BattlePassCurScheduleUpdateNotify>): BattlePassCurScheduleUpdateNotify {
        const message = { haveCurSchedule: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassCurScheduleUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassCurScheduleUpdateNotify): BattlePassCurScheduleUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool have_cur_schedule */ 9:
                    message.haveCurSchedule = reader.bool();
                    break;
                case /* BattlePassSchedule cur_schedule */ 15:
                    message.curSchedule = BattlePassSchedule.internalBinaryRead(reader, reader.uint32(), options, message.curSchedule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassCurScheduleUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool have_cur_schedule = 9; */
        if (message.haveCurSchedule !== false)
            writer.tag(9, WireType.Varint).bool(message.haveCurSchedule);
        /* BattlePassSchedule cur_schedule = 15; */
        if (message.curSchedule)
            BattlePassSchedule.internalBinaryWrite(message.curSchedule, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassCurScheduleUpdateNotify
 */
export const BattlePassCurScheduleUpdateNotify = new BattlePassCurScheduleUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassCycle$Type extends MessageType<BattlePassCycle> {
    constructor() {
        super("BattlePassCycle", [
            { no: 8, name: "cycle_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassCycle>): BattlePassCycle {
        const message = { cycleIdx: 0, beginTime: 0, endTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassCycle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassCycle): BattlePassCycle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cycle_idx */ 8:
                    message.cycleIdx = reader.uint32();
                    break;
                case /* uint32 begin_time */ 14:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 9:
                    message.endTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassCycle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cycle_idx = 8; */
        if (message.cycleIdx !== 0)
            writer.tag(8, WireType.Varint).uint32(message.cycleIdx);
        /* uint32 begin_time = 14; */
        if (message.beginTime !== 0)
            writer.tag(14, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 9; */
        if (message.endTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassCycle
 */
export const BattlePassCycle = new BattlePassCycle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassMission$Type extends MessageType<BattlePassMission> {
    constructor() {
        super("BattlePassMission", [
            { no: 9, name: "mission_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cur_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "total_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "reward_battle_pass_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "mission_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "mission_status", kind: "enum", T: () => ["BattlePassMission.MissionStatus", BattlePassMission_MissionStatus, "MISSION_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<BattlePassMission>): BattlePassMission {
        const message = { missionId: 0, curProgress: 0, totalProgress: 0, rewardBattlePassPoint: 0, missionType: 0, missionStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassMission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassMission): BattlePassMission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 mission_id */ 9:
                    message.missionId = reader.uint32();
                    break;
                case /* uint32 cur_progress */ 2:
                    message.curProgress = reader.uint32();
                    break;
                case /* uint32 total_progress */ 1:
                    message.totalProgress = reader.uint32();
                    break;
                case /* uint32 reward_battle_pass_point */ 15:
                    message.rewardBattlePassPoint = reader.uint32();
                    break;
                case /* uint32 mission_type */ 7:
                    message.missionType = reader.uint32();
                    break;
                case /* BattlePassMission.MissionStatus mission_status */ 13:
                    message.missionStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassMission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 mission_id = 9; */
        if (message.missionId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.missionId);
        /* uint32 cur_progress = 2; */
        if (message.curProgress !== 0)
            writer.tag(2, WireType.Varint).uint32(message.curProgress);
        /* uint32 total_progress = 1; */
        if (message.totalProgress !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalProgress);
        /* uint32 reward_battle_pass_point = 15; */
        if (message.rewardBattlePassPoint !== 0)
            writer.tag(15, WireType.Varint).uint32(message.rewardBattlePassPoint);
        /* uint32 mission_type = 7; */
        if (message.missionType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.missionType);
        /* BattlePassMission.MissionStatus mission_status = 13; */
        if (message.missionStatus !== 0)
            writer.tag(13, WireType.Varint).int32(message.missionStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassMission
 */
export const BattlePassMission = new BattlePassMission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassMissionDelNotify$Type extends MessageType<BattlePassMissionDelNotify> {
    constructor() {
        super("BattlePassMissionDelNotify", [
            { no: 4, name: "del_mission_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassMissionDelNotify>): BattlePassMissionDelNotify {
        const message = { delMissionIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassMissionDelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassMissionDelNotify): BattlePassMissionDelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 del_mission_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delMissionIdList.push(reader.uint32());
                    else
                        message.delMissionIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassMissionDelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 del_mission_id_list = 4; */
        if (message.delMissionIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delMissionIdList.length; i++)
                writer.uint32(message.delMissionIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassMissionDelNotify
 */
export const BattlePassMissionDelNotify = new BattlePassMissionDelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassMissionUpdateNotify$Type extends MessageType<BattlePassMissionUpdateNotify> {
    constructor() {
        super("BattlePassMissionUpdateNotify", [
            { no: 6, name: "mission_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BattlePassMission }
        ]);
    }
    create(value?: PartialMessage<BattlePassMissionUpdateNotify>): BattlePassMissionUpdateNotify {
        const message = { missionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassMissionUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassMissionUpdateNotify): BattlePassMissionUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BattlePassMission mission_list */ 6:
                    message.missionList.push(BattlePassMission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassMissionUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BattlePassMission mission_list = 6; */
        for (let i = 0; i < message.missionList.length; i++)
            BattlePassMission.internalBinaryWrite(message.missionList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassMissionUpdateNotify
 */
export const BattlePassMissionUpdateNotify = new BattlePassMissionUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassProduct$Type extends MessageType<BattlePassProduct> {
    constructor() {
        super("BattlePassProduct", [
            { no: 8, name: "normal_product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "extra_product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "upgrade_product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassProduct>): BattlePassProduct {
        const message = { normalProductId: "", extraProductId: "", upgradeProductId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassProduct): BattlePassProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string normal_product_id */ 8:
                    message.normalProductId = reader.string();
                    break;
                case /* string extra_product_id */ 4:
                    message.extraProductId = reader.string();
                    break;
                case /* string upgrade_product_id */ 14:
                    message.upgradeProductId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string normal_product_id = 8; */
        if (message.normalProductId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.normalProductId);
        /* string extra_product_id = 4; */
        if (message.extraProductId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.extraProductId);
        /* string upgrade_product_id = 14; */
        if (message.upgradeProductId !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.upgradeProductId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassProduct
 */
export const BattlePassProduct = new BattlePassProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassRewardTag$Type extends MessageType<BattlePassRewardTag> {
    constructor() {
        super("BattlePassRewardTag", [
            { no: 7, name: "unlock_status", kind: "enum", T: () => ["BattlePassUnlockStatus", BattlePassUnlockStatus, "BATTLE_PASS_UNLOCK_STATUS_"] },
            { no: 1, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassRewardTag>): BattlePassRewardTag {
        const message = { unlockStatus: 0, level: 0, rewardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassRewardTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassRewardTag): BattlePassRewardTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BattlePassUnlockStatus unlock_status */ 7:
                    message.unlockStatus = reader.int32();
                    break;
                case /* uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                case /* uint32 reward_id */ 15:
                    message.rewardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassRewardTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BattlePassUnlockStatus unlock_status = 7; */
        if (message.unlockStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.unlockStatus);
        /* uint32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).uint32(message.level);
        /* uint32 reward_id = 15; */
        if (message.rewardId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.rewardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassRewardTag
 */
export const BattlePassRewardTag = new BattlePassRewardTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassRewardTakeOption$Type extends MessageType<BattlePassRewardTakeOption> {
    constructor() {
        super("BattlePassRewardTakeOption", [
            { no: 8, name: "tag", kind: "message", T: () => BattlePassRewardTag },
            { no: 5, name: "option_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassRewardTakeOption>): BattlePassRewardTakeOption {
        const message = { optionIdx: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassRewardTakeOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassRewardTakeOption): BattlePassRewardTakeOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BattlePassRewardTag tag */ 8:
                    message.tag = BattlePassRewardTag.internalBinaryRead(reader, reader.uint32(), options, message.tag);
                    break;
                case /* uint32 option_idx */ 5:
                    message.optionIdx = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassRewardTakeOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BattlePassRewardTag tag = 8; */
        if (message.tag)
            BattlePassRewardTag.internalBinaryWrite(message.tag, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 option_idx = 5; */
        if (message.optionIdx !== 0)
            writer.tag(5, WireType.Varint).uint32(message.optionIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassRewardTakeOption
 */
export const BattlePassRewardTakeOption = new BattlePassRewardTakeOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BattlePassSchedule$Type extends MessageType<BattlePassSchedule> {
    constructor() {
        super("BattlePassSchedule", [
            { no: 12, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "unlock_status", kind: "enum", T: () => ["BattlePassUnlockStatus", BattlePassUnlockStatus, "BATTLE_PASS_UNLOCK_STATUS_"] },
            { no: 4, name: "reward_taken_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BattlePassRewardTag },
            { no: 9, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "cur_cycle", kind: "message", T: () => BattlePassCycle },
            { no: 8, name: "is_extra_paid_reward_taken", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "product_info", kind: "message", T: () => BattlePassProduct },
            { no: 11, name: "is_viewed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cur_cycle_points", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "JPFMGBEBBBJ", kind: "scalar", jsonName: "JPFMGBEBBBJ", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BattlePassSchedule>): BattlePassSchedule {
        const message = { scheduleId: 0, level: 0, point: 0, unlockStatus: 0, rewardTakenList: [], beginTime: 0, endTime: 0, isExtraPaidRewardTaken: false, isViewed: false, curCyclePoints: 0, jPFMGBEBBBJ: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BattlePassSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BattlePassSchedule): BattlePassSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 schedule_id */ 12:
                    message.scheduleId = reader.uint32();
                    break;
                case /* uint32 level */ 10:
                    message.level = reader.uint32();
                    break;
                case /* uint32 point */ 7:
                    message.point = reader.uint32();
                    break;
                case /* BattlePassUnlockStatus unlock_status */ 5:
                    message.unlockStatus = reader.int32();
                    break;
                case /* repeated BattlePassRewardTag reward_taken_list */ 4:
                    message.rewardTakenList.push(BattlePassRewardTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 begin_time */ 9:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 1:
                    message.endTime = reader.uint32();
                    break;
                case /* BattlePassCycle cur_cycle */ 14:
                    message.curCycle = BattlePassCycle.internalBinaryRead(reader, reader.uint32(), options, message.curCycle);
                    break;
                case /* bool is_extra_paid_reward_taken */ 8:
                    message.isExtraPaidRewardTaken = reader.bool();
                    break;
                case /* BattlePassProduct product_info */ 13:
                    message.productInfo = BattlePassProduct.internalBinaryRead(reader, reader.uint32(), options, message.productInfo);
                    break;
                case /* bool is_viewed */ 11:
                    message.isViewed = reader.bool();
                    break;
                case /* uint32 cur_cycle_points */ 3:
                    message.curCyclePoints = reader.uint32();
                    break;
                case /* uint32 JPFMGBEBBBJ = 6 [json_name = "JPFMGBEBBBJ"];*/ 6:
                    message.jPFMGBEBBBJ = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BattlePassSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 schedule_id = 12; */
        if (message.scheduleId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.scheduleId);
        /* uint32 level = 10; */
        if (message.level !== 0)
            writer.tag(10, WireType.Varint).uint32(message.level);
        /* uint32 point = 7; */
        if (message.point !== 0)
            writer.tag(7, WireType.Varint).uint32(message.point);
        /* BattlePassUnlockStatus unlock_status = 5; */
        if (message.unlockStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.unlockStatus);
        /* repeated BattlePassRewardTag reward_taken_list = 4; */
        for (let i = 0; i < message.rewardTakenList.length; i++)
            BattlePassRewardTag.internalBinaryWrite(message.rewardTakenList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 begin_time = 9; */
        if (message.beginTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 1; */
        if (message.endTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.endTime);
        /* BattlePassCycle cur_cycle = 14; */
        if (message.curCycle)
            BattlePassCycle.internalBinaryWrite(message.curCycle, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* bool is_extra_paid_reward_taken = 8; */
        if (message.isExtraPaidRewardTaken !== false)
            writer.tag(8, WireType.Varint).bool(message.isExtraPaidRewardTaken);
        /* BattlePassProduct product_info = 13; */
        if (message.productInfo)
            BattlePassProduct.internalBinaryWrite(message.productInfo, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool is_viewed = 11; */
        if (message.isViewed !== false)
            writer.tag(11, WireType.Varint).bool(message.isViewed);
        /* uint32 cur_cycle_points = 3; */
        if (message.curCyclePoints !== 0)
            writer.tag(3, WireType.Varint).uint32(message.curCyclePoints);
        /* uint32 JPFMGBEBBBJ = 6 [json_name = "JPFMGBEBBBJ"]; */
        if (message.jPFMGBEBBBJ !== 0)
            writer.tag(6, WireType.Varint).uint32(message.jPFMGBEBBBJ);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BattlePassSchedule
 */
export const BattlePassSchedule = new BattlePassSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Birthday$Type extends MessageType<Birthday> {
    constructor() {
        super("Birthday", [
            { no: 1, name: "month", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "day", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Birthday>): Birthday {
        const message = { month: 0, day: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Birthday>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Birthday): Birthday {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 month */ 1:
                    message.month = reader.uint32();
                    break;
                case /* uint32 day */ 2:
                    message.day = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Birthday, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 month = 1; */
        if (message.month !== 0)
            writer.tag(1, WireType.Varint).uint32(message.month);
        /* uint32 day = 2; */
        if (message.day !== 0)
            writer.tag(2, WireType.Varint).uint32(message.day);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Birthday
 */
export const Birthday = new Birthday$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockInfo$Type extends MessageType<BlockInfo> {
    constructor() {
        super("BlockInfo", [
            { no: 1, name: "block_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "bin_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "is_dirty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BlockInfo>): BlockInfo {
        const message = { blockId: 0, dataVersion: 0, binData: new Uint8Array(0), isDirty: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockInfo): BlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 block_id */ 1:
                    message.blockId = reader.uint32();
                    break;
                case /* uint32 data_version */ 2:
                    message.dataVersion = reader.uint32();
                    break;
                case /* bytes bin_data */ 3:
                    message.binData = reader.bytes();
                    break;
                case /* bool is_dirty */ 4:
                    message.isDirty = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 block_id = 1; */
        if (message.blockId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.blockId);
        /* uint32 data_version = 2; */
        if (message.dataVersion !== 0)
            writer.tag(2, WireType.Varint).uint32(message.dataVersion);
        /* bytes bin_data = 3; */
        if (message.binData.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.binData);
        /* bool is_dirty = 4; */
        if (message.isDirty !== false)
            writer.tag(4, WireType.Varint).bool(message.isDirty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlockInfo
 */
export const BlockInfo = new BlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlossomBriefInfo$Type extends MessageType<BlossomBriefInfo> {
    constructor() {
        super("BlossomBriefInfo", [
            { no: 14, name: "refresh_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "circle_camp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "city_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "pos", kind: "message", T: () => Vector },
            { no: 15, name: "reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "monster_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_guide_opened", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlossomBriefInfo>): BlossomBriefInfo {
        const message = { refreshId: 0, circleCampId: 0, cityId: 0, resin: 0, rewardId: 0, monsterLevel: 0, isGuideOpened: false, state: 0, sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlossomBriefInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlossomBriefInfo): BlossomBriefInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 refresh_id */ 14:
                    message.refreshId = reader.uint32();
                    break;
                case /* uint32 circle_camp_id */ 5:
                    message.circleCampId = reader.uint32();
                    break;
                case /* uint32 city_id */ 3:
                    message.cityId = reader.uint32();
                    break;
                case /* uint32 resin */ 10:
                    message.resin = reader.uint32();
                    break;
                case /* Vector pos */ 12:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* uint32 reward_id */ 15:
                    message.rewardId = reader.uint32();
                    break;
                case /* uint32 monster_level */ 9:
                    message.monsterLevel = reader.uint32();
                    break;
                case /* bool is_guide_opened */ 4:
                    message.isGuideOpened = reader.bool();
                    break;
                case /* uint32 state */ 6:
                    message.state = reader.uint32();
                    break;
                case /* uint32 scene_id */ 11:
                    message.sceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlossomBriefInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 refresh_id = 14; */
        if (message.refreshId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.refreshId);
        /* uint32 circle_camp_id = 5; */
        if (message.circleCampId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.circleCampId);
        /* uint32 city_id = 3; */
        if (message.cityId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cityId);
        /* uint32 resin = 10; */
        if (message.resin !== 0)
            writer.tag(10, WireType.Varint).uint32(message.resin);
        /* Vector pos = 12; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 reward_id = 15; */
        if (message.rewardId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.rewardId);
        /* uint32 monster_level = 9; */
        if (message.monsterLevel !== 0)
            writer.tag(9, WireType.Varint).uint32(message.monsterLevel);
        /* bool is_guide_opened = 4; */
        if (message.isGuideOpened !== false)
            writer.tag(4, WireType.Varint).bool(message.isGuideOpened);
        /* uint32 state = 6; */
        if (message.state !== 0)
            writer.tag(6, WireType.Varint).uint32(message.state);
        /* uint32 scene_id = 11; */
        if (message.sceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlossomBriefInfo
 */
export const BlossomBriefInfo = new BlossomBriefInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlossomChestInfo$Type extends MessageType<BlossomChestInfo> {
    constructor() {
        super("BlossomChestInfo", [
            { no: 1, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "qualify_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "remain_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "dead_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "blossom_refresh_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "refresh_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlossomChestInfo>): BlossomChestInfo {
        const message = { resin: 0, qualifyUidList: [], remainUidList: [], deadTime: 0, blossomRefreshType: 0, refreshId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlossomChestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlossomChestInfo): BlossomChestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 resin */ 1:
                    message.resin = reader.uint32();
                    break;
                case /* repeated uint32 qualify_uid_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.qualifyUidList.push(reader.uint32());
                    else
                        message.qualifyUidList.push(reader.uint32());
                    break;
                case /* repeated uint32 remain_uid_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.remainUidList.push(reader.uint32());
                    else
                        message.remainUidList.push(reader.uint32());
                    break;
                case /* uint32 dead_time */ 4:
                    message.deadTime = reader.uint32();
                    break;
                case /* uint32 blossom_refresh_type */ 5:
                    message.blossomRefreshType = reader.uint32();
                    break;
                case /* uint32 refresh_id */ 6:
                    message.refreshId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlossomChestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 resin = 1; */
        if (message.resin !== 0)
            writer.tag(1, WireType.Varint).uint32(message.resin);
        /* repeated uint32 qualify_uid_list = 2; */
        if (message.qualifyUidList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.qualifyUidList.length; i++)
                writer.uint32(message.qualifyUidList[i]);
            writer.join();
        }
        /* repeated uint32 remain_uid_list = 3; */
        if (message.remainUidList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.remainUidList.length; i++)
                writer.uint32(message.remainUidList[i]);
            writer.join();
        }
        /* uint32 dead_time = 4; */
        if (message.deadTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.deadTime);
        /* uint32 blossom_refresh_type = 5; */
        if (message.blossomRefreshType !== 0)
            writer.tag(5, WireType.Varint).uint32(message.blossomRefreshType);
        /* uint32 refresh_id = 6; */
        if (message.refreshId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.refreshId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlossomChestInfo
 */
export const BlossomChestInfo = new BlossomChestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BossChestInfo$Type extends MessageType<BossChestInfo> {
    constructor() {
        super("BossChestInfo", [
            { no: 1, name: "monster_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "remain_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "qualify_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "uid_discount_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => WeeklyBossResinDiscountInfo } }
        ]);
    }
    create(value?: PartialMessage<BossChestInfo>): BossChestInfo {
        const message = { monsterConfigId: 0, resin: 0, remainUidList: [], qualifyUidList: [], uidDiscountMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BossChestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BossChestInfo): BossChestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 monster_config_id */ 1:
                    message.monsterConfigId = reader.uint32();
                    break;
                case /* uint32 resin */ 2:
                    message.resin = reader.uint32();
                    break;
                case /* repeated uint32 remain_uid_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.remainUidList.push(reader.uint32());
                    else
                        message.remainUidList.push(reader.uint32());
                    break;
                case /* repeated uint32 qualify_uid_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.qualifyUidList.push(reader.uint32());
                    else
                        message.qualifyUidList.push(reader.uint32());
                    break;
                case /* map<uint32, WeeklyBossResinDiscountInfo> uid_discount_map */ 5:
                    this.binaryReadMap5(message.uidDiscountMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: BossChestInfo["uidDiscountMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BossChestInfo["uidDiscountMap"] | undefined, val: BossChestInfo["uidDiscountMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = WeeklyBossResinDiscountInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field BossChestInfo.uid_discount_map");
            }
        }
        map[key ?? 0] = val ?? WeeklyBossResinDiscountInfo.create();
    }
    internalBinaryWrite(message: BossChestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 monster_config_id = 1; */
        if (message.monsterConfigId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.monsterConfigId);
        /* uint32 resin = 2; */
        if (message.resin !== 0)
            writer.tag(2, WireType.Varint).uint32(message.resin);
        /* repeated uint32 remain_uid_list = 3; */
        if (message.remainUidList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.remainUidList.length; i++)
                writer.uint32(message.remainUidList[i]);
            writer.join();
        }
        /* repeated uint32 qualify_uid_list = 4; */
        if (message.qualifyUidList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.qualifyUidList.length; i++)
                writer.uint32(message.qualifyUidList[i]);
            writer.join();
        }
        /* map<uint32, WeeklyBossResinDiscountInfo> uid_discount_map = 5; */
        for (let k of Object.keys(message.uidDiscountMap)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            WeeklyBossResinDiscountInfo.internalBinaryWrite(message.uidDiscountMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BossChestInfo
 */
export const BossChestInfo = new BossChestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildingInfo$Type extends MessageType<BuildingInfo> {
    constructor() {
        super("BuildingInfo", [
            { no: 1, name: "building_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "point_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "refund", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuildingInfo>): BuildingInfo {
        const message = { buildingId: 0, pointConfigId: 0, cost: 0, level: 0, refund: 0, ownerUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildingInfo): BuildingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 building_id */ 1:
                    message.buildingId = reader.uint32();
                    break;
                case /* uint32 point_config_id */ 2:
                    message.pointConfigId = reader.uint32();
                    break;
                case /* uint32 cost */ 3:
                    message.cost = reader.uint32();
                    break;
                case /* uint32 level */ 4:
                    message.level = reader.uint32();
                    break;
                case /* uint32 refund */ 5:
                    message.refund = reader.uint32();
                    break;
                case /* uint32 owner_uid */ 6:
                    message.ownerUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 building_id = 1; */
        if (message.buildingId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.buildingId);
        /* uint32 point_config_id = 2; */
        if (message.pointConfigId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.pointConfigId);
        /* uint32 cost = 3; */
        if (message.cost !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cost);
        /* uint32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).uint32(message.level);
        /* uint32 refund = 5; */
        if (message.refund !== 0)
            writer.tag(5, WireType.Varint).uint32(message.refund);
        /* uint32 owner_uid = 6; */
        if (message.ownerUid !== 0)
            writer.tag(6, WireType.Varint).uint32(message.ownerUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuildingInfo
 */
export const BuildingInfo = new BuildingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyBattlePassLevelReq$Type extends MessageType<BuyBattlePassLevelReq> {
    constructor() {
        super("BuyBattlePassLevelReq", [
            { no: 10, name: "buy_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuyBattlePassLevelReq>): BuyBattlePassLevelReq {
        const message = { buyLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyBattlePassLevelReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyBattlePassLevelReq): BuyBattlePassLevelReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 buy_level */ 10:
                    message.buyLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuyBattlePassLevelReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 buy_level = 10; */
        if (message.buyLevel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.buyLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyBattlePassLevelReq
 */
export const BuyBattlePassLevelReq = new BuyBattlePassLevelReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyBattlePassLevelRsp$Type extends MessageType<BuyBattlePassLevelRsp> {
    constructor() {
        super("BuyBattlePassLevelRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "buy_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuyBattlePassLevelRsp>): BuyBattlePassLevelRsp {
        const message = { retcode: 0, buyLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyBattlePassLevelRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyBattlePassLevelRsp): BuyBattlePassLevelRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 buy_level */ 6:
                    message.buyLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuyBattlePassLevelRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 buy_level = 6; */
        if (message.buyLevel !== 0)
            writer.tag(6, WireType.Varint).uint32(message.buyLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyBattlePassLevelRsp
 */
export const BuyBattlePassLevelRsp = new BuyBattlePassLevelRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyGoodsReq$Type extends MessageType<BuyGoodsReq> {
    constructor() {
        super("BuyGoodsReq", [
            { no: 15, name: "shop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "goods", kind: "message", T: () => ShopGoods },
            { no: 6, name: "buy_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuyGoodsReq>): BuyGoodsReq {
        const message = { shopType: 0, buyCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyGoodsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyGoodsReq): BuyGoodsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shop_type */ 15:
                    message.shopType = reader.uint32();
                    break;
                case /* ShopGoods goods */ 13:
                    message.goods = ShopGoods.internalBinaryRead(reader, reader.uint32(), options, message.goods);
                    break;
                case /* uint32 buy_count */ 6:
                    message.buyCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuyGoodsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shop_type = 15; */
        if (message.shopType !== 0)
            writer.tag(15, WireType.Varint).uint32(message.shopType);
        /* ShopGoods goods = 13; */
        if (message.goods)
            ShopGoods.internalBinaryWrite(message.goods, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 buy_count = 6; */
        if (message.buyCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.buyCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyGoodsReq
 */
export const BuyGoodsReq = new BuyGoodsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyGoodsRsp$Type extends MessageType<BuyGoodsRsp> {
    constructor() {
        super("BuyGoodsRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "shop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "goods", kind: "message", T: () => ShopGoods },
            { no: 8, name: "buy_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "goods_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopGoods }
        ]);
    }
    create(value?: PartialMessage<BuyGoodsRsp>): BuyGoodsRsp {
        const message = { retcode: 0, shopType: 0, buyCount: 0, goodsList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyGoodsRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyGoodsRsp): BuyGoodsRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 shop_type */ 12:
                    message.shopType = reader.uint32();
                    break;
                case /* ShopGoods goods */ 13:
                    message.goods = ShopGoods.internalBinaryRead(reader, reader.uint32(), options, message.goods);
                    break;
                case /* uint32 buy_count */ 8:
                    message.buyCount = reader.uint32();
                    break;
                case /* repeated ShopGoods goods_list */ 1:
                    message.goodsList.push(ShopGoods.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuyGoodsRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 shop_type = 12; */
        if (message.shopType !== 0)
            writer.tag(12, WireType.Varint).uint32(message.shopType);
        /* ShopGoods goods = 13; */
        if (message.goods)
            ShopGoods.internalBinaryWrite(message.goods, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 buy_count = 8; */
        if (message.buyCount !== 0)
            writer.tag(8, WireType.Varint).uint32(message.buyCount);
        /* repeated ShopGoods goods_list = 1; */
        for (let i = 0; i < message.goodsList.length; i++)
            ShopGoods.internalBinaryWrite(message.goodsList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyGoodsRsp
 */
export const BuyGoodsRsp = new BuyGoodsRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalcWeaponUpgradeReturnItemsReq$Type extends MessageType<CalcWeaponUpgradeReturnItemsReq> {
    constructor() {
        super("CalcWeaponUpgradeReturnItemsReq", [
            { no: 9, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "food_weapon_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<CalcWeaponUpgradeReturnItemsReq>): CalcWeaponUpgradeReturnItemsReq {
        const message = { targetWeaponGuid: 0n, foodWeaponGuidList: [], itemParamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalcWeaponUpgradeReturnItemsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalcWeaponUpgradeReturnItemsReq): CalcWeaponUpgradeReturnItemsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_weapon_guid */ 9:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 food_weapon_guid_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.foodWeaponGuidList.push(reader.uint64().toBigInt());
                    else
                        message.foodWeaponGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated ItemParam item_param_list */ 14:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalcWeaponUpgradeReturnItemsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_weapon_guid = 9; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.targetWeaponGuid);
        /* repeated uint64 food_weapon_guid_list = 10; */
        if (message.foodWeaponGuidList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.foodWeaponGuidList.length; i++)
                writer.uint64(message.foodWeaponGuidList[i]);
            writer.join();
        }
        /* repeated ItemParam item_param_list = 14; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CalcWeaponUpgradeReturnItemsReq
 */
export const CalcWeaponUpgradeReturnItemsReq = new CalcWeaponUpgradeReturnItemsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalcWeaponUpgradeReturnItemsRsp$Type extends MessageType<CalcWeaponUpgradeReturnItemsRsp> {
    constructor() {
        super("CalcWeaponUpgradeReturnItemsRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<CalcWeaponUpgradeReturnItemsRsp>): CalcWeaponUpgradeReturnItemsRsp {
        const message = { retcode: 0, targetWeaponGuid: 0n, itemParamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalcWeaponUpgradeReturnItemsRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalcWeaponUpgradeReturnItemsRsp): CalcWeaponUpgradeReturnItemsRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_weapon_guid */ 10:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated ItemParam item_param_list */ 3:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalcWeaponUpgradeReturnItemsRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint64 target_weapon_guid = 10; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.targetWeaponGuid);
        /* repeated ItemParam item_param_list = 3; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CalcWeaponUpgradeReturnItemsRsp
 */
export const CalcWeaponUpgradeReturnItemsRsp = new CalcWeaponUpgradeReturnItemsRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CanUseSkillNotify$Type extends MessageType<CanUseSkillNotify> {
    constructor() {
        super("CanUseSkillNotify", [
            { no: 6, name: "is_can_use_skill", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CanUseSkillNotify>): CanUseSkillNotify {
        const message = { isCanUseSkill: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CanUseSkillNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CanUseSkillNotify): CanUseSkillNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_can_use_skill */ 6:
                    message.isCanUseSkill = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CanUseSkillNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_can_use_skill = 6; */
        if (message.isCanUseSkill !== false)
            writer.tag(6, WireType.Varint).bool(message.isCanUseSkill);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CanUseSkillNotify
 */
export const CanUseSkillNotify = new CanUseSkillNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CardProductRewardNotify$Type extends MessageType<CardProductRewardNotify> {
    constructor() {
        super("CardProductRewardNotify", [
            { no: 6, name: "product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "hcoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "remain_days", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CardProductRewardNotify>): CardProductRewardNotify {
        const message = { productId: "", hcoin: 0, remainDays: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CardProductRewardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CardProductRewardNotify): CardProductRewardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string product_id */ 6:
                    message.productId = reader.string();
                    break;
                case /* uint32 hcoin */ 11:
                    message.hcoin = reader.uint32();
                    break;
                case /* uint32 remain_days */ 5:
                    message.remainDays = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CardProductRewardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string product_id = 6; */
        if (message.productId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.productId);
        /* uint32 hcoin = 11; */
        if (message.hcoin !== 0)
            writer.tag(11, WireType.Varint).uint32(message.hcoin);
        /* uint32 remain_days = 5; */
        if (message.remainDays !== 0)
            writer.tag(5, WireType.Varint).uint32(message.remainDays);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CardProductRewardNotify
 */
export const CardProductRewardNotify = new CardProductRewardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChallengeDataNotify$Type extends MessageType<ChallengeDataNotify> {
    constructor() {
        super("ChallengeDataNotify", [
            { no: 8, name: "challenge_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "param_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChallengeDataNotify>): ChallengeDataNotify {
        const message = { challengeIndex: 0, paramIndex: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChallengeDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChallengeDataNotify): ChallengeDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 challenge_index */ 8:
                    message.challengeIndex = reader.uint32();
                    break;
                case /* uint32 param_index */ 9:
                    message.paramIndex = reader.uint32();
                    break;
                case /* uint32 value */ 1:
                    message.value = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChallengeDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 challenge_index = 8; */
        if (message.challengeIndex !== 0)
            writer.tag(8, WireType.Varint).uint32(message.challengeIndex);
        /* uint32 param_index = 9; */
        if (message.paramIndex !== 0)
            writer.tag(9, WireType.Varint).uint32(message.paramIndex);
        /* uint32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).uint32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChallengeDataNotify
 */
export const ChallengeDataNotify = new ChallengeDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeAvatarReq$Type extends MessageType<ChangeAvatarReq> {
    constructor() {
        super("ChangeAvatarReq", [
            { no: 5, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_move", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "move_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<ChangeAvatarReq>): ChangeAvatarReq {
        const message = { guid: 0n, skillId: 0, isMove: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeAvatarReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeAvatarReq): ChangeAvatarReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 guid */ 5:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 skill_id */ 11:
                    message.skillId = reader.uint32();
                    break;
                case /* bool is_move */ 7:
                    message.isMove = reader.bool();
                    break;
                case /* Vector move_pos */ 9:
                    message.movePos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.movePos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeAvatarReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 guid = 5; */
        if (message.guid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.guid);
        /* uint32 skill_id = 11; */
        if (message.skillId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.skillId);
        /* bool is_move = 7; */
        if (message.isMove !== false)
            writer.tag(7, WireType.Varint).bool(message.isMove);
        /* Vector move_pos = 9; */
        if (message.movePos)
            Vector.internalBinaryWrite(message.movePos, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeAvatarReq
 */
export const ChangeAvatarReq = new ChangeAvatarReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeAvatarRsp$Type extends MessageType<ChangeAvatarRsp> {
    constructor() {
        super("ChangeAvatarRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "cur_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeAvatarRsp>): ChangeAvatarRsp {
        const message = { retcode: 0, curGuid: 0n, skillId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeAvatarRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeAvatarRsp): ChangeAvatarRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 cur_guid */ 11:
                    message.curGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 skill_id */ 5:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeAvatarRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* uint64 cur_guid = 11; */
        if (message.curGuid !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.curGuid);
        /* uint32 skill_id = 5; */
        if (message.skillId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeAvatarRsp
 */
export const ChangeAvatarRsp = new ChangeAvatarRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeGameTimeReq$Type extends MessageType<ChangeGameTimeReq> {
    constructor() {
        super("ChangeGameTimeReq", [
            { no: 9, name: "game_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_force_set", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "extra_days", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeGameTimeReq>): ChangeGameTimeReq {
        const message = { gameTime: 0, isForceSet: false, extraDays: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeGameTimeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeGameTimeReq): ChangeGameTimeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 game_time */ 9:
                    message.gameTime = reader.uint32();
                    break;
                case /* bool is_force_set */ 7:
                    message.isForceSet = reader.bool();
                    break;
                case /* uint32 extra_days */ 6:
                    message.extraDays = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeGameTimeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 game_time = 9; */
        if (message.gameTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.gameTime);
        /* bool is_force_set = 7; */
        if (message.isForceSet !== false)
            writer.tag(7, WireType.Varint).bool(message.isForceSet);
        /* uint32 extra_days = 6; */
        if (message.extraDays !== 0)
            writer.tag(6, WireType.Varint).uint32(message.extraDays);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeGameTimeReq
 */
export const ChangeGameTimeReq = new ChangeGameTimeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeGameTimeRsp$Type extends MessageType<ChangeGameTimeRsp> {
    constructor() {
        super("ChangeGameTimeRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "cur_game_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "extra_days", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeGameTimeRsp>): ChangeGameTimeRsp {
        const message = { retcode: 0, curGameTime: 0, extraDays: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeGameTimeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeGameTimeRsp): ChangeGameTimeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 cur_game_time */ 1:
                    message.curGameTime = reader.uint32();
                    break;
                case /* uint32 extra_days */ 2:
                    message.extraDays = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeGameTimeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 cur_game_time = 1; */
        if (message.curGameTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.curGameTime);
        /* uint32 extra_days = 2; */
        if (message.extraDays !== 0)
            writer.tag(2, WireType.Varint).uint32(message.extraDays);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeGameTimeRsp
 */
export const ChangeGameTimeRsp = new ChangeGameTimeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMailStarNotify$Type extends MessageType<ChangeMailStarNotify> {
    constructor() {
        super("ChangeMailStarNotify", [
            { no: 5, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_star", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeMailStarNotify>): ChangeMailStarNotify {
        const message = { mailIdList: [], isStar: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeMailStarNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMailStarNotify): ChangeMailStarNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 mail_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                case /* bool is_star */ 9:
                    message.isStar = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMailStarNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 mail_id_list = 5; */
        if (message.mailIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        /* bool is_star = 9; */
        if (message.isStar !== false)
            writer.tag(9, WireType.Varint).bool(message.isStar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeMailStarNotify
 */
export const ChangeMailStarNotify = new ChangeMailStarNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMpTeamAvatarReq$Type extends MessageType<ChangeMpTeamAvatarReq> {
    constructor() {
        super("ChangeMpTeamAvatarReq", [
            { no: 5, name: "avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "cur_avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeMpTeamAvatarReq>): ChangeMpTeamAvatarReq {
        const message = { avatarGuidList: [], curAvatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeMpTeamAvatarReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMpTeamAvatarReq): ChangeMpTeamAvatarReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 avatar_guid_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* uint64 cur_avatar_guid */ 12:
                    message.curAvatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMpTeamAvatarReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 avatar_guid_list = 5; */
        if (message.avatarGuidList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuidList.length; i++)
                writer.uint64(message.avatarGuidList[i]);
            writer.join();
        }
        /* uint64 cur_avatar_guid = 12; */
        if (message.curAvatarGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.curAvatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeMpTeamAvatarReq
 */
export const ChangeMpTeamAvatarReq = new ChangeMpTeamAvatarReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMpTeamAvatarRsp$Type extends MessageType<ChangeMpTeamAvatarRsp> {
    constructor() {
        super("ChangeMpTeamAvatarRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "cur_avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeMpTeamAvatarRsp>): ChangeMpTeamAvatarRsp {
        const message = { retcode: 0, avatarGuidList: [], curAvatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeMpTeamAvatarRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMpTeamAvatarRsp): ChangeMpTeamAvatarRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint64 avatar_guid_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* uint64 cur_avatar_guid */ 8:
                    message.curAvatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMpTeamAvatarRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* repeated uint64 avatar_guid_list = 3; */
        if (message.avatarGuidList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuidList.length; i++)
                writer.uint64(message.avatarGuidList[i]);
            writer.join();
        }
        /* uint64 cur_avatar_guid = 8; */
        if (message.curAvatarGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.curAvatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeMpTeamAvatarRsp
 */
export const ChangeMpTeamAvatarRsp = new ChangeMpTeamAvatarRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTeamNameReq$Type extends MessageType<ChangeTeamNameReq> {
    constructor() {
        super("ChangeTeamNameReq", [
            { no: 12, name: "team_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "team_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeTeamNameReq>): ChangeTeamNameReq {
        const message = { teamId: 0, teamName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeTeamNameReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTeamNameReq): ChangeTeamNameReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 team_id */ 12:
                    message.teamId = reader.int32();
                    break;
                case /* string team_name */ 15:
                    message.teamName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeTeamNameReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 team_id = 12; */
        if (message.teamId !== 0)
            writer.tag(12, WireType.Varint).int32(message.teamId);
        /* string team_name = 15; */
        if (message.teamName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.teamName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeTeamNameReq
 */
export const ChangeTeamNameReq = new ChangeTeamNameReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTeamNameRsp$Type extends MessageType<ChangeTeamNameRsp> {
    constructor() {
        super("ChangeTeamNameRsp", [
            { no: 6, name: "team_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "team_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeTeamNameRsp>): ChangeTeamNameRsp {
        const message = { teamId: 0, teamName: "", retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeTeamNameRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTeamNameRsp): ChangeTeamNameRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 team_id */ 6:
                    message.teamId = reader.int32();
                    break;
                case /* string team_name */ 2:
                    message.teamName = reader.string();
                    break;
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeTeamNameRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 team_id = 6; */
        if (message.teamId !== 0)
            writer.tag(6, WireType.Varint).int32(message.teamId);
        /* string team_name = 2; */
        if (message.teamName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.teamName);
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeTeamNameRsp
 */
export const ChangeTeamNameRsp = new ChangeTeamNameRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannelerSlabLoopDungeonResultInfo$Type extends MessageType<ChannelerSlabLoopDungeonResultInfo> {
    constructor() {
        super("ChannelerSlabLoopDungeonResultInfo", [
            { no: 11, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "challenge_max_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "dungeon_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_in_time_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "challenge_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChannelerSlabLoopDungeonResultInfo>): ChannelerSlabLoopDungeonResultInfo {
        const message = { isSuccess: false, challengeMaxScore: 0, dungeonIndex: 0, isInTimeLimit: false, challengeScore: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannelerSlabLoopDungeonResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelerSlabLoopDungeonResultInfo): ChannelerSlabLoopDungeonResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_success */ 11:
                    message.isSuccess = reader.bool();
                    break;
                case /* uint32 challenge_max_score */ 8:
                    message.challengeMaxScore = reader.uint32();
                    break;
                case /* uint32 dungeon_index */ 7:
                    message.dungeonIndex = reader.uint32();
                    break;
                case /* bool is_in_time_limit */ 10:
                    message.isInTimeLimit = reader.bool();
                    break;
                case /* uint32 challenge_score */ 12:
                    message.challengeScore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannelerSlabLoopDungeonResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_success = 11; */
        if (message.isSuccess !== false)
            writer.tag(11, WireType.Varint).bool(message.isSuccess);
        /* uint32 challenge_max_score = 8; */
        if (message.challengeMaxScore !== 0)
            writer.tag(8, WireType.Varint).uint32(message.challengeMaxScore);
        /* uint32 dungeon_index = 7; */
        if (message.dungeonIndex !== 0)
            writer.tag(7, WireType.Varint).uint32(message.dungeonIndex);
        /* bool is_in_time_limit = 10; */
        if (message.isInTimeLimit !== false)
            writer.tag(10, WireType.Varint).bool(message.isInTimeLimit);
        /* uint32 challenge_score = 12; */
        if (message.challengeScore !== 0)
            writer.tag(12, WireType.Varint).uint32(message.challengeScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChannelerSlabLoopDungeonResultInfo
 */
export const ChannelerSlabLoopDungeonResultInfo = new ChannelerSlabLoopDungeonResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChannellerSlabLoopDungeonResultInfo$Type extends MessageType<ChannellerSlabLoopDungeonResultInfo> {
    constructor() {
        super("ChannellerSlabLoopDungeonResultInfo", [
            { no: 1, name: "dungeon_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "challenge_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "challenge_max_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_in_time_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChannellerSlabLoopDungeonResultInfo>): ChannellerSlabLoopDungeonResultInfo {
        const message = { dungeonIndex: 0, isSuccess: false, challengeScore: 0, challengeMaxScore: 0, isInTimeLimit: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChannellerSlabLoopDungeonResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannellerSlabLoopDungeonResultInfo): ChannellerSlabLoopDungeonResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 dungeon_index */ 1:
                    message.dungeonIndex = reader.uint32();
                    break;
                case /* bool is_success */ 2:
                    message.isSuccess = reader.bool();
                    break;
                case /* uint32 challenge_score */ 3:
                    message.challengeScore = reader.uint32();
                    break;
                case /* uint32 challenge_max_score */ 4:
                    message.challengeMaxScore = reader.uint32();
                    break;
                case /* bool is_in_time_limit */ 5:
                    message.isInTimeLimit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChannellerSlabLoopDungeonResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 dungeon_index = 1; */
        if (message.dungeonIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.dungeonIndex);
        /* bool is_success = 2; */
        if (message.isSuccess !== false)
            writer.tag(2, WireType.Varint).bool(message.isSuccess);
        /* uint32 challenge_score = 3; */
        if (message.challengeScore !== 0)
            writer.tag(3, WireType.Varint).uint32(message.challengeScore);
        /* uint32 challenge_max_score = 4; */
        if (message.challengeMaxScore !== 0)
            writer.tag(4, WireType.Varint).uint32(message.challengeMaxScore);
        /* bool is_in_time_limit = 5; */
        if (message.isInTimeLimit !== false)
            writer.tag(5, WireType.Varint).bool(message.isInTimeLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChannellerSlabLoopDungeonResultInfo
 */
export const ChannellerSlabLoopDungeonResultInfo = new ChannellerSlabLoopDungeonResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterStateNotify$Type extends MessageType<ChapterStateNotify> {
    constructor() {
        super("ChapterStateNotify", [
            { no: 1, name: "chapter_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "chapter_state", kind: "enum", T: () => ["ChapterState", ChapterState, "CHAPTER_STATE_"] },
            { no: 10, name: "need_player_level", kind: "message", T: () => ChapterStateNotify_NeedPlayerLevel },
            { no: 14, name: "need_begin_time", kind: "message", T: () => ChapterStateNotify_NeedBeginTime }
        ]);
    }
    create(value?: PartialMessage<ChapterStateNotify>): ChapterStateNotify {
        const message = { chapterId: 0, chapterState: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChapterStateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterStateNotify): ChapterStateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 chapter_id */ 1:
                    message.chapterId = reader.uint32();
                    break;
                case /* ChapterState chapter_state */ 12:
                    message.chapterState = reader.int32();
                    break;
                case /* ChapterStateNotify.NeedPlayerLevel need_player_level */ 10:
                    message.needPlayerLevel = ChapterStateNotify_NeedPlayerLevel.internalBinaryRead(reader, reader.uint32(), options, message.needPlayerLevel);
                    break;
                case /* ChapterStateNotify.NeedBeginTime need_begin_time */ 14:
                    message.needBeginTime = ChapterStateNotify_NeedBeginTime.internalBinaryRead(reader, reader.uint32(), options, message.needBeginTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterStateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 chapter_id = 1; */
        if (message.chapterId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.chapterId);
        /* ChapterState chapter_state = 12; */
        if (message.chapterState !== 0)
            writer.tag(12, WireType.Varint).int32(message.chapterState);
        /* ChapterStateNotify.NeedPlayerLevel need_player_level = 10; */
        if (message.needPlayerLevel)
            ChapterStateNotify_NeedPlayerLevel.internalBinaryWrite(message.needPlayerLevel, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* ChapterStateNotify.NeedBeginTime need_begin_time = 14; */
        if (message.needBeginTime)
            ChapterStateNotify_NeedBeginTime.internalBinaryWrite(message.needBeginTime, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChapterStateNotify
 */
export const ChapterStateNotify = new ChapterStateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterStateNotify_NeedPlayerLevel$Type extends MessageType<ChapterStateNotify_NeedPlayerLevel> {
    constructor() {
        super("ChapterStateNotify.NeedPlayerLevel", [
            { no: 3, name: "is_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "config_need_player_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChapterStateNotify_NeedPlayerLevel>): ChapterStateNotify_NeedPlayerLevel {
        const message = { isLimit: false, configNeedPlayerLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChapterStateNotify_NeedPlayerLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterStateNotify_NeedPlayerLevel): ChapterStateNotify_NeedPlayerLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_limit */ 3:
                    message.isLimit = reader.bool();
                    break;
                case /* uint32 config_need_player_level */ 10:
                    message.configNeedPlayerLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterStateNotify_NeedPlayerLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_limit = 3; */
        if (message.isLimit !== false)
            writer.tag(3, WireType.Varint).bool(message.isLimit);
        /* uint32 config_need_player_level = 10; */
        if (message.configNeedPlayerLevel !== 0)
            writer.tag(10, WireType.Varint).uint32(message.configNeedPlayerLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChapterStateNotify.NeedPlayerLevel
 */
export const ChapterStateNotify_NeedPlayerLevel = new ChapterStateNotify_NeedPlayerLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterStateNotify_NeedBeginTime$Type extends MessageType<ChapterStateNotify_NeedBeginTime> {
    constructor() {
        super("ChapterStateNotify.NeedBeginTime", [
            { no: 13, name: "is_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "config_need_begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChapterStateNotify_NeedBeginTime>): ChapterStateNotify_NeedBeginTime {
        const message = { isLimit: false, configNeedBeginTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChapterStateNotify_NeedBeginTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterStateNotify_NeedBeginTime): ChapterStateNotify_NeedBeginTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_limit */ 13:
                    message.isLimit = reader.bool();
                    break;
                case /* uint32 config_need_begin_time */ 6:
                    message.configNeedBeginTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterStateNotify_NeedBeginTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_limit = 13; */
        if (message.isLimit !== false)
            writer.tag(13, WireType.Varint).bool(message.isLimit);
        /* uint32 config_need_begin_time = 6; */
        if (message.configNeedBeginTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.configNeedBeginTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChapterStateNotify.NeedBeginTime
 */
export const ChapterStateNotify_NeedBeginTime = new ChapterStateNotify_NeedBeginTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatInfo$Type extends MessageType<ChatInfo> {
    constructor() {
        super("ChatInfo", [
            { no: 10, name: "time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "sequence", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "to_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_read", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 439, name: "text", kind: "scalar", oneof: "content", T: 9 /*ScalarType.STRING*/ },
            { no: 960, name: "icon", kind: "scalar", oneof: "content", T: 13 /*ScalarType.UINT32*/ },
            { no: 1632, name: "system_hint", kind: "message", oneof: "content", T: () => ChatInfo_SystemHint }
        ]);
    }
    create(value?: PartialMessage<ChatInfo>): ChatInfo {
        const message = { time: 0, uid: 0, sequence: 0, toUid: 0, isRead: false, content: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChatInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatInfo): ChatInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 time */ 10:
                    message.time = reader.uint32();
                    break;
                case /* uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 sequence */ 13:
                    message.sequence = reader.uint32();
                    break;
                case /* uint32 to_uid */ 4:
                    message.toUid = reader.uint32();
                    break;
                case /* bool is_read */ 6:
                    message.isRead = reader.bool();
                    break;
                case /* string text */ 439:
                    message.content = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* uint32 icon */ 960:
                    message.content = {
                        oneofKind: "icon",
                        icon: reader.uint32()
                    };
                    break;
                case /* ChatInfo.SystemHint system_hint */ 1632:
                    message.content = {
                        oneofKind: "systemHint",
                        systemHint: ChatInfo_SystemHint.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).systemHint)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 time = 10; */
        if (message.time !== 0)
            writer.tag(10, WireType.Varint).uint32(message.time);
        /* uint32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        /* uint32 sequence = 13; */
        if (message.sequence !== 0)
            writer.tag(13, WireType.Varint).uint32(message.sequence);
        /* uint32 to_uid = 4; */
        if (message.toUid !== 0)
            writer.tag(4, WireType.Varint).uint32(message.toUid);
        /* bool is_read = 6; */
        if (message.isRead !== false)
            writer.tag(6, WireType.Varint).bool(message.isRead);
        /* string text = 439; */
        if (message.content.oneofKind === "text")
            writer.tag(439, WireType.LengthDelimited).string(message.content.text);
        /* uint32 icon = 960; */
        if (message.content.oneofKind === "icon")
            writer.tag(960, WireType.Varint).uint32(message.content.icon);
        /* ChatInfo.SystemHint system_hint = 1632; */
        if (message.content.oneofKind === "systemHint")
            ChatInfo_SystemHint.internalBinaryWrite(message.content.systemHint, writer.tag(1632, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChatInfo
 */
export const ChatInfo = new ChatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatInfo_SystemHint$Type extends MessageType<ChatInfo_SystemHint> {
    constructor() {
        super("ChatInfo.SystemHint", [
            { no: 6, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChatInfo_SystemHint>): ChatInfo_SystemHint {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChatInfo_SystemHint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatInfo_SystemHint): ChatInfo_SystemHint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 6:
                    message.type = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatInfo_SystemHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 6; */
        if (message.type !== 0)
            writer.tag(6, WireType.Varint).uint32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChatInfo.SystemHint
 */
export const ChatInfo_SystemHint = new ChatInfo_SystemHint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAddItemExceedLimitNotify$Type extends MessageType<CheckAddItemExceedLimitNotify> {
    constructor() {
        super("CheckAddItemExceedLimitNotify", [
            { no: 1, name: "is_drop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "exceeded_item_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "exceeded_item_type_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "msg_type", kind: "enum", T: () => ["CheckAddItemExceedLimitNotify.ItemExceedLimitMsgType", CheckAddItemExceedLimitNotify_ItemExceedLimitMsgType, "ITEM_EXCEED_LIMIT_MSG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<CheckAddItemExceedLimitNotify>): CheckAddItemExceedLimitNotify {
        const message = { isDrop: false, exceededItemList: [], exceededItemTypeList: [], msgType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckAddItemExceedLimitNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAddItemExceedLimitNotify): CheckAddItemExceedLimitNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_drop */ 1:
                    message.isDrop = reader.bool();
                    break;
                case /* repeated uint32 exceeded_item_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exceededItemList.push(reader.uint32());
                    else
                        message.exceededItemList.push(reader.uint32());
                    break;
                case /* repeated uint32 exceeded_item_type_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.exceededItemTypeList.push(reader.uint32());
                    else
                        message.exceededItemTypeList.push(reader.uint32());
                    break;
                case /* CheckAddItemExceedLimitNotify.ItemExceedLimitMsgType msg_type */ 14:
                    message.msgType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAddItemExceedLimitNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_drop = 1; */
        if (message.isDrop !== false)
            writer.tag(1, WireType.Varint).bool(message.isDrop);
        /* repeated uint32 exceeded_item_list = 8; */
        if (message.exceededItemList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exceededItemList.length; i++)
                writer.uint32(message.exceededItemList[i]);
            writer.join();
        }
        /* repeated uint32 exceeded_item_type_list = 3; */
        if (message.exceededItemTypeList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.exceededItemTypeList.length; i++)
                writer.uint32(message.exceededItemTypeList[i]);
            writer.join();
        }
        /* CheckAddItemExceedLimitNotify.ItemExceedLimitMsgType msg_type = 14; */
        if (message.msgType !== 0)
            writer.tag(14, WireType.Varint).int32(message.msgType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CheckAddItemExceedLimitNotify
 */
export const CheckAddItemExceedLimitNotify = new CheckAddItemExceedLimitNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChildQuest$Type extends MessageType<ChildQuest> {
    constructor() {
        super("ChildQuest", [
            { no: 1, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "quest_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChildQuest>): ChildQuest {
        const message = { questId: 0, state: 0, questConfigId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChildQuest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChildQuest): ChildQuest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 1:
                    message.questId = reader.uint32();
                    break;
                case /* uint32 state */ 2:
                    message.state = reader.uint32();
                    break;
                case /* uint32 quest_config_id */ 3:
                    message.questConfigId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChildQuest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 1; */
        if (message.questId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.questId);
        /* uint32 state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).uint32(message.state);
        /* uint32 quest_config_id = 3; */
        if (message.questConfigId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.questConfigId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChildQuest
 */
export const ChildQuest = new ChildQuest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChooseCurAvatarTeamReq$Type extends MessageType<ChooseCurAvatarTeamReq> {
    constructor() {
        super("ChooseCurAvatarTeamReq", [
            { no: 14, name: "team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChooseCurAvatarTeamReq>): ChooseCurAvatarTeamReq {
        const message = { teamId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChooseCurAvatarTeamReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChooseCurAvatarTeamReq): ChooseCurAvatarTeamReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 team_id */ 14:
                    message.teamId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChooseCurAvatarTeamReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 team_id = 14; */
        if (message.teamId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.teamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChooseCurAvatarTeamReq
 */
export const ChooseCurAvatarTeamReq = new ChooseCurAvatarTeamReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChooseCurAvatarTeamRsp$Type extends MessageType<ChooseCurAvatarTeamRsp> {
    constructor() {
        super("ChooseCurAvatarTeamRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cur_team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChooseCurAvatarTeamRsp>): ChooseCurAvatarTeamRsp {
        const message = { retcode: 0, curTeamId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChooseCurAvatarTeamRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChooseCurAvatarTeamRsp): ChooseCurAvatarTeamRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 cur_team_id */ 4:
                    message.curTeamId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChooseCurAvatarTeamRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 cur_team_id = 4; */
        if (message.curTeamId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.curTeamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChooseCurAvatarTeamRsp
 */
export const ChooseCurAvatarTeamRsp = new ChooseCurAvatarTeamRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CityInfo$Type extends MessageType<CityInfo> {
    constructor() {
        super("CityInfo", [
            { no: 14, name: "city_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "crystal_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CityInfo>): CityInfo {
        const message = { cityId: 0, level: 0, crystalNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CityInfo): CityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 city_id */ 14:
                    message.cityId = reader.uint32();
                    break;
                case /* uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* uint32 crystal_num */ 12:
                    message.crystalNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 city_id = 14; */
        if (message.cityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.cityId);
        /* uint32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* uint32 crystal_num = 12; */
        if (message.crystalNum !== 0)
            writer.tag(12, WireType.Varint).uint32(message.crystalNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CityInfo
 */
export const CityInfo = new CityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientAbilityChangeNotify$Type extends MessageType<ClientAbilityChangeNotify> {
    constructor() {
        super("ClientAbilityChangeNotify", [
            { no: 6, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "invokes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityInvokeEntry }
        ]);
    }
    create(value?: PartialMessage<ClientAbilityChangeNotify>): ClientAbilityChangeNotify {
        const message = { entityId: 0, invokes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientAbilityChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientAbilityChangeNotify): ClientAbilityChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 6:
                    message.entityId = reader.uint32();
                    break;
                case /* repeated AbilityInvokeEntry invokes */ 8:
                    message.invokes.push(AbilityInvokeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientAbilityChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 6; */
        if (message.entityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.entityId);
        /* repeated AbilityInvokeEntry invokes = 8; */
        for (let i = 0; i < message.invokes.length; i++)
            AbilityInvokeEntry.internalBinaryWrite(message.invokes[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientAbilityChangeNotify
 */
export const ClientAbilityChangeNotify = new ClientAbilityChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientAbilityInitBeginNotify$Type extends MessageType<ClientAbilityInitBeginNotify> {
    constructor() {
        super("ClientAbilityInitBeginNotify", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClientAbilityInitBeginNotify>): ClientAbilityInitBeginNotify {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientAbilityInitBeginNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientAbilityInitBeginNotify): ClientAbilityInitBeginNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientAbilityInitBeginNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientAbilityInitBeginNotify
 */
export const ClientAbilityInitBeginNotify = new ClientAbilityInitBeginNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientAbilityInitFinishNotify$Type extends MessageType<ClientAbilityInitFinishNotify> {
    constructor() {
        super("ClientAbilityInitFinishNotify", [
            { no: 13, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "invokes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AbilityInvokeEntry }
        ]);
    }
    create(value?: PartialMessage<ClientAbilityInitFinishNotify>): ClientAbilityInitFinishNotify {
        const message = { entityId: 0, invokes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientAbilityInitFinishNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientAbilityInitFinishNotify): ClientAbilityInitFinishNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 13:
                    message.entityId = reader.uint32();
                    break;
                case /* repeated AbilityInvokeEntry invokes */ 9:
                    message.invokes.push(AbilityInvokeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientAbilityInitFinishNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 13; */
        if (message.entityId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.entityId);
        /* repeated AbilityInvokeEntry invokes = 9; */
        for (let i = 0; i < message.invokes.length; i++)
            AbilityInvokeEntry.internalBinaryWrite(message.invokes[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientAbilityInitFinishNotify
 */
export const ClientAbilityInitFinishNotify = new ClientAbilityInitFinishNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientCollectorData$Type extends MessageType<ClientCollectorData> {
    constructor() {
        super("ClientCollectorData", [
            { no: 6, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "max_points", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "curr_points", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClientCollectorData>): ClientCollectorData {
        const message = { materialId: 0, maxPoints: 0, currPoints: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientCollectorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientCollectorData): ClientCollectorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 6:
                    message.materialId = reader.uint32();
                    break;
                case /* uint32 max_points */ 2:
                    message.maxPoints = reader.uint32();
                    break;
                case /* uint32 curr_points */ 8:
                    message.currPoints = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientCollectorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 6; */
        if (message.materialId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.materialId);
        /* uint32 max_points = 2; */
        if (message.maxPoints !== 0)
            writer.tag(2, WireType.Varint).uint32(message.maxPoints);
        /* uint32 curr_points = 8; */
        if (message.currPoints !== 0)
            writer.tag(8, WireType.Varint).uint32(message.currPoints);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientCollectorData
 */
export const ClientCollectorData = new ClientCollectorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientCollectorDataNotify$Type extends MessageType<ClientCollectorDataNotify> {
    constructor() {
        super("ClientCollectorDataNotify", [
            { no: 8, name: "client_collector_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientCollectorData }
        ]);
    }
    create(value?: PartialMessage<ClientCollectorDataNotify>): ClientCollectorDataNotify {
        const message = { clientCollectorDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientCollectorDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientCollectorDataNotify): ClientCollectorDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ClientCollectorData client_collector_data_list */ 8:
                    message.clientCollectorDataList.push(ClientCollectorData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientCollectorDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ClientCollectorData client_collector_data_list = 8; */
        for (let i = 0; i < message.clientCollectorDataList.length; i++)
            ClientCollectorData.internalBinaryWrite(message.clientCollectorDataList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientCollectorDataNotify
 */
export const ClientCollectorDataNotify = new ClientCollectorDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientGadgetInfo$Type extends MessageType<ClientGadgetInfo> {
    constructor() {
        super("ClientGadgetInfo", [
            { no: 1, name: "camp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "camp_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "target_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "async_load", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClientGadgetInfo>): ClientGadgetInfo {
        const message = { campId: 0, campType: 0, guid: 0n, ownerEntityId: 0, targetEntityId: 0, asyncLoad: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientGadgetInfo): ClientGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 camp_id */ 1:
                    message.campId = reader.uint32();
                    break;
                case /* uint32 camp_type */ 2:
                    message.campType = reader.uint32();
                    break;
                case /* uint64 guid */ 3:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 owner_entity_id */ 4:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* uint32 target_entity_id */ 5:
                    message.targetEntityId = reader.uint32();
                    break;
                case /* bool async_load */ 6:
                    message.asyncLoad = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 camp_id = 1; */
        if (message.campId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.campId);
        /* uint32 camp_type = 2; */
        if (message.campType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.campType);
        /* uint64 guid = 3; */
        if (message.guid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.guid);
        /* uint32 owner_entity_id = 4; */
        if (message.ownerEntityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.ownerEntityId);
        /* uint32 target_entity_id = 5; */
        if (message.targetEntityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.targetEntityId);
        /* bool async_load = 6; */
        if (message.asyncLoad !== false)
            writer.tag(6, WireType.Varint).bool(message.asyncLoad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClientGadgetInfo
 */
export const ClientGadgetInfo = new ClientGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodexDataFullNotify$Type extends MessageType<CodexDataFullNotify> {
    constructor() {
        super("CodexDataFullNotify", [
            { no: 5, name: "type_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CodexTypeData }
        ]);
    }
    create(value?: PartialMessage<CodexDataFullNotify>): CodexDataFullNotify {
        const message = { typeDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodexDataFullNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodexDataFullNotify): CodexDataFullNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CodexTypeData type_data_list */ 5:
                    message.typeDataList.push(CodexTypeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodexDataFullNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CodexTypeData type_data_list = 5; */
        for (let i = 0; i < message.typeDataList.length; i++)
            CodexTypeData.internalBinaryWrite(message.typeDataList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CodexDataFullNotify
 */
export const CodexDataFullNotify = new CodexDataFullNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodexDataUpdateNotify$Type extends MessageType<CodexDataUpdateNotify> {
    constructor() {
        super("CodexDataUpdateNotify", [
            { no: 3, name: "type", kind: "enum", T: () => ["CodexType", CodexType, "CODEX_TYPE_"] },
            { no: 4, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "weapon_max_promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CodexDataUpdateNotify>): CodexDataUpdateNotify {
        const message = { type: 0, id: 0, weaponMaxPromoteLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodexDataUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodexDataUpdateNotify): CodexDataUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CodexType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* uint32 id */ 4:
                    message.id = reader.uint32();
                    break;
                case /* uint32 weapon_max_promote_level */ 12:
                    message.weaponMaxPromoteLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodexDataUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CodexType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* uint32 id = 4; */
        if (message.id !== 0)
            writer.tag(4, WireType.Varint).uint32(message.id);
        /* uint32 weapon_max_promote_level = 12; */
        if (message.weaponMaxPromoteLevel !== 0)
            writer.tag(12, WireType.Varint).uint32(message.weaponMaxPromoteLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CodexDataUpdateNotify
 */
export const CodexDataUpdateNotify = new CodexDataUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodexTypeComparer$Type extends MessageType<CodexTypeComparer> {
    constructor() {
        super("CodexTypeComparer", []);
    }
    create(value?: PartialMessage<CodexTypeComparer>): CodexTypeComparer {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodexTypeComparer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodexTypeComparer): CodexTypeComparer {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CodexTypeComparer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CodexTypeComparer
 */
export const CodexTypeComparer = new CodexTypeComparer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodexTypeData$Type extends MessageType<CodexTypeData> {
    constructor() {
        super("CodexTypeData", [
            { no: 3, name: "type", kind: "enum", T: () => ["CodexType", CodexType, "CODEX_TYPE_"] },
            { no: 11, name: "codex_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "have_viewed_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "weapon_max_promote_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<CodexTypeData>): CodexTypeData {
        const message = { type: 0, codexIdList: [], haveViewedList: [], weaponMaxPromoteLevelMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodexTypeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodexTypeData): CodexTypeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CodexType type */ 3:
                    message.type = reader.int32();
                    break;
                case /* repeated uint32 codex_id_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.codexIdList.push(reader.uint32());
                    else
                        message.codexIdList.push(reader.uint32());
                    break;
                case /* repeated bool have_viewed_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.haveViewedList.push(reader.bool());
                    else
                        message.haveViewedList.push(reader.bool());
                    break;
                case /* map<uint32, uint32> weapon_max_promote_level_map */ 12:
                    this.binaryReadMap12(message.weaponMaxPromoteLevelMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap12(map: CodexTypeData["weaponMaxPromoteLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CodexTypeData["weaponMaxPromoteLevelMap"] | undefined, val: CodexTypeData["weaponMaxPromoteLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field CodexTypeData.weapon_max_promote_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: CodexTypeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CodexType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        /* repeated uint32 codex_id_list = 11; */
        if (message.codexIdList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.codexIdList.length; i++)
                writer.uint32(message.codexIdList[i]);
            writer.join();
        }
        /* repeated bool have_viewed_list = 7; */
        if (message.haveViewedList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.haveViewedList.length; i++)
                writer.bool(message.haveViewedList[i]);
            writer.join();
        }
        /* map<uint32, uint32> weapon_max_promote_level_map = 12; */
        for (let k of Object.keys(message.weaponMaxPromoteLevelMap))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.weaponMaxPromoteLevelMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CodexTypeData
 */
export const CodexTypeData = new CodexTypeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatInvocationsNotify$Type extends MessageType<CombatInvocationsNotify> {
    constructor() {
        super("CombatInvocationsNotify", [
            { no: 4, name: "invoke_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CombatInvokeEntry }
        ]);
    }
    create(value?: PartialMessage<CombatInvocationsNotify>): CombatInvocationsNotify {
        const message = { invokeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombatInvocationsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatInvocationsNotify): CombatInvocationsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CombatInvokeEntry invoke_list */ 4:
                    message.invokeList.push(CombatInvokeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatInvocationsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CombatInvokeEntry invoke_list = 4; */
        for (let i = 0; i < message.invokeList.length; i++)
            CombatInvokeEntry.internalBinaryWrite(message.invokeList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombatInvocationsNotify
 */
export const CombatInvocationsNotify = new CombatInvocationsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombatInvokeEntry$Type extends MessageType<CombatInvokeEntry> {
    constructor() {
        super("CombatInvokeEntry", [
            { no: 14, name: "argument_type", kind: "enum", T: () => ["CombatTypeArgument", CombatTypeArgument, "COMBAT_TYPE_ARGUMENT_"] },
            { no: 12, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 11, name: "combat_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CombatInvokeEntry>): CombatInvokeEntry {
        const message = { argumentType: 0, forwardType: 0, combatData: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombatInvokeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombatInvokeEntry): CombatInvokeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CombatTypeArgument argument_type */ 14:
                    message.argumentType = reader.int32();
                    break;
                case /* ForwardType forward_type */ 12:
                    message.forwardType = reader.int32();
                    break;
                case /* bytes combat_data */ 11:
                    message.combatData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombatInvokeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CombatTypeArgument argument_type = 14; */
        if (message.argumentType !== 0)
            writer.tag(14, WireType.Varint).int32(message.argumentType);
        /* ForwardType forward_type = 12; */
        if (message.forwardType !== 0)
            writer.tag(12, WireType.Varint).int32(message.forwardType);
        /* bytes combat_data = 11; */
        if (message.combatData.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.combatData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombatInvokeEntry
 */
export const CombatInvokeEntry = new CombatInvokeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombineDataNotify$Type extends MessageType<CombineDataNotify> {
    constructor() {
        super("CombineDataNotify", [
            { no: 5, name: "combine_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CombineDataNotify>): CombineDataNotify {
        const message = { combineIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombineDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombineDataNotify): CombineDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 combine_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.combineIdList.push(reader.uint32());
                    else
                        message.combineIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombineDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 combine_id_list = 5; */
        if (message.combineIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.combineIdList.length; i++)
                writer.uint32(message.combineIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombineDataNotify
 */
export const CombineDataNotify = new CombineDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombineFormulaDataNotify$Type extends MessageType<CombineFormulaDataNotify> {
    constructor() {
        super("CombineFormulaDataNotify", [
            { no: 6, name: "combine_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CombineFormulaDataNotify>): CombineFormulaDataNotify {
        const message = { combineId: 0, isLocked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombineFormulaDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombineFormulaDataNotify): CombineFormulaDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 combine_id */ 6:
                    message.combineId = reader.uint32();
                    break;
                case /* bool is_locked */ 5:
                    message.isLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombineFormulaDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 combine_id = 6; */
        if (message.combineId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.combineId);
        /* bool is_locked = 5; */
        if (message.isLocked !== false)
            writer.tag(5, WireType.Varint).bool(message.isLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombineFormulaDataNotify
 */
export const CombineFormulaDataNotify = new CombineFormulaDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombineReq$Type extends MessageType<CombineReq> {
    constructor() {
        super("CombineReq", [
            { no: 5, name: "combine_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "combine_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CombineReq>): CombineReq {
        const message = { combineId: 0, combineCount: 0, avatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombineReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombineReq): CombineReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 combine_id */ 5:
                    message.combineId = reader.uint32();
                    break;
                case /* uint32 combine_count */ 3:
                    message.combineCount = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 8:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombineReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 combine_id = 5; */
        if (message.combineId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.combineId);
        /* uint32 combine_count = 3; */
        if (message.combineCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.combineCount);
        /* uint64 avatar_guid = 8; */
        if (message.avatarGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.avatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombineReq
 */
export const CombineReq = new CombineReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CombineRsp$Type extends MessageType<CombineRsp> {
    constructor() {
        super("CombineRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "combine_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "combine_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "cost_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "result_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 9, name: "total_random_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 4, name: "total_return_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 8, name: "total_extra_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<CombineRsp>): CombineRsp {
        const message = { retcode: 0, combineId: 0, combineCount: 0, avatarGuid: 0n, costItemList: [], resultItemList: [], totalRandomItemList: [], totalReturnItemList: [], totalExtraItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CombineRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CombineRsp): CombineRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 combine_id */ 12:
                    message.combineId = reader.uint32();
                    break;
                case /* uint32 combine_count */ 6:
                    message.combineCount = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 15:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated ItemParam cost_item_list */ 10:
                    message.costItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam result_item_list */ 2:
                    message.resultItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam total_random_item_list */ 9:
                    message.totalRandomItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam total_return_item_list */ 4:
                    message.totalReturnItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam total_extra_item_list */ 8:
                    message.totalExtraItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CombineRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 combine_id = 12; */
        if (message.combineId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.combineId);
        /* uint32 combine_count = 6; */
        if (message.combineCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.combineCount);
        /* uint64 avatar_guid = 15; */
        if (message.avatarGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.avatarGuid);
        /* repeated ItemParam cost_item_list = 10; */
        for (let i = 0; i < message.costItemList.length; i++)
            ItemParam.internalBinaryWrite(message.costItemList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam result_item_list = 2; */
        for (let i = 0; i < message.resultItemList.length; i++)
            ItemParam.internalBinaryWrite(message.resultItemList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam total_random_item_list = 9; */
        for (let i = 0; i < message.totalRandomItemList.length; i++)
            ItemParam.internalBinaryWrite(message.totalRandomItemList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam total_return_item_list = 4; */
        for (let i = 0; i < message.totalReturnItemList.length; i++)
            ItemParam.internalBinaryWrite(message.totalReturnItemList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam total_extra_item_list = 8; */
        for (let i = 0; i < message.totalExtraItemList.length; i++)
            ItemParam.internalBinaryWrite(message.totalExtraItemList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CombineRsp
 */
export const CombineRsp = new CombineRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CookDataNotify$Type extends MessageType<CookDataNotify> {
    constructor() {
        super("CookDataNotify", [
            { no: 8, name: "grade", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "recipe_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CookRecipeData }
        ]);
    }
    create(value?: PartialMessage<CookDataNotify>): CookDataNotify {
        const message = { grade: 0, recipeDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CookDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CookDataNotify): CookDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 grade */ 8:
                    message.grade = reader.uint32();
                    break;
                case /* repeated CookRecipeData recipe_data_list */ 2:
                    message.recipeDataList.push(CookRecipeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CookDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 grade = 8; */
        if (message.grade !== 0)
            writer.tag(8, WireType.Varint).uint32(message.grade);
        /* repeated CookRecipeData recipe_data_list = 2; */
        for (let i = 0; i < message.recipeDataList.length; i++)
            CookRecipeData.internalBinaryWrite(message.recipeDataList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CookDataNotify
 */
export const CookDataNotify = new CookDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CookGradeDataNotify$Type extends MessageType<CookGradeDataNotify> {
    constructor() {
        super("CookGradeDataNotify", [
            { no: 6, name: "grade", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CookGradeDataNotify>): CookGradeDataNotify {
        const message = { grade: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CookGradeDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CookGradeDataNotify): CookGradeDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 grade */ 6:
                    message.grade = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CookGradeDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 grade = 6; */
        if (message.grade !== 0)
            writer.tag(6, WireType.Varint).uint32(message.grade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CookGradeDataNotify
 */
export const CookGradeDataNotify = new CookGradeDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CookRecipeData$Type extends MessageType<CookRecipeData> {
    constructor() {
        super("CookRecipeData", [
            { no: 6, name: "recipe_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "proficiency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CookRecipeData>): CookRecipeData {
        const message = { recipeId: 0, proficiency: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CookRecipeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CookRecipeData): CookRecipeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 recipe_id */ 6:
                    message.recipeId = reader.uint32();
                    break;
                case /* uint32 proficiency */ 12:
                    message.proficiency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CookRecipeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 recipe_id = 6; */
        if (message.recipeId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.recipeId);
        /* uint32 proficiency = 12; */
        if (message.proficiency !== 0)
            writer.tag(12, WireType.Varint).uint32(message.proficiency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CookRecipeData
 */
export const CookRecipeData = new CookRecipeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CookRecipeDataNotify$Type extends MessageType<CookRecipeDataNotify> {
    constructor() {
        super("CookRecipeDataNotify", [
            { no: 1, name: "recipe_data", kind: "message", T: () => CookRecipeData }
        ]);
    }
    create(value?: PartialMessage<CookRecipeDataNotify>): CookRecipeDataNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CookRecipeDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CookRecipeDataNotify): CookRecipeDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CookRecipeData recipe_data */ 1:
                    message.recipeData = CookRecipeData.internalBinaryRead(reader, reader.uint32(), options, message.recipeData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CookRecipeDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CookRecipeData recipe_data = 1; */
        if (message.recipeData)
            CookRecipeData.internalBinaryWrite(message.recipeData, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CookRecipeDataNotify
 */
export const CookRecipeDataNotify = new CookRecipeDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoopCg$Type extends MessageType<CoopCg> {
    constructor() {
        super("CoopCg", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_unlock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CoopCg>): CoopCg {
        const message = { id: 0, isUnlock: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoopCg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoopCg): CoopCg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* bool is_unlock */ 2:
                    message.isUnlock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoopCg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* bool is_unlock = 2; */
        if (message.isUnlock !== false)
            writer.tag(2, WireType.Varint).bool(message.isUnlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoopCg
 */
export const CoopCg = new CoopCg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoopChapter$Type extends MessageType<CoopChapter> {
    constructor() {
        super("CoopChapter", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["CoopChapter.State", CoopChapter_State, "STATE_"] },
            { no: 3, name: "lock_reason_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "coop_point_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoopPoint },
            { no: 5, name: "coop_reward_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoopReward },
            { no: 6, name: "coop_cg_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoopCg },
            { no: 7, name: "total_end_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "finished_end_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "seen_ending_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 10, name: "finish_dialog_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CoopChapter>): CoopChapter {
        const message = { id: 0, state: 0, lockReasonList: [], coopPointList: [], coopRewardList: [], coopCgList: [], totalEndCount: 0, finishedEndCount: 0, seenEndingMap: {}, finishDialogList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoopChapter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoopChapter): CoopChapter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* CoopChapter.State state */ 2:
                    message.state = reader.int32();
                    break;
                case /* repeated uint32 lock_reason_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lockReasonList.push(reader.uint32());
                    else
                        message.lockReasonList.push(reader.uint32());
                    break;
                case /* repeated CoopPoint coop_point_list */ 4:
                    message.coopPointList.push(CoopPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CoopReward coop_reward_list */ 5:
                    message.coopRewardList.push(CoopReward.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CoopCg coop_cg_list */ 6:
                    message.coopCgList.push(CoopCg.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 total_end_count */ 7:
                    message.totalEndCount = reader.uint32();
                    break;
                case /* uint32 finished_end_count */ 8:
                    message.finishedEndCount = reader.uint32();
                    break;
                case /* map<uint32, uint32> seen_ending_map */ 9:
                    this.binaryReadMap9(message.seenEndingMap, reader, options);
                    break;
                case /* repeated uint32 finish_dialog_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishDialogList.push(reader.uint32());
                    else
                        message.finishDialogList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: CoopChapter["seenEndingMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CoopChapter["seenEndingMap"] | undefined, val: CoopChapter["seenEndingMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field CoopChapter.seen_ending_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: CoopChapter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* CoopChapter.State state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* repeated uint32 lock_reason_list = 3; */
        if (message.lockReasonList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lockReasonList.length; i++)
                writer.uint32(message.lockReasonList[i]);
            writer.join();
        }
        /* repeated CoopPoint coop_point_list = 4; */
        for (let i = 0; i < message.coopPointList.length; i++)
            CoopPoint.internalBinaryWrite(message.coopPointList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CoopReward coop_reward_list = 5; */
        for (let i = 0; i < message.coopRewardList.length; i++)
            CoopReward.internalBinaryWrite(message.coopRewardList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CoopCg coop_cg_list = 6; */
        for (let i = 0; i < message.coopCgList.length; i++)
            CoopCg.internalBinaryWrite(message.coopCgList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 total_end_count = 7; */
        if (message.totalEndCount !== 0)
            writer.tag(7, WireType.Varint).uint32(message.totalEndCount);
        /* uint32 finished_end_count = 8; */
        if (message.finishedEndCount !== 0)
            writer.tag(8, WireType.Varint).uint32(message.finishedEndCount);
        /* map<uint32, uint32> seen_ending_map = 9; */
        for (let k of Object.keys(message.seenEndingMap))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.seenEndingMap[k as any]).join();
        /* repeated uint32 finish_dialog_list = 10; */
        if (message.finishDialogList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishDialogList.length; i++)
                writer.uint32(message.finishDialogList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoopChapter
 */
export const CoopChapter = new CoopChapter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoopDataNotify$Type extends MessageType<CoopDataNotify> {
    constructor() {
        super("CoopDataNotify", [
            { no: 13, name: "chapter_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoopChapter },
            { no: 14, name: "is_have_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "cur_coop_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "viewed_chapter_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CoopDataNotify>): CoopDataNotify {
        const message = { chapterList: [], isHaveProgress: false, curCoopPoint: 0, viewedChapterList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoopDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoopDataNotify): CoopDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CoopChapter chapter_list */ 13:
                    message.chapterList.push(CoopChapter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_have_progress */ 14:
                    message.isHaveProgress = reader.bool();
                    break;
                case /* uint32 cur_coop_point */ 5:
                    message.curCoopPoint = reader.uint32();
                    break;
                case /* repeated uint32 viewed_chapter_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.viewedChapterList.push(reader.uint32());
                    else
                        message.viewedChapterList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoopDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CoopChapter chapter_list = 13; */
        for (let i = 0; i < message.chapterList.length; i++)
            CoopChapter.internalBinaryWrite(message.chapterList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool is_have_progress = 14; */
        if (message.isHaveProgress !== false)
            writer.tag(14, WireType.Varint).bool(message.isHaveProgress);
        /* uint32 cur_coop_point = 5; */
        if (message.curCoopPoint !== 0)
            writer.tag(5, WireType.Varint).uint32(message.curCoopPoint);
        /* repeated uint32 viewed_chapter_list = 2; */
        if (message.viewedChapterList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.viewedChapterList.length; i++)
                writer.uint32(message.viewedChapterList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoopDataNotify
 */
export const CoopDataNotify = new CoopDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoopPoint$Type extends MessageType<CoopPoint> {
    constructor() {
        super("CoopPoint", [
            { no: 15, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "state", kind: "enum", T: () => ["CoopPoint.State", CoopPoint_State, "STATE_"] },
            { no: 8, name: "self_confidence", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CoopPoint>): CoopPoint {
        const message = { id: 0, state: 0, selfConfidence: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoopPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoopPoint): CoopPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 15:
                    message.id = reader.uint32();
                    break;
                case /* CoopPoint.State state */ 11:
                    message.state = reader.int32();
                    break;
                case /* uint32 self_confidence */ 8:
                    message.selfConfidence = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoopPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 15; */
        if (message.id !== 0)
            writer.tag(15, WireType.Varint).uint32(message.id);
        /* CoopPoint.State state = 11; */
        if (message.state !== 0)
            writer.tag(11, WireType.Varint).int32(message.state);
        /* uint32 self_confidence = 8; */
        if (message.selfConfidence !== 0)
            writer.tag(8, WireType.Varint).uint32(message.selfConfidence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoopPoint
 */
export const CoopPoint = new CoopPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoopReward$Type extends MessageType<CoopReward> {
    constructor() {
        super("CoopReward", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["CoopReward.State", CoopReward_State, "STATE_"] }
        ]);
    }
    create(value?: PartialMessage<CoopReward>): CoopReward {
        const message = { id: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoopReward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoopReward): CoopReward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* CoopReward.State state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoopReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* CoopReward.State state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoopReward
 */
export const CoopReward = new CoopReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountDownDelete$Type extends MessageType<CountDownDelete> {
    constructor() {
        super("CountDownDelete", []);
    }
    create(value?: PartialMessage<CountDownDelete>): CountDownDelete {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CountDownDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountDownDelete): CountDownDelete {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CountDownDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CountDownDelete
 */
export const CountDownDelete = new CountDownDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateVehicleReq$Type extends MessageType<CreateVehicleReq> {
    constructor() {
        super("CreateVehicleReq", [
            { no: 9, name: "vehicle_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "scene_point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "pos", kind: "message", T: () => Vector },
            { no: 7, name: "rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<CreateVehicleReq>): CreateVehicleReq {
        const message = { vehicleId: 0, scenePointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateVehicleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateVehicleReq): CreateVehicleReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 vehicle_id */ 9:
                    message.vehicleId = reader.uint32();
                    break;
                case /* uint32 scene_point_id */ 15:
                    message.scenePointId = reader.uint32();
                    break;
                case /* Vector pos */ 1:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 7:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateVehicleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 vehicle_id = 9; */
        if (message.vehicleId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.vehicleId);
        /* uint32 scene_point_id = 15; */
        if (message.scenePointId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.scenePointId);
        /* Vector pos = 1; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 7; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateVehicleReq
 */
export const CreateVehicleReq = new CreateVehicleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateVehicleRsp$Type extends MessageType<CreateVehicleRsp> {
    constructor() {
        super("CreateVehicleRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "vehicle_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateVehicleRsp>): CreateVehicleRsp {
        const message = { retcode: 0, vehicleId: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateVehicleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateVehicleRsp): CreateVehicleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 vehicle_id */ 8:
                    message.vehicleId = reader.uint32();
                    break;
                case /* uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateVehicleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 vehicle_id = 8; */
        if (message.vehicleId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.vehicleId);
        /* uint32 entity_id = 10; */
        if (message.entityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateVehicleRsp
 */
export const CreateVehicleRsp = new CreateVehicleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrystalLinkSettleInfo$Type extends MessageType<CrystalLinkSettleInfo> {
    constructor() {
        super("CrystalLinkSettleInfo", [
            { no: 2, name: "kill_elite_monster_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "final_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "level_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_new_record", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "difficulty_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "kill_normal_mosnter_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CrystalLinkSettleInfo>): CrystalLinkSettleInfo {
        const message = { killEliteMonsterNum: 0, finalScore: 0, levelId: 0, isNewRecord: false, difficultyId: 0, killNormalMosnterNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CrystalLinkSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrystalLinkSettleInfo): CrystalLinkSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 kill_elite_monster_num */ 2:
                    message.killEliteMonsterNum = reader.uint32();
                    break;
                case /* uint32 final_score */ 6:
                    message.finalScore = reader.uint32();
                    break;
                case /* uint32 level_id */ 12:
                    message.levelId = reader.uint32();
                    break;
                case /* bool is_new_record */ 13:
                    message.isNewRecord = reader.bool();
                    break;
                case /* uint32 difficulty_id */ 9:
                    message.difficultyId = reader.uint32();
                    break;
                case /* uint32 kill_normal_mosnter_num */ 3:
                    message.killNormalMosnterNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrystalLinkSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 kill_elite_monster_num = 2; */
        if (message.killEliteMonsterNum !== 0)
            writer.tag(2, WireType.Varint).uint32(message.killEliteMonsterNum);
        /* uint32 final_score = 6; */
        if (message.finalScore !== 0)
            writer.tag(6, WireType.Varint).uint32(message.finalScore);
        /* uint32 level_id = 12; */
        if (message.levelId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.levelId);
        /* bool is_new_record = 13; */
        if (message.isNewRecord !== false)
            writer.tag(13, WireType.Varint).bool(message.isNewRecord);
        /* uint32 difficulty_id = 9; */
        if (message.difficultyId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.difficultyId);
        /* uint32 kill_normal_mosnter_num = 3; */
        if (message.killNormalMosnterNum !== 0)
            writer.tag(3, WireType.Varint).uint32(message.killNormalMosnterNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CrystalLinkSettleInfo
 */
export const CrystalLinkSettleInfo = new CrystalLinkSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurVehicleInfo$Type extends MessageType<CurVehicleInfo> {
    constructor() {
        super("CurVehicleInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pos", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CurVehicleInfo>): CurVehicleInfo {
        const message = { entityId: 0, pos: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurVehicleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurVehicleInfo): CurVehicleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 pos */ 2:
                    message.pos = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurVehicleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* uint32 pos = 2; */
        if (message.pos !== 0)
            writer.tag(2, WireType.Varint).uint32(message.pos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CurVehicleInfo
 */
export const CurVehicleInfo = new CurVehicleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomCommonNodeInfo$Type extends MessageType<CustomCommonNodeInfo> {
    constructor() {
        super("CustomCommonNodeInfo", [
            { no: 1, name: "parent_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "slot_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomCommonNodeInfo>): CustomCommonNodeInfo {
        const message = { parentIndex: 0, configId: 0, slotIdentifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomCommonNodeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomCommonNodeInfo): CustomCommonNodeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 parent_index */ 1:
                    message.parentIndex = reader.int32();
                    break;
                case /* uint32 config_id */ 2:
                    message.configId = reader.uint32();
                    break;
                case /* string slot_identifier */ 3:
                    message.slotIdentifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomCommonNodeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 parent_index = 1; */
        if (message.parentIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.parentIndex);
        /* uint32 config_id = 2; */
        if (message.configId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.configId);
        /* string slot_identifier = 3; */
        if (message.slotIdentifier !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.slotIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CustomCommonNodeInfo
 */
export const CustomCommonNodeInfo = new CustomCommonNodeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomDungeonResultInfo$Type extends MessageType<CustomDungeonResultInfo> {
    constructor() {
        super("CustomDungeonResultInfo", [
            { no: 12, name: "Unk2700_BONNHGKDLFO", kind: "scalar", jsonName: "Unk2700BONNHGKDLFO", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "Unk2700_FBBEJKCDMEI", kind: "scalar", jsonName: "Unk2700FBBEJKCDMEI", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "child_challenge_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Unk2700_FDEGJOCDDGH },
            { no: 3, name: "Unk2700_ONOOJBEABOE", kind: "scalar", jsonName: "Unk2700ONOOJBEABOE", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "Unk2700_ONCDLPDHFAB", kind: "enum", jsonName: "Unk2700ONCDLPDHFAB", T: () => ["Unk2700_OCOKILBJIPJ", Unk2700_OCOKILBJIPJ] },
            { no: 11, name: "time_cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "Unk2700_IBDCFAMBGOK", kind: "scalar", jsonName: "Unk2700IBDCFAMBGOK", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "Unk2700_HBFLKFOCKBF", kind: "scalar", jsonName: "Unk2700HBFLKFOCKBF", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CustomDungeonResultInfo>): CustomDungeonResultInfo {
        const message = { unk2700BONNHGKDLFO: false, unk2700FBBEJKCDMEI: 0, childChallengeList: [], unk2700ONOOJBEABOE: 0n, unk2700ONCDLPDHFAB: 0, timeCost: 0, unk2700IBDCFAMBGOK: false, unk2700HBFLKFOCKBF: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomDungeonResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomDungeonResultInfo): CustomDungeonResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Unk2700_BONNHGKDLFO = 12 [json_name = "Unk2700BONNHGKDLFO"];*/ 12:
                    message.unk2700BONNHGKDLFO = reader.bool();
                    break;
                case /* uint32 Unk2700_FBBEJKCDMEI = 9 [json_name = "Unk2700FBBEJKCDMEI"];*/ 9:
                    message.unk2700FBBEJKCDMEI = reader.uint32();
                    break;
                case /* repeated Unk2700_FDEGJOCDDGH child_challenge_list */ 6:
                    message.childChallengeList.push(Unk2700_FDEGJOCDDGH.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 Unk2700_ONOOJBEABOE = 3 [json_name = "Unk2700ONOOJBEABOE"];*/ 3:
                    message.unk2700ONOOJBEABOE = reader.uint64().toBigInt();
                    break;
                case /* Unk2700_OCOKILBJIPJ Unk2700_ONCDLPDHFAB = 7 [json_name = "Unk2700ONCDLPDHFAB"];*/ 7:
                    message.unk2700ONCDLPDHFAB = reader.int32();
                    break;
                case /* uint32 time_cost */ 11:
                    message.timeCost = reader.uint32();
                    break;
                case /* bool Unk2700_IBDCFAMBGOK = 2 [json_name = "Unk2700IBDCFAMBGOK"];*/ 2:
                    message.unk2700IBDCFAMBGOK = reader.bool();
                    break;
                case /* bool Unk2700_HBFLKFOCKBF = 14 [json_name = "Unk2700HBFLKFOCKBF"];*/ 14:
                    message.unk2700HBFLKFOCKBF = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomDungeonResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Unk2700_BONNHGKDLFO = 12 [json_name = "Unk2700BONNHGKDLFO"]; */
        if (message.unk2700BONNHGKDLFO !== false)
            writer.tag(12, WireType.Varint).bool(message.unk2700BONNHGKDLFO);
        /* uint32 Unk2700_FBBEJKCDMEI = 9 [json_name = "Unk2700FBBEJKCDMEI"]; */
        if (message.unk2700FBBEJKCDMEI !== 0)
            writer.tag(9, WireType.Varint).uint32(message.unk2700FBBEJKCDMEI);
        /* repeated Unk2700_FDEGJOCDDGH child_challenge_list = 6; */
        for (let i = 0; i < message.childChallengeList.length; i++)
            Unk2700_FDEGJOCDDGH.internalBinaryWrite(message.childChallengeList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 Unk2700_ONOOJBEABOE = 3 [json_name = "Unk2700ONOOJBEABOE"]; */
        if (message.unk2700ONOOJBEABOE !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.unk2700ONOOJBEABOE);
        /* Unk2700_OCOKILBJIPJ Unk2700_ONCDLPDHFAB = 7 [json_name = "Unk2700ONCDLPDHFAB"]; */
        if (message.unk2700ONCDLPDHFAB !== 0)
            writer.tag(7, WireType.Varint).int32(message.unk2700ONCDLPDHFAB);
        /* uint32 time_cost = 11; */
        if (message.timeCost !== 0)
            writer.tag(11, WireType.Varint).uint32(message.timeCost);
        /* bool Unk2700_IBDCFAMBGOK = 2 [json_name = "Unk2700IBDCFAMBGOK"]; */
        if (message.unk2700IBDCFAMBGOK !== false)
            writer.tag(2, WireType.Varint).bool(message.unk2700IBDCFAMBGOK);
        /* bool Unk2700_HBFLKFOCKBF = 14 [json_name = "Unk2700HBFLKFOCKBF"]; */
        if (message.unk2700HBFLKFOCKBF !== false)
            writer.tag(14, WireType.Varint).bool(message.unk2700HBFLKFOCKBF);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CustomDungeonResultInfo
 */
export const CustomDungeonResultInfo = new CustomDungeonResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomGadgetTreeInfo$Type extends MessageType<CustomGadgetTreeInfo> {
    constructor() {
        super("CustomGadgetTreeInfo", [
            { no: 1, name: "node_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomCommonNodeInfo }
        ]);
    }
    create(value?: PartialMessage<CustomGadgetTreeInfo>): CustomGadgetTreeInfo {
        const message = { nodeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomGadgetTreeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomGadgetTreeInfo): CustomGadgetTreeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CustomCommonNodeInfo node_list */ 1:
                    message.nodeList.push(CustomCommonNodeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomGadgetTreeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CustomCommonNodeInfo node_list = 1; */
        for (let i = 0; i < message.nodeList.length; i++)
            CustomCommonNodeInfo.internalBinaryWrite(message.nodeList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CustomGadgetTreeInfo
 */
export const CustomGadgetTreeInfo = new CustomGadgetTreeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CutSceneBeginNotify$Type extends MessageType<CutSceneBeginNotify> {
    constructor() {
        super("CutSceneBeginNotify", [
            { no: 9, name: "cutscene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_wait_others", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CutSceneBeginNotify>): CutSceneBeginNotify {
        const message = { cutsceneId: 0, isWaitOthers: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CutSceneBeginNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CutSceneBeginNotify): CutSceneBeginNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cutscene_id */ 9:
                    message.cutsceneId = reader.uint32();
                    break;
                case /* bool is_wait_others */ 11:
                    message.isWaitOthers = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CutSceneBeginNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cutscene_id = 9; */
        if (message.cutsceneId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.cutsceneId);
        /* bool is_wait_others = 11; */
        if (message.isWaitOthers !== false)
            writer.tag(11, WireType.Varint).bool(message.isWaitOthers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CutSceneBeginNotify
 */
export const CutSceneBeginNotify = new CutSceneBeginNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CutSceneEndNotify$Type extends MessageType<CutSceneEndNotify> {
    constructor() {
        super("CutSceneEndNotify", [
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "cutscene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CutSceneEndNotify>): CutSceneEndNotify {
        const message = { retcode: 0, cutsceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CutSceneEndNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CutSceneEndNotify): CutSceneEndNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 cutscene_id */ 11:
                    message.cutsceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CutSceneEndNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* uint32 cutscene_id = 11; */
        if (message.cutsceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.cutsceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CutSceneEndNotify
 */
export const CutSceneEndNotify = new CutSceneEndNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CutSceneFinishNotify$Type extends MessageType<CutSceneFinishNotify> {
    constructor() {
        super("CutSceneFinishNotify", [
            { no: 14, name: "cutscene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CutSceneFinishNotify>): CutSceneFinishNotify {
        const message = { cutsceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CutSceneFinishNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CutSceneFinishNotify): CutSceneFinishNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cutscene_id */ 14:
                    message.cutsceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CutSceneFinishNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cutscene_id = 14; */
        if (message.cutsceneId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.cutsceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CutSceneFinishNotify
 */
export const CutSceneFinishNotify = new CutSceneFinishNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DailyDungeonEntryInfo$Type extends MessageType<DailyDungeonEntryInfo> {
    constructor() {
        super("DailyDungeonEntryInfo", [
            { no: 3, name: "dungeon_entry_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "dungeon_entry_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "recommend_dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "recommend_dungeon_entry_info", kind: "message", T: () => DungeonEntryInfo }
        ]);
    }
    create(value?: PartialMessage<DailyDungeonEntryInfo>): DailyDungeonEntryInfo {
        const message = { dungeonEntryId: 0, dungeonEntryConfigId: 0, recommendDungeonId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DailyDungeonEntryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DailyDungeonEntryInfo): DailyDungeonEntryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 dungeon_entry_id */ 3:
                    message.dungeonEntryId = reader.uint32();
                    break;
                case /* uint32 dungeon_entry_config_id */ 1:
                    message.dungeonEntryConfigId = reader.uint32();
                    break;
                case /* uint32 recommend_dungeon_id */ 13:
                    message.recommendDungeonId = reader.uint32();
                    break;
                case /* DungeonEntryInfo recommend_dungeon_entry_info */ 7:
                    message.recommendDungeonEntryInfo = DungeonEntryInfo.internalBinaryRead(reader, reader.uint32(), options, message.recommendDungeonEntryInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DailyDungeonEntryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 dungeon_entry_id = 3; */
        if (message.dungeonEntryId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.dungeonEntryId);
        /* uint32 dungeon_entry_config_id = 1; */
        if (message.dungeonEntryConfigId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.dungeonEntryConfigId);
        /* uint32 recommend_dungeon_id = 13; */
        if (message.recommendDungeonId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.recommendDungeonId);
        /* DungeonEntryInfo recommend_dungeon_entry_info = 7; */
        if (message.recommendDungeonEntryInfo)
            DungeonEntryInfo.internalBinaryWrite(message.recommendDungeonEntryInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DailyDungeonEntryInfo
 */
export const DailyDungeonEntryInfo = new DailyDungeonEntryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DateTimeDelete$Type extends MessageType<DateTimeDelete> {
    constructor() {
        super("DateTimeDelete", []);
    }
    create(value?: PartialMessage<DateTimeDelete>): DateTimeDelete {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DateTimeDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DateTimeDelete): DateTimeDelete {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DateTimeDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DateTimeDelete
 */
export const DateTimeDelete = new DateTimeDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DealAddFriendReq$Type extends MessageType<DealAddFriendReq> {
    constructor() {
        super("DealAddFriendReq", [
            { no: 7, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "deal_add_friend_result", kind: "enum", T: () => ["DealAddFriendResultType", DealAddFriendResultType, "DEAL_ADD_FRIEND_RESULT_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<DealAddFriendReq>): DealAddFriendReq {
        const message = { targetUid: 0, dealAddFriendResult: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DealAddFriendReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DealAddFriendReq): DealAddFriendReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 7:
                    message.targetUid = reader.uint32();
                    break;
                case /* DealAddFriendResultType deal_add_friend_result */ 1:
                    message.dealAddFriendResult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DealAddFriendReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 7; */
        if (message.targetUid !== 0)
            writer.tag(7, WireType.Varint).uint32(message.targetUid);
        /* DealAddFriendResultType deal_add_friend_result = 1; */
        if (message.dealAddFriendResult !== 0)
            writer.tag(1, WireType.Varint).int32(message.dealAddFriendResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DealAddFriendReq
 */
export const DealAddFriendReq = new DealAddFriendReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DealAddFriendRsp$Type extends MessageType<DealAddFriendRsp> {
    constructor() {
        super("DealAddFriendRsp", [
            { no: 3, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "deal_add_friend_result", kind: "enum", T: () => ["DealAddFriendResultType", DealAddFriendResultType, "DEAL_ADD_FRIEND_RESULT_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<DealAddFriendRsp>): DealAddFriendRsp {
        const message = { retcode: 0, targetUid: 0, dealAddFriendResult: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DealAddFriendRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DealAddFriendRsp): DealAddFriendRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 2:
                    message.targetUid = reader.uint32();
                    break;
                case /* DealAddFriendResultType deal_add_friend_result */ 15:
                    message.dealAddFriendResult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DealAddFriendRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 3; */
        if (message.retcode !== 0)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 2; */
        if (message.targetUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetUid);
        /* DealAddFriendResultType deal_add_friend_result = 15; */
        if (message.dealAddFriendResult !== 0)
            writer.tag(15, WireType.Varint).int32(message.dealAddFriendResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DealAddFriendRsp
 */
export const DealAddFriendRsp = new DealAddFriendRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelayWeekCountDownDelete$Type extends MessageType<DelayWeekCountDownDelete> {
    constructor() {
        super("DelayWeekCountDownDelete", []);
    }
    create(value?: PartialMessage<DelayWeekCountDownDelete>): DelayWeekCountDownDelete {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelayWeekCountDownDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelayWeekCountDownDelete): DelayWeekCountDownDelete {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DelayWeekCountDownDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DelayWeekCountDownDelete
 */
export const DelayWeekCountDownDelete = new DelayWeekCountDownDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFriendNotify$Type extends MessageType<DeleteFriendNotify> {
    constructor() {
        super("DeleteFriendNotify", [
            { no: 14, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteFriendNotify>): DeleteFriendNotify {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteFriendNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFriendNotify): DeleteFriendNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 14:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFriendNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 14; */
        if (message.targetUid !== 0)
            writer.tag(14, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteFriendNotify
 */
export const DeleteFriendNotify = new DeleteFriendNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFriendReq$Type extends MessageType<DeleteFriendReq> {
    constructor() {
        super("DeleteFriendReq", [
            { no: 7, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteFriendReq>): DeleteFriendReq {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteFriendReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFriendReq): DeleteFriendReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 7:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFriendReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 7; */
        if (message.targetUid !== 0)
            writer.tag(7, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteFriendReq
 */
export const DeleteFriendReq = new DeleteFriendReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFriendRsp$Type extends MessageType<DeleteFriendRsp> {
    constructor() {
        super("DeleteFriendRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteFriendRsp>): DeleteFriendRsp {
        const message = { retcode: 0, targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteFriendRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFriendRsp): DeleteFriendRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 8:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFriendRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 8; */
        if (message.targetUid !== 0)
            writer.tag(8, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteFriendRsp
 */
export const DeleteFriendRsp = new DeleteFriendRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelMailReq$Type extends MessageType<DelMailReq> {
    constructor() {
        super("DelMailReq", [
            { no: 6, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DelMailReq>): DelMailReq {
        const message = { mailIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelMailReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelMailReq): DelMailReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 mail_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelMailReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 mail_id_list = 6; */
        if (message.mailIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DelMailReq
 */
export const DelMailReq = new DelMailReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelMailRsp$Type extends MessageType<DelMailRsp> {
    constructor() {
        super("DelMailRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DelMailRsp>): DelMailRsp {
        const message = { retcode: 0, mailIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelMailRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelMailRsp): DelMailRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 mail_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelMailRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* repeated uint32 mail_id_list = 4; */
        if (message.mailIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DelMailRsp
 */
export const DelMailRsp = new DelMailRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelTeamEntityNotify$Type extends MessageType<DelTeamEntityNotify> {
    constructor() {
        super("DelTeamEntityNotify", [
            { no: 8, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "del_entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DelTeamEntityNotify>): DelTeamEntityNotify {
        const message = { sceneId: 0, delEntityIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelTeamEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelTeamEntityNotify): DelTeamEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 8:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated uint32 del_entity_id_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delEntityIdList.push(reader.uint32());
                    else
                        message.delEntityIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelTeamEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 8; */
        if (message.sceneId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.sceneId);
        /* repeated uint32 del_entity_id_list = 15; */
        if (message.delEntityIdList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delEntityIdList.length; i++)
                writer.uint32(message.delEntityIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DelTeamEntityNotify
 */
export const DelTeamEntityNotify = new DelTeamEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DestroyMaterialReq$Type extends MessageType<DestroyMaterialReq> {
    constructor() {
        super("DestroyMaterialReq", [
            { no: 12, name: "material_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MaterialInfo }
        ]);
    }
    create(value?: PartialMessage<DestroyMaterialReq>): DestroyMaterialReq {
        const message = { materialList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DestroyMaterialReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DestroyMaterialReq): DestroyMaterialReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MaterialInfo material_list */ 12:
                    message.materialList.push(MaterialInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DestroyMaterialReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MaterialInfo material_list = 12; */
        for (let i = 0; i < message.materialList.length; i++)
            MaterialInfo.internalBinaryWrite(message.materialList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DestroyMaterialReq
 */
export const DestroyMaterialReq = new DestroyMaterialReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DestroyMaterialRsp$Type extends MessageType<DestroyMaterialRsp> {
    constructor() {
        super("DestroyMaterialRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "item_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "item_count_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DestroyMaterialRsp>): DestroyMaterialRsp {
        const message = { retcode: 0, itemIdList: [], itemCountList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DestroyMaterialRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DestroyMaterialRsp): DestroyMaterialRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 item_id_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemIdList.push(reader.uint32());
                    else
                        message.itemIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 item_count_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemCountList.push(reader.uint32());
                    else
                        message.itemCountList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DestroyMaterialRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* repeated uint32 item_id_list = 11; */
        if (message.itemIdList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemIdList.length; i++)
                writer.uint32(message.itemIdList[i]);
            writer.join();
        }
        /* repeated uint32 item_count_list = 10; */
        if (message.itemCountList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemCountList.length; i++)
                writer.uint32(message.itemCountList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DestroyMaterialRsp
 */
export const DestroyMaterialRsp = new DestroyMaterialRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoGachaReq$Type extends MessageType<DoGachaReq> {
    constructor() {
        super("DoGachaReq", [
            { no: 10, name: "gacha_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "gacha_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gacha_random", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "gacha_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "gacha_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DoGachaReq>): DoGachaReq {
        const message = { gachaType: 0, gachaTimes: 0, gachaRandom: 0, gachaScheduleId: 0, gachaTag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoGachaReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoGachaReq): DoGachaReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gacha_type */ 10:
                    message.gachaType = reader.uint32();
                    break;
                case /* uint32 gacha_times */ 15:
                    message.gachaTimes = reader.uint32();
                    break;
                case /* uint32 gacha_random */ 5:
                    message.gachaRandom = reader.uint32();
                    break;
                case /* uint32 gacha_schedule_id */ 6:
                    message.gachaScheduleId = reader.uint32();
                    break;
                case /* string gacha_tag */ 4:
                    message.gachaTag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoGachaReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gacha_type = 10; */
        if (message.gachaType !== 0)
            writer.tag(10, WireType.Varint).uint32(message.gachaType);
        /* uint32 gacha_times = 15; */
        if (message.gachaTimes !== 0)
            writer.tag(15, WireType.Varint).uint32(message.gachaTimes);
        /* uint32 gacha_random = 5; */
        if (message.gachaRandom !== 0)
            writer.tag(5, WireType.Varint).uint32(message.gachaRandom);
        /* uint32 gacha_schedule_id = 6; */
        if (message.gachaScheduleId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.gachaScheduleId);
        /* string gacha_tag = 4; */
        if (message.gachaTag !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.gachaTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DoGachaReq
 */
export const DoGachaReq = new DoGachaReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoGachaRsp$Type extends MessageType<DoGachaRsp> {
    constructor() {
        super("DoGachaRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "gacha_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "gacha_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "gacha_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gacha_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GachaItem },
            { no: 8, name: "new_gacha_random", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "cost_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "cost_item_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "ten_cost_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ten_cost_item_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "left_gacha_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "gacha_times_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "wish_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "wish_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "wish_max_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DoGachaRsp>): DoGachaRsp {
        const message = { retcode: 0, gachaType: 0, gachaTimes: 0, gachaScheduleId: 0, gachaItemList: [], newGachaRandom: 0, costItemId: 0, costItemNum: 0, tenCostItemId: 0, tenCostItemNum: 0, leftGachaTimes: 0, gachaTimesLimit: 0, wishItemId: 0, wishProgress: 0, wishMaxProgress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoGachaRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoGachaRsp): DoGachaRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 gacha_type */ 11:
                    message.gachaType = reader.uint32();
                    break;
                case /* uint32 gacha_times */ 3:
                    message.gachaTimes = reader.uint32();
                    break;
                case /* uint32 gacha_schedule_id */ 4:
                    message.gachaScheduleId = reader.uint32();
                    break;
                case /* repeated GachaItem gacha_item_list */ 2:
                    message.gachaItemList.push(GachaItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 new_gacha_random */ 8:
                    message.newGachaRandom = reader.uint32();
                    break;
                case /* uint32 cost_item_id */ 6:
                    message.costItemId = reader.uint32();
                    break;
                case /* uint32 cost_item_num */ 1:
                    message.costItemNum = reader.uint32();
                    break;
                case /* uint32 ten_cost_item_id */ 14:
                    message.tenCostItemId = reader.uint32();
                    break;
                case /* uint32 ten_cost_item_num */ 7:
                    message.tenCostItemNum = reader.uint32();
                    break;
                case /* uint32 left_gacha_times */ 15:
                    message.leftGachaTimes = reader.uint32();
                    break;
                case /* uint32 gacha_times_limit */ 13:
                    message.gachaTimesLimit = reader.uint32();
                    break;
                case /* uint32 wish_item_id */ 10:
                    message.wishItemId = reader.uint32();
                    break;
                case /* uint32 wish_progress */ 5:
                    message.wishProgress = reader.uint32();
                    break;
                case /* uint32 wish_max_progress */ 12:
                    message.wishMaxProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoGachaRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 gacha_type = 11; */
        if (message.gachaType !== 0)
            writer.tag(11, WireType.Varint).uint32(message.gachaType);
        /* uint32 gacha_times = 3; */
        if (message.gachaTimes !== 0)
            writer.tag(3, WireType.Varint).uint32(message.gachaTimes);
        /* uint32 gacha_schedule_id = 4; */
        if (message.gachaScheduleId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.gachaScheduleId);
        /* repeated GachaItem gacha_item_list = 2; */
        for (let i = 0; i < message.gachaItemList.length; i++)
            GachaItem.internalBinaryWrite(message.gachaItemList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 new_gacha_random = 8; */
        if (message.newGachaRandom !== 0)
            writer.tag(8, WireType.Varint).uint32(message.newGachaRandom);
        /* uint32 cost_item_id = 6; */
        if (message.costItemId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.costItemId);
        /* uint32 cost_item_num = 1; */
        if (message.costItemNum !== 0)
            writer.tag(1, WireType.Varint).uint32(message.costItemNum);
        /* uint32 ten_cost_item_id = 14; */
        if (message.tenCostItemId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.tenCostItemId);
        /* uint32 ten_cost_item_num = 7; */
        if (message.tenCostItemNum !== 0)
            writer.tag(7, WireType.Varint).uint32(message.tenCostItemNum);
        /* uint32 left_gacha_times = 15; */
        if (message.leftGachaTimes !== 0)
            writer.tag(15, WireType.Varint).uint32(message.leftGachaTimes);
        /* uint32 gacha_times_limit = 13; */
        if (message.gachaTimesLimit !== 0)
            writer.tag(13, WireType.Varint).uint32(message.gachaTimesLimit);
        /* uint32 wish_item_id = 10; */
        if (message.wishItemId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.wishItemId);
        /* uint32 wish_progress = 5; */
        if (message.wishProgress !== 0)
            writer.tag(5, WireType.Varint).uint32(message.wishProgress);
        /* uint32 wish_max_progress = 12; */
        if (message.wishMaxProgress !== 0)
            writer.tag(12, WireType.Varint).uint32(message.wishMaxProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DoGachaRsp
 */
export const DoGachaRsp = new DoGachaRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropHintNotify$Type extends MessageType<DropHintNotify> {
    constructor() {
        super("DropHintNotify", [
            { no: 12, name: "item_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "position", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<DropHintNotify>): DropHintNotify {
        const message = { itemIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DropHintNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DropHintNotify): DropHintNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 item_id_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemIdList.push(reader.uint32());
                    else
                        message.itemIdList.push(reader.uint32());
                    break;
                case /* Vector position */ 1:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DropHintNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 item_id_list = 12; */
        if (message.itemIdList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemIdList.length; i++)
                writer.uint32(message.itemIdList[i]);
            writer.join();
        }
        /* Vector position = 1; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DropHintNotify
 */
export const DropHintNotify = new DropHintNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonChallengeBeginNotify$Type extends MessageType<DungeonChallengeBeginNotify> {
    constructor() {
        super("DungeonChallengeBeginNotify", [
            { no: 8, name: "challenge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "challenge_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "param_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "father_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DungeonChallengeBeginNotify>): DungeonChallengeBeginNotify {
        const message = { challengeId: 0, challengeIndex: 0, paramList: [], groupId: 0, fatherIndex: 0, uidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonChallengeBeginNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonChallengeBeginNotify): DungeonChallengeBeginNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 challenge_id */ 8:
                    message.challengeId = reader.uint32();
                    break;
                case /* uint32 challenge_index */ 11:
                    message.challengeIndex = reader.uint32();
                    break;
                case /* repeated uint32 param_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.uint32());
                    else
                        message.paramList.push(reader.uint32());
                    break;
                case /* uint32 group_id */ 12:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 father_index */ 6:
                    message.fatherIndex = reader.uint32();
                    break;
                case /* repeated uint32 uid_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uidList.push(reader.uint32());
                    else
                        message.uidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonChallengeBeginNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 challenge_id = 8; */
        if (message.challengeId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.challengeId);
        /* uint32 challenge_index = 11; */
        if (message.challengeIndex !== 0)
            writer.tag(11, WireType.Varint).uint32(message.challengeIndex);
        /* repeated uint32 param_list = 13; */
        if (message.paramList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.uint32(message.paramList[i]);
            writer.join();
        }
        /* uint32 group_id = 12; */
        if (message.groupId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.groupId);
        /* uint32 father_index = 6; */
        if (message.fatherIndex !== 0)
            writer.tag(6, WireType.Varint).uint32(message.fatherIndex);
        /* repeated uint32 uid_list = 9; */
        if (message.uidList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uidList.length; i++)
                writer.uint32(message.uidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonChallengeBeginNotify
 */
export const DungeonChallengeBeginNotify = new DungeonChallengeBeginNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonChallengeFinishNotify$Type extends MessageType<DungeonChallengeFinishNotify> {
    constructor() {
        super("DungeonChallengeFinishNotify", [
            { no: 1758, name: "channeller_slab_loop_dungeon_result_info", kind: "message", oneof: "detail", T: () => ChannellerSlabLoopDungeonResultInfo },
            { no: 913, name: "effigy_challenge_dungeon_result_info", kind: "message", oneof: "detail", T: () => EffigyChallengeDungeonResultInfo },
            { no: 11, name: "challenge_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "is_new_record", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "challenge_record_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "current_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "strengthen_point_data_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => StrengthenPointData } }
        ]);
    }
    create(value?: PartialMessage<DungeonChallengeFinishNotify>): DungeonChallengeFinishNotify {
        const message = { detail: { oneofKind: undefined }, challengeIndex: 0, isSuccess: false, isNewRecord: false, challengeRecordType: 0, currentValue: 0, strengthenPointDataMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonChallengeFinishNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonChallengeFinishNotify): DungeonChallengeFinishNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info */ 1758:
                    message.detail = {
                        oneofKind: "channellerSlabLoopDungeonResultInfo",
                        channellerSlabLoopDungeonResultInfo: ChannellerSlabLoopDungeonResultInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).channellerSlabLoopDungeonResultInfo)
                    };
                    break;
                case /* EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info */ 913:
                    message.detail = {
                        oneofKind: "effigyChallengeDungeonResultInfo",
                        effigyChallengeDungeonResultInfo: EffigyChallengeDungeonResultInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).effigyChallengeDungeonResultInfo)
                    };
                    break;
                case /* uint32 challenge_index */ 11:
                    message.challengeIndex = reader.uint32();
                    break;
                case /* bool is_success */ 4:
                    message.isSuccess = reader.bool();
                    break;
                case /* bool is_new_record */ 2:
                    message.isNewRecord = reader.bool();
                    break;
                case /* uint32 challenge_record_type */ 10:
                    message.challengeRecordType = reader.uint32();
                    break;
                case /* uint32 current_value */ 12:
                    message.currentValue = reader.uint32();
                    break;
                case /* map<uint32, StrengthenPointData> strengthen_point_data_map */ 13:
                    this.binaryReadMap13(message.strengthenPointDataMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: DungeonChallengeFinishNotify["strengthenPointDataMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DungeonChallengeFinishNotify["strengthenPointDataMap"] | undefined, val: DungeonChallengeFinishNotify["strengthenPointDataMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = StrengthenPointData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DungeonChallengeFinishNotify.strengthen_point_data_map");
            }
        }
        map[key ?? 0] = val ?? StrengthenPointData.create();
    }
    internalBinaryWrite(message: DungeonChallengeFinishNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info = 1758; */
        if (message.detail.oneofKind === "channellerSlabLoopDungeonResultInfo")
            ChannellerSlabLoopDungeonResultInfo.internalBinaryWrite(message.detail.channellerSlabLoopDungeonResultInfo, writer.tag(1758, WireType.LengthDelimited).fork(), options).join();
        /* EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info = 913; */
        if (message.detail.oneofKind === "effigyChallengeDungeonResultInfo")
            EffigyChallengeDungeonResultInfo.internalBinaryWrite(message.detail.effigyChallengeDungeonResultInfo, writer.tag(913, WireType.LengthDelimited).fork(), options).join();
        /* uint32 challenge_index = 11; */
        if (message.challengeIndex !== 0)
            writer.tag(11, WireType.Varint).uint32(message.challengeIndex);
        /* bool is_success = 4; */
        if (message.isSuccess !== false)
            writer.tag(4, WireType.Varint).bool(message.isSuccess);
        /* bool is_new_record = 2; */
        if (message.isNewRecord !== false)
            writer.tag(2, WireType.Varint).bool(message.isNewRecord);
        /* uint32 challenge_record_type = 10; */
        if (message.challengeRecordType !== 0)
            writer.tag(10, WireType.Varint).uint32(message.challengeRecordType);
        /* uint32 current_value = 12; */
        if (message.currentValue !== 0)
            writer.tag(12, WireType.Varint).uint32(message.currentValue);
        /* map<uint32, StrengthenPointData> strengthen_point_data_map = 13; */
        for (let k of Object.keys(message.strengthenPointDataMap)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            StrengthenPointData.internalBinaryWrite(message.strengthenPointDataMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonChallengeFinishNotify
 */
export const DungeonChallengeFinishNotify = new DungeonChallengeFinishNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonDataNotify$Type extends MessageType<DungeonDataNotify> {
    constructor() {
        super("DungeonDataNotify", [
            { no: 6, name: "dungeon_data_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<DungeonDataNotify>): DungeonDataNotify {
        const message = { dungeonDataMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonDataNotify): DungeonDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> dungeon_data_map */ 6:
                    this.binaryReadMap6(message.dungeonDataMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: DungeonDataNotify["dungeonDataMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DungeonDataNotify["dungeonDataMap"] | undefined, val: DungeonDataNotify["dungeonDataMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DungeonDataNotify.dungeon_data_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: DungeonDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> dungeon_data_map = 6; */
        for (let k of Object.keys(message.dungeonDataMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.dungeonDataMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonDataNotify
 */
export const DungeonDataNotify = new DungeonDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonEntryInfo$Type extends MessageType<DungeonEntryInfo> {
    constructor() {
        super("DungeonEntryInfo", [
            { no: 8, name: "dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_passed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "left_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "max_boss_chest_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "boss_chest_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "next_refresh_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "weekly_boss_resin_discount_info", kind: "message", T: () => WeeklyBossResinDiscountInfo }
        ]);
    }
    create(value?: PartialMessage<DungeonEntryInfo>): DungeonEntryInfo {
        const message = { dungeonId: 0, isPassed: false, leftTimes: 0, startTime: 0, endTime: 0, maxBossChestNum: 0, bossChestNum: 0, nextRefreshTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonEntryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonEntryInfo): DungeonEntryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 dungeon_id */ 8:
                    message.dungeonId = reader.uint32();
                    break;
                case /* bool is_passed */ 15:
                    message.isPassed = reader.bool();
                    break;
                case /* uint32 left_times */ 2:
                    message.leftTimes = reader.uint32();
                    break;
                case /* uint32 start_time */ 7:
                    message.startTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 3:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 max_boss_chest_num */ 9:
                    message.maxBossChestNum = reader.uint32();
                    break;
                case /* uint32 boss_chest_num */ 13:
                    message.bossChestNum = reader.uint32();
                    break;
                case /* uint32 next_refresh_time */ 10:
                    message.nextRefreshTime = reader.uint32();
                    break;
                case /* WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info */ 1:
                    message.weeklyBossResinDiscountInfo = WeeklyBossResinDiscountInfo.internalBinaryRead(reader, reader.uint32(), options, message.weeklyBossResinDiscountInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonEntryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 dungeon_id = 8; */
        if (message.dungeonId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.dungeonId);
        /* bool is_passed = 15; */
        if (message.isPassed !== false)
            writer.tag(15, WireType.Varint).bool(message.isPassed);
        /* uint32 left_times = 2; */
        if (message.leftTimes !== 0)
            writer.tag(2, WireType.Varint).uint32(message.leftTimes);
        /* uint32 start_time = 7; */
        if (message.startTime !== 0)
            writer.tag(7, WireType.Varint).uint32(message.startTime);
        /* uint32 end_time = 3; */
        if (message.endTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.endTime);
        /* uint32 max_boss_chest_num = 9; */
        if (message.maxBossChestNum !== 0)
            writer.tag(9, WireType.Varint).uint32(message.maxBossChestNum);
        /* uint32 boss_chest_num = 13; */
        if (message.bossChestNum !== 0)
            writer.tag(13, WireType.Varint).uint32(message.bossChestNum);
        /* uint32 next_refresh_time = 10; */
        if (message.nextRefreshTime !== 0)
            writer.tag(10, WireType.Varint).uint32(message.nextRefreshTime);
        /* WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info = 1; */
        if (message.weeklyBossResinDiscountInfo)
            WeeklyBossResinDiscountInfo.internalBinaryWrite(message.weeklyBossResinDiscountInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonEntryInfo
 */
export const DungeonEntryInfo = new DungeonEntryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonEntryInfoReq$Type extends MessageType<DungeonEntryInfoReq> {
    constructor() {
        super("DungeonEntryInfoReq", [
            { no: 15, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DungeonEntryInfoReq>): DungeonEntryInfoReq {
        const message = { pointId: 0, sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonEntryInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonEntryInfoReq): DungeonEntryInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 point_id */ 15:
                    message.pointId = reader.uint32();
                    break;
                case /* uint32 scene_id */ 3:
                    message.sceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonEntryInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 point_id = 15; */
        if (message.pointId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.pointId);
        /* uint32 scene_id = 3; */
        if (message.sceneId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonEntryInfoReq
 */
export const DungeonEntryInfoReq = new DungeonEntryInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonEntryInfoRsp$Type extends MessageType<DungeonEntryInfoRsp> {
    constructor() {
        super("DungeonEntryInfoRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "dungeon_entry_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DungeonEntryInfo },
            { no: 4, name: "recommend_dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DungeonEntryInfoRsp>): DungeonEntryInfoRsp {
        const message = { retcode: 0, pointId: 0, dungeonEntryList: [], recommendDungeonId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonEntryInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonEntryInfoRsp): DungeonEntryInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 point_id */ 9:
                    message.pointId = reader.uint32();
                    break;
                case /* repeated DungeonEntryInfo dungeon_entry_list */ 10:
                    message.dungeonEntryList.push(DungeonEntryInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 recommend_dungeon_id */ 4:
                    message.recommendDungeonId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonEntryInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint32 point_id = 9; */
        if (message.pointId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.pointId);
        /* repeated DungeonEntryInfo dungeon_entry_list = 10; */
        for (let i = 0; i < message.dungeonEntryList.length; i++)
            DungeonEntryInfo.internalBinaryWrite(message.dungeonEntryList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* uint32 recommend_dungeon_id = 4; */
        if (message.recommendDungeonId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.recommendDungeonId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonEntryInfoRsp
 */
export const DungeonEntryInfoRsp = new DungeonEntryInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonGetStatueDropRsp$Type extends MessageType<DungeonGetStatueDropRsp> {
    constructor() {
        super("DungeonGetStatueDropRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DungeonGetStatueDropRsp>): DungeonGetStatueDropRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonGetStatueDropRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonGetStatueDropRsp): DungeonGetStatueDropRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonGetStatueDropRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonGetStatueDropRsp
 */
export const DungeonGetStatueDropRsp = new DungeonGetStatueDropRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonSettleExhibitionInfo$Type extends MessageType<DungeonSettleExhibitionInfo> {
    constructor() {
        super("DungeonSettleExhibitionInfo", [
            { no: 3, name: "player_info", kind: "message", T: () => OnlinePlayerInfo },
            { no: 9, name: "card_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExhibitionDisplayInfo }
        ]);
    }
    create(value?: PartialMessage<DungeonSettleExhibitionInfo>): DungeonSettleExhibitionInfo {
        const message = { cardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonSettleExhibitionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonSettleExhibitionInfo): DungeonSettleExhibitionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* OnlinePlayerInfo player_info */ 3:
                    message.playerInfo = OnlinePlayerInfo.internalBinaryRead(reader, reader.uint32(), options, message.playerInfo);
                    break;
                case /* repeated ExhibitionDisplayInfo card_list */ 9:
                    message.cardList.push(ExhibitionDisplayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonSettleExhibitionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* OnlinePlayerInfo player_info = 3; */
        if (message.playerInfo)
            OnlinePlayerInfo.internalBinaryWrite(message.playerInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated ExhibitionDisplayInfo card_list = 9; */
        for (let i = 0; i < message.cardList.length; i++)
            ExhibitionDisplayInfo.internalBinaryWrite(message.cardList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonSettleExhibitionInfo
 */
export const DungeonSettleExhibitionInfo = new DungeonSettleExhibitionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonSettleNotify$Type extends MessageType<DungeonSettleNotify> {
    constructor() {
        super("DungeonSettleNotify", [
            { no: 9, name: "dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "fail_cond_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "settle_show", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ParamList } },
            { no: 12, name: "close_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "strengthen_point_data_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => StrengthenPointData } },
            { no: 15, name: "result", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "exhibition_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DungeonSettleExhibitionInfo },
            { no: 97, name: "tower_level_end_notify", kind: "message", oneof: "detail", T: () => TowerLevelEndNotify },
            { no: 796, name: "trial_avatar_first_pass_dungeon_notify", kind: "message", oneof: "detail", T: () => TrialAvatarFirstPassDungeonNotify },
            { no: 1671, name: "channeller_slab_loop_dungeon_result_info", kind: "message", oneof: "detail", T: () => ChannellerSlabLoopDungeonResultInfo },
            { no: 1638, name: "effigy_challenge_dungeon_result_info", kind: "message", oneof: "detail", T: () => EffigyChallengeDungeonResultInfo },
            { no: 71, name: "roguelike_dungeon_settle_info", kind: "message", oneof: "detail", T: () => RoguelikeDungeonSettleInfo }
        ]);
    }
    create(value?: PartialMessage<DungeonSettleNotify>): DungeonSettleNotify {
        const message = { dungeonId: 0, isSuccess: false, failCondList: [], settleShow: {}, closeTime: 0, strengthenPointDataMap: {}, result: 0, exhibitionInfoList: [], detail: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonSettleNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonSettleNotify): DungeonSettleNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 dungeon_id */ 9:
                    message.dungeonId = reader.uint32();
                    break;
                case /* bool is_success */ 10:
                    message.isSuccess = reader.bool();
                    break;
                case /* repeated uint32 fail_cond_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.failCondList.push(reader.uint32());
                    else
                        message.failCondList.push(reader.uint32());
                    break;
                case /* map<uint32, ParamList> settle_show */ 11:
                    this.binaryReadMap11(message.settleShow, reader, options);
                    break;
                case /* uint32 close_time */ 12:
                    message.closeTime = reader.uint32();
                    break;
                case /* map<uint32, StrengthenPointData> strengthen_point_data_map */ 4:
                    this.binaryReadMap4(message.strengthenPointDataMap, reader, options);
                    break;
                case /* uint32 result */ 15:
                    message.result = reader.uint32();
                    break;
                case /* repeated DungeonSettleExhibitionInfo exhibition_info_list */ 14:
                    message.exhibitionInfoList.push(DungeonSettleExhibitionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TowerLevelEndNotify tower_level_end_notify */ 97:
                    message.detail = {
                        oneofKind: "towerLevelEndNotify",
                        towerLevelEndNotify: TowerLevelEndNotify.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).towerLevelEndNotify)
                    };
                    break;
                case /* TrialAvatarFirstPassDungeonNotify trial_avatar_first_pass_dungeon_notify */ 796:
                    message.detail = {
                        oneofKind: "trialAvatarFirstPassDungeonNotify",
                        trialAvatarFirstPassDungeonNotify: TrialAvatarFirstPassDungeonNotify.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).trialAvatarFirstPassDungeonNotify)
                    };
                    break;
                case /* ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info */ 1671:
                    message.detail = {
                        oneofKind: "channellerSlabLoopDungeonResultInfo",
                        channellerSlabLoopDungeonResultInfo: ChannellerSlabLoopDungeonResultInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).channellerSlabLoopDungeonResultInfo)
                    };
                    break;
                case /* EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info */ 1638:
                    message.detail = {
                        oneofKind: "effigyChallengeDungeonResultInfo",
                        effigyChallengeDungeonResultInfo: EffigyChallengeDungeonResultInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).effigyChallengeDungeonResultInfo)
                    };
                    break;
                case /* RoguelikeDungeonSettleInfo roguelike_dungeon_settle_info */ 71:
                    message.detail = {
                        oneofKind: "roguelikeDungeonSettleInfo",
                        roguelikeDungeonSettleInfo: RoguelikeDungeonSettleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).roguelikeDungeonSettleInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: DungeonSettleNotify["settleShow"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DungeonSettleNotify["settleShow"] | undefined, val: DungeonSettleNotify["settleShow"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ParamList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DungeonSettleNotify.settle_show");
            }
        }
        map[key ?? 0] = val ?? ParamList.create();
    }
    private binaryReadMap4(map: DungeonSettleNotify["strengthenPointDataMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DungeonSettleNotify["strengthenPointDataMap"] | undefined, val: DungeonSettleNotify["strengthenPointDataMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = StrengthenPointData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field DungeonSettleNotify.strengthen_point_data_map");
            }
        }
        map[key ?? 0] = val ?? StrengthenPointData.create();
    }
    internalBinaryWrite(message: DungeonSettleNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 dungeon_id = 9; */
        if (message.dungeonId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.dungeonId);
        /* bool is_success = 10; */
        if (message.isSuccess !== false)
            writer.tag(10, WireType.Varint).bool(message.isSuccess);
        /* repeated uint32 fail_cond_list = 13; */
        if (message.failCondList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.failCondList.length; i++)
                writer.uint32(message.failCondList[i]);
            writer.join();
        }
        /* map<uint32, ParamList> settle_show = 11; */
        for (let k of Object.keys(message.settleShow)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ParamList.internalBinaryWrite(message.settleShow[k as any], writer, options);
            writer.join().join();
        }
        /* uint32 close_time = 12; */
        if (message.closeTime !== 0)
            writer.tag(12, WireType.Varint).uint32(message.closeTime);
        /* map<uint32, StrengthenPointData> strengthen_point_data_map = 4; */
        for (let k of Object.keys(message.strengthenPointDataMap)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            StrengthenPointData.internalBinaryWrite(message.strengthenPointDataMap[k as any], writer, options);
            writer.join().join();
        }
        /* uint32 result = 15; */
        if (message.result !== 0)
            writer.tag(15, WireType.Varint).uint32(message.result);
        /* repeated DungeonSettleExhibitionInfo exhibition_info_list = 14; */
        for (let i = 0; i < message.exhibitionInfoList.length; i++)
            DungeonSettleExhibitionInfo.internalBinaryWrite(message.exhibitionInfoList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* TowerLevelEndNotify tower_level_end_notify = 97; */
        if (message.detail.oneofKind === "towerLevelEndNotify")
            TowerLevelEndNotify.internalBinaryWrite(message.detail.towerLevelEndNotify, writer.tag(97, WireType.LengthDelimited).fork(), options).join();
        /* TrialAvatarFirstPassDungeonNotify trial_avatar_first_pass_dungeon_notify = 796; */
        if (message.detail.oneofKind === "trialAvatarFirstPassDungeonNotify")
            TrialAvatarFirstPassDungeonNotify.internalBinaryWrite(message.detail.trialAvatarFirstPassDungeonNotify, writer.tag(796, WireType.LengthDelimited).fork(), options).join();
        /* ChannellerSlabLoopDungeonResultInfo channeller_slab_loop_dungeon_result_info = 1671; */
        if (message.detail.oneofKind === "channellerSlabLoopDungeonResultInfo")
            ChannellerSlabLoopDungeonResultInfo.internalBinaryWrite(message.detail.channellerSlabLoopDungeonResultInfo, writer.tag(1671, WireType.LengthDelimited).fork(), options).join();
        /* EffigyChallengeDungeonResultInfo effigy_challenge_dungeon_result_info = 1638; */
        if (message.detail.oneofKind === "effigyChallengeDungeonResultInfo")
            EffigyChallengeDungeonResultInfo.internalBinaryWrite(message.detail.effigyChallengeDungeonResultInfo, writer.tag(1638, WireType.LengthDelimited).fork(), options).join();
        /* RoguelikeDungeonSettleInfo roguelike_dungeon_settle_info = 71; */
        if (message.detail.oneofKind === "roguelikeDungeonSettleInfo")
            RoguelikeDungeonSettleInfo.internalBinaryWrite(message.detail.roguelikeDungeonSettleInfo, writer.tag(71, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonSettleNotify
 */
export const DungeonSettleNotify = new DungeonSettleNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonShowReminderNotify$Type extends MessageType<DungeonShowReminderNotify> {
    constructor() {
        super("DungeonShowReminderNotify", [
            { no: 10, name: "reminder_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DungeonShowReminderNotify>): DungeonShowReminderNotify {
        const message = { reminderId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonShowReminderNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonShowReminderNotify): DungeonShowReminderNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 reminder_id */ 10:
                    message.reminderId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonShowReminderNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 reminder_id = 10; */
        if (message.reminderId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.reminderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonShowReminderNotify
 */
export const DungeonShowReminderNotify = new DungeonShowReminderNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoShellInfo$Type extends MessageType<EchoShellInfo> {
    constructor() {
        super("EchoShellInfo", [
            { no: 1, name: "shell_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EchoShellInfo>): EchoShellInfo {
        const message = { shellId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EchoShellInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoShellInfo): EchoShellInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shell_id */ 1:
                    message.shellId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoShellInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shell_id = 1; */
        if (message.shellId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.shellId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EchoShellInfo
 */
export const EchoShellInfo = new EchoShellInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EffigyChallengeDungeonResultInfo$Type extends MessageType<EffigyChallengeDungeonResultInfo> {
    constructor() {
        super("EffigyChallengeDungeonResultInfo", [
            { no: 1, name: "challenge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "challenge_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "challenge_max_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_in_time_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EffigyChallengeDungeonResultInfo>): EffigyChallengeDungeonResultInfo {
        const message = { challengeId: 0, isSuccess: false, challengeScore: 0, challengeMaxScore: 0, isInTimeLimit: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EffigyChallengeDungeonResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffigyChallengeDungeonResultInfo): EffigyChallengeDungeonResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 challenge_id */ 1:
                    message.challengeId = reader.uint32();
                    break;
                case /* bool is_success */ 2:
                    message.isSuccess = reader.bool();
                    break;
                case /* uint32 challenge_score */ 3:
                    message.challengeScore = reader.uint32();
                    break;
                case /* uint32 challenge_max_score */ 4:
                    message.challengeMaxScore = reader.uint32();
                    break;
                case /* bool is_in_time_limit */ 5:
                    message.isInTimeLimit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EffigyChallengeDungeonResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 challenge_id = 1; */
        if (message.challengeId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.challengeId);
        /* bool is_success = 2; */
        if (message.isSuccess !== false)
            writer.tag(2, WireType.Varint).bool(message.isSuccess);
        /* uint32 challenge_score = 3; */
        if (message.challengeScore !== 0)
            writer.tag(3, WireType.Varint).uint32(message.challengeScore);
        /* uint32 challenge_max_score = 4; */
        if (message.challengeMaxScore !== 0)
            writer.tag(4, WireType.Varint).uint32(message.challengeMaxScore);
        /* bool is_in_time_limit = 5; */
        if (message.isInTimeLimit !== false)
            writer.tag(5, WireType.Varint).bool(message.isInTimeLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EffigyChallengeDungeonResultInfo
 */
export const EffigyChallengeDungeonResultInfo = new EffigyChallengeDungeonResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterSceneDoneRsp$Type extends MessageType<EnterSceneDoneRsp> {
    constructor() {
        super("EnterSceneDoneRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterSceneDoneRsp>): EnterSceneDoneRsp {
        const message = { retcode: 0, enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterSceneDoneRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterSceneDoneRsp): EnterSceneDoneRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 enter_scene_token */ 8:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterSceneDoneRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 enter_scene_token = 8; */
        if (message.enterSceneToken !== 0)
            writer.tag(8, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterSceneDoneRsp
 */
export const EnterSceneDoneRsp = new EnterSceneDoneRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterScenePeerNotify$Type extends MessageType<EnterScenePeerNotify> {
    constructor() {
        super("EnterScenePeerNotify", [
            { no: 13, name: "dest_scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "host_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterScenePeerNotify>): EnterScenePeerNotify {
        const message = { destSceneId: 0, peerId: 0, hostPeerId: 0, enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterScenePeerNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterScenePeerNotify): EnterScenePeerNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 dest_scene_id */ 13:
                    message.destSceneId = reader.uint32();
                    break;
                case /* uint32 peer_id */ 11:
                    message.peerId = reader.uint32();
                    break;
                case /* uint32 host_peer_id */ 6:
                    message.hostPeerId = reader.uint32();
                    break;
                case /* uint32 enter_scene_token */ 15:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterScenePeerNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 dest_scene_id = 13; */
        if (message.destSceneId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.destSceneId);
        /* uint32 peer_id = 11; */
        if (message.peerId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.peerId);
        /* uint32 host_peer_id = 6; */
        if (message.hostPeerId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.hostPeerId);
        /* uint32 enter_scene_token = 15; */
        if (message.enterSceneToken !== 0)
            writer.tag(15, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterScenePeerNotify
 */
export const EnterScenePeerNotify = new EnterScenePeerNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterSceneReadyRsp$Type extends MessageType<EnterSceneReadyRsp> {
    constructor() {
        super("EnterSceneReadyRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterSceneReadyRsp>): EnterSceneReadyRsp {
        const message = { retcode: 0, enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterSceneReadyRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterSceneReadyRsp): EnterSceneReadyRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 enter_scene_token */ 8:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterSceneReadyRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint32 enter_scene_token = 8; */
        if (message.enterSceneToken !== 0)
            writer.tag(8, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterSceneReadyRsp
 */
export const EnterSceneReadyRsp = new EnterSceneReadyRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterTransPointRegionNotify$Type extends MessageType<EnterTransPointRegionNotify> {
    constructor() {
        super("EnterTransPointRegionNotify", [
            { no: 15, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterTransPointRegionNotify>): EnterTransPointRegionNotify {
        const message = { sceneId: 0, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterTransPointRegionNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterTransPointRegionNotify): EnterTransPointRegionNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 15:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 point_id */ 12:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterTransPointRegionNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 15; */
        if (message.sceneId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.sceneId);
        /* uint32 point_id = 12; */
        if (message.pointId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterTransPointRegionNotify
 */
export const EnterTransPointRegionNotify = new EnterTransPointRegionNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterWorldAreaReq$Type extends MessageType<EnterWorldAreaReq> {
    constructor() {
        super("EnterWorldAreaReq", [
            { no: 12, name: "area_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterWorldAreaReq>): EnterWorldAreaReq {
        const message = { areaType: 0, areaId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterWorldAreaReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterWorldAreaReq): EnterWorldAreaReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 area_type */ 12:
                    message.areaType = reader.uint32();
                    break;
                case /* uint32 area_id */ 10:
                    message.areaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterWorldAreaReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 area_type = 12; */
        if (message.areaType !== 0)
            writer.tag(12, WireType.Varint).uint32(message.areaType);
        /* uint32 area_id = 10; */
        if (message.areaId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.areaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterWorldAreaReq
 */
export const EnterWorldAreaReq = new EnterWorldAreaReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterWorldAreaRsp$Type extends MessageType<EnterWorldAreaRsp> {
    constructor() {
        super("EnterWorldAreaRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "area_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterWorldAreaRsp>): EnterWorldAreaRsp {
        const message = { retcode: 0, areaType: 0, areaId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterWorldAreaRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterWorldAreaRsp): EnterWorldAreaRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 area_type */ 2:
                    message.areaType = reader.uint32();
                    break;
                case /* uint32 area_id */ 4:
                    message.areaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterWorldAreaRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 area_type = 2; */
        if (message.areaType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.areaType);
        /* uint32 area_id = 4; */
        if (message.areaId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.areaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterWorldAreaRsp
 */
export const EnterWorldAreaRsp = new EnterWorldAreaRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAiSyncNotify$Type extends MessageType<EntityAiSyncNotify> {
    constructor() {
        super("EntityAiSyncNotify", [
            { no: 1, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AiSyncInfo },
            { no: 10, name: "local_avatar_alerted_monster_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityAiSyncNotify>): EntityAiSyncNotify {
        const message = { infoList: [], localAvatarAlertedMonsterList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAiSyncNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAiSyncNotify): EntityAiSyncNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AiSyncInfo info_list */ 1:
                    message.infoList.push(AiSyncInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 local_avatar_alerted_monster_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.localAvatarAlertedMonsterList.push(reader.uint32());
                    else
                        message.localAvatarAlertedMonsterList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAiSyncNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AiSyncInfo info_list = 1; */
        for (let i = 0; i < message.infoList.length; i++)
            AiSyncInfo.internalBinaryWrite(message.infoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 local_avatar_alerted_monster_list = 10; */
        if (message.localAvatarAlertedMonsterList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.localAvatarAlertedMonsterList.length; i++)
                writer.uint32(message.localAvatarAlertedMonsterList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityAiSyncNotify
 */
export const EntityAiSyncNotify = new EntityAiSyncNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAuthorityInfo$Type extends MessageType<EntityAuthorityInfo> {
    constructor() {
        super("EntityAuthorityInfo", [
            { no: 1, name: "ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 2, name: "renderer_changed_info", kind: "message", T: () => EntityRendererChangedInfo },
            { no: 3, name: "ai_info", kind: "message", T: () => SceneEntityAiInfo },
            { no: 4, name: "born_pos", kind: "message", T: () => Vector },
            { no: 5, name: "pose_para_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnimatorParameterValueInfoPair }
        ]);
    }
    create(value?: PartialMessage<EntityAuthorityInfo>): EntityAuthorityInfo {
        const message = { poseParaList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAuthorityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAuthorityInfo): EntityAuthorityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AbilitySyncStateInfo ability_info */ 1:
                    message.abilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.abilityInfo);
                    break;
                case /* EntityRendererChangedInfo renderer_changed_info */ 2:
                    message.rendererChangedInfo = EntityRendererChangedInfo.internalBinaryRead(reader, reader.uint32(), options, message.rendererChangedInfo);
                    break;
                case /* SceneEntityAiInfo ai_info */ 3:
                    message.aiInfo = SceneEntityAiInfo.internalBinaryRead(reader, reader.uint32(), options, message.aiInfo);
                    break;
                case /* Vector born_pos */ 4:
                    message.bornPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.bornPos);
                    break;
                case /* repeated AnimatorParameterValueInfoPair pose_para_list */ 5:
                    message.poseParaList.push(AnimatorParameterValueInfoPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAuthorityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AbilitySyncStateInfo ability_info = 1; */
        if (message.abilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.abilityInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* EntityRendererChangedInfo renderer_changed_info = 2; */
        if (message.rendererChangedInfo)
            EntityRendererChangedInfo.internalBinaryWrite(message.rendererChangedInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* SceneEntityAiInfo ai_info = 3; */
        if (message.aiInfo)
            SceneEntityAiInfo.internalBinaryWrite(message.aiInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Vector born_pos = 4; */
        if (message.bornPos)
            Vector.internalBinaryWrite(message.bornPos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated AnimatorParameterValueInfoPair pose_para_list = 5; */
        for (let i = 0; i < message.poseParaList.length; i++)
            AnimatorParameterValueInfoPair.internalBinaryWrite(message.poseParaList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityAuthorityInfo
 */
export const EntityAuthorityInfo = new EntityAuthorityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityClientData$Type extends MessageType<EntityClientData> {
    constructor() {
        super("EntityClientData", [
            { no: 1, name: "wind_change_scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "windmill_sync_angle", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "wind_change_target_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityClientData>): EntityClientData {
        const message = { windChangeSceneTime: 0, windmillSyncAngle: 0, windChangeTargetLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityClientData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityClientData): EntityClientData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 wind_change_scene_time */ 1:
                    message.windChangeSceneTime = reader.uint32();
                    break;
                case /* float windmill_sync_angle */ 2:
                    message.windmillSyncAngle = reader.float();
                    break;
                case /* int32 wind_change_target_level */ 3:
                    message.windChangeTargetLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityClientData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 wind_change_scene_time = 1; */
        if (message.windChangeSceneTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.windChangeSceneTime);
        /* float windmill_sync_angle = 2; */
        if (message.windmillSyncAngle !== 0)
            writer.tag(2, WireType.Bit32).float(message.windmillSyncAngle);
        /* int32 wind_change_target_level = 3; */
        if (message.windChangeTargetLevel !== 0)
            writer.tag(3, WireType.Varint).int32(message.windChangeTargetLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityClientData
 */
export const EntityClientData = new EntityClientData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityEnvironmentInfo$Type extends MessageType<EntityEnvironmentInfo> {
    constructor() {
        super("EntityEnvironmentInfo", [
            { no: 1, name: "json_climate_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "climate_area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EntityEnvironmentInfo>): EntityEnvironmentInfo {
        const message = { jsonClimateType: 0, climateAreaId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityEnvironmentInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityEnvironmentInfo): EntityEnvironmentInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 json_climate_type */ 1:
                    message.jsonClimateType = reader.uint32();
                    break;
                case /* uint32 climate_area_id */ 2:
                    message.climateAreaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityEnvironmentInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 json_climate_type = 1; */
        if (message.jsonClimateType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.jsonClimateType);
        /* uint32 climate_area_id = 2; */
        if (message.climateAreaId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.climateAreaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityEnvironmentInfo
 */
export const EntityEnvironmentInfo = new EntityEnvironmentInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityFightPropChangeReasonNotify$Type extends MessageType<EntityFightPropChangeReasonNotify> {
    constructor() {
        super("EntityFightPropChangeReasonNotify", [
            { no: 11, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "prop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "prop_delta", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "reason", kind: "enum", T: () => ["PropChangeReason", PropChangeReason, "PROP_CHANGE_REASON_"] },
            { no: 10, name: "param_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "change_hp_reason", kind: "enum", T: () => ["ChangeHpReason", ChangeHpReason, "CHANGE_HP_REASON_"] },
            { no: 4, name: "change_energy_reson", kind: "enum", T: () => ["ChangeEnergyReason", ChangeEnergyReason, "CHANGE_ENERGY_REASON_"] }
        ]);
    }
    create(value?: PartialMessage<EntityFightPropChangeReasonNotify>): EntityFightPropChangeReasonNotify {
        const message = { entityId: 0, propType: 0, propDelta: 0, reason: 0, paramList: [], changeHpReason: 0, changeEnergyReson: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityFightPropChangeReasonNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityFightPropChangeReasonNotify): EntityFightPropChangeReasonNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 11:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 prop_type */ 6:
                    message.propType = reader.uint32();
                    break;
                case /* float prop_delta */ 9:
                    message.propDelta = reader.float();
                    break;
                case /* PropChangeReason reason */ 5:
                    message.reason = reader.int32();
                    break;
                case /* repeated uint32 param_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.uint32());
                    else
                        message.paramList.push(reader.uint32());
                    break;
                case /* ChangeHpReason change_hp_reason */ 12:
                    message.changeHpReason = reader.int32();
                    break;
                case /* ChangeEnergyReason change_energy_reson */ 4:
                    message.changeEnergyReson = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityFightPropChangeReasonNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 11; */
        if (message.entityId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.entityId);
        /* uint32 prop_type = 6; */
        if (message.propType !== 0)
            writer.tag(6, WireType.Varint).uint32(message.propType);
        /* float prop_delta = 9; */
        if (message.propDelta !== 0)
            writer.tag(9, WireType.Bit32).float(message.propDelta);
        /* PropChangeReason reason = 5; */
        if (message.reason !== 0)
            writer.tag(5, WireType.Varint).int32(message.reason);
        /* repeated uint32 param_list = 10; */
        if (message.paramList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.uint32(message.paramList[i]);
            writer.join();
        }
        /* ChangeHpReason change_hp_reason = 12; */
        if (message.changeHpReason !== 0)
            writer.tag(12, WireType.Varint).int32(message.changeHpReason);
        /* ChangeEnergyReason change_energy_reson = 4; */
        if (message.changeEnergyReson !== 0)
            writer.tag(4, WireType.Varint).int32(message.changeEnergyReson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityFightPropChangeReasonNotify
 */
export const EntityFightPropChangeReasonNotify = new EntityFightPropChangeReasonNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityFightPropUpdateNotify$Type extends MessageType<EntityFightPropUpdateNotify> {
    constructor() {
        super("EntityFightPropUpdateNotify", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<EntityFightPropUpdateNotify>): EntityFightPropUpdateNotify {
        const message = { entityId: 0, fightPropMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityFightPropUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityFightPropUpdateNotify): EntityFightPropUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* map<uint32, float> fight_prop_map */ 8:
                    this.binaryReadMap8(message.fightPropMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: EntityFightPropUpdateNotify["fightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityFightPropUpdateNotify["fightPropMap"] | undefined, val: EntityFightPropUpdateNotify["fightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field EntityFightPropUpdateNotify.fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: EntityFightPropUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* map<uint32, float> fight_prop_map = 8; */
        for (let k of Object.keys(message.fightPropMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.fightPropMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityFightPropUpdateNotify
 */
export const EntityFightPropUpdateNotify = new EntityFightPropUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityMoveInfo$Type extends MessageType<EntityMoveInfo> {
    constructor() {
        super("EntityMoveInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "motion_info", kind: "message", T: () => MotionInfo },
            { no: 3, name: "scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "reliable_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_reliable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EntityMoveInfo>): EntityMoveInfo {
        const message = { entityId: 0, sceneTime: 0, reliableSeq: 0, isReliable: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityMoveInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityMoveInfo): EntityMoveInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* MotionInfo motion_info */ 2:
                    message.motionInfo = MotionInfo.internalBinaryRead(reader, reader.uint32(), options, message.motionInfo);
                    break;
                case /* uint32 scene_time */ 3:
                    message.sceneTime = reader.uint32();
                    break;
                case /* uint32 reliable_seq */ 4:
                    message.reliableSeq = reader.uint32();
                    break;
                case /* bool is_reliable */ 5:
                    message.isReliable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityMoveInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* MotionInfo motion_info = 2; */
        if (message.motionInfo)
            MotionInfo.internalBinaryWrite(message.motionInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 scene_time = 3; */
        if (message.sceneTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sceneTime);
        /* uint32 reliable_seq = 4; */
        if (message.reliableSeq !== 0)
            writer.tag(4, WireType.Varint).uint32(message.reliableSeq);
        /* bool is_reliable = 5; */
        if (message.isReliable !== false)
            writer.tag(5, WireType.Varint).bool(message.isReliable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityMoveInfo
 */
export const EntityMoveInfo = new EntityMoveInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityPropNotify$Type extends MessageType<EntityPropNotify> {
    constructor() {
        super("EntityPropNotify", [
            { no: 5, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } }
        ]);
    }
    create(value?: PartialMessage<EntityPropNotify>): EntityPropNotify {
        const message = { entityId: 0, propMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityPropNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityPropNotify): EntityPropNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 5:
                    message.entityId = reader.uint32();
                    break;
                case /* map<uint32, PropValue> prop_map */ 4:
                    this.binaryReadMap4(message.propMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: EntityPropNotify["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityPropNotify["propMap"] | undefined, val: EntityPropNotify["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field EntityPropNotify.prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    internalBinaryWrite(message: EntityPropNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 5; */
        if (message.entityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.entityId);
        /* map<uint32, PropValue> prop_map = 4; */
        for (let k of Object.keys(message.propMap)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.propMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityPropNotify
 */
export const EntityPropNotify = new EntityPropNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityRendererChangedInfo$Type extends MessageType<EntityRendererChangedInfo> {
    constructor() {
        super("EntityRendererChangedInfo", [
            { no: 1, name: "changed_renderers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 2, name: "visibility_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_cached", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EntityRendererChangedInfo>): EntityRendererChangedInfo {
        const message = { changedRenderers: {}, visibilityCount: 0, isCached: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityRendererChangedInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityRendererChangedInfo): EntityRendererChangedInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint32> changed_renderers */ 1:
                    this.binaryReadMap1(message.changedRenderers, reader, options);
                    break;
                case /* uint32 visibility_count */ 2:
                    message.visibilityCount = reader.uint32();
                    break;
                case /* bool is_cached */ 3:
                    message.isCached = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: EntityRendererChangedInfo["changedRenderers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityRendererChangedInfo["changedRenderers"] | undefined, val: EntityRendererChangedInfo["changedRenderers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field EntityRendererChangedInfo.changed_renderers");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: EntityRendererChangedInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint32> changed_renderers = 1; */
        for (let k of Object.keys(message.changedRenderers))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint32(message.changedRenderers[k]).join();
        /* uint32 visibility_count = 2; */
        if (message.visibilityCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.visibilityCount);
        /* bool is_cached = 3; */
        if (message.isCached !== false)
            writer.tag(3, WireType.Varint).bool(message.isCached);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EntityRendererChangedInfo
 */
export const EntityRendererChangedInfo = new EntityRendererChangedInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Equip$Type extends MessageType<Equip> {
    constructor() {
        super("Equip", [
            { no: 1, name: "reliquary", kind: "message", oneof: "detail", T: () => Reliquary },
            { no: 2, name: "weapon", kind: "message", oneof: "detail", T: () => Weapon },
            { no: 3, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Equip>): Equip {
        const message = { detail: { oneofKind: undefined }, isLocked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Equip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Equip): Equip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Reliquary reliquary */ 1:
                    message.detail = {
                        oneofKind: "reliquary",
                        reliquary: Reliquary.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).reliquary)
                    };
                    break;
                case /* Weapon weapon */ 2:
                    message.detail = {
                        oneofKind: "weapon",
                        weapon: Weapon.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).weapon)
                    };
                    break;
                case /* bool is_locked */ 3:
                    message.isLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Equip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Reliquary reliquary = 1; */
        if (message.detail.oneofKind === "reliquary")
            Reliquary.internalBinaryWrite(message.detail.reliquary, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Weapon weapon = 2; */
        if (message.detail.oneofKind === "weapon")
            Weapon.internalBinaryWrite(message.detail.weapon, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool is_locked = 3; */
        if (message.isLocked !== false)
            writer.tag(3, WireType.Varint).bool(message.isLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Equip
 */
export const Equip = new Equip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipParam$Type extends MessageType<EquipParam> {
    constructor() {
        super("EquipParam", [
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "item_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "item_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EquipParam>): EquipParam {
        const message = { itemId: 0, itemNum: 0, itemLevel: 0, promoteLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipParam): EquipParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                case /* uint32 item_num */ 2:
                    message.itemNum = reader.uint32();
                    break;
                case /* uint32 item_level */ 3:
                    message.itemLevel = reader.uint32();
                    break;
                case /* uint32 promote_level */ 4:
                    message.promoteLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        /* uint32 item_num = 2; */
        if (message.itemNum !== 0)
            writer.tag(2, WireType.Varint).uint32(message.itemNum);
        /* uint32 item_level = 3; */
        if (message.itemLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.itemLevel);
        /* uint32 promote_level = 4; */
        if (message.promoteLevel !== 0)
            writer.tag(4, WireType.Varint).uint32(message.promoteLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipParam
 */
export const EquipParam = new EquipParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAiSyncCombatThreatInfoNotify$Type extends MessageType<EvtAiSyncCombatThreatInfoNotify> {
    constructor() {
        super("EvtAiSyncCombatThreatInfoNotify", [
            { no: 14, name: "combat_threat_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AiThreatInfo } }
        ]);
    }
    create(value?: PartialMessage<EvtAiSyncCombatThreatInfoNotify>): EvtAiSyncCombatThreatInfoNotify {
        const message = { combatThreatInfoMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAiSyncCombatThreatInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAiSyncCombatThreatInfoNotify): EvtAiSyncCombatThreatInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, AiThreatInfo> combat_threat_info_map */ 14:
                    this.binaryReadMap14(message.combatThreatInfoMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap14(map: EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"] | undefined, val: EvtAiSyncCombatThreatInfoNotify["combatThreatInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AiThreatInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field EvtAiSyncCombatThreatInfoNotify.combat_threat_info_map");
            }
        }
        map[key ?? 0] = val ?? AiThreatInfo.create();
    }
    internalBinaryWrite(message: EvtAiSyncCombatThreatInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, AiThreatInfo> combat_threat_info_map = 14; */
        for (let k of Object.keys(message.combatThreatInfoMap)) {
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AiThreatInfo.internalBinaryWrite(message.combatThreatInfoMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAiSyncCombatThreatInfoNotify
 */
export const EvtAiSyncCombatThreatInfoNotify = new EvtAiSyncCombatThreatInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAiSyncSkillCdNotify$Type extends MessageType<EvtAiSyncSkillCdNotify> {
    constructor() {
        super("EvtAiSyncSkillCdNotify", [
            { no: 5, name: "ai_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => AiSkillCdInfo } }
        ]);
    }
    create(value?: PartialMessage<EvtAiSyncSkillCdNotify>): EvtAiSyncSkillCdNotify {
        const message = { aiCdMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAiSyncSkillCdNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAiSyncSkillCdNotify): EvtAiSyncSkillCdNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, AiSkillCdInfo> ai_cd_map */ 5:
                    this.binaryReadMap5(message.aiCdMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: EvtAiSyncSkillCdNotify["aiCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EvtAiSyncSkillCdNotify["aiCdMap"] | undefined, val: EvtAiSyncSkillCdNotify["aiCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = AiSkillCdInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field EvtAiSyncSkillCdNotify.ai_cd_map");
            }
        }
        map[key ?? 0] = val ?? AiSkillCdInfo.create();
    }
    internalBinaryWrite(message: EvtAiSyncSkillCdNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, AiSkillCdInfo> ai_cd_map = 5; */
        for (let k of Object.keys(message.aiCdMap)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            AiSkillCdInfo.internalBinaryWrite(message.aiCdMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAiSyncSkillCdNotify
 */
export const EvtAiSyncSkillCdNotify = new EvtAiSyncSkillCdNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarLockChairReq$Type extends MessageType<EvtAvatarLockChairReq> {
    constructor() {
        super("EvtAvatarLockChairReq", [
            { no: 10, name: "chair_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "position", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarLockChairReq>): EvtAvatarLockChairReq {
        const message = { chairId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarLockChairReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarLockChairReq): EvtAvatarLockChairReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 chair_id */ 10:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                case /* Vector position */ 3:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarLockChairReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 chair_id = 10; */
        if (message.chairId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.chairId);
        /* Vector position = 3; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAvatarLockChairReq
 */
export const EvtAvatarLockChairReq = new EvtAvatarLockChairReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarLockChairRsp$Type extends MessageType<EvtAvatarLockChairRsp> {
    constructor() {
        super("EvtAvatarLockChairRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "position", kind: "message", T: () => Vector },
            { no: 15, name: "chair_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarLockChairRsp>): EvtAvatarLockChairRsp {
        const message = { retcode: 0, entityId: 0, chairId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarLockChairRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarLockChairRsp): EvtAvatarLockChairRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* Vector position */ 12:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* uint64 chair_id */ 15:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarLockChairRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* uint32 entity_id = 4; */
        if (message.entityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* Vector position = 12; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint64 chair_id = 15; */
        if (message.chairId !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.chairId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAvatarLockChairRsp
 */
export const EvtAvatarLockChairRsp = new EvtAvatarLockChairRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarSitDownNotify$Type extends MessageType<EvtAvatarSitDownNotify> {
    constructor() {
        super("EvtAvatarSitDownNotify", [
            { no: 10, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "position", kind: "message", T: () => Vector },
            { no: 8, name: "chair_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarSitDownNotify>): EvtAvatarSitDownNotify {
        const message = { entityId: 0, chairId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarSitDownNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarSitDownNotify): EvtAvatarSitDownNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                case /* Vector position */ 5:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* uint64 chair_id */ 8:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarSitDownNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 10; */
        if (message.entityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        /* Vector position = 5; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint64 chair_id = 8; */
        if (message.chairId !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.chairId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAvatarSitDownNotify
 */
export const EvtAvatarSitDownNotify = new EvtAvatarSitDownNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtAvatarStandUpNotify$Type extends MessageType<EvtAvatarStandUpNotify> {
    constructor() {
        super("EvtAvatarStandUpNotify", [
            { no: 10, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "direction", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "perform_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "chair_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EvtAvatarStandUpNotify>): EvtAvatarStandUpNotify {
        const message = { entityId: 0, direction: 0, performId: 0, chairId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtAvatarStandUpNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtAvatarStandUpNotify): EvtAvatarStandUpNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                case /* int32 direction */ 3:
                    message.direction = reader.int32();
                    break;
                case /* int32 perform_id */ 8:
                    message.performId = reader.int32();
                    break;
                case /* uint64 chair_id */ 11:
                    message.chairId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtAvatarStandUpNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 10; */
        if (message.entityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        /* int32 direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        /* int32 perform_id = 8; */
        if (message.performId !== 0)
            writer.tag(8, WireType.Varint).int32(message.performId);
        /* uint64 chair_id = 11; */
        if (message.chairId !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.chairId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtAvatarStandUpNotify
 */
export const EvtAvatarStandUpNotify = new EvtAvatarStandUpNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitInfo$Type extends MessageType<EvtBeingHitInfo> {
    constructor() {
        super("EvtBeingHitInfo", [
            { no: 12, name: "peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "attack_result", kind: "message", T: () => AttackResult },
            { no: 3, name: "frame_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitInfo>): EvtBeingHitInfo {
        const message = { peerId: 0, frameNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitInfo): EvtBeingHitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 peer_id */ 12:
                    message.peerId = reader.uint32();
                    break;
                case /* AttackResult attack_result */ 8:
                    message.attackResult = AttackResult.internalBinaryRead(reader, reader.uint32(), options, message.attackResult);
                    break;
                case /* uint32 frame_num */ 3:
                    message.frameNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 peer_id = 12; */
        if (message.peerId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.peerId);
        /* AttackResult attack_result = 8; */
        if (message.attackResult)
            AttackResult.internalBinaryWrite(message.attackResult, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 frame_num = 3; */
        if (message.frameNum !== 0)
            writer.tag(3, WireType.Varint).uint32(message.frameNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtBeingHitInfo
 */
export const EvtBeingHitInfo = new EvtBeingHitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitNotify$Type extends MessageType<EvtBeingHitNotify> {
    constructor() {
        super("EvtBeingHitNotify", [
            { no: 13, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 7, name: "being_hit_info", kind: "message", T: () => EvtBeingHitInfo }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitNotify>): EvtBeingHitNotify {
        const message = { forwardType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitNotify): EvtBeingHitNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 13:
                    message.forwardType = reader.int32();
                    break;
                case /* EvtBeingHitInfo being_hit_info */ 7:
                    message.beingHitInfo = EvtBeingHitInfo.internalBinaryRead(reader, reader.uint32(), options, message.beingHitInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 13; */
        if (message.forwardType !== 0)
            writer.tag(13, WireType.Varint).int32(message.forwardType);
        /* EvtBeingHitInfo being_hit_info = 7; */
        if (message.beingHitInfo)
            EvtBeingHitInfo.internalBinaryWrite(message.beingHitInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtBeingHitNotify
 */
export const EvtBeingHitNotify = new EvtBeingHitNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtBeingHitsCombineNotify$Type extends MessageType<EvtBeingHitsCombineNotify> {
    constructor() {
        super("EvtBeingHitsCombineNotify", [
            { no: 1, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 14, name: "evt_being_hit_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EvtBeingHitInfo }
        ]);
    }
    create(value?: PartialMessage<EvtBeingHitsCombineNotify>): EvtBeingHitsCombineNotify {
        const message = { forwardType: 0, evtBeingHitInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtBeingHitsCombineNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtBeingHitsCombineNotify): EvtBeingHitsCombineNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 1:
                    message.forwardType = reader.int32();
                    break;
                case /* repeated EvtBeingHitInfo evt_being_hit_info_list */ 14:
                    message.evtBeingHitInfoList.push(EvtBeingHitInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtBeingHitsCombineNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 1; */
        if (message.forwardType !== 0)
            writer.tag(1, WireType.Varint).int32(message.forwardType);
        /* repeated EvtBeingHitInfo evt_being_hit_info_list = 14; */
        for (let i = 0; i < message.evtBeingHitInfoList.length; i++)
            EvtBeingHitInfo.internalBinaryWrite(message.evtBeingHitInfoList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtBeingHitsCombineNotify
 */
export const EvtBeingHitsCombineNotify = new EvtBeingHitsCombineNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtCreateGadgetNotify$Type extends MessageType<EvtCreateGadgetNotify> {
    constructor() {
        super("EvtCreateGadgetNotify", [
            { no: 8, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 14, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "camp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "camp_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "init_pos", kind: "message", T: () => Vector },
            { no: 5, name: "init_euler_angles", kind: "message", T: () => Vector },
            { no: 1, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "target_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_async_load", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "target_lock_point_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "room_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "prop_owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "sight_group_with_owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EvtCreateGadgetNotify>): EvtCreateGadgetNotify {
        const message = { forwardType: 0, entityId: 0, configId: 0, campId: 0, campType: 0, guid: 0n, ownerEntityId: 0, targetEntityId: 0, isAsyncLoad: false, targetLockPointIndex: 0, roomId: 0, propOwnerEntityId: 0, sightGroupWithOwner: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtCreateGadgetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtCreateGadgetNotify): EvtCreateGadgetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 8:
                    message.forwardType = reader.int32();
                    break;
                case /* uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 config_id */ 11:
                    message.configId = reader.uint32();
                    break;
                case /* uint32 camp_id */ 13:
                    message.campId = reader.uint32();
                    break;
                case /* uint32 camp_type */ 3:
                    message.campType = reader.uint32();
                    break;
                case /* Vector init_pos */ 15:
                    message.initPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.initPos);
                    break;
                case /* Vector init_euler_angles */ 5:
                    message.initEulerAngles = Vector.internalBinaryRead(reader, reader.uint32(), options, message.initEulerAngles);
                    break;
                case /* uint64 guid */ 1:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 owner_entity_id */ 2:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* uint32 target_entity_id */ 7:
                    message.targetEntityId = reader.uint32();
                    break;
                case /* bool is_async_load */ 9:
                    message.isAsyncLoad = reader.bool();
                    break;
                case /* uint32 target_lock_point_index */ 4:
                    message.targetLockPointIndex = reader.uint32();
                    break;
                case /* uint32 room_id */ 10:
                    message.roomId = reader.uint32();
                    break;
                case /* uint32 prop_owner_entity_id */ 6:
                    message.propOwnerEntityId = reader.uint32();
                    break;
                case /* bool sight_group_with_owner */ 12:
                    message.sightGroupWithOwner = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtCreateGadgetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 8; */
        if (message.forwardType !== 0)
            writer.tag(8, WireType.Varint).int32(message.forwardType);
        /* uint32 entity_id = 14; */
        if (message.entityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        /* uint32 config_id = 11; */
        if (message.configId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.configId);
        /* uint32 camp_id = 13; */
        if (message.campId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.campId);
        /* uint32 camp_type = 3; */
        if (message.campType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.campType);
        /* Vector init_pos = 15; */
        if (message.initPos)
            Vector.internalBinaryWrite(message.initPos, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* Vector init_euler_angles = 5; */
        if (message.initEulerAngles)
            Vector.internalBinaryWrite(message.initEulerAngles, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint64 guid = 1; */
        if (message.guid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.guid);
        /* uint32 owner_entity_id = 2; */
        if (message.ownerEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.ownerEntityId);
        /* uint32 target_entity_id = 7; */
        if (message.targetEntityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.targetEntityId);
        /* bool is_async_load = 9; */
        if (message.isAsyncLoad !== false)
            writer.tag(9, WireType.Varint).bool(message.isAsyncLoad);
        /* uint32 target_lock_point_index = 4; */
        if (message.targetLockPointIndex !== 0)
            writer.tag(4, WireType.Varint).uint32(message.targetLockPointIndex);
        /* uint32 room_id = 10; */
        if (message.roomId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.roomId);
        /* uint32 prop_owner_entity_id = 6; */
        if (message.propOwnerEntityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.propOwnerEntityId);
        /* bool sight_group_with_owner = 12; */
        if (message.sightGroupWithOwner !== false)
            writer.tag(12, WireType.Varint).bool(message.sightGroupWithOwner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtCreateGadgetNotify
 */
export const EvtCreateGadgetNotify = new EvtCreateGadgetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtDestroyGadgetNotify$Type extends MessageType<EvtDestroyGadgetNotify> {
    constructor() {
        super("EvtDestroyGadgetNotify", [
            { no: 10, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EvtDestroyGadgetNotify>): EvtDestroyGadgetNotify {
        const message = { forwardType: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtDestroyGadgetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtDestroyGadgetNotify): EvtDestroyGadgetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 10:
                    message.forwardType = reader.int32();
                    break;
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtDestroyGadgetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 10; */
        if (message.forwardType !== 0)
            writer.tag(10, WireType.Varint).int32(message.forwardType);
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtDestroyGadgetNotify
 */
export const EvtDestroyGadgetNotify = new EvtDestroyGadgetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtDoSkillSuccNotify$Type extends MessageType<EvtDoSkillSuccNotify> {
    constructor() {
        super("EvtDoSkillSuccNotify", [
            { no: 6, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 10, name: "caster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "forward", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<EvtDoSkillSuccNotify>): EvtDoSkillSuccNotify {
        const message = { forwardType: 0, casterId: 0, skillId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtDoSkillSuccNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtDoSkillSuccNotify): EvtDoSkillSuccNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 6:
                    message.forwardType = reader.int32();
                    break;
                case /* uint32 caster_id */ 10:
                    message.casterId = reader.uint32();
                    break;
                case /* uint32 skill_id */ 1:
                    message.skillId = reader.uint32();
                    break;
                case /* Vector forward */ 8:
                    message.forward = Vector.internalBinaryRead(reader, reader.uint32(), options, message.forward);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtDoSkillSuccNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 6; */
        if (message.forwardType !== 0)
            writer.tag(6, WireType.Varint).int32(message.forwardType);
        /* uint32 caster_id = 10; */
        if (message.casterId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.casterId);
        /* uint32 skill_id = 1; */
        if (message.skillId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.skillId);
        /* Vector forward = 8; */
        if (message.forward)
            Vector.internalBinaryWrite(message.forward, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtDoSkillSuccNotify
 */
export const EvtDoSkillSuccNotify = new EvtDoSkillSuccNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtEntityRenderersChangedNotify$Type extends MessageType<EvtEntityRenderersChangedNotify> {
    constructor() {
        super("EvtEntityRenderersChangedNotify", [
            { no: 2, name: "forward_type", kind: "enum", T: () => ["ForwardType", ForwardType, "FORWARD_TYPE_"] },
            { no: 7, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_server_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "renderer_changed_info", kind: "message", T: () => EntityRendererChangedInfo }
        ]);
    }
    create(value?: PartialMessage<EvtEntityRenderersChangedNotify>): EvtEntityRenderersChangedNotify {
        const message = { forwardType: 0, entityId: 0, isServerCache: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtEntityRenderersChangedNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtEntityRenderersChangedNotify): EvtEntityRenderersChangedNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForwardType forward_type */ 2:
                    message.forwardType = reader.int32();
                    break;
                case /* uint32 entity_id */ 7:
                    message.entityId = reader.uint32();
                    break;
                case /* bool is_server_cache */ 15:
                    message.isServerCache = reader.bool();
                    break;
                case /* EntityRendererChangedInfo renderer_changed_info */ 3:
                    message.rendererChangedInfo = EntityRendererChangedInfo.internalBinaryRead(reader, reader.uint32(), options, message.rendererChangedInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtEntityRenderersChangedNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForwardType forward_type = 2; */
        if (message.forwardType !== 0)
            writer.tag(2, WireType.Varint).int32(message.forwardType);
        /* uint32 entity_id = 7; */
        if (message.entityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.entityId);
        /* bool is_server_cache = 15; */
        if (message.isServerCache !== false)
            writer.tag(15, WireType.Varint).bool(message.isServerCache);
        /* EntityRendererChangedInfo renderer_changed_info = 3; */
        if (message.rendererChangedInfo)
            EntityRendererChangedInfo.internalBinaryWrite(message.rendererChangedInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtEntityRenderersChangedNotify
 */
export const EvtEntityRenderersChangedNotify = new EvtEntityRenderersChangedNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EvtHittingOtherInfo$Type extends MessageType<EvtHittingOtherInfo> {
    constructor() {
        super("EvtHittingOtherInfo", [
            { no: 1, name: "peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "attack_result", kind: "message", T: () => AttackResult }
        ]);
    }
    create(value?: PartialMessage<EvtHittingOtherInfo>): EvtHittingOtherInfo {
        const message = { peerId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EvtHittingOtherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EvtHittingOtherInfo): EvtHittingOtherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 peer_id */ 1:
                    message.peerId = reader.uint32();
                    break;
                case /* AttackResult attack_result */ 2:
                    message.attackResult = AttackResult.internalBinaryRead(reader, reader.uint32(), options, message.attackResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EvtHittingOtherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 peer_id = 1; */
        if (message.peerId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.peerId);
        /* AttackResult attack_result = 2; */
        if (message.attackResult)
            AttackResult.internalBinaryWrite(message.attackResult, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EvtHittingOtherInfo
 */
export const EvtHittingOtherInfo = new EvtHittingOtherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExhibitionDisplayInfo$Type extends MessageType<ExhibitionDisplayInfo> {
    constructor() {
        super("ExhibitionDisplayInfo", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "detail_param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExhibitionDisplayInfo>): ExhibitionDisplayInfo {
        const message = { id: 0, param: 0, detailParam: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExhibitionDisplayInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExhibitionDisplayInfo): ExhibitionDisplayInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 param */ 2:
                    message.param = reader.uint32();
                    break;
                case /* uint32 detail_param */ 3:
                    message.detailParam = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExhibitionDisplayInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 param = 2; */
        if (message.param !== 0)
            writer.tag(2, WireType.Varint).uint32(message.param);
        /* uint32 detail_param = 3; */
        if (message.detailParam !== 0)
            writer.tag(3, WireType.Varint).uint32(message.detailParam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExhibitionDisplayInfo
 */
export const ExhibitionDisplayInfo = new ExhibitionDisplayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeatureBlockInfo$Type extends MessageType<FeatureBlockInfo> {
    constructor() {
        super("FeatureBlockInfo", [
            { no: 1, name: "feature_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FeatureBlockInfo>): FeatureBlockInfo {
        const message = { featureType: 0, endTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeatureBlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeatureBlockInfo): FeatureBlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 feature_type */ 1:
                    message.featureType = reader.uint32();
                    break;
                case /* uint32 end_time */ 2:
                    message.endTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeatureBlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 feature_type = 1; */
        if (message.featureType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.featureType);
        /* uint32 end_time = 2; */
        if (message.endTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FeatureBlockInfo
 */
export const FeatureBlockInfo = new FeatureBlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetterData$Type extends MessageType<FetterData> {
    constructor() {
        super("FetterData", [
            { no: 1, name: "fetter_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fetter_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cond_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FetterData>): FetterData {
        const message = { fetterId: 0, fetterState: 0, condIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetterData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetterData): FetterData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fetter_id */ 1:
                    message.fetterId = reader.uint32();
                    break;
                case /* uint32 fetter_state */ 2:
                    message.fetterState = reader.uint32();
                    break;
                case /* repeated uint32 cond_index_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.condIndexList.push(reader.uint32());
                    else
                        message.condIndexList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetterData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fetter_id = 1; */
        if (message.fetterId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fetterId);
        /* uint32 fetter_state = 2; */
        if (message.fetterState !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fetterState);
        /* repeated uint32 cond_index_list = 3; */
        if (message.condIndexList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.condIndexList.length; i++)
                writer.uint32(message.condIndexList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FetterData
 */
export const FetterData = new FetterData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightPropPair$Type extends MessageType<FightPropPair> {
    constructor() {
        super("FightPropPair", [
            { no: 1, name: "prop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "prop_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FightPropPair>): FightPropPair {
        const message = { propType: 0, propValue: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightPropPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightPropPair): FightPropPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 prop_type */ 1:
                    message.propType = reader.uint32();
                    break;
                case /* float prop_value */ 2:
                    message.propValue = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightPropPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 prop_type = 1; */
        if (message.propType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.propType);
        /* float prop_value = 2; */
        if (message.propValue !== 0)
            writer.tag(2, WireType.Bit32).float(message.propValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightPropPair
 */
export const FightPropPair = new FightPropPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinishedParentQuestNotify$Type extends MessageType<FinishedParentQuestNotify> {
    constructor() {
        super("FinishedParentQuestNotify", [
            { no: 12, name: "parent_quest_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParentQuest }
        ]);
    }
    create(value?: PartialMessage<FinishedParentQuestNotify>): FinishedParentQuestNotify {
        const message = { parentQuestList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinishedParentQuestNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinishedParentQuestNotify): FinishedParentQuestNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ParentQuest parent_quest_list */ 12:
                    message.parentQuestList.push(ParentQuest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinishedParentQuestNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ParentQuest parent_quest_list = 12; */
        for (let i = 0; i < message.parentQuestList.length; i++)
            ParentQuest.internalBinaryWrite(message.parentQuestList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FinishedParentQuestNotify
 */
export const FinishedParentQuestNotify = new FinishedParentQuestNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinishedParentQuestUpdateNotify$Type extends MessageType<FinishedParentQuestUpdateNotify> {
    constructor() {
        super("FinishedParentQuestUpdateNotify", [
            { no: 6, name: "parent_quest_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ParentQuest }
        ]);
    }
    create(value?: PartialMessage<FinishedParentQuestUpdateNotify>): FinishedParentQuestUpdateNotify {
        const message = { parentQuestList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinishedParentQuestUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinishedParentQuestUpdateNotify): FinishedParentQuestUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ParentQuest parent_quest_list */ 6:
                    message.parentQuestList.push(ParentQuest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinishedParentQuestUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ParentQuest parent_quest_list = 6; */
        for (let i = 0; i < message.parentQuestList.length; i++)
            ParentQuest.internalBinaryWrite(message.parentQuestList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FinishedParentQuestUpdateNotify
 */
export const FinishedParentQuestUpdateNotify = new FinishedParentQuestUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireWorkData$Type extends MessageType<FireWorkData> {
    constructor() {
        super("FireWorkData", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fireWorkInstance", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FireWorkInstance }
        ]);
    }
    create(value?: PartialMessage<FireWorkData>): FireWorkData {
        const message = { id: 0, fireWorkInstance: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireWorkData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireWorkData): FireWorkData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* repeated FireWorkInstance fireWorkInstance */ 2:
                    message.fireWorkInstance.push(FireWorkInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireWorkData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* repeated FireWorkInstance fireWorkInstance = 2; */
        for (let i = 0; i < message.fireWorkInstance.length; i++)
            FireWorkInstance.internalBinaryWrite(message.fireWorkInstance[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireWorkData
 */
export const FireWorkData = new FireWorkData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireWorkInstance$Type extends MessageType<FireWorkInstance> {
    constructor() {
        super("FireWorkInstance", [
            { no: 1, name: "type", kind: "enum", T: () => ["FireWorkType", FireWorkType] },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FireWorkInstance>): FireWorkInstance {
        const message = { type: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireWorkInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireWorkInstance): FireWorkInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FireWorkType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireWorkInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* FireWorkType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireWorkInstance
 */
export const FireWorkInstance = new FireWorkInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireWorkNotify$Type extends MessageType<FireWorkNotify> {
    constructor() {
        super("FireWorkNotify", [
            { no: 1, name: "fireWorkData", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FireWorkData }
        ]);
    }
    create(value?: PartialMessage<FireWorkNotify>): FireWorkNotify {
        const message = { fireWorkData: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireWorkNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireWorkNotify): FireWorkNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FireWorkData fireWorkData */ 1:
                    message.fireWorkData.push(FireWorkData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireWorkNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FireWorkData fireWorkData = 1; */
        for (let i = 0; i < message.fireWorkData.length; i++)
            FireWorkData.internalBinaryWrite(message.fireWorkData[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireWorkNotify
 */
export const FireWorkNotify = new FireWorkNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireWorkReq$Type extends MessageType<FireWorkReq> {
    constructor() {
        super("FireWorkReq", [
            { no: 7, name: "fireWorkData", kind: "message", T: () => FireWorkData }
        ]);
    }
    create(value?: PartialMessage<FireWorkReq>): FireWorkReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireWorkReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireWorkReq): FireWorkReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FireWorkData fireWorkData */ 7:
                    message.fireWorkData = FireWorkData.internalBinaryRead(reader, reader.uint32(), options, message.fireWorkData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireWorkReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* FireWorkData fireWorkData = 7; */
        if (message.fireWorkData)
            FireWorkData.internalBinaryWrite(message.fireWorkData, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireWorkReq
 */
export const FireWorkReq = new FireWorkReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireWorkRsp$Type extends MessageType<FireWorkRsp> {
    constructor() {
        super("FireWorkRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FireWorkRsp>): FireWorkRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireWorkRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireWorkRsp): FireWorkRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireWorkRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireWorkRsp
 */
export const FireWorkRsp = new FireWorkRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireworkSetData$Type extends MessageType<FireworkSetData> {
    constructor() {
        super("FireworkSetData", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "_unknown_field_", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "fireWorkInstance", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FireWorkInstance }
        ]);
    }
    create(value?: PartialMessage<FireworkSetData>): FireworkSetData {
        const message = { id: 0, UnknownField: [], fireWorkInstance: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireworkSetData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireworkSetData): FireworkSetData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* repeated uint32 _unknown_field_ */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.UnknownField.push(reader.uint32());
                    else
                        message.UnknownField.push(reader.uint32());
                    break;
                case /* repeated FireWorkInstance fireWorkInstance */ 3:
                    message.fireWorkInstance.push(FireWorkInstance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireworkSetData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* repeated uint32 _unknown_field_ = 2; */
        if (message.UnknownField.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.UnknownField.length; i++)
                writer.uint32(message.UnknownField[i]);
            writer.join();
        }
        /* repeated FireWorkInstance fireWorkInstance = 3; */
        for (let i = 0; i < message.fireWorkInstance.length; i++)
            FireWorkInstance.internalBinaryWrite(message.fireWorkInstance[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireworkSetData
 */
export const FireworkSetData = new FireworkSetData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireworkSetNotify$Type extends MessageType<FireworkSetNotify> {
    constructor() {
        super("FireworkSetNotify", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FireworkSetData }
        ]);
    }
    create(value?: PartialMessage<FireworkSetNotify>): FireworkSetNotify {
        const message = { code: 0, data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireworkSetNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireworkSetNotify): FireworkSetNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* repeated FireworkSetData data */ 9:
                    message.data.push(FireworkSetData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireworkSetNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* repeated FireworkSetData data = 9; */
        for (let i = 0; i < message.data.length; i++)
            FireworkSetData.internalBinaryWrite(message.data[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireworkSetNotify
 */
export const FireworkSetNotify = new FireworkSetNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FireworkSetReq$Type extends MessageType<FireworkSetReq> {
    constructor() {
        super("FireworkSetReq", [
            { no: 2, name: "data", kind: "message", T: () => FireworkSetData }
        ]);
    }
    create(value?: PartialMessage<FireworkSetReq>): FireworkSetReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FireworkSetReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FireworkSetReq): FireworkSetReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FireworkSetData data */ 2:
                    message.data = FireworkSetData.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FireworkSetReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* FireworkSetData data = 2; */
        if (message.data)
            FireworkSetData.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FireworkSetReq
 */
export const FireworkSetReq = new FireworkSetReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NBFJOJPCCEK_Rsp$Type extends MessageType<NBFJOJPCCEK_Rsp> {
    constructor() {
        super("NBFJOJPCCEK_Rsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NBFJOJPCCEK_Rsp>): NBFJOJPCCEK_Rsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NBFJOJPCCEK_Rsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NBFJOJPCCEK_Rsp): NBFJOJPCCEK_Rsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NBFJOJPCCEK_Rsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NBFJOJPCCEK_Rsp
 */
export const NBFJOJPCCEK_Rsp = new NBFJOJPCCEK_Rsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FishPoolInfo$Type extends MessageType<FishPoolInfo> {
    constructor() {
        super("FishPoolInfo", [
            { no: 1, name: "pool_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fish_area_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "today_fish_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FishPoolInfo>): FishPoolInfo {
        const message = { poolId: 0, fishAreaList: [], todayFishNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FishPoolInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FishPoolInfo): FishPoolInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 pool_id */ 1:
                    message.poolId = reader.uint32();
                    break;
                case /* repeated uint32 fish_area_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fishAreaList.push(reader.uint32());
                    else
                        message.fishAreaList.push(reader.uint32());
                    break;
                case /* uint32 today_fish_num */ 3:
                    message.todayFishNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FishPoolInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 pool_id = 1; */
        if (message.poolId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.poolId);
        /* repeated uint32 fish_area_list = 2; */
        if (message.fishAreaList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fishAreaList.length; i++)
                writer.uint32(message.fishAreaList[i]);
            writer.join();
        }
        /* uint32 today_fish_num = 3; */
        if (message.todayFishNum !== 0)
            writer.tag(3, WireType.Varint).uint32(message.todayFishNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FishPoolInfo
 */
export const FishPoolInfo = new FishPoolInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceUpdateInfo$Type extends MessageType<ForceUpdateInfo> {
    constructor() {
        super("ForceUpdateInfo", [
            { no: 1, name: "force_update_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ForceUpdateInfo>): ForceUpdateInfo {
        const message = { forceUpdateUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForceUpdateInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForceUpdateInfo): ForceUpdateInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string force_update_url */ 1:
                    message.forceUpdateUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForceUpdateInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string force_update_url = 1; */
        if (message.forceUpdateUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.forceUpdateUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForceUpdateInfo
 */
export const ForceUpdateInfo = new ForceUpdateInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeDataNotify$Type extends MessageType<ForgeDataNotify> {
    constructor() {
        super("ForgeDataNotify", [
            { no: 13, name: "forge_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "max_queue_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "forge_queue_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ForgeQueueData } }
        ]);
    }
    create(value?: PartialMessage<ForgeDataNotify>): ForgeDataNotify {
        const message = { forgeIdList: [], maxQueueNum: 0, forgeQueueMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeDataNotify): ForgeDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 forge_id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.forgeIdList.push(reader.uint32());
                    else
                        message.forgeIdList.push(reader.uint32());
                    break;
                case /* uint32 max_queue_num */ 15:
                    message.maxQueueNum = reader.uint32();
                    break;
                case /* map<uint32, ForgeQueueData> forge_queue_map */ 1:
                    this.binaryReadMap1(message.forgeQueueMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ForgeDataNotify["forgeQueueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ForgeDataNotify["forgeQueueMap"] | undefined, val: ForgeDataNotify["forgeQueueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ForgeQueueData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ForgeDataNotify.forge_queue_map");
            }
        }
        map[key ?? 0] = val ?? ForgeQueueData.create();
    }
    internalBinaryWrite(message: ForgeDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 forge_id_list = 13; */
        if (message.forgeIdList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.forgeIdList.length; i++)
                writer.uint32(message.forgeIdList[i]);
            writer.join();
        }
        /* uint32 max_queue_num = 15; */
        if (message.maxQueueNum !== 0)
            writer.tag(15, WireType.Varint).uint32(message.maxQueueNum);
        /* map<uint32, ForgeQueueData> forge_queue_map = 1; */
        for (let k of Object.keys(message.forgeQueueMap)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForgeQueueData.internalBinaryWrite(message.forgeQueueMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeDataNotify
 */
export const ForgeDataNotify = new ForgeDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeFormulaDataNotify$Type extends MessageType<ForgeFormulaDataNotify> {
    constructor() {
        super("ForgeFormulaDataNotify", [
            { no: 11, name: "forge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ForgeFormulaDataNotify>): ForgeFormulaDataNotify {
        const message = { forgeId: 0, isLocked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeFormulaDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeFormulaDataNotify): ForgeFormulaDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 forge_id */ 11:
                    message.forgeId = reader.uint32();
                    break;
                case /* bool is_locked */ 8:
                    message.isLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeFormulaDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 forge_id = 11; */
        if (message.forgeId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.forgeId);
        /* bool is_locked = 8; */
        if (message.isLocked !== false)
            writer.tag(8, WireType.Varint).bool(message.isLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeFormulaDataNotify
 */
export const ForgeFormulaDataNotify = new ForgeFormulaDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeGetQueueDataRsp$Type extends MessageType<ForgeGetQueueDataRsp> {
    constructor() {
        super("ForgeGetQueueDataRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "max_queue_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "forge_queue_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ForgeQueueData } }
        ]);
    }
    create(value?: PartialMessage<ForgeGetQueueDataRsp>): ForgeGetQueueDataRsp {
        const message = { retcode: 0, maxQueueNum: 0, forgeQueueMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeGetQueueDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeGetQueueDataRsp): ForgeGetQueueDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 max_queue_num */ 13:
                    message.maxQueueNum = reader.uint32();
                    break;
                case /* map<uint32, ForgeQueueData> forge_queue_map */ 11:
                    this.binaryReadMap11(message.forgeQueueMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: ForgeGetQueueDataRsp["forgeQueueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ForgeGetQueueDataRsp["forgeQueueMap"] | undefined, val: ForgeGetQueueDataRsp["forgeQueueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ForgeQueueData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ForgeGetQueueDataRsp.forge_queue_map");
            }
        }
        map[key ?? 0] = val ?? ForgeQueueData.create();
    }
    internalBinaryWrite(message: ForgeGetQueueDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 max_queue_num = 13; */
        if (message.maxQueueNum !== 0)
            writer.tag(13, WireType.Varint).uint32(message.maxQueueNum);
        /* map<uint32, ForgeQueueData> forge_queue_map = 11; */
        for (let k of Object.keys(message.forgeQueueMap)) {
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForgeQueueData.internalBinaryWrite(message.forgeQueueMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeGetQueueDataRsp
 */
export const ForgeGetQueueDataRsp = new ForgeGetQueueDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeQueueData$Type extends MessageType<ForgeQueueData> {
    constructor() {
        super("ForgeQueueData", [
            { no: 1, name: "queue_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "forge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "finish_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "unfinish_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "next_finish_timestamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "total_finish_timestamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForgeQueueData>): ForgeQueueData {
        const message = { queueId: 0, forgeId: 0, finishCount: 0, unfinishCount: 0, nextFinishTimestamp: 0, totalFinishTimestamp: 0, avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeQueueData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeQueueData): ForgeQueueData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 queue_id */ 1:
                    message.queueId = reader.uint32();
                    break;
                case /* uint32 forge_id */ 2:
                    message.forgeId = reader.uint32();
                    break;
                case /* uint32 finish_count */ 3:
                    message.finishCount = reader.uint32();
                    break;
                case /* uint32 unfinish_count */ 4:
                    message.unfinishCount = reader.uint32();
                    break;
                case /* uint32 next_finish_timestamp */ 5:
                    message.nextFinishTimestamp = reader.uint32();
                    break;
                case /* uint32 total_finish_timestamp */ 6:
                    message.totalFinishTimestamp = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 7:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeQueueData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 queue_id = 1; */
        if (message.queueId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.queueId);
        /* uint32 forge_id = 2; */
        if (message.forgeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.forgeId);
        /* uint32 finish_count = 3; */
        if (message.finishCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.finishCount);
        /* uint32 unfinish_count = 4; */
        if (message.unfinishCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.unfinishCount);
        /* uint32 next_finish_timestamp = 5; */
        if (message.nextFinishTimestamp !== 0)
            writer.tag(5, WireType.Varint).uint32(message.nextFinishTimestamp);
        /* uint32 total_finish_timestamp = 6; */
        if (message.totalFinishTimestamp !== 0)
            writer.tag(6, WireType.Varint).uint32(message.totalFinishTimestamp);
        /* uint32 avatar_id = 7; */
        if (message.avatarId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeQueueData
 */
export const ForgeQueueData = new ForgeQueueData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeQueueDataNotify$Type extends MessageType<ForgeQueueDataNotify> {
    constructor() {
        super("ForgeQueueDataNotify", [
            { no: 14, name: "forge_queue_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => ForgeQueueData } },
            { no: 8, name: "removed_forge_queue_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForgeQueueDataNotify>): ForgeQueueDataNotify {
        const message = { forgeQueueMap: {}, removedForgeQueueList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeQueueDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeQueueDataNotify): ForgeQueueDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, ForgeQueueData> forge_queue_map */ 14:
                    this.binaryReadMap14(message.forgeQueueMap, reader, options);
                    break;
                case /* repeated uint32 removed_forge_queue_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.removedForgeQueueList.push(reader.uint32());
                    else
                        message.removedForgeQueueList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap14(map: ForgeQueueDataNotify["forgeQueueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ForgeQueueDataNotify["forgeQueueMap"] | undefined, val: ForgeQueueDataNotify["forgeQueueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = ForgeQueueData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ForgeQueueDataNotify.forge_queue_map");
            }
        }
        map[key ?? 0] = val ?? ForgeQueueData.create();
    }
    internalBinaryWrite(message: ForgeQueueDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, ForgeQueueData> forge_queue_map = 14; */
        for (let k of Object.keys(message.forgeQueueMap)) {
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ForgeQueueData.internalBinaryWrite(message.forgeQueueMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated uint32 removed_forge_queue_list = 8; */
        if (message.removedForgeQueueList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.removedForgeQueueList.length; i++)
                writer.uint32(message.removedForgeQueueList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeQueueDataNotify
 */
export const ForgeQueueDataNotify = new ForgeQueueDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeQueueManipulateReq$Type extends MessageType<ForgeQueueManipulateReq> {
    constructor() {
        super("ForgeQueueManipulateReq", [
            { no: 11, name: "forge_queue_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "manipulate_type", kind: "enum", T: () => ["ForgeQueueManipulateType", ForgeQueueManipulateType, "FORGE_QUEUE_MANIPULATE_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ForgeQueueManipulateReq>): ForgeQueueManipulateReq {
        const message = { forgeQueueId: 0, manipulateType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeQueueManipulateReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeQueueManipulateReq): ForgeQueueManipulateReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 forge_queue_id */ 11:
                    message.forgeQueueId = reader.uint32();
                    break;
                case /* ForgeQueueManipulateType manipulate_type */ 7:
                    message.manipulateType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeQueueManipulateReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 forge_queue_id = 11; */
        if (message.forgeQueueId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.forgeQueueId);
        /* ForgeQueueManipulateType manipulate_type = 7; */
        if (message.manipulateType !== 0)
            writer.tag(7, WireType.Varint).int32(message.manipulateType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeQueueManipulateReq
 */
export const ForgeQueueManipulateReq = new ForgeQueueManipulateReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeQueueManipulateRsp$Type extends MessageType<ForgeQueueManipulateRsp> {
    constructor() {
        super("ForgeQueueManipulateRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "manipulate_type", kind: "enum", T: () => ["ForgeQueueManipulateType", ForgeQueueManipulateType, "FORGE_QUEUE_MANIPULATE_TYPE_"] },
            { no: 6, name: "output_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 10, name: "return_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 3, name: "extra_output_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<ForgeQueueManipulateRsp>): ForgeQueueManipulateRsp {
        const message = { retcode: 0, manipulateType: 0, outputItemList: [], returnItemList: [], extraOutputItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeQueueManipulateRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeQueueManipulateRsp): ForgeQueueManipulateRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* ForgeQueueManipulateType manipulate_type */ 8:
                    message.manipulateType = reader.int32();
                    break;
                case /* repeated ItemParam output_item_list */ 6:
                    message.outputItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam return_item_list */ 10:
                    message.returnItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam extra_output_item_list */ 3:
                    message.extraOutputItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeQueueManipulateRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* ForgeQueueManipulateType manipulate_type = 8; */
        if (message.manipulateType !== 0)
            writer.tag(8, WireType.Varint).int32(message.manipulateType);
        /* repeated ItemParam output_item_list = 6; */
        for (let i = 0; i < message.outputItemList.length; i++)
            ItemParam.internalBinaryWrite(message.outputItemList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam return_item_list = 10; */
        for (let i = 0; i < message.returnItemList.length; i++)
            ItemParam.internalBinaryWrite(message.returnItemList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam extra_output_item_list = 3; */
        for (let i = 0; i < message.extraOutputItemList.length; i++)
            ItemParam.internalBinaryWrite(message.extraOutputItemList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeQueueManipulateRsp
 */
export const ForgeQueueManipulateRsp = new ForgeQueueManipulateRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeStartReq$Type extends MessageType<ForgeStartReq> {
    constructor() {
        super("ForgeStartReq", [
            { no: 9, name: "forge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "forge_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForgeStartReq>): ForgeStartReq {
        const message = { forgeId: 0, forgeCount: 0, avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeStartReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeStartReq): ForgeStartReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 forge_id */ 9:
                    message.forgeId = reader.uint32();
                    break;
                case /* uint32 forge_count */ 11:
                    message.forgeCount = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 13:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeStartReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 forge_id = 9; */
        if (message.forgeId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.forgeId);
        /* uint32 forge_count = 11; */
        if (message.forgeCount !== 0)
            writer.tag(11, WireType.Varint).uint32(message.forgeCount);
        /* uint32 avatar_id = 13; */
        if (message.avatarId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeStartReq
 */
export const ForgeStartReq = new ForgeStartReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgeStartRsp$Type extends MessageType<ForgeStartRsp> {
    constructor() {
        super("ForgeStartRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ForgeStartRsp>): ForgeStartRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgeStartRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgeStartRsp): ForgeStartRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgeStartRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ForgeStartRsp
 */
export const ForgeStartRsp = new ForgeStartRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FoundationInfo$Type extends MessageType<FoundationInfo> {
    constructor() {
        super("FoundationInfo", [
            { no: 1, name: "status", kind: "enum", T: () => ["FoundationStatus", FoundationStatus, "FOUNDATION_STATUS_"] },
            { no: 2, name: "uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "current_building_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "begin_build_time_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "demolition_refund", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "building_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BuildingInfo },
            { no: 7, name: "current_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "max_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "locked_by_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FoundationInfo>): FoundationInfo {
        const message = { status: 0, uidList: [], currentBuildingId: 0, beginBuildTimeMs: 0, demolitionRefund: 0, buildingList: [], currentNum: 0, maxNum: 0, lockedByUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FoundationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FoundationInfo): FoundationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FoundationStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* repeated uint32 uid_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uidList.push(reader.uint32());
                    else
                        message.uidList.push(reader.uint32());
                    break;
                case /* uint32 current_building_id */ 3:
                    message.currentBuildingId = reader.uint32();
                    break;
                case /* uint32 begin_build_time_ms */ 4:
                    message.beginBuildTimeMs = reader.uint32();
                    break;
                case /* uint32 demolition_refund */ 5:
                    message.demolitionRefund = reader.uint32();
                    break;
                case /* repeated BuildingInfo building_list */ 6:
                    message.buildingList.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 current_num */ 7:
                    message.currentNum = reader.uint32();
                    break;
                case /* uint32 max_num */ 8:
                    message.maxNum = reader.uint32();
                    break;
                case /* uint32 locked_by_uid */ 9:
                    message.lockedByUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FoundationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* FoundationStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* repeated uint32 uid_list = 2; */
        if (message.uidList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uidList.length; i++)
                writer.uint32(message.uidList[i]);
            writer.join();
        }
        /* uint32 current_building_id = 3; */
        if (message.currentBuildingId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.currentBuildingId);
        /* uint32 begin_build_time_ms = 4; */
        if (message.beginBuildTimeMs !== 0)
            writer.tag(4, WireType.Varint).uint32(message.beginBuildTimeMs);
        /* uint32 demolition_refund = 5; */
        if (message.demolitionRefund !== 0)
            writer.tag(5, WireType.Varint).uint32(message.demolitionRefund);
        /* repeated BuildingInfo building_list = 6; */
        for (let i = 0; i < message.buildingList.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 current_num = 7; */
        if (message.currentNum !== 0)
            writer.tag(7, WireType.Varint).uint32(message.currentNum);
        /* uint32 max_num = 8; */
        if (message.maxNum !== 0)
            writer.tag(8, WireType.Varint).uint32(message.maxNum);
        /* uint32 locked_by_uid = 9; */
        if (message.lockedByUid !== 0)
            writer.tag(9, WireType.Varint).uint32(message.lockedByUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FoundationInfo
 */
export const FoundationInfo = new FoundationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FriendBrief$Type extends MessageType<FriendBrief> {
    constructor() {
        super("FriendBrief", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "world_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "online_state", kind: "enum", T: () => ["FriendOnlineState", FriendOnlineState, "FRIEND_ONLINE_STATE_"] },
            { no: 8, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_mp_mode_available", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "online_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "last_active_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "mp_player_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_chat_no_disturb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "chat_sequence", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "remark_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "show_avatar_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SocialShowAvatarInfo },
            { no: 23, name: "friend_enter_home_option", kind: "enum", T: () => ["FriendEnterHomeOption", FriendEnterHomeOption, "FRIEND_ENTER_HOME_OPTION_"] },
            { no: 24, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 25, name: "is_game_source", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "is_psn_source", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "platform_type", kind: "enum", T: () => ["PlatformType", PlatformType, "PLATFORM_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<FriendBrief>): FriendBrief {
        const message = { uid: 0, nickname: "", level: 0, avatarId: 0, worldLevel: 0, signature: "", onlineState: 0, param: 0, isMpModeAvailable: false, onlineId: "", lastActiveTime: 0, nameCardId: 0, mpPlayerNum: 0, isChatNoDisturb: false, chatSequence: 0, remarkName: "", showAvatarInfoList: [], friendEnterHomeOption: 0, isGameSource: false, isPsnSource: false, platformType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FriendBrief>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FriendBrief): FriendBrief {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* string nickname */ 2:
                    message.nickname = reader.string();
                    break;
                case /* uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 4:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint32 world_level */ 5:
                    message.worldLevel = reader.uint32();
                    break;
                case /* string signature */ 6:
                    message.signature = reader.string();
                    break;
                case /* FriendOnlineState online_state */ 7:
                    message.onlineState = reader.int32();
                    break;
                case /* uint32 param */ 8:
                    message.param = reader.uint32();
                    break;
                case /* bool is_mp_mode_available */ 10:
                    message.isMpModeAvailable = reader.bool();
                    break;
                case /* string online_id */ 11:
                    message.onlineId = reader.string();
                    break;
                case /* uint32 last_active_time */ 12:
                    message.lastActiveTime = reader.uint32();
                    break;
                case /* uint32 name_card_id */ 13:
                    message.nameCardId = reader.uint32();
                    break;
                case /* uint32 mp_player_num */ 14:
                    message.mpPlayerNum = reader.uint32();
                    break;
                case /* bool is_chat_no_disturb */ 15:
                    message.isChatNoDisturb = reader.bool();
                    break;
                case /* uint32 chat_sequence */ 16:
                    message.chatSequence = reader.uint32();
                    break;
                case /* string remark_name */ 17:
                    message.remarkName = reader.string();
                    break;
                case /* repeated SocialShowAvatarInfo show_avatar_info_list */ 22:
                    message.showAvatarInfoList.push(SocialShowAvatarInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* FriendEnterHomeOption friend_enter_home_option */ 23:
                    message.friendEnterHomeOption = reader.int32();
                    break;
                case /* ProfilePicture profile_picture */ 24:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* bool is_game_source */ 25:
                    message.isGameSource = reader.bool();
                    break;
                case /* bool is_psn_source */ 26:
                    message.isPsnSource = reader.bool();
                    break;
                case /* PlatformType platform_type */ 27:
                    message.platformType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FriendBrief, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* string nickname = 2; */
        if (message.nickname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nickname);
        /* uint32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* uint32 avatar_id = 4; */
        if (message.avatarId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.avatarId);
        /* uint32 world_level = 5; */
        if (message.worldLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.worldLevel);
        /* string signature = 6; */
        if (message.signature !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.signature);
        /* FriendOnlineState online_state = 7; */
        if (message.onlineState !== 0)
            writer.tag(7, WireType.Varint).int32(message.onlineState);
        /* uint32 param = 8; */
        if (message.param !== 0)
            writer.tag(8, WireType.Varint).uint32(message.param);
        /* bool is_mp_mode_available = 10; */
        if (message.isMpModeAvailable !== false)
            writer.tag(10, WireType.Varint).bool(message.isMpModeAvailable);
        /* string online_id = 11; */
        if (message.onlineId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.onlineId);
        /* uint32 last_active_time = 12; */
        if (message.lastActiveTime !== 0)
            writer.tag(12, WireType.Varint).uint32(message.lastActiveTime);
        /* uint32 name_card_id = 13; */
        if (message.nameCardId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.nameCardId);
        /* uint32 mp_player_num = 14; */
        if (message.mpPlayerNum !== 0)
            writer.tag(14, WireType.Varint).uint32(message.mpPlayerNum);
        /* bool is_chat_no_disturb = 15; */
        if (message.isChatNoDisturb !== false)
            writer.tag(15, WireType.Varint).bool(message.isChatNoDisturb);
        /* uint32 chat_sequence = 16; */
        if (message.chatSequence !== 0)
            writer.tag(16, WireType.Varint).uint32(message.chatSequence);
        /* string remark_name = 17; */
        if (message.remarkName !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.remarkName);
        /* repeated SocialShowAvatarInfo show_avatar_info_list = 22; */
        for (let i = 0; i < message.showAvatarInfoList.length; i++)
            SocialShowAvatarInfo.internalBinaryWrite(message.showAvatarInfoList[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* FriendEnterHomeOption friend_enter_home_option = 23; */
        if (message.friendEnterHomeOption !== 0)
            writer.tag(23, WireType.Varint).int32(message.friendEnterHomeOption);
        /* ProfilePicture profile_picture = 24; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* bool is_game_source = 25; */
        if (message.isGameSource !== false)
            writer.tag(25, WireType.Varint).bool(message.isGameSource);
        /* bool is_psn_source = 26; */
        if (message.isPsnSource !== false)
            writer.tag(26, WireType.Varint).bool(message.isPsnSource);
        /* PlatformType platform_type = 27; */
        if (message.platformType !== 0)
            writer.tag(27, WireType.Varint).int32(message.platformType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FriendBrief
 */
export const FriendBrief = new FriendBrief$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Furniture$Type extends MessageType<Furniture> {
    constructor() {
        super("Furniture", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Furniture>): Furniture {
        const message = { count: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Furniture>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Furniture): Furniture {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Furniture, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Furniture
 */
export const Furniture = new Furniture$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureCurModuleArrangeCountNotify$Type extends MessageType<FurnitureCurModuleArrangeCountNotify> {
    constructor() {
        super("FurnitureCurModuleArrangeCountNotify", [
            { no: 9, name: "furniture_arrange_count_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Uint32Pair }
        ]);
    }
    create(value?: PartialMessage<FurnitureCurModuleArrangeCountNotify>): FurnitureCurModuleArrangeCountNotify {
        const message = { furnitureArrangeCountList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureCurModuleArrangeCountNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureCurModuleArrangeCountNotify): FurnitureCurModuleArrangeCountNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Uint32Pair furniture_arrange_count_list */ 9:
                    message.furnitureArrangeCountList.push(Uint32Pair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureCurModuleArrangeCountNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Uint32Pair furniture_arrange_count_list = 9; */
        for (let i = 0; i < message.furnitureArrangeCountList.length; i++)
            Uint32Pair.internalBinaryWrite(message.furnitureArrangeCountList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureCurModuleArrangeCountNotify
 */
export const FurnitureCurModuleArrangeCountNotify = new FurnitureCurModuleArrangeCountNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeBeHelpedData$Type extends MessageType<FurnitureMakeBeHelpedData> {
    constructor() {
        super("FurnitureMakeBeHelpedData", [
            { no: 9, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "icon", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "profile_picture", kind: "message", T: () => ProfilePicture }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeBeHelpedData>): FurnitureMakeBeHelpedData {
        const message = { playerName: "", time: 0, uid: 0, icon: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeBeHelpedData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeBeHelpedData): FurnitureMakeBeHelpedData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 9:
                    message.playerName = reader.string();
                    break;
                case /* uint32 time */ 10:
                    message.time = reader.uint32();
                    break;
                case /* uint32 uid */ 13:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 icon */ 8:
                    message.icon = reader.uint32();
                    break;
                case /* ProfilePicture profile_picture */ 1:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeBeHelpedData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 9; */
        if (message.playerName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.playerName);
        /* uint32 time = 10; */
        if (message.time !== 0)
            writer.tag(10, WireType.Varint).uint32(message.time);
        /* uint32 uid = 13; */
        if (message.uid !== 0)
            writer.tag(13, WireType.Varint).uint32(message.uid);
        /* uint32 icon = 8; */
        if (message.icon !== 0)
            writer.tag(8, WireType.Varint).uint32(message.icon);
        /* ProfilePicture profile_picture = 1; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeBeHelpedData
 */
export const FurnitureMakeBeHelpedData = new FurnitureMakeBeHelpedData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeData$Type extends MessageType<FurnitureMakeData> {
    constructor() {
        super("FurnitureMakeData", [
            { no: 9, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "make_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "dur_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "accelerate_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeData>): FurnitureMakeData {
        const message = { index: 0, makeId: 0, beginTime: 0, durTime: 0, accelerateTime: 0, avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeData): FurnitureMakeData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 9:
                    message.index = reader.uint32();
                    break;
                case /* uint32 make_id */ 11:
                    message.makeId = reader.uint32();
                    break;
                case /* uint32 begin_time */ 4:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 dur_time */ 7:
                    message.durTime = reader.uint32();
                    break;
                case /* uint32 accelerate_time */ 1:
                    message.accelerateTime = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 14:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 9; */
        if (message.index !== 0)
            writer.tag(9, WireType.Varint).uint32(message.index);
        /* uint32 make_id = 11; */
        if (message.makeId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.makeId);
        /* uint32 begin_time = 4; */
        if (message.beginTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.beginTime);
        /* uint32 dur_time = 7; */
        if (message.durTime !== 0)
            writer.tag(7, WireType.Varint).uint32(message.durTime);
        /* uint32 accelerate_time = 1; */
        if (message.accelerateTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.accelerateTime);
        /* uint32 avatar_id = 14; */
        if (message.avatarId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeData
 */
export const FurnitureMakeData = new FurnitureMakeData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeHelpData$Type extends MessageType<FurnitureMakeHelpData> {
    constructor() {
        super("FurnitureMakeHelpData", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeHelpData>): FurnitureMakeHelpData {
        const message = { uid: 0, times: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeHelpData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeHelpData): FurnitureMakeHelpData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 times */ 11:
                    message.times = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeHelpData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint32 times = 11; */
        if (message.times !== 0)
            writer.tag(11, WireType.Varint).uint32(message.times);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeHelpData
 */
export const FurnitureMakeHelpData = new FurnitureMakeHelpData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeMakeInfo$Type extends MessageType<FurnitureMakeMakeInfo> {
    constructor() {
        super("FurnitureMakeMakeInfo", [
            { no: 7, name: "furniture_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "make_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeMakeInfo>): FurnitureMakeMakeInfo {
        const message = { furnitureId: 0, makeCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeMakeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeMakeInfo): FurnitureMakeMakeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 furniture_id */ 7:
                    message.furnitureId = reader.uint32();
                    break;
                case /* uint32 make_count */ 11:
                    message.makeCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeMakeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 furniture_id = 7; */
        if (message.furnitureId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.furnitureId);
        /* uint32 make_count = 11; */
        if (message.makeCount !== 0)
            writer.tag(11, WireType.Varint).uint32(message.makeCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeMakeInfo
 */
export const FurnitureMakeMakeInfo = new FurnitureMakeMakeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeReq$Type extends MessageType<FurnitureMakeReq> {
    constructor() {
        super("FurnitureMakeReq", []);
    }
    create(value?: PartialMessage<FurnitureMakeReq>): FurnitureMakeReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeReq): FurnitureMakeReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FurnitureMakeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeReq
 */
export const FurnitureMakeReq = new FurnitureMakeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeRsp$Type extends MessageType<FurnitureMakeRsp> {
    constructor() {
        super("FurnitureMakeRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "furniture_make_slot", kind: "message", T: () => FurnitureMakeSlot },
            { no: 13, name: "help_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FurnitureMakeHelpData },
            { no: 12, name: "helped_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FurnitureMakeBeHelpedData },
            { no: 11, name: "make_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FurnitureMakeMakeInfo }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeRsp>): FurnitureMakeRsp {
        const message = { retcode: 0, helpDataList: [], helpedDataList: [], makeInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeRsp): FurnitureMakeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* FurnitureMakeSlot furniture_make_slot */ 10:
                    message.furnitureMakeSlot = FurnitureMakeSlot.internalBinaryRead(reader, reader.uint32(), options, message.furnitureMakeSlot);
                    break;
                case /* repeated FurnitureMakeHelpData help_data_list */ 13:
                    message.helpDataList.push(FurnitureMakeHelpData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FurnitureMakeBeHelpedData helped_data_list */ 12:
                    message.helpedDataList.push(FurnitureMakeBeHelpedData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FurnitureMakeMakeInfo make_info_list */ 11:
                    message.makeInfoList.push(FurnitureMakeMakeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* FurnitureMakeSlot furniture_make_slot = 10; */
        if (message.furnitureMakeSlot)
            FurnitureMakeSlot.internalBinaryWrite(message.furnitureMakeSlot, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated FurnitureMakeHelpData help_data_list = 13; */
        for (let i = 0; i < message.helpDataList.length; i++)
            FurnitureMakeHelpData.internalBinaryWrite(message.helpDataList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated FurnitureMakeBeHelpedData helped_data_list = 12; */
        for (let i = 0; i < message.helpedDataList.length; i++)
            FurnitureMakeBeHelpedData.internalBinaryWrite(message.helpedDataList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated FurnitureMakeMakeInfo make_info_list = 11; */
        for (let i = 0; i < message.makeInfoList.length; i++)
            FurnitureMakeMakeInfo.internalBinaryWrite(message.makeInfoList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeRsp
 */
export const FurnitureMakeRsp = new FurnitureMakeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeSlot$Type extends MessageType<FurnitureMakeSlot> {
    constructor() {
        super("FurnitureMakeSlot", [
            { no: 15, name: "furniture_make_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FurnitureMakeData }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeSlot>): FurnitureMakeSlot {
        const message = { furnitureMakeDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeSlot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeSlot): FurnitureMakeSlot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FurnitureMakeData furniture_make_data_list */ 15:
                    message.furnitureMakeDataList.push(FurnitureMakeData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeSlot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FurnitureMakeData furniture_make_data_list = 15; */
        for (let i = 0; i < message.furnitureMakeDataList.length; i++)
            FurnitureMakeData.internalBinaryWrite(message.furnitureMakeDataList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeSlot
 */
export const FurnitureMakeSlot = new FurnitureMakeSlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeStartReq$Type extends MessageType<FurnitureMakeStartReq> {
    constructor() {
        super("FurnitureMakeStartReq", [
            { no: 1, name: "make_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeStartReq>): FurnitureMakeStartReq {
        const message = { makeId: 0, avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeStartReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeStartReq): FurnitureMakeStartReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 make_id */ 1:
                    message.makeId = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 14:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeStartReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 make_id = 1; */
        if (message.makeId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.makeId);
        /* uint32 avatar_id = 14; */
        if (message.avatarId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeStartReq
 */
export const FurnitureMakeStartReq = new FurnitureMakeStartReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FurnitureMakeStartRsp$Type extends MessageType<FurnitureMakeStartRsp> {
    constructor() {
        super("FurnitureMakeStartRsp", [
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "furniture_make_slot", kind: "message", T: () => FurnitureMakeSlot }
        ]);
    }
    create(value?: PartialMessage<FurnitureMakeStartRsp>): FurnitureMakeStartRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FurnitureMakeStartRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FurnitureMakeStartRsp): FurnitureMakeStartRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* FurnitureMakeSlot furniture_make_slot */ 10:
                    message.furnitureMakeSlot = FurnitureMakeSlot.internalBinaryRead(reader, reader.uint32(), options, message.furnitureMakeSlot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FurnitureMakeStartRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* FurnitureMakeSlot furniture_make_slot = 10; */
        if (message.furnitureMakeSlot)
            FurnitureMakeSlot.internalBinaryWrite(message.furnitureMakeSlot, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FurnitureMakeStartRsp
 */
export const FurnitureMakeStartRsp = new FurnitureMakeStartRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaInfo$Type extends MessageType<GachaInfo> {
    constructor() {
        super("GachaInfo", [
            { no: 13, name: "gacha_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "cost_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "cost_item_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "gacha_prefab_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "gacha_prob_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "gacha_record_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "gacha_preview_prefab_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "ten_cost_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "ten_cost_item_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "left_gacha_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gacha_times_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "gacha_sort_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 227, name: "gacha_prob_url_oversea", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1995, name: "gacha_record_url_oversea", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 883, name: "gacha_up_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GachaUpInfo },
            { no: 1044, name: "title_textmap", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1743, name: "display_up_5_item_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 969, name: "display_up_4_item_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1344, name: "wish_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1519, name: "wish_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 219, name: "wish_max_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 472, name: "is_new_wish", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GachaInfo>): GachaInfo {
        const message = { gachaType: 0, scheduleId: 0, beginTime: 0, endTime: 0, costItemId: 0, costItemNum: 0, gachaPrefabPath: "", gachaProbUrl: "", gachaRecordUrl: "", gachaPreviewPrefabPath: "", tenCostItemId: 0, tenCostItemNum: 0, leftGachaTimes: 0, gachaTimesLimit: 0, gachaSortId: 0, gachaProbUrlOversea: "", gachaRecordUrlOversea: "", gachaUpInfoList: [], titleTextmap: "", displayUp5ItemList: [], displayUp4ItemList: [], wishItemId: 0, wishProgress: 0, wishMaxProgress: 0, isNewWish: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaInfo): GachaInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gacha_type */ 13:
                    message.gachaType = reader.uint32();
                    break;
                case /* uint32 schedule_id */ 4:
                    message.scheduleId = reader.uint32();
                    break;
                case /* uint32 begin_time */ 2:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 6:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 cost_item_id */ 10:
                    message.costItemId = reader.uint32();
                    break;
                case /* uint32 cost_item_num */ 1:
                    message.costItemNum = reader.uint32();
                    break;
                case /* string gacha_prefab_path */ 11:
                    message.gachaPrefabPath = reader.string();
                    break;
                case /* string gacha_prob_url */ 14:
                    message.gachaProbUrl = reader.string();
                    break;
                case /* string gacha_record_url */ 9:
                    message.gachaRecordUrl = reader.string();
                    break;
                case /* string gacha_preview_prefab_path */ 7:
                    message.gachaPreviewPrefabPath = reader.string();
                    break;
                case /* uint32 ten_cost_item_id */ 8:
                    message.tenCostItemId = reader.uint32();
                    break;
                case /* uint32 ten_cost_item_num */ 12:
                    message.tenCostItemNum = reader.uint32();
                    break;
                case /* uint32 left_gacha_times */ 3:
                    message.leftGachaTimes = reader.uint32();
                    break;
                case /* uint32 gacha_times_limit */ 5:
                    message.gachaTimesLimit = reader.uint32();
                    break;
                case /* uint32 gacha_sort_id */ 15:
                    message.gachaSortId = reader.uint32();
                    break;
                case /* string gacha_prob_url_oversea */ 227:
                    message.gachaProbUrlOversea = reader.string();
                    break;
                case /* string gacha_record_url_oversea */ 1995:
                    message.gachaRecordUrlOversea = reader.string();
                    break;
                case /* repeated GachaUpInfo gacha_up_info_list */ 883:
                    message.gachaUpInfoList.push(GachaUpInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string title_textmap */ 1044:
                    message.titleTextmap = reader.string();
                    break;
                case /* repeated uint32 display_up_5_item_list */ 1743:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.displayUp5ItemList.push(reader.uint32());
                    else
                        message.displayUp5ItemList.push(reader.uint32());
                    break;
                case /* repeated uint32 display_up_4_item_list */ 969:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.displayUp4ItemList.push(reader.uint32());
                    else
                        message.displayUp4ItemList.push(reader.uint32());
                    break;
                case /* uint32 wish_item_id */ 1344:
                    message.wishItemId = reader.uint32();
                    break;
                case /* uint32 wish_progress */ 1519:
                    message.wishProgress = reader.uint32();
                    break;
                case /* uint32 wish_max_progress */ 219:
                    message.wishMaxProgress = reader.uint32();
                    break;
                case /* bool is_new_wish */ 472:
                    message.isNewWish = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gacha_type = 13; */
        if (message.gachaType !== 0)
            writer.tag(13, WireType.Varint).uint32(message.gachaType);
        /* uint32 schedule_id = 4; */
        if (message.scheduleId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.scheduleId);
        /* uint32 begin_time = 2; */
        if (message.beginTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 6; */
        if (message.endTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.endTime);
        /* uint32 cost_item_id = 10; */
        if (message.costItemId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.costItemId);
        /* uint32 cost_item_num = 1; */
        if (message.costItemNum !== 0)
            writer.tag(1, WireType.Varint).uint32(message.costItemNum);
        /* string gacha_prefab_path = 11; */
        if (message.gachaPrefabPath !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.gachaPrefabPath);
        /* string gacha_prob_url = 14; */
        if (message.gachaProbUrl !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.gachaProbUrl);
        /* string gacha_record_url = 9; */
        if (message.gachaRecordUrl !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.gachaRecordUrl);
        /* string gacha_preview_prefab_path = 7; */
        if (message.gachaPreviewPrefabPath !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.gachaPreviewPrefabPath);
        /* uint32 ten_cost_item_id = 8; */
        if (message.tenCostItemId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.tenCostItemId);
        /* uint32 ten_cost_item_num = 12; */
        if (message.tenCostItemNum !== 0)
            writer.tag(12, WireType.Varint).uint32(message.tenCostItemNum);
        /* uint32 left_gacha_times = 3; */
        if (message.leftGachaTimes !== 0)
            writer.tag(3, WireType.Varint).uint32(message.leftGachaTimes);
        /* uint32 gacha_times_limit = 5; */
        if (message.gachaTimesLimit !== 0)
            writer.tag(5, WireType.Varint).uint32(message.gachaTimesLimit);
        /* uint32 gacha_sort_id = 15; */
        if (message.gachaSortId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.gachaSortId);
        /* string gacha_prob_url_oversea = 227; */
        if (message.gachaProbUrlOversea !== "")
            writer.tag(227, WireType.LengthDelimited).string(message.gachaProbUrlOversea);
        /* string gacha_record_url_oversea = 1995; */
        if (message.gachaRecordUrlOversea !== "")
            writer.tag(1995, WireType.LengthDelimited).string(message.gachaRecordUrlOversea);
        /* repeated GachaUpInfo gacha_up_info_list = 883; */
        for (let i = 0; i < message.gachaUpInfoList.length; i++)
            GachaUpInfo.internalBinaryWrite(message.gachaUpInfoList[i], writer.tag(883, WireType.LengthDelimited).fork(), options).join();
        /* string title_textmap = 1044; */
        if (message.titleTextmap !== "")
            writer.tag(1044, WireType.LengthDelimited).string(message.titleTextmap);
        /* repeated uint32 display_up_5_item_list = 1743; */
        if (message.displayUp5ItemList.length) {
            writer.tag(1743, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.displayUp5ItemList.length; i++)
                writer.uint32(message.displayUp5ItemList[i]);
            writer.join();
        }
        /* repeated uint32 display_up_4_item_list = 969; */
        if (message.displayUp4ItemList.length) {
            writer.tag(969, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.displayUp4ItemList.length; i++)
                writer.uint32(message.displayUp4ItemList[i]);
            writer.join();
        }
        /* uint32 wish_item_id = 1344; */
        if (message.wishItemId !== 0)
            writer.tag(1344, WireType.Varint).uint32(message.wishItemId);
        /* uint32 wish_progress = 1519; */
        if (message.wishProgress !== 0)
            writer.tag(1519, WireType.Varint).uint32(message.wishProgress);
        /* uint32 wish_max_progress = 219; */
        if (message.wishMaxProgress !== 0)
            writer.tag(219, WireType.Varint).uint32(message.wishMaxProgress);
        /* bool is_new_wish = 472; */
        if (message.isNewWish !== false)
            writer.tag(472, WireType.Varint).bool(message.isNewWish);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaInfo
 */
export const GachaInfo = new GachaInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaItem$Type extends MessageType<GachaItem> {
    constructor() {
        super("GachaItem", [
            { no: 5, name: "gacha_item_", kind: "message", T: () => ItemParam },
            { no: 3, name: "transfer_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GachaTransferItem },
            { no: 4, name: "is_flash_card", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "is_gacha_item_new", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "token_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<GachaItem>): GachaItem {
        const message = { transferItems: [], isFlashCard: false, isGachaItemNew: false, tokenItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaItem): GachaItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ItemParam gacha_item_ */ 5:
                    message.gachaItem = ItemParam.internalBinaryRead(reader, reader.uint32(), options, message.gachaItem);
                    break;
                case /* repeated GachaTransferItem transfer_items */ 3:
                    message.transferItems.push(GachaTransferItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_flash_card */ 4:
                    message.isFlashCard = reader.bool();
                    break;
                case /* bool is_gacha_item_new */ 8:
                    message.isGachaItemNew = reader.bool();
                    break;
                case /* repeated ItemParam token_item_list */ 13:
                    message.tokenItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ItemParam gacha_item_ = 5; */
        if (message.gachaItem)
            ItemParam.internalBinaryWrite(message.gachaItem, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated GachaTransferItem transfer_items = 3; */
        for (let i = 0; i < message.transferItems.length; i++)
            GachaTransferItem.internalBinaryWrite(message.transferItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_flash_card = 4; */
        if (message.isFlashCard !== false)
            writer.tag(4, WireType.Varint).bool(message.isFlashCard);
        /* bool is_gacha_item_new = 8; */
        if (message.isGachaItemNew !== false)
            writer.tag(8, WireType.Varint).bool(message.isGachaItemNew);
        /* repeated ItemParam token_item_list = 13; */
        for (let i = 0; i < message.tokenItemList.length; i++)
            ItemParam.internalBinaryWrite(message.tokenItemList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaItem
 */
export const GachaItem = new GachaItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaTransferItem$Type extends MessageType<GachaTransferItem> {
    constructor() {
        super("GachaTransferItem", [
            { no: 8, name: "item", kind: "message", T: () => ItemParam },
            { no: 13, name: "is_transfer_item_new", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GachaTransferItem>): GachaTransferItem {
        const message = { isTransferItemNew: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaTransferItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaTransferItem): GachaTransferItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ItemParam item */ 8:
                    message.item = ItemParam.internalBinaryRead(reader, reader.uint32(), options, message.item);
                    break;
                case /* bool is_transfer_item_new */ 13:
                    message.isTransferItemNew = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaTransferItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ItemParam item = 8; */
        if (message.item)
            ItemParam.internalBinaryWrite(message.item, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool is_transfer_item_new = 13; */
        if (message.isTransferItemNew !== false)
            writer.tag(13, WireType.Varint).bool(message.isTransferItemNew);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaTransferItem
 */
export const GachaTransferItem = new GachaTransferItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaUpInfo$Type extends MessageType<GachaUpInfo> {
    constructor() {
        super("GachaUpInfo", [
            { no: 12, name: "item_parent_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "item_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GachaUpInfo>): GachaUpInfo {
        const message = { itemParentType: 0, itemIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaUpInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaUpInfo): GachaUpInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_parent_type */ 12:
                    message.itemParentType = reader.uint32();
                    break;
                case /* repeated uint32 item_id_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemIdList.push(reader.uint32());
                    else
                        message.itemIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaUpInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_parent_type = 12; */
        if (message.itemParentType !== 0)
            writer.tag(12, WireType.Varint).uint32(message.itemParentType);
        /* repeated uint32 item_id_list = 10; */
        if (message.itemIdList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.itemIdList.length; i++)
                writer.uint32(message.itemIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaUpInfo
 */
export const GachaUpInfo = new GachaUpInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaWishReq$Type extends MessageType<GachaWishReq> {
    constructor() {
        super("GachaWishReq", [
            { no: 2, name: "gacha_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "gacha_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GachaWishReq>): GachaWishReq {
        const message = { gachaType: 0, gachaScheduleId: 0, itemId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaWishReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaWishReq): GachaWishReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gacha_type */ 2:
                    message.gachaType = reader.uint32();
                    break;
                case /* uint32 gacha_schedule_id */ 4:
                    message.gachaScheduleId = reader.uint32();
                    break;
                case /* uint32 item_id */ 14:
                    message.itemId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaWishReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gacha_type = 2; */
        if (message.gachaType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gachaType);
        /* uint32 gacha_schedule_id = 4; */
        if (message.gachaScheduleId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.gachaScheduleId);
        /* uint32 item_id = 14; */
        if (message.itemId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.itemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaWishReq
 */
export const GachaWishReq = new GachaWishReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GachaWishRsp$Type extends MessageType<GachaWishRsp> {
    constructor() {
        super("GachaWishRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "gacha_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "gacha_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "wish_item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "wish_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "wish_max_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GachaWishRsp>): GachaWishRsp {
        const message = { retcode: 0, gachaType: 0, gachaScheduleId: 0, wishItemId: 0, wishProgress: 0, wishMaxProgress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GachaWishRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GachaWishRsp): GachaWishRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 gacha_type */ 14:
                    message.gachaType = reader.uint32();
                    break;
                case /* uint32 gacha_schedule_id */ 15:
                    message.gachaScheduleId = reader.uint32();
                    break;
                case /* uint32 wish_item_id */ 3:
                    message.wishItemId = reader.uint32();
                    break;
                case /* uint32 wish_progress */ 12:
                    message.wishProgress = reader.uint32();
                    break;
                case /* uint32 wish_max_progress */ 10:
                    message.wishMaxProgress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GachaWishRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 gacha_type = 14; */
        if (message.gachaType !== 0)
            writer.tag(14, WireType.Varint).uint32(message.gachaType);
        /* uint32 gacha_schedule_id = 15; */
        if (message.gachaScheduleId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.gachaScheduleId);
        /* uint32 wish_item_id = 3; */
        if (message.wishItemId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.wishItemId);
        /* uint32 wish_progress = 12; */
        if (message.wishProgress !== 0)
            writer.tag(12, WireType.Varint).uint32(message.wishProgress);
        /* uint32 wish_max_progress = 10; */
        if (message.wishMaxProgress !== 0)
            writer.tag(10, WireType.Varint).uint32(message.wishMaxProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GachaWishRsp
 */
export const GachaWishRsp = new GachaWishRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetAutoPickDropInfoNotify$Type extends MessageType<GadgetAutoPickDropInfoNotify> {
    constructor() {
        super("GadgetAutoPickDropInfoNotify", [
            { no: 15, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Item }
        ]);
    }
    create(value?: PartialMessage<GadgetAutoPickDropInfoNotify>): GadgetAutoPickDropInfoNotify {
        const message = { itemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetAutoPickDropInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetAutoPickDropInfoNotify): GadgetAutoPickDropInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Item item_list */ 15:
                    message.itemList.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetAutoPickDropInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Item item_list = 15; */
        for (let i = 0; i < message.itemList.length; i++)
            Item.internalBinaryWrite(message.itemList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetAutoPickDropInfoNotify
 */
export const GadgetAutoPickDropInfoNotify = new GadgetAutoPickDropInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetClientParam$Type extends MessageType<GadgetClientParam> {
    constructor() {
        super("GadgetClientParam", [
            { no: 1, name: "campId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "campType", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "ownerEntityId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "targetEntityId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "asyncLoad", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetClientParam>): GadgetClientParam {
        const message = { campId: 0, campType: 0, guid: 0n, ownerEntityId: 0, targetEntityId: 0, asyncLoad: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetClientParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetClientParam): GadgetClientParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 campId */ 1:
                    message.campId = reader.uint32();
                    break;
                case /* uint32 campType */ 2:
                    message.campType = reader.uint32();
                    break;
                case /* uint64 guid */ 3:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 ownerEntityId */ 4:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* uint32 targetEntityId */ 5:
                    message.targetEntityId = reader.uint32();
                    break;
                case /* bool asyncLoad */ 6:
                    message.asyncLoad = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetClientParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 campId = 1; */
        if (message.campId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.campId);
        /* uint32 campType = 2; */
        if (message.campType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.campType);
        /* uint64 guid = 3; */
        if (message.guid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.guid);
        /* uint32 ownerEntityId = 4; */
        if (message.ownerEntityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.ownerEntityId);
        /* uint32 targetEntityId = 5; */
        if (message.targetEntityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.targetEntityId);
        /* bool asyncLoad = 6; */
        if (message.asyncLoad !== false)
            writer.tag(6, WireType.Varint).bool(message.asyncLoad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetClientParam
 */
export const GadgetClientParam = new GadgetClientParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetCrucibleInfo$Type extends MessageType<GadgetCrucibleInfo> {
    constructor() {
        super("GadgetCrucibleInfo", [
            { no: 1, name: "mp_play_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "prepare_end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetCrucibleInfo>): GadgetCrucibleInfo {
        const message = { mpPlayId: 0, prepareEndTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetCrucibleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetCrucibleInfo): GadgetCrucibleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 mp_play_id */ 1:
                    message.mpPlayId = reader.uint32();
                    break;
                case /* uint32 prepare_end_time */ 2:
                    message.prepareEndTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetCrucibleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 mp_play_id = 1; */
        if (message.mpPlayId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.mpPlayId);
        /* uint32 prepare_end_time = 2; */
        if (message.prepareEndTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.prepareEndTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetCrucibleInfo
 */
export const GadgetCrucibleInfo = new GadgetCrucibleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetGeneralRewardInfo$Type extends MessageType<GadgetGeneralRewardInfo> {
    constructor() {
        super("GadgetGeneralRewardInfo", [
            { no: 1, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "dead_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "remain_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "qualify_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "item_param", kind: "message", T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<GadgetGeneralRewardInfo>): GadgetGeneralRewardInfo {
        const message = { resin: 0, deadTime: 0, remainUidList: [], qualifyUidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetGeneralRewardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetGeneralRewardInfo): GadgetGeneralRewardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 resin */ 1:
                    message.resin = reader.uint32();
                    break;
                case /* uint32 dead_time */ 2:
                    message.deadTime = reader.uint32();
                    break;
                case /* repeated uint32 remain_uid_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.remainUidList.push(reader.uint32());
                    else
                        message.remainUidList.push(reader.uint32());
                    break;
                case /* repeated uint32 qualify_uid_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.qualifyUidList.push(reader.uint32());
                    else
                        message.qualifyUidList.push(reader.uint32());
                    break;
                case /* ItemParam item_param */ 5:
                    message.itemParam = ItemParam.internalBinaryRead(reader, reader.uint32(), options, message.itemParam);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetGeneralRewardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 resin = 1; */
        if (message.resin !== 0)
            writer.tag(1, WireType.Varint).uint32(message.resin);
        /* uint32 dead_time = 2; */
        if (message.deadTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.deadTime);
        /* repeated uint32 remain_uid_list = 3; */
        if (message.remainUidList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.remainUidList.length; i++)
                writer.uint32(message.remainUidList[i]);
            writer.join();
        }
        /* repeated uint32 qualify_uid_list = 4; */
        if (message.qualifyUidList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.qualifyUidList.length; i++)
                writer.uint32(message.qualifyUidList[i]);
            writer.join();
        }
        /* ItemParam item_param = 5; */
        if (message.itemParam)
            ItemParam.internalBinaryWrite(message.itemParam, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetGeneralRewardInfo
 */
export const GadgetGeneralRewardInfo = new GadgetGeneralRewardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetInteractReq$Type extends MessageType<GadgetInteractReq> {
    constructor() {
        super("GadgetInteractReq", [
            { no: 9, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "op_type", kind: "enum", T: () => ["InterOpType", InterOpType, "INTER_OP_TYPE_"] },
            { no: 14, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_use_condense_resin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "resin_cost_type", kind: "enum", T: () => ["ResinCostType", ResinCostType, "RESIN_COST_TYPE_"] },
            { no: 12, name: "MPDBGIONLDB", kind: "scalar", jsonName: "MPDBGIONLDB", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetInteractReq>): GadgetInteractReq {
        const message = { gadgetEntityId: 0, opType: 0, gadgetId: 0, isUseCondenseResin: false, resinCostType: 0, mPDBGIONLDB: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetInteractReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetInteractReq): GadgetInteractReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_entity_id */ 9:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* InterOpType op_type */ 6:
                    message.opType = reader.int32();
                    break;
                case /* uint32 gadget_id */ 14:
                    message.gadgetId = reader.uint32();
                    break;
                case /* bool is_use_condense_resin */ 15:
                    message.isUseCondenseResin = reader.bool();
                    break;
                case /* ResinCostType resin_cost_type */ 11:
                    message.resinCostType = reader.int32();
                    break;
                case /* uint32 MPDBGIONLDB = 12 [json_name = "MPDBGIONLDB"];*/ 12:
                    message.mPDBGIONLDB = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetInteractReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_entity_id = 9; */
        if (message.gadgetEntityId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.gadgetEntityId);
        /* InterOpType op_type = 6; */
        if (message.opType !== 0)
            writer.tag(6, WireType.Varint).int32(message.opType);
        /* uint32 gadget_id = 14; */
        if (message.gadgetId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.gadgetId);
        /* bool is_use_condense_resin = 15; */
        if (message.isUseCondenseResin !== false)
            writer.tag(15, WireType.Varint).bool(message.isUseCondenseResin);
        /* ResinCostType resin_cost_type = 11; */
        if (message.resinCostType !== 0)
            writer.tag(11, WireType.Varint).int32(message.resinCostType);
        /* uint32 MPDBGIONLDB = 12 [json_name = "MPDBGIONLDB"]; */
        if (message.mPDBGIONLDB !== 0)
            writer.tag(12, WireType.Varint).uint32(message.mPDBGIONLDB);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetInteractReq
 */
export const GadgetInteractReq = new GadgetInteractReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetInteractRsp$Type extends MessageType<GadgetInteractRsp> {
    constructor() {
        super("GadgetInteractRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "interact_type", kind: "enum", T: () => ["InteractType", InteractType, "INTERACT_TYPE_"] },
            { no: 1, name: "op_type", kind: "enum", T: () => ["InterOpType", InterOpType, "INTER_OP_TYPE_"] },
            { no: 14, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetInteractRsp>): GadgetInteractRsp {
        const message = { retcode: 0, gadgetEntityId: 0, interactType: 0, opType: 0, gadgetId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetInteractRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetInteractRsp): GadgetInteractRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 gadget_entity_id */ 6:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* InteractType interact_type */ 9:
                    message.interactType = reader.int32();
                    break;
                case /* InterOpType op_type */ 1:
                    message.opType = reader.int32();
                    break;
                case /* uint32 gadget_id */ 14:
                    message.gadgetId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetInteractRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* uint32 gadget_entity_id = 6; */
        if (message.gadgetEntityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.gadgetEntityId);
        /* InteractType interact_type = 9; */
        if (message.interactType !== 0)
            writer.tag(9, WireType.Varint).int32(message.interactType);
        /* InterOpType op_type = 1; */
        if (message.opType !== 0)
            writer.tag(1, WireType.Varint).int32(message.opType);
        /* uint32 gadget_id = 14; */
        if (message.gadgetId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.gadgetId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetInteractRsp
 */
export const GadgetInteractRsp = new GadgetInteractRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetPlayInfo$Type extends MessageType<GadgetPlayInfo> {
    constructor() {
        super("GadgetPlayInfo", [
            { no: 21, name: "crucible_info", kind: "message", oneof: "playInfo", T: () => GadgetCrucibleInfo },
            { no: 1, name: "play_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "progress_stage_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_cd", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetPlayInfo>): GadgetPlayInfo {
        const message = { playInfo: { oneofKind: undefined }, playType: 0, duration: 0, progressStageList: [], startCd: 0, startTime: 0, progress: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetPlayInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetPlayInfo): GadgetPlayInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* GadgetCrucibleInfo crucible_info */ 21:
                    message.playInfo = {
                        oneofKind: "crucibleInfo",
                        crucibleInfo: GadgetCrucibleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.playInfo as any).crucibleInfo)
                    };
                    break;
                case /* uint32 play_type */ 1:
                    message.playType = reader.uint32();
                    break;
                case /* uint32 duration */ 2:
                    message.duration = reader.uint32();
                    break;
                case /* repeated uint32 progress_stage_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.progressStageList.push(reader.uint32());
                    else
                        message.progressStageList.push(reader.uint32());
                    break;
                case /* uint32 start_cd */ 4:
                    message.startCd = reader.uint32();
                    break;
                case /* uint32 start_time */ 5:
                    message.startTime = reader.uint32();
                    break;
                case /* uint32 progress */ 6:
                    message.progress = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetPlayInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* GadgetCrucibleInfo crucible_info = 21; */
        if (message.playInfo.oneofKind === "crucibleInfo")
            GadgetCrucibleInfo.internalBinaryWrite(message.playInfo.crucibleInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* uint32 play_type = 1; */
        if (message.playType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.playType);
        /* uint32 duration = 2; */
        if (message.duration !== 0)
            writer.tag(2, WireType.Varint).uint32(message.duration);
        /* repeated uint32 progress_stage_list = 3; */
        if (message.progressStageList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.progressStageList.length; i++)
                writer.uint32(message.progressStageList[i]);
            writer.join();
        }
        /* uint32 start_cd = 4; */
        if (message.startCd !== 0)
            writer.tag(4, WireType.Varint).uint32(message.startCd);
        /* uint32 start_time = 5; */
        if (message.startTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.startTime);
        /* uint32 progress = 6; */
        if (message.progress !== 0)
            writer.tag(6, WireType.Varint).uint32(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetPlayInfo
 */
export const GadgetPlayInfo = new GadgetPlayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GadgetStateNotify$Type extends MessageType<GadgetStateNotify> {
    constructor() {
        super("GadgetStateNotify", [
            { no: 2, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "gadget_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_enable_interact", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GadgetStateNotify>): GadgetStateNotify {
        const message = { gadgetEntityId: 0, gadgetState: 0, isEnableInteract: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GadgetStateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GadgetStateNotify): GadgetStateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_entity_id */ 2:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* uint32 gadget_state */ 11:
                    message.gadgetState = reader.uint32();
                    break;
                case /* bool is_enable_interact */ 10:
                    message.isEnableInteract = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GadgetStateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_entity_id = 2; */
        if (message.gadgetEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gadgetEntityId);
        /* uint32 gadget_state = 11; */
        if (message.gadgetState !== 0)
            writer.tag(11, WireType.Varint).uint32(message.gadgetState);
        /* bool is_enable_interact = 10; */
        if (message.isEnableInteract !== false)
            writer.tag(10, WireType.Varint).bool(message.isEnableInteract);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GadgetStateNotify
 */
export const GadgetStateNotify = new GadgetStateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatherGadgetInfo$Type extends MessageType<GatherGadgetInfo> {
    constructor() {
        super("GatherGadgetInfo", [
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_forbid_guest", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GatherGadgetInfo>): GatherGadgetInfo {
        const message = { itemId: 0, isForbidGuest: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GatherGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GatherGadgetInfo): GatherGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                case /* bool is_forbid_guest */ 2:
                    message.isForbidGuest = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatherGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        /* bool is_forbid_guest = 2; */
        if (message.isForbidGuest !== false)
            writer.tag(2, WireType.Varint).bool(message.isForbidGuest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GatherGadgetInfo
 */
export const GatherGadgetInfo = new GatherGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetActivityInfoReq$Type extends MessageType<GetActivityInfoReq> {
    constructor() {
        super("GetActivityInfoReq", [
            { no: 14, name: "activity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetActivityInfoReq>): GetActivityInfoReq {
        const message = { activityIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetActivityInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetActivityInfoReq): GetActivityInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 activity_id_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.activityIdList.push(reader.uint32());
                    else
                        message.activityIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetActivityInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 activity_id_list = 14; */
        if (message.activityIdList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.activityIdList.length; i++)
                writer.uint32(message.activityIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetActivityInfoReq
 */
export const GetActivityInfoReq = new GetActivityInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetActivityInfoRsp$Type extends MessageType<GetActivityInfoRsp> {
    constructor() {
        super("GetActivityInfoRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "activity_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActivityInfo },
            { no: 2, name: "activated_sale_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "disable_transfer_point_interaction_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Uint32Pair }
        ]);
    }
    create(value?: PartialMessage<GetActivityInfoRsp>): GetActivityInfoRsp {
        const message = { retcode: 0, activityInfoList: [], activatedSaleIdList: [], disableTransferPointInteractionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetActivityInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetActivityInfoRsp): GetActivityInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* repeated ActivityInfo activity_info_list */ 14:
                    message.activityInfoList.push(ActivityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 activated_sale_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.activatedSaleIdList.push(reader.uint32());
                    else
                        message.activatedSaleIdList.push(reader.uint32());
                    break;
                case /* repeated Uint32Pair disable_transfer_point_interaction_list */ 4:
                    message.disableTransferPointInteractionList.push(Uint32Pair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetActivityInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* repeated ActivityInfo activity_info_list = 14; */
        for (let i = 0; i < message.activityInfoList.length; i++)
            ActivityInfo.internalBinaryWrite(message.activityInfoList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 activated_sale_id_list = 2; */
        if (message.activatedSaleIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.activatedSaleIdList.length; i++)
                writer.uint32(message.activatedSaleIdList[i]);
            writer.join();
        }
        /* repeated Uint32Pair disable_transfer_point_interaction_list = 4; */
        for (let i = 0; i < message.disableTransferPointInteractionList.length; i++)
            Uint32Pair.internalBinaryWrite(message.disableTransferPointInteractionList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetActivityInfoRsp
 */
export const GetActivityInfoRsp = new GetActivityInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllMailReq$Type extends MessageType<GetAllMailReq> {
    constructor() {
        super("GetAllMailReq", [
            { no: 7, name: "ANKKGPJCINB", kind: "scalar", jsonName: "ANKKGPJCINB", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllMailReq>): GetAllMailReq {
        const message = { aNKKGPJCINB: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllMailReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllMailReq): GetAllMailReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"];*/ 7:
                    message.aNKKGPJCINB = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllMailReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"]; */
        if (message.aNKKGPJCINB !== false)
            writer.tag(7, WireType.Varint).bool(message.aNKKGPJCINB);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllMailReq
 */
export const GetAllMailReq = new GetAllMailReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllMailRsp$Type extends MessageType<GetAllMailRsp> {
    constructor() {
        super("GetAllMailRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "mail_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MailData },
            { no: 5, name: "is_truncated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "ANKKGPJCINB", kind: "scalar", jsonName: "ANKKGPJCINB", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllMailRsp>): GetAllMailRsp {
        const message = { retcode: 0, mailList: [], isTruncated: false, aNKKGPJCINB: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllMailRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllMailRsp): GetAllMailRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* repeated MailData mail_list */ 9:
                    message.mailList.push(MailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_truncated */ 5:
                    message.isTruncated = reader.bool();
                    break;
                case /* bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"];*/ 7:
                    message.aNKKGPJCINB = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllMailRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* repeated MailData mail_list = 9; */
        for (let i = 0; i < message.mailList.length; i++)
            MailData.internalBinaryWrite(message.mailList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool is_truncated = 5; */
        if (message.isTruncated !== false)
            writer.tag(5, WireType.Varint).bool(message.isTruncated);
        /* bool ANKKGPJCINB = 7 [json_name = "ANKKGPJCINB"]; */
        if (message.aNKKGPJCINB !== false)
            writer.tag(7, WireType.Varint).bool(message.aNKKGPJCINB);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllMailRsp
 */
export const GetAllMailRsp = new GetAllMailRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllUnlockNameCardRsp$Type extends MessageType<GetAllUnlockNameCardRsp> {
    constructor() {
        super("GetAllUnlockNameCardRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_card_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllUnlockNameCardRsp>): GetAllUnlockNameCardRsp {
        const message = { retcode: 0, nameCardList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllUnlockNameCardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllUnlockNameCardRsp): GetAllUnlockNameCardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 name_card_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.nameCardList.push(reader.uint32());
                    else
                        message.nameCardList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllUnlockNameCardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* repeated uint32 name_card_list = 2; */
        if (message.nameCardList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.nameCardList.length; i++)
                writer.uint32(message.nameCardList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllUnlockNameCardRsp
 */
export const GetAllUnlockNameCardRsp = new GetAllUnlockNameCardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthkeyReq$Type extends MessageType<GetAuthkeyReq> {
    constructor() {
        super("GetAuthkeyReq", [
            { no: 12, name: "auth_appid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "sign_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "authkey_ver", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthkeyReq>): GetAuthkeyReq {
        const message = { authAppid: "", signType: 0, authkeyVer: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAuthkeyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthkeyReq): GetAuthkeyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string auth_appid */ 12:
                    message.authAppid = reader.string();
                    break;
                case /* uint32 sign_type */ 15:
                    message.signType = reader.uint32();
                    break;
                case /* uint32 authkey_ver */ 7:
                    message.authkeyVer = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthkeyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string auth_appid = 12; */
        if (message.authAppid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.authAppid);
        /* uint32 sign_type = 15; */
        if (message.signType !== 0)
            writer.tag(15, WireType.Varint).uint32(message.signType);
        /* uint32 authkey_ver = 7; */
        if (message.authkeyVer !== 0)
            writer.tag(7, WireType.Varint).uint32(message.authkeyVer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAuthkeyReq
 */
export const GetAuthkeyReq = new GetAuthkeyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthkeyRsp$Type extends MessageType<GetAuthkeyRsp> {
    constructor() {
        super("GetAuthkeyRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "authkey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth_appid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sign_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "authkey_ver", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "game_biz", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthkeyRsp>): GetAuthkeyRsp {
        const message = { retcode: 0, authkey: "", authAppid: "", signType: 0, authkeyVer: 0, gameBiz: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAuthkeyRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthkeyRsp): GetAuthkeyRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* string authkey */ 1:
                    message.authkey = reader.string();
                    break;
                case /* string auth_appid */ 2:
                    message.authAppid = reader.string();
                    break;
                case /* uint32 sign_type */ 7:
                    message.signType = reader.uint32();
                    break;
                case /* uint32 authkey_ver */ 10:
                    message.authkeyVer = reader.uint32();
                    break;
                case /* string game_biz */ 4:
                    message.gameBiz = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthkeyRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* string authkey = 1; */
        if (message.authkey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authkey);
        /* string auth_appid = 2; */
        if (message.authAppid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authAppid);
        /* uint32 sign_type = 7; */
        if (message.signType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.signType);
        /* uint32 authkey_ver = 10; */
        if (message.authkeyVer !== 0)
            writer.tag(10, WireType.Varint).uint32(message.authkeyVer);
        /* string game_biz = 4; */
        if (message.gameBiz !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.gameBiz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAuthkeyRsp
 */
export const GetAuthkeyRsp = new GetAuthkeyRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBattlePassProductReq$Type extends MessageType<GetBattlePassProductReq> {
    constructor() {
        super("GetBattlePassProductReq", [
            { no: 2, name: "battle_pass_product_play_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBattlePassProductReq>): GetBattlePassProductReq {
        const message = { battlePassProductPlayType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBattlePassProductReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBattlePassProductReq): GetBattlePassProductReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 battle_pass_product_play_type */ 2:
                    message.battlePassProductPlayType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBattlePassProductReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 battle_pass_product_play_type = 2; */
        if (message.battlePassProductPlayType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.battlePassProductPlayType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBattlePassProductReq
 */
export const GetBattlePassProductReq = new GetBattlePassProductReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBattlePassProductRsp$Type extends MessageType<GetBattlePassProductRsp> {
    constructor() {
        super("GetBattlePassProductRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "battle_pass_product_play_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cur_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetBattlePassProductRsp>): GetBattlePassProductRsp {
        const message = { retcode: 0, battlePassProductPlayType: 0, curScheduleId: 0, productId: "", priceTier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBattlePassProductRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBattlePassProductRsp): GetBattlePassProductRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 battle_pass_product_play_type */ 9:
                    message.battlePassProductPlayType = reader.uint32();
                    break;
                case /* uint32 cur_schedule_id */ 12:
                    message.curScheduleId = reader.uint32();
                    break;
                case /* string product_id */ 7:
                    message.productId = reader.string();
                    break;
                case /* string price_tier */ 5:
                    message.priceTier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBattlePassProductRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 battle_pass_product_play_type = 9; */
        if (message.battlePassProductPlayType !== 0)
            writer.tag(9, WireType.Varint).uint32(message.battlePassProductPlayType);
        /* uint32 cur_schedule_id = 12; */
        if (message.curScheduleId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.curScheduleId);
        /* string product_id = 7; */
        if (message.productId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.productId);
        /* string price_tier = 5; */
        if (message.priceTier !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.priceTier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBattlePassProductRsp
 */
export const GetBattlePassProductRsp = new GetBattlePassProductRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDailyDungeonEntryInfoReq$Type extends MessageType<GetDailyDungeonEntryInfoReq> {
    constructor() {
        super("GetDailyDungeonEntryInfoReq", [
            { no: 11, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDailyDungeonEntryInfoReq>): GetDailyDungeonEntryInfoReq {
        const message = { sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDailyDungeonEntryInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDailyDungeonEntryInfoReq): GetDailyDungeonEntryInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 11:
                    message.sceneId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDailyDungeonEntryInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 11; */
        if (message.sceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sceneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDailyDungeonEntryInfoReq
 */
export const GetDailyDungeonEntryInfoReq = new GetDailyDungeonEntryInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDailyDungeonEntryInfoRsp$Type extends MessageType<GetDailyDungeonEntryInfoRsp> {
    constructor() {
        super("GetDailyDungeonEntryInfoRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "daily_dungeon_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DailyDungeonEntryInfo }
        ]);
    }
    create(value?: PartialMessage<GetDailyDungeonEntryInfoRsp>): GetDailyDungeonEntryInfoRsp {
        const message = { retcode: 0, dailyDungeonInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDailyDungeonEntryInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDailyDungeonEntryInfoRsp): GetDailyDungeonEntryInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* repeated DailyDungeonEntryInfo daily_dungeon_info_list */ 4:
                    message.dailyDungeonInfoList.push(DailyDungeonEntryInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDailyDungeonEntryInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* repeated DailyDungeonEntryInfo daily_dungeon_info_list = 4; */
        for (let i = 0; i < message.dailyDungeonInfoList.length; i++)
            DailyDungeonEntryInfo.internalBinaryWrite(message.dailyDungeonInfoList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDailyDungeonEntryInfoRsp
 */
export const GetDailyDungeonEntryInfoRsp = new GetDailyDungeonEntryInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFriendShowAvatarInfoReq$Type extends MessageType<GetFriendShowAvatarInfoReq> {
    constructor() {
        super("GetFriendShowAvatarInfoReq", [
            { no: 9, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetFriendShowAvatarInfoReq>): GetFriendShowAvatarInfoReq {
        const message = { uid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFriendShowAvatarInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFriendShowAvatarInfoReq): GetFriendShowAvatarInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 9:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFriendShowAvatarInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 9; */
        if (message.uid !== 0)
            writer.tag(9, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFriendShowAvatarInfoReq
 */
export const GetFriendShowAvatarInfoReq = new GetFriendShowAvatarInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFriendShowAvatarInfoRsp$Type extends MessageType<GetFriendShowAvatarInfoRsp> {
    constructor() {
        super("GetFriendShowAvatarInfoRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "show_avatar_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShowAvatarInfo }
        ]);
    }
    create(value?: PartialMessage<GetFriendShowAvatarInfoRsp>): GetFriendShowAvatarInfoRsp {
        const message = { retcode: 0, uid: 0, showAvatarInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFriendShowAvatarInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFriendShowAvatarInfoRsp): GetFriendShowAvatarInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 uid */ 11:
                    message.uid = reader.uint32();
                    break;
                case /* repeated ShowAvatarInfo show_avatar_info_list */ 7:
                    message.showAvatarInfoList.push(ShowAvatarInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFriendShowAvatarInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint32 uid = 11; */
        if (message.uid !== 0)
            writer.tag(11, WireType.Varint).uint32(message.uid);
        /* repeated ShowAvatarInfo show_avatar_info_list = 7; */
        for (let i = 0; i < message.showAvatarInfoList.length; i++)
            ShowAvatarInfo.internalBinaryWrite(message.showAvatarInfoList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFriendShowAvatarInfoRsp
 */
export const GetFriendShowAvatarInfoRsp = new GetFriendShowAvatarInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFurnitureCurModuleArrangeCountReq$Type extends MessageType<GetFurnitureCurModuleArrangeCountReq> {
    constructor() {
        super("GetFurnitureCurModuleArrangeCountReq", []);
    }
    create(value?: PartialMessage<GetFurnitureCurModuleArrangeCountReq>): GetFurnitureCurModuleArrangeCountReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFurnitureCurModuleArrangeCountReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFurnitureCurModuleArrangeCountReq): GetFurnitureCurModuleArrangeCountReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFurnitureCurModuleArrangeCountReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFurnitureCurModuleArrangeCountReq
 */
export const GetFurnitureCurModuleArrangeCountReq = new GetFurnitureCurModuleArrangeCountReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGachaInfoRsp$Type extends MessageType<GetGachaInfoRsp> {
    constructor() {
        super("GetGachaInfoRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "gacha_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GachaInfo },
            { no: 13, name: "gacha_random", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "KKHCOFPEMNJ", kind: "scalar", jsonName: "KKHCOFPEMNJ", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "LCPFDBAGIEC", kind: "scalar", jsonName: "LCPFDBAGIEC", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetGachaInfoRsp>): GetGachaInfoRsp {
        const message = { retcode: 0, gachaInfoList: [], gachaRandom: 0, kKHCOFPEMNJ: 0, lCPFDBAGIEC: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetGachaInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGachaInfoRsp): GetGachaInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* repeated GachaInfo gacha_info_list */ 12:
                    message.gachaInfoList.push(GachaInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 gacha_random */ 13:
                    message.gachaRandom = reader.uint32();
                    break;
                case /* uint32 KKHCOFPEMNJ = 7 [json_name = "KKHCOFPEMNJ"];*/ 7:
                    message.kKHCOFPEMNJ = reader.uint32();
                    break;
                case /* bool LCPFDBAGIEC = 9 [json_name = "LCPFDBAGIEC"];*/ 9:
                    message.lCPFDBAGIEC = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGachaInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* repeated GachaInfo gacha_info_list = 12; */
        for (let i = 0; i < message.gachaInfoList.length; i++)
            GachaInfo.internalBinaryWrite(message.gachaInfoList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 gacha_random = 13; */
        if (message.gachaRandom !== 0)
            writer.tag(13, WireType.Varint).uint32(message.gachaRandom);
        /* uint32 KKHCOFPEMNJ = 7 [json_name = "KKHCOFPEMNJ"]; */
        if (message.kKHCOFPEMNJ !== 0)
            writer.tag(7, WireType.Varint).uint32(message.kKHCOFPEMNJ);
        /* bool LCPFDBAGIEC = 9 [json_name = "LCPFDBAGIEC"]; */
        if (message.lCPFDBAGIEC !== false)
            writer.tag(9, WireType.Varint).bool(message.lCPFDBAGIEC);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetGachaInfoRsp
 */
export const GetGachaInfoRsp = new GetGachaInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInvestigationMonsterReq$Type extends MessageType<GetInvestigationMonsterReq> {
    constructor() {
        super("GetInvestigationMonsterReq", [
            { no: 13, name: "city_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "ABFECCDJENJ", kind: "scalar", jsonName: "ABFECCDJENJ", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetInvestigationMonsterReq>): GetInvestigationMonsterReq {
        const message = { cityIdList: [], aBFECCDJENJ: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInvestigationMonsterReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvestigationMonsterReq): GetInvestigationMonsterReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 city_id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cityIdList.push(reader.uint32());
                    else
                        message.cityIdList.push(reader.uint32());
                    break;
                case /* bool ABFECCDJENJ = 11 [json_name = "ABFECCDJENJ"];*/ 11:
                    message.aBFECCDJENJ = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInvestigationMonsterReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 city_id_list = 13; */
        if (message.cityIdList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cityIdList.length; i++)
                writer.uint32(message.cityIdList[i]);
            writer.join();
        }
        /* bool ABFECCDJENJ = 11 [json_name = "ABFECCDJENJ"]; */
        if (message.aBFECCDJENJ !== false)
            writer.tag(11, WireType.Varint).bool(message.aBFECCDJENJ);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetInvestigationMonsterReq
 */
export const GetInvestigationMonsterReq = new GetInvestigationMonsterReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInvestigationMonsterRsp$Type extends MessageType<GetInvestigationMonsterRsp> {
    constructor() {
        super("GetInvestigationMonsterRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "monster_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InvestigationMonster },
            { no: 10, name: "ABFECCDJENJ", kind: "scalar", jsonName: "ABFECCDJENJ", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetInvestigationMonsterRsp>): GetInvestigationMonsterRsp {
        const message = { retcode: 0, monsterList: [], aBFECCDJENJ: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInvestigationMonsterRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInvestigationMonsterRsp): GetInvestigationMonsterRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* repeated InvestigationMonster monster_list */ 7:
                    message.monsterList.push(InvestigationMonster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool ABFECCDJENJ = 10 [json_name = "ABFECCDJENJ"];*/ 10:
                    message.aBFECCDJENJ = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInvestigationMonsterRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* repeated InvestigationMonster monster_list = 7; */
        for (let i = 0; i < message.monsterList.length; i++)
            InvestigationMonster.internalBinaryWrite(message.monsterList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool ABFECCDJENJ = 10 [json_name = "ABFECCDJENJ"]; */
        if (message.aBFECCDJENJ !== false)
            writer.tag(10, WireType.Varint).bool(message.aBFECCDJENJ);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetInvestigationMonsterRsp
 */
export const GetInvestigationMonsterRsp = new GetInvestigationMonsterRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMailItemReq$Type extends MessageType<GetMailItemReq> {
    constructor() {
        super("GetMailItemReq", [
            { no: 8, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetMailItemReq>): GetMailItemReq {
        const message = { mailIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMailItemReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMailItemReq): GetMailItemReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 mail_id_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMailItemReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 mail_id_list = 8; */
        if (message.mailIdList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMailItemReq
 */
export const GetMailItemReq = new GetMailItemReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMailItemRsp$Type extends MessageType<GetMailItemRsp> {
    constructor() {
        super("GetMailItemRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EquipParam }
        ]);
    }
    create(value?: PartialMessage<GetMailItemRsp>): GetMailItemRsp {
        const message = { retcode: 0, mailIdList: [], itemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMailItemRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMailItemRsp): GetMailItemRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 mail_id_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                case /* repeated EquipParam item_list */ 5:
                    message.itemList.push(EquipParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMailItemRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* repeated uint32 mail_id_list = 10; */
        if (message.mailIdList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        /* repeated EquipParam item_list = 5; */
        for (let i = 0; i < message.itemList.length; i++)
            EquipParam.internalBinaryWrite(message.itemList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMailItemRsp
 */
export const GetMailItemRsp = new GetMailItemRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOnlinePlayerListReq$Type extends MessageType<GetOnlinePlayerListReq> {
    constructor() {
        super("GetOnlinePlayerListReq", []);
    }
    create(value?: PartialMessage<GetOnlinePlayerListReq>): GetOnlinePlayerListReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOnlinePlayerListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOnlinePlayerListReq): GetOnlinePlayerListReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetOnlinePlayerListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetOnlinePlayerListReq
 */
export const GetOnlinePlayerListReq = new GetOnlinePlayerListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOnlinePlayerListRsp$Type extends MessageType<GetOnlinePlayerListRsp> {
    constructor() {
        super("GetOnlinePlayerListRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "player_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OnlinePlayerInfo },
            { no: 2, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetOnlinePlayerListRsp>): GetOnlinePlayerListRsp {
        const message = { retcode: 0, playerInfoList: [], param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOnlinePlayerListRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOnlinePlayerListRsp): GetOnlinePlayerListRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* repeated OnlinePlayerInfo player_info_list */ 10:
                    message.playerInfoList.push(OnlinePlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 param */ 2:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOnlinePlayerListRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* repeated OnlinePlayerInfo player_info_list = 10; */
        for (let i = 0; i < message.playerInfoList.length; i++)
            OnlinePlayerInfo.internalBinaryWrite(message.playerInfoList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* uint32 param = 2; */
        if (message.param !== 0)
            writer.tag(2, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetOnlinePlayerListRsp
 */
export const GetOnlinePlayerListRsp = new GetOnlinePlayerListRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerAskFriendListRsp$Type extends MessageType<GetPlayerAskFriendListRsp> {
    constructor() {
        super("GetPlayerAskFriendListRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "ask_friend_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FriendBrief }
        ]);
    }
    create(value?: PartialMessage<GetPlayerAskFriendListRsp>): GetPlayerAskFriendListRsp {
        const message = { retcode: 0, askFriendList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerAskFriendListRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerAskFriendListRsp): GetPlayerAskFriendListRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* repeated FriendBrief ask_friend_list */ 13:
                    message.askFriendList.push(FriendBrief.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerAskFriendListRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* repeated FriendBrief ask_friend_list = 13; */
        for (let i = 0; i < message.askFriendList.length; i++)
            FriendBrief.internalBinaryWrite(message.askFriendList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerAskFriendListRsp
 */
export const GetPlayerAskFriendListRsp = new GetPlayerAskFriendListRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerBlacklistRsp$Type extends MessageType<GetPlayerBlacklistRsp> {
    constructor() {
        super("GetPlayerBlacklistRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "blacklist", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FriendBrief }
        ]);
    }
    create(value?: PartialMessage<GetPlayerBlacklistRsp>): GetPlayerBlacklistRsp {
        const message = { retcode: 0, blacklist: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerBlacklistRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerBlacklistRsp): GetPlayerBlacklistRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* repeated FriendBrief blacklist */ 5:
                    message.blacklist.push(FriendBrief.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerBlacklistRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* repeated FriendBrief blacklist = 5; */
        for (let i = 0; i < message.blacklist.length; i++)
            FriendBrief.internalBinaryWrite(message.blacklist[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerBlacklistRsp
 */
export const GetPlayerBlacklistRsp = new GetPlayerBlacklistRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerFriendListRsp$Type extends MessageType<GetPlayerFriendListRsp> {
    constructor() {
        super("GetPlayerFriendListRsp", [
            { no: 3, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "friend_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FriendBrief },
            { no: 5, name: "ask_friend_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FriendBrief }
        ]);
    }
    create(value?: PartialMessage<GetPlayerFriendListRsp>): GetPlayerFriendListRsp {
        const message = { retcode: 0, friendList: [], askFriendList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerFriendListRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerFriendListRsp): GetPlayerFriendListRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* repeated FriendBrief friend_list */ 6:
                    message.friendList.push(FriendBrief.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FriendBrief ask_friend_list */ 5:
                    message.askFriendList.push(FriendBrief.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerFriendListRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 3; */
        if (message.retcode !== 0)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* repeated FriendBrief friend_list = 6; */
        for (let i = 0; i < message.friendList.length; i++)
            FriendBrief.internalBinaryWrite(message.friendList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated FriendBrief ask_friend_list = 5; */
        for (let i = 0; i < message.askFriendList.length; i++)
            FriendBrief.internalBinaryWrite(message.askFriendList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerFriendListRsp
 */
export const GetPlayerFriendListRsp = new GetPlayerFriendListRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerHomeCompInfoReq$Type extends MessageType<GetPlayerHomeCompInfoReq> {
    constructor() {
        super("GetPlayerHomeCompInfoReq", []);
    }
    create(value?: PartialMessage<GetPlayerHomeCompInfoReq>): GetPlayerHomeCompInfoReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerHomeCompInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerHomeCompInfoReq): GetPlayerHomeCompInfoReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetPlayerHomeCompInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerHomeCompInfoReq
 */
export const GetPlayerHomeCompInfoReq = new GetPlayerHomeCompInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerSocialDetailReq$Type extends MessageType<GetPlayerSocialDetailReq> {
    constructor() {
        super("GetPlayerSocialDetailReq", [
            { no: 14, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPlayerSocialDetailReq>): GetPlayerSocialDetailReq {
        const message = { uid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerSocialDetailReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerSocialDetailReq): GetPlayerSocialDetailReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 14:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerSocialDetailReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 14; */
        if (message.uid !== 0)
            writer.tag(14, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerSocialDetailReq
 */
export const GetPlayerSocialDetailReq = new GetPlayerSocialDetailReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerSocialDetailRsp$Type extends MessageType<GetPlayerSocialDetailRsp> {
    constructor() {
        super("GetPlayerSocialDetailRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "detail_data", kind: "message", T: () => SocialDetail }
        ]);
    }
    create(value?: PartialMessage<GetPlayerSocialDetailRsp>): GetPlayerSocialDetailRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerSocialDetailRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerSocialDetailRsp): GetPlayerSocialDetailRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* SocialDetail detail_data */ 15:
                    message.detailData = SocialDetail.internalBinaryRead(reader, reader.uint32(), options, message.detailData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerSocialDetailRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* SocialDetail detail_data = 15; */
        if (message.detailData)
            SocialDetail.internalBinaryWrite(message.detailData, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerSocialDetailRsp
 */
export const GetPlayerSocialDetailRsp = new GetPlayerSocialDetailRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerTokenReq$Type extends MessageType<GetPlayerTokenReq> {
    constructor() {
        super("GetPlayerTokenReq", [
            { no: 3, name: "account_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "account_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "account_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "account_ext", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_guest", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "platform_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "cloud_client_ip", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "online_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "psn_region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "sub_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "psn_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "client_ip_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 966, name: "birthday", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1883, name: "unk1", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 924, name: "client_seed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 550, name: "key_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPlayerTokenReq>): GetPlayerTokenReq {
        const message = { accountType: 0, accountUid: "", accountToken: "", accountExt: "", uid: 0, isGuest: false, platformType: 0, cloudClientIp: 0, onlineId: "", psnRegion: "", channelId: 0, subChannelId: 0, countryCode: "", psnId: "", clientIpStr: "", birthday: "", unk1: 0, clientSeed: "", keyId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerTokenReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerTokenReq): GetPlayerTokenReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 account_type */ 3:
                    message.accountType = reader.uint32();
                    break;
                case /* string account_uid */ 12:
                    message.accountUid = reader.string();
                    break;
                case /* string account_token */ 14:
                    message.accountToken = reader.string();
                    break;
                case /* string account_ext */ 2:
                    message.accountExt = reader.string();
                    break;
                case /* uint32 uid */ 8:
                    message.uid = reader.uint32();
                    break;
                case /* bool is_guest */ 4:
                    message.isGuest = reader.bool();
                    break;
                case /* uint32 platform_type */ 7:
                    message.platformType = reader.uint32();
                    break;
                case /* uint32 cloud_client_ip */ 13:
                    message.cloudClientIp = reader.uint32();
                    break;
                case /* string online_id */ 9:
                    message.onlineId = reader.string();
                    break;
                case /* string psn_region */ 15:
                    message.psnRegion = reader.string();
                    break;
                case /* uint32 channel_id */ 10:
                    message.channelId = reader.uint32();
                    break;
                case /* uint32 sub_channel_id */ 1:
                    message.subChannelId = reader.uint32();
                    break;
                case /* string country_code */ 11:
                    message.countryCode = reader.string();
                    break;
                case /* string psn_id */ 5:
                    message.psnId = reader.string();
                    break;
                case /* string client_ip_str */ 6:
                    message.clientIpStr = reader.string();
                    break;
                case /* string birthday */ 966:
                    message.birthday = reader.string();
                    break;
                case /* uint32 unk1 */ 1883:
                    message.unk1 = reader.uint32();
                    break;
                case /* string client_seed */ 924:
                    message.clientSeed = reader.string();
                    break;
                case /* uint32 key_id */ 550:
                    message.keyId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerTokenReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 account_type = 3; */
        if (message.accountType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.accountType);
        /* string account_uid = 12; */
        if (message.accountUid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.accountUid);
        /* string account_token = 14; */
        if (message.accountToken !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.accountToken);
        /* string account_ext = 2; */
        if (message.accountExt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountExt);
        /* uint32 uid = 8; */
        if (message.uid !== 0)
            writer.tag(8, WireType.Varint).uint32(message.uid);
        /* bool is_guest = 4; */
        if (message.isGuest !== false)
            writer.tag(4, WireType.Varint).bool(message.isGuest);
        /* uint32 platform_type = 7; */
        if (message.platformType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.platformType);
        /* uint32 cloud_client_ip = 13; */
        if (message.cloudClientIp !== 0)
            writer.tag(13, WireType.Varint).uint32(message.cloudClientIp);
        /* string online_id = 9; */
        if (message.onlineId !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.onlineId);
        /* string psn_region = 15; */
        if (message.psnRegion !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.psnRegion);
        /* uint32 channel_id = 10; */
        if (message.channelId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.channelId);
        /* uint32 sub_channel_id = 1; */
        if (message.subChannelId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.subChannelId);
        /* string country_code = 11; */
        if (message.countryCode !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.countryCode);
        /* string psn_id = 5; */
        if (message.psnId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.psnId);
        /* string client_ip_str = 6; */
        if (message.clientIpStr !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.clientIpStr);
        /* string birthday = 966; */
        if (message.birthday !== "")
            writer.tag(966, WireType.LengthDelimited).string(message.birthday);
        /* uint32 unk1 = 1883; */
        if (message.unk1 !== 0)
            writer.tag(1883, WireType.Varint).uint32(message.unk1);
        /* string client_seed = 924; */
        if (message.clientSeed !== "")
            writer.tag(924, WireType.LengthDelimited).string(message.clientSeed);
        /* uint32 key_id = 550; */
        if (message.keyId !== 0)
            writer.tag(550, WireType.Varint).uint32(message.keyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerTokenReq
 */
export const GetPlayerTokenReq = new GetPlayerTokenReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPlayerTokenRsp$Type extends MessageType<GetPlayerTokenRsp> {
    constructor() {
        super("GetPlayerTokenRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "black_uid_end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "account_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "account_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_proficient_player", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "secret_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "gm_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "secret_key_seed", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "security_cmd_buffer", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "platform_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "extra_bin_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "is_guest", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1614, name: "channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1911, name: "sub_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1855, name: "tag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 739, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 977, name: "is_login_white_list", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 245, name: "psn_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1387, name: "client_version_random_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 633, name: "reg_platform", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1238, name: "client_ip_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1109, name: "birthday", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1728, name: "unk1", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1679, name: "unk2", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2012, name: "unk3", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1596, name: "encrypted_seed", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1501, name: "seed_signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1447, name: "unk6", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPlayerTokenRsp>): GetPlayerTokenRsp {
        const message = { retcode: 0, msg: "", uid: 0, token: "", blackUidEndTime: 0, accountType: 0, accountUid: "", isProficientPlayer: false, secretKey: "", gmUid: 0, secretKeySeed: 0n, securityCmdBuffer: new Uint8Array(0), platformType: 0, extraBinData: new Uint8Array(0), isGuest: false, channelId: 0, subChannelId: 0, tag: 0, countryCode: "", isLoginWhiteList: false, psnId: "", clientVersionRandomKey: "", regPlatform: 0, clientIpStr: "", birthday: "", unk1: 0, unk2: false, unk3: [], encryptedSeed: "", seedSignature: "", unk6: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPlayerTokenRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPlayerTokenRsp): GetPlayerTokenRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* string msg */ 10:
                    message.msg = reader.string();
                    break;
                case /* uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* uint32 black_uid_end_time */ 15:
                    message.blackUidEndTime = reader.uint32();
                    break;
                case /* uint32 account_type */ 12:
                    message.accountType = reader.uint32();
                    break;
                case /* string account_uid */ 4:
                    message.accountUid = reader.string();
                    break;
                case /* bool is_proficient_player */ 5:
                    message.isProficientPlayer = reader.bool();
                    break;
                case /* string secret_key */ 13:
                    message.secretKey = reader.string();
                    break;
                case /* uint32 gm_uid */ 14:
                    message.gmUid = reader.uint32();
                    break;
                case /* uint64 secret_key_seed */ 11:
                    message.secretKeySeed = reader.uint64().toBigInt();
                    break;
                case /* bytes security_cmd_buffer */ 6:
                    message.securityCmdBuffer = reader.bytes();
                    break;
                case /* uint32 platform_type */ 3:
                    message.platformType = reader.uint32();
                    break;
                case /* bytes extra_bin_data */ 8:
                    message.extraBinData = reader.bytes();
                    break;
                case /* bool is_guest */ 9:
                    message.isGuest = reader.bool();
                    break;
                case /* uint32 channel_id */ 1614:
                    message.channelId = reader.uint32();
                    break;
                case /* uint32 sub_channel_id */ 1911:
                    message.subChannelId = reader.uint32();
                    break;
                case /* uint32 tag */ 1855:
                    message.tag = reader.uint32();
                    break;
                case /* string country_code */ 739:
                    message.countryCode = reader.string();
                    break;
                case /* bool is_login_white_list */ 977:
                    message.isLoginWhiteList = reader.bool();
                    break;
                case /* string psn_id */ 245:
                    message.psnId = reader.string();
                    break;
                case /* string client_version_random_key */ 1387:
                    message.clientVersionRandomKey = reader.string();
                    break;
                case /* uint32 reg_platform */ 633:
                    message.regPlatform = reader.uint32();
                    break;
                case /* string client_ip_str */ 1238:
                    message.clientIpStr = reader.string();
                    break;
                case /* string birthday */ 1109:
                    message.birthday = reader.string();
                    break;
                case /* uint32 unk1 */ 1728:
                    message.unk1 = reader.uint32();
                    break;
                case /* bool unk2 */ 1679:
                    message.unk2 = reader.bool();
                    break;
                case /* repeated uint32 unk3 */ 2012:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unk3.push(reader.uint32());
                    else
                        message.unk3.push(reader.uint32());
                    break;
                case /* string encrypted_seed */ 1596:
                    message.encryptedSeed = reader.string();
                    break;
                case /* string seed_signature */ 1501:
                    message.seedSignature = reader.string();
                    break;
                case /* uint32 unk6 */ 1447:
                    message.unk6 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPlayerTokenRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* string msg = 10; */
        if (message.msg !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.msg);
        /* uint32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* uint32 black_uid_end_time = 15; */
        if (message.blackUidEndTime !== 0)
            writer.tag(15, WireType.Varint).uint32(message.blackUidEndTime);
        /* uint32 account_type = 12; */
        if (message.accountType !== 0)
            writer.tag(12, WireType.Varint).uint32(message.accountType);
        /* string account_uid = 4; */
        if (message.accountUid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accountUid);
        /* bool is_proficient_player = 5; */
        if (message.isProficientPlayer !== false)
            writer.tag(5, WireType.Varint).bool(message.isProficientPlayer);
        /* string secret_key = 13; */
        if (message.secretKey !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.secretKey);
        /* uint32 gm_uid = 14; */
        if (message.gmUid !== 0)
            writer.tag(14, WireType.Varint).uint32(message.gmUid);
        /* uint64 secret_key_seed = 11; */
        if (message.secretKeySeed !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.secretKeySeed);
        /* bytes security_cmd_buffer = 6; */
        if (message.securityCmdBuffer.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.securityCmdBuffer);
        /* uint32 platform_type = 3; */
        if (message.platformType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.platformType);
        /* bytes extra_bin_data = 8; */
        if (message.extraBinData.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.extraBinData);
        /* bool is_guest = 9; */
        if (message.isGuest !== false)
            writer.tag(9, WireType.Varint).bool(message.isGuest);
        /* uint32 channel_id = 1614; */
        if (message.channelId !== 0)
            writer.tag(1614, WireType.Varint).uint32(message.channelId);
        /* uint32 sub_channel_id = 1911; */
        if (message.subChannelId !== 0)
            writer.tag(1911, WireType.Varint).uint32(message.subChannelId);
        /* uint32 tag = 1855; */
        if (message.tag !== 0)
            writer.tag(1855, WireType.Varint).uint32(message.tag);
        /* string country_code = 739; */
        if (message.countryCode !== "")
            writer.tag(739, WireType.LengthDelimited).string(message.countryCode);
        /* bool is_login_white_list = 977; */
        if (message.isLoginWhiteList !== false)
            writer.tag(977, WireType.Varint).bool(message.isLoginWhiteList);
        /* string psn_id = 245; */
        if (message.psnId !== "")
            writer.tag(245, WireType.LengthDelimited).string(message.psnId);
        /* string client_version_random_key = 1387; */
        if (message.clientVersionRandomKey !== "")
            writer.tag(1387, WireType.LengthDelimited).string(message.clientVersionRandomKey);
        /* uint32 reg_platform = 633; */
        if (message.regPlatform !== 0)
            writer.tag(633, WireType.Varint).uint32(message.regPlatform);
        /* string client_ip_str = 1238; */
        if (message.clientIpStr !== "")
            writer.tag(1238, WireType.LengthDelimited).string(message.clientIpStr);
        /* string birthday = 1109; */
        if (message.birthday !== "")
            writer.tag(1109, WireType.LengthDelimited).string(message.birthday);
        /* uint32 unk1 = 1728; */
        if (message.unk1 !== 0)
            writer.tag(1728, WireType.Varint).uint32(message.unk1);
        /* bool unk2 = 1679; */
        if (message.unk2 !== false)
            writer.tag(1679, WireType.Varint).bool(message.unk2);
        /* repeated uint32 unk3 = 2012; */
        if (message.unk3.length) {
            writer.tag(2012, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unk3.length; i++)
                writer.uint32(message.unk3[i]);
            writer.join();
        }
        /* string encrypted_seed = 1596; */
        if (message.encryptedSeed !== "")
            writer.tag(1596, WireType.LengthDelimited).string(message.encryptedSeed);
        /* string seed_signature = 1501; */
        if (message.seedSignature !== "")
            writer.tag(1501, WireType.LengthDelimited).string(message.seedSignature);
        /* uint32 unk6 = 1447; */
        if (message.unk6 !== 0)
            writer.tag(1447, WireType.Varint).uint32(message.unk6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPlayerTokenRsp
 */
export const GetPlayerTokenRsp = new GetPlayerTokenRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSceneAreaReq$Type extends MessageType<GetSceneAreaReq> {
    constructor() {
        super("GetSceneAreaReq", [
            { no: 4, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "belong_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSceneAreaReq>): GetSceneAreaReq {
        const message = { sceneId: 0, belongUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSceneAreaReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSceneAreaReq): GetSceneAreaReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 4:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 belong_uid */ 3:
                    message.belongUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSceneAreaReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 4; */
        if (message.sceneId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.sceneId);
        /* uint32 belong_uid = 3; */
        if (message.belongUid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.belongUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSceneAreaReq
 */
export const GetSceneAreaReq = new GetSceneAreaReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSceneAreaRsp$Type extends MessageType<GetSceneAreaRsp> {
    constructor() {
        super("GetSceneAreaRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "area_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "city_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CityInfo }
        ]);
    }
    create(value?: PartialMessage<GetSceneAreaRsp>): GetSceneAreaRsp {
        const message = { retcode: 0, sceneId: 0, areaIdList: [], cityInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSceneAreaRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSceneAreaRsp): GetSceneAreaRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 scene_id */ 13:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated uint32 area_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.areaIdList.push(reader.uint32());
                    else
                        message.areaIdList.push(reader.uint32());
                    break;
                case /* repeated CityInfo city_info_list */ 3:
                    message.cityInfoList.push(CityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSceneAreaRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint32 scene_id = 13; */
        if (message.sceneId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.sceneId);
        /* repeated uint32 area_id_list = 6; */
        if (message.areaIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.areaIdList.length; i++)
                writer.uint32(message.areaIdList[i]);
            writer.join();
        }
        /* repeated CityInfo city_info_list = 3; */
        for (let i = 0; i < message.cityInfoList.length; i++)
            CityInfo.internalBinaryWrite(message.cityInfoList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSceneAreaRsp
 */
export const GetSceneAreaRsp = new GetSceneAreaRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScenePointReq$Type extends MessageType<GetScenePointReq> {
    constructor() {
        super("GetScenePointReq", [
            { no: 4, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "belong_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetScenePointReq>): GetScenePointReq {
        const message = { sceneId: 0, belongUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetScenePointReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetScenePointReq): GetScenePointReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 4:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 belong_uid */ 10:
                    message.belongUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetScenePointReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 4; */
        if (message.sceneId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.sceneId);
        /* uint32 belong_uid = 10; */
        if (message.belongUid !== 0)
            writer.tag(10, WireType.Varint).uint32(message.belongUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetScenePointReq
 */
export const GetScenePointReq = new GetScenePointReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScenePointRsp$Type extends MessageType<GetScenePointRsp> {
    constructor() {
        super("GetScenePointRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "unlocked_point_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "belong_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "unlock_area_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "locked_point_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "to_be_explore_dungeon_entry_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "not_explored_dungeon_entry_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "group_unlimit_point_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "not_interact_dungeon_entry_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "hide_point_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetScenePointRsp>): GetScenePointRsp {
        const message = { retcode: 0, sceneId: 0, unlockedPointList: [], belongUid: 0, unlockAreaList: [], lockedPointList: [], toBeExploreDungeonEntryList: [], notExploredDungeonEntryList: [], groupUnlimitPointList: [], notInteractDungeonEntryList: [], hidePointList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetScenePointRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetScenePointRsp): GetScenePointRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 scene_id */ 12:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated uint32 unlocked_point_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockedPointList.push(reader.uint32());
                    else
                        message.unlockedPointList.push(reader.uint32());
                    break;
                case /* uint32 belong_uid */ 15:
                    message.belongUid = reader.uint32();
                    break;
                case /* repeated uint32 unlock_area_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockAreaList.push(reader.uint32());
                    else
                        message.unlockAreaList.push(reader.uint32());
                    break;
                case /* repeated uint32 locked_point_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lockedPointList.push(reader.uint32());
                    else
                        message.lockedPointList.push(reader.uint32());
                    break;
                case /* repeated uint32 to_be_explore_dungeon_entry_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.toBeExploreDungeonEntryList.push(reader.uint32());
                    else
                        message.toBeExploreDungeonEntryList.push(reader.uint32());
                    break;
                case /* repeated uint32 not_explored_dungeon_entry_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notExploredDungeonEntryList.push(reader.uint32());
                    else
                        message.notExploredDungeonEntryList.push(reader.uint32());
                    break;
                case /* repeated uint32 group_unlimit_point_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.groupUnlimitPointList.push(reader.uint32());
                    else
                        message.groupUnlimitPointList.push(reader.uint32());
                    break;
                case /* repeated uint32 not_interact_dungeon_entry_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.notInteractDungeonEntryList.push(reader.uint32());
                    else
                        message.notInteractDungeonEntryList.push(reader.uint32());
                    break;
                case /* repeated uint32 hide_point_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hidePointList.push(reader.uint32());
                    else
                        message.hidePointList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetScenePointRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint32 scene_id = 12; */
        if (message.sceneId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.sceneId);
        /* repeated uint32 unlocked_point_list = 14; */
        if (message.unlockedPointList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockedPointList.length; i++)
                writer.uint32(message.unlockedPointList[i]);
            writer.join();
        }
        /* uint32 belong_uid = 15; */
        if (message.belongUid !== 0)
            writer.tag(15, WireType.Varint).uint32(message.belongUid);
        /* repeated uint32 unlock_area_list = 11; */
        if (message.unlockAreaList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockAreaList.length; i++)
                writer.uint32(message.unlockAreaList[i]);
            writer.join();
        }
        /* repeated uint32 locked_point_list = 4; */
        if (message.lockedPointList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lockedPointList.length; i++)
                writer.uint32(message.lockedPointList[i]);
            writer.join();
        }
        /* repeated uint32 to_be_explore_dungeon_entry_list = 8; */
        if (message.toBeExploreDungeonEntryList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.toBeExploreDungeonEntryList.length; i++)
                writer.uint32(message.toBeExploreDungeonEntryList[i]);
            writer.join();
        }
        /* repeated uint32 not_explored_dungeon_entry_list = 3; */
        if (message.notExploredDungeonEntryList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.notExploredDungeonEntryList.length; i++)
                writer.uint32(message.notExploredDungeonEntryList[i]);
            writer.join();
        }
        /* repeated uint32 group_unlimit_point_list = 6; */
        if (message.groupUnlimitPointList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.groupUnlimitPointList.length; i++)
                writer.uint32(message.groupUnlimitPointList[i]);
            writer.join();
        }
        /* repeated uint32 not_interact_dungeon_entry_list = 1; */
        if (message.notInteractDungeonEntryList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.notInteractDungeonEntryList.length; i++)
                writer.uint32(message.notInteractDungeonEntryList[i]);
            writer.join();
        }
        /* repeated uint32 hide_point_list = 9; */
        if (message.hidePointList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.hidePointList.length; i++)
                writer.uint32(message.hidePointList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetScenePointRsp
 */
export const GetScenePointRsp = new GetScenePointRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopmallDataRsp$Type extends MessageType<GetShopmallDataRsp> {
    constructor() {
        super("GetShopmallDataRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "shop_type_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetShopmallDataRsp>): GetShopmallDataRsp {
        const message = { retcode: 0, shopTypeList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopmallDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopmallDataRsp): GetShopmallDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 shop_type_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.shopTypeList.push(reader.uint32());
                    else
                        message.shopTypeList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopmallDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* repeated uint32 shop_type_list = 15; */
        if (message.shopTypeList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.shopTypeList.length; i++)
                writer.uint32(message.shopTypeList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetShopmallDataRsp
 */
export const GetShopmallDataRsp = new GetShopmallDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopReq$Type extends MessageType<GetShopReq> {
    constructor() {
        super("GetShopReq", [
            { no: 5, name: "shop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetShopReq>): GetShopReq {
        const message = { shopType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopReq): GetShopReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shop_type */ 5:
                    message.shopType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shop_type = 5; */
        if (message.shopType !== 0)
            writer.tag(5, WireType.Varint).uint32(message.shopType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetShopReq
 */
export const GetShopReq = new GetShopReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShopRsp$Type extends MessageType<GetShopRsp> {
    constructor() {
        super("GetShopRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "shop", kind: "message", T: () => Shop }
        ]);
    }
    create(value?: PartialMessage<GetShopRsp>): GetShopRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetShopRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShopRsp): GetShopRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* Shop shop */ 14:
                    message.shop = Shop.internalBinaryRead(reader, reader.uint32(), options, message.shop);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShopRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* Shop shop = 14; */
        if (message.shop)
            Shop.internalBinaryWrite(message.shop, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetShopRsp
 */
export const GetShopRsp = new GetShopRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWidgetSlotReq$Type extends MessageType<GetWidgetSlotReq> {
    constructor() {
        super("GetWidgetSlotReq", []);
    }
    create(value?: PartialMessage<GetWidgetSlotReq>): GetWidgetSlotReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetWidgetSlotReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWidgetSlotReq): GetWidgetSlotReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetWidgetSlotReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetWidgetSlotReq
 */
export const GetWidgetSlotReq = new GetWidgetSlotReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWidgetSlotRsp$Type extends MessageType<GetWidgetSlotRsp> {
    constructor() {
        super("GetWidgetSlotRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "slot_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetSlotData }
        ]);
    }
    create(value?: PartialMessage<GetWidgetSlotRsp>): GetWidgetSlotRsp {
        const message = { retcode: 0, slotList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetWidgetSlotRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWidgetSlotRsp): GetWidgetSlotRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* repeated WidgetSlotData slot_list */ 8:
                    message.slotList.push(WidgetSlotData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWidgetSlotRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* repeated WidgetSlotData slot_list = 8; */
        for (let i = 0; i < message.slotList.length; i++)
            WidgetSlotData.internalBinaryWrite(message.slotList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetWidgetSlotRsp
 */
export const GetWidgetSlotRsp = new GetWidgetSlotRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorldMpInfoRsp$Type extends MessageType<GetWorldMpInfoRsp> {
    constructor() {
        super("GetWorldMpInfoRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "is_in_mp_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "quit_mp_valid_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorldMpInfoRsp>): GetWorldMpInfoRsp {
        const message = { retcode: 0, isInMpMode: false, quitMpValidTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetWorldMpInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorldMpInfoRsp): GetWorldMpInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* bool is_in_mp_mode */ 5:
                    message.isInMpMode = reader.bool();
                    break;
                case /* uint32 quit_mp_valid_time */ 13:
                    message.quitMpValidTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorldMpInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* bool is_in_mp_mode = 5; */
        if (message.isInMpMode !== false)
            writer.tag(5, WireType.Varint).bool(message.isInMpMode);
        /* uint32 quit_mp_valid_time = 13; */
        if (message.quitMpValidTime !== 0)
            writer.tag(13, WireType.Varint).uint32(message.quitMpValidTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetWorldMpInfoRsp
 */
export const GetWorldMpInfoRsp = new GetWorldMpInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupSuiteNotify$Type extends MessageType<GroupSuiteNotify> {
    constructor() {
        super("GroupSuiteNotify", [
            { no: 11, name: "group_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<GroupSuiteNotify>): GroupSuiteNotify {
        const message = { groupMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupSuiteNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupSuiteNotify): GroupSuiteNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> group_map */ 11:
                    this.binaryReadMap11(message.groupMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: GroupSuiteNotify["groupMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GroupSuiteNotify["groupMap"] | undefined, val: GroupSuiteNotify["groupMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field GroupSuiteNotify.group_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: GroupSuiteNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> group_map = 11; */
        for (let k of Object.keys(message.groupMap))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.groupMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GroupSuiteNotify
 */
export const GroupSuiteNotify = new GroupSuiteNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupUnloadNotify$Type extends MessageType<GroupUnloadNotify> {
    constructor() {
        super("GroupUnloadNotify", [
            { no: 1, name: "group_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GroupUnloadNotify>): GroupUnloadNotify {
        const message = { groupList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupUnloadNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupUnloadNotify): GroupUnloadNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 group_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.groupList.push(reader.uint32());
                    else
                        message.groupList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupUnloadNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 group_list = 1; */
        if (message.groupList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.groupList.length; i++)
                writer.uint32(message.groupList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GroupUnloadNotify
 */
export const GroupUnloadNotify = new GroupUnloadNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class H5ActivityIdsNotify$Type extends MessageType<H5ActivityIdsNotify> {
    constructor() {
        super("H5ActivityIdsNotify", [
            { no: 3, name: "h_5_activity_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 15, name: "client_red_dot_timestamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<H5ActivityIdsNotify>): H5ActivityIdsNotify {
        const message = { h5ActivityMap: {}, clientRedDotTimestamp: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<H5ActivityIdsNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: H5ActivityIdsNotify): H5ActivityIdsNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> h_5_activity_map */ 3:
                    this.binaryReadMap3(message.h5ActivityMap, reader, options);
                    break;
                case /* uint32 client_red_dot_timestamp */ 15:
                    message.clientRedDotTimestamp = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: H5ActivityIdsNotify["h5ActivityMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof H5ActivityIdsNotify["h5ActivityMap"] | undefined, val: H5ActivityIdsNotify["h5ActivityMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field H5ActivityIdsNotify.h_5_activity_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: H5ActivityIdsNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> h_5_activity_map = 3; */
        for (let k of Object.keys(message.h5ActivityMap))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.h5ActivityMap[k as any]).join();
        /* uint32 client_red_dot_timestamp = 15; */
        if (message.clientRedDotTimestamp !== 0)
            writer.tag(15, WireType.Varint).uint32(message.clientRedDotTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message H5ActivityIdsNotify
 */
export const H5ActivityIdsNotify = new H5ActivityIdsNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HitCollision$Type extends MessageType<HitCollision> {
    constructor() {
        super("HitCollision", [
            { no: 10, name: "hit_collider_type", kind: "enum", T: () => ["HitColliderType", HitColliderType, "HIT_COLLIDER_TYPE_"] },
            { no: 1, name: "hit_box_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "hit_point", kind: "message", T: () => Vector },
            { no: 5, name: "hit_dir", kind: "message", T: () => Vector },
            { no: 14, name: "attackee_hit_force_angle", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "attackee_hit_entity_angle", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<HitCollision>): HitCollision {
        const message = { hitColliderType: 0, hitBoxIndex: 0, attackeeHitForceAngle: 0, attackeeHitEntityAngle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HitCollision>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HitCollision): HitCollision {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* HitColliderType hit_collider_type */ 10:
                    message.hitColliderType = reader.int32();
                    break;
                case /* int32 hit_box_index */ 1:
                    message.hitBoxIndex = reader.int32();
                    break;
                case /* Vector hit_point */ 11:
                    message.hitPoint = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitPoint);
                    break;
                case /* Vector hit_dir */ 5:
                    message.hitDir = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitDir);
                    break;
                case /* float attackee_hit_force_angle */ 14:
                    message.attackeeHitForceAngle = reader.float();
                    break;
                case /* float attackee_hit_entity_angle */ 8:
                    message.attackeeHitEntityAngle = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HitCollision, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* HitColliderType hit_collider_type = 10; */
        if (message.hitColliderType !== 0)
            writer.tag(10, WireType.Varint).int32(message.hitColliderType);
        /* int32 hit_box_index = 1; */
        if (message.hitBoxIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.hitBoxIndex);
        /* Vector hit_point = 11; */
        if (message.hitPoint)
            Vector.internalBinaryWrite(message.hitPoint, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* Vector hit_dir = 5; */
        if (message.hitDir)
            Vector.internalBinaryWrite(message.hitDir, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* float attackee_hit_force_angle = 14; */
        if (message.attackeeHitForceAngle !== 0)
            writer.tag(14, WireType.Bit32).float(message.attackeeHitForceAngle);
        /* float attackee_hit_entity_angle = 8; */
        if (message.attackeeHitEntityAngle !== 0)
            writer.tag(8, WireType.Bit32).float(message.attackeeHitEntityAngle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HitCollision
 */
export const HitCollision = new HitCollision$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HitTreeNotify$Type extends MessageType<HitTreeNotify> {
    constructor() {
        super("HitTreeNotify", [
            { no: 4, name: "wood_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "unknown_data", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "hit_postion", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<HitTreeNotify>): HitTreeNotify {
        const message = { woodType: 0, unknownData: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HitTreeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HitTreeNotify): HitTreeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 wood_type */ 4:
                    message.woodType = reader.uint32();
                    break;
                case /* uint32 unknown_data */ 3:
                    message.unknownData = reader.uint32();
                    break;
                case /* Vector hit_postion */ 13:
                    message.hitPostion = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hitPostion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HitTreeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 wood_type = 4; */
        if (message.woodType !== 0)
            writer.tag(4, WireType.Varint).uint32(message.woodType);
        /* uint32 unknown_data = 3; */
        if (message.unknownData !== 0)
            writer.tag(3, WireType.Varint).uint32(message.unknownData);
        /* Vector hit_postion = 13; */
        if (message.hitPostion)
            Vector.internalBinaryWrite(message.hitPostion, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HitTreeNotify
 */
export const HitTreeNotify = new HitTreeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeAnimalData$Type extends MessageType<HomeAnimalData> {
    constructor() {
        super("HomeAnimalData", [
            { no: 4, name: "furniture_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "spawn_pos", kind: "message", T: () => Vector },
            { no: 13, name: "spawn_rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<HomeAnimalData>): HomeAnimalData {
        const message = { furnitureId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeAnimalData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeAnimalData): HomeAnimalData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 furniture_id */ 4:
                    message.furnitureId = reader.uint32();
                    break;
                case /* Vector spawn_pos */ 3:
                    message.spawnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnPos);
                    break;
                case /* Vector spawn_rot */ 13:
                    message.spawnRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnRot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeAnimalData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 furniture_id = 4; */
        if (message.furnitureId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.furnitureId);
        /* Vector spawn_pos = 3; */
        if (message.spawnPos)
            Vector.internalBinaryWrite(message.spawnPos, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* Vector spawn_rot = 13; */
        if (message.spawnRot)
            Vector.internalBinaryWrite(message.spawnRot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeAnimalData
 */
export const HomeAnimalData = new HomeAnimalData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBasicInfo$Type extends MessageType<HomeBasicInfo> {
    constructor() {
        super("HomeBasicInfo", [
            { no: 9, name: "cur_module_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cur_room_scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_in_edit_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "exp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "home_owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "limited_shop_info", kind: "message", T: () => HomeLimitedShopInfo },
            { no: 5, name: "owner_nick_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HomeBasicInfo>): HomeBasicInfo {
        const message = { curModuleId: 0, curRoomSceneId: 0, isInEditMode: false, exp: 0n, level: 0, homeOwnerUid: 0, ownerNickName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBasicInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBasicInfo): HomeBasicInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cur_module_id */ 9:
                    message.curModuleId = reader.uint32();
                    break;
                case /* uint32 cur_room_scene_id */ 4:
                    message.curRoomSceneId = reader.uint32();
                    break;
                case /* bool is_in_edit_mode */ 3:
                    message.isInEditMode = reader.bool();
                    break;
                case /* uint64 exp */ 10:
                    message.exp = reader.uint64().toBigInt();
                    break;
                case /* uint32 level */ 12:
                    message.level = reader.uint32();
                    break;
                case /* uint32 home_owner_uid */ 1:
                    message.homeOwnerUid = reader.uint32();
                    break;
                case /* HomeLimitedShopInfo limited_shop_info */ 2:
                    message.limitedShopInfo = HomeLimitedShopInfo.internalBinaryRead(reader, reader.uint32(), options, message.limitedShopInfo);
                    break;
                case /* string owner_nick_name */ 5:
                    message.ownerNickName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBasicInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cur_module_id = 9; */
        if (message.curModuleId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.curModuleId);
        /* uint32 cur_room_scene_id = 4; */
        if (message.curRoomSceneId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.curRoomSceneId);
        /* bool is_in_edit_mode = 3; */
        if (message.isInEditMode !== false)
            writer.tag(3, WireType.Varint).bool(message.isInEditMode);
        /* uint64 exp = 10; */
        if (message.exp !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.exp);
        /* uint32 level = 12; */
        if (message.level !== 0)
            writer.tag(12, WireType.Varint).uint32(message.level);
        /* uint32 home_owner_uid = 1; */
        if (message.homeOwnerUid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.homeOwnerUid);
        /* HomeLimitedShopInfo limited_shop_info = 2; */
        if (message.limitedShopInfo)
            HomeLimitedShopInfo.internalBinaryWrite(message.limitedShopInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string owner_nick_name = 5; */
        if (message.ownerNickName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ownerNickName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBasicInfo
 */
export const HomeBasicInfo = new HomeBasicInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBasicInfoNotify$Type extends MessageType<HomeBasicInfoNotify> {
    constructor() {
        super("HomeBasicInfoNotify", [
            { no: 9, name: "basic_info", kind: "message", T: () => HomeBasicInfo }
        ]);
    }
    create(value?: PartialMessage<HomeBasicInfoNotify>): HomeBasicInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBasicInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBasicInfoNotify): HomeBasicInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* HomeBasicInfo basic_info */ 9:
                    message.basicInfo = HomeBasicInfo.internalBinaryRead(reader, reader.uint32(), options, message.basicInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBasicInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* HomeBasicInfo basic_info = 9; */
        if (message.basicInfo)
            HomeBasicInfo.internalBinaryWrite(message.basicInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBasicInfoNotify
 */
export const HomeBasicInfoNotify = new HomeBasicInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBlockArrangementInfo$Type extends MessageType<HomeBlockArrangementInfo> {
    constructor() {
        super("HomeBlockArrangementInfo", [
            { no: 4, name: "block_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "persistent_furniture_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureData },
            { no: 7, name: "deploy_furniure_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureData },
            { no: 11, name: "deploy_npc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeNpcData },
            { no: 10, name: "furniture_suite_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureSuiteData },
            { no: 14, name: "deploy_animal_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeAnimalData },
            { no: 15, name: "is_unlocked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "comfort_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "dot_pattern_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeBlockDotPattern },
            { no: 13, name: "field_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeBlockFieldData }
        ]);
    }
    create(value?: PartialMessage<HomeBlockArrangementInfo>): HomeBlockArrangementInfo {
        const message = { blockId: 0, persistentFurnitureList: [], deployFurniureList: [], deployNpcList: [], furnitureSuiteList: [], deployAnimalList: [], isUnlocked: false, comfortValue: 0, dotPatternList: [], fieldList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBlockArrangementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBlockArrangementInfo): HomeBlockArrangementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 block_id */ 4:
                    message.blockId = reader.uint32();
                    break;
                case /* repeated HomeFurnitureData persistent_furniture_list */ 2:
                    message.persistentFurnitureList.push(HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeFurnitureData deploy_furniure_list */ 7:
                    message.deployFurniureList.push(HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeNpcData deploy_npc_list */ 11:
                    message.deployNpcList.push(HomeNpcData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeFurnitureSuiteData furniture_suite_list */ 10:
                    message.furnitureSuiteList.push(HomeFurnitureSuiteData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeAnimalData deploy_animal_list */ 14:
                    message.deployAnimalList.push(HomeAnimalData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_unlocked */ 15:
                    message.isUnlocked = reader.bool();
                    break;
                case /* uint32 comfort_value */ 1:
                    message.comfortValue = reader.uint32();
                    break;
                case /* repeated HomeBlockDotPattern dot_pattern_list */ 6:
                    message.dotPatternList.push(HomeBlockDotPattern.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeBlockFieldData field_list */ 13:
                    message.fieldList.push(HomeBlockFieldData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBlockArrangementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 block_id = 4; */
        if (message.blockId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.blockId);
        /* repeated HomeFurnitureData persistent_furniture_list = 2; */
        for (let i = 0; i < message.persistentFurnitureList.length; i++)
            HomeFurnitureData.internalBinaryWrite(message.persistentFurnitureList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeFurnitureData deploy_furniure_list = 7; */
        for (let i = 0; i < message.deployFurniureList.length; i++)
            HomeFurnitureData.internalBinaryWrite(message.deployFurniureList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeNpcData deploy_npc_list = 11; */
        for (let i = 0; i < message.deployNpcList.length; i++)
            HomeNpcData.internalBinaryWrite(message.deployNpcList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeFurnitureSuiteData furniture_suite_list = 10; */
        for (let i = 0; i < message.furnitureSuiteList.length; i++)
            HomeFurnitureSuiteData.internalBinaryWrite(message.furnitureSuiteList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeAnimalData deploy_animal_list = 14; */
        for (let i = 0; i < message.deployAnimalList.length; i++)
            HomeAnimalData.internalBinaryWrite(message.deployAnimalList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* bool is_unlocked = 15; */
        if (message.isUnlocked !== false)
            writer.tag(15, WireType.Varint).bool(message.isUnlocked);
        /* uint32 comfort_value = 1; */
        if (message.comfortValue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.comfortValue);
        /* repeated HomeBlockDotPattern dot_pattern_list = 6; */
        for (let i = 0; i < message.dotPatternList.length; i++)
            HomeBlockDotPattern.internalBinaryWrite(message.dotPatternList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeBlockFieldData field_list = 13; */
        for (let i = 0; i < message.fieldList.length; i++)
            HomeBlockFieldData.internalBinaryWrite(message.fieldList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBlockArrangementInfo
 */
export const HomeBlockArrangementInfo = new HomeBlockArrangementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBlockDotPattern$Type extends MessageType<HomeBlockDotPattern> {
    constructor() {
        super("HomeBlockDotPattern", [
            { no: 8, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HomeBlockDotPattern>): HomeBlockDotPattern {
        const message = { height: 0, width: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBlockDotPattern>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBlockDotPattern): HomeBlockDotPattern {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 height */ 8:
                    message.height = reader.uint32();
                    break;
                case /* uint32 width */ 4:
                    message.width = reader.uint32();
                    break;
                case /* bytes data */ 14:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBlockDotPattern, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 height = 8; */
        if (message.height !== 0)
            writer.tag(8, WireType.Varint).uint32(message.height);
        /* uint32 width = 4; */
        if (message.width !== 0)
            writer.tag(4, WireType.Varint).uint32(message.width);
        /* bytes data = 14; */
        if (message.data.length)
            writer.tag(14, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBlockDotPattern
 */
export const HomeBlockDotPattern = new HomeBlockDotPattern$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBlockFieldData$Type extends MessageType<HomeBlockFieldData> {
    constructor() {
        super("HomeBlockFieldData", [
            { no: 7, name: "guid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "furniture_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "pos", kind: "message", T: () => Vector },
            { no: 11, name: "rot", kind: "message", T: () => Vector },
            { no: 14, name: "sub_field_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeBlockSubFieldData }
        ]);
    }
    create(value?: PartialMessage<HomeBlockFieldData>): HomeBlockFieldData {
        const message = { guid: 0, furnitureId: 0, subFieldList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBlockFieldData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBlockFieldData): HomeBlockFieldData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 guid */ 7:
                    message.guid = reader.uint32();
                    break;
                case /* uint32 furniture_id */ 1:
                    message.furnitureId = reader.uint32();
                    break;
                case /* Vector pos */ 12:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 11:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* repeated HomeBlockSubFieldData sub_field_list */ 14:
                    message.subFieldList.push(HomeBlockSubFieldData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBlockFieldData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 guid = 7; */
        if (message.guid !== 0)
            writer.tag(7, WireType.Varint).uint32(message.guid);
        /* uint32 furniture_id = 1; */
        if (message.furnitureId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.furnitureId);
        /* Vector pos = 12; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 11; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeBlockSubFieldData sub_field_list = 14; */
        for (let i = 0; i < message.subFieldList.length; i++)
            HomeBlockSubFieldData.internalBinaryWrite(message.subFieldList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBlockFieldData
 */
export const HomeBlockFieldData = new HomeBlockFieldData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBlockNotify$Type extends MessageType<HomeBlockNotify> {
    constructor() {
        super("HomeBlockNotify", [
            { no: 7, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeBlockNotify>): HomeBlockNotify {
        const message = { endTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBlockNotify): HomeBlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 end_time */ 7:
                    message.endTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 end_time = 7; */
        if (message.endTime !== 0)
            writer.tag(7, WireType.Varint).uint32(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBlockNotify
 */
export const HomeBlockNotify = new HomeBlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeBlockSubFieldData$Type extends MessageType<HomeBlockSubFieldData> {
    constructor() {
        super("HomeBlockSubFieldData", [
            { no: 12, name: "pos", kind: "message", T: () => Vector },
            { no: 14, name: "rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<HomeBlockSubFieldData>): HomeBlockSubFieldData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeBlockSubFieldData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeBlockSubFieldData): HomeBlockSubFieldData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector pos */ 12:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 14:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeBlockSubFieldData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector pos = 12; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 14; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeBlockSubFieldData
 */
export const HomeBlockSubFieldData = new HomeBlockSubFieldData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeChangeEditModeReq$Type extends MessageType<HomeChangeEditModeReq> {
    constructor() {
        super("HomeChangeEditModeReq", [
            { no: 5, name: "is_enter_edit_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeChangeEditModeReq>): HomeChangeEditModeReq {
        const message = { isEnterEditMode: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeChangeEditModeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeChangeEditModeReq): HomeChangeEditModeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_enter_edit_mode */ 5:
                    message.isEnterEditMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeChangeEditModeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_enter_edit_mode = 5; */
        if (message.isEnterEditMode !== false)
            writer.tag(5, WireType.Varint).bool(message.isEnterEditMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeChangeEditModeReq
 */
export const HomeChangeEditModeReq = new HomeChangeEditModeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeChangeEditModeRsp$Type extends MessageType<HomeChangeEditModeRsp> {
    constructor() {
        super("HomeChangeEditModeRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "is_enter_edit_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeChangeEditModeRsp>): HomeChangeEditModeRsp {
        const message = { retcode: 0, isEnterEditMode: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeChangeEditModeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeChangeEditModeRsp): HomeChangeEditModeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* bool is_enter_edit_mode */ 5:
                    message.isEnterEditMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeChangeEditModeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* bool is_enter_edit_mode = 5; */
        if (message.isEnterEditMode !== false)
            writer.tag(5, WireType.Varint).bool(message.isEnterEditMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeChangeEditModeRsp
 */
export const HomeChangeEditModeRsp = new HomeChangeEditModeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeChooseModuleReq$Type extends MessageType<HomeChooseModuleReq> {
    constructor() {
        super("HomeChooseModuleReq", [
            { no: 2, name: "module_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeChooseModuleReq>): HomeChooseModuleReq {
        const message = { moduleId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeChooseModuleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeChooseModuleReq): HomeChooseModuleReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 module_id */ 2:
                    message.moduleId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeChooseModuleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 module_id = 2; */
        if (message.moduleId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.moduleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeChooseModuleReq
 */
export const HomeChooseModuleReq = new HomeChooseModuleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeChooseModuleRsp$Type extends MessageType<HomeChooseModuleRsp> {
    constructor() {
        super("HomeChooseModuleRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "module_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeChooseModuleRsp>): HomeChooseModuleRsp {
        const message = { retcode: 0, moduleId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeChooseModuleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeChooseModuleRsp): HomeChooseModuleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 module_id */ 11:
                    message.moduleId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeChooseModuleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint32 module_id = 11; */
        if (message.moduleId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.moduleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeChooseModuleRsp
 */
export const HomeChooseModuleRsp = new HomeChooseModuleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeComfortInfoNotify$Type extends MessageType<HomeComfortInfoNotify> {
    constructor() {
        super("HomeComfortInfoNotify", [
            { no: 1, name: "module_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeModuleComfortInfo }
        ]);
    }
    create(value?: PartialMessage<HomeComfortInfoNotify>): HomeComfortInfoNotify {
        const message = { moduleInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeComfortInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeComfortInfoNotify): HomeComfortInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated HomeModuleComfortInfo module_info_list */ 1:
                    message.moduleInfoList.push(HomeModuleComfortInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeComfortInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated HomeModuleComfortInfo module_info_list = 1; */
        for (let i = 0; i < message.moduleInfoList.length; i++)
            HomeModuleComfortInfo.internalBinaryWrite(message.moduleInfoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeComfortInfoNotify
 */
export const HomeComfortInfoNotify = new HomeComfortInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeFurnitureData$Type extends MessageType<HomeFurnitureData> {
    constructor() {
        super("HomeFurnitureData", [
            { no: 13, name: "furniture_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "spawn_pos", kind: "message", T: () => Vector },
            { no: 7, name: "spawn_rot", kind: "message", T: () => Vector },
            { no: 4, name: "parent_furniture_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "guid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeFurnitureData>): HomeFurnitureData {
        const message = { furnitureId: 0, parentFurnitureIndex: 0, guid: 0, version: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeFurnitureData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeFurnitureData): HomeFurnitureData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 furniture_id */ 13:
                    message.furnitureId = reader.uint32();
                    break;
                case /* Vector spawn_pos */ 9:
                    message.spawnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnPos);
                    break;
                case /* Vector spawn_rot */ 7:
                    message.spawnRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnRot);
                    break;
                case /* int32 parent_furniture_index */ 4:
                    message.parentFurnitureIndex = reader.int32();
                    break;
                case /* uint32 guid */ 3:
                    message.guid = reader.uint32();
                    break;
                case /* uint32 version */ 12:
                    message.version = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeFurnitureData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 furniture_id = 13; */
        if (message.furnitureId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.furnitureId);
        /* Vector spawn_pos = 9; */
        if (message.spawnPos)
            Vector.internalBinaryWrite(message.spawnPos, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* Vector spawn_rot = 7; */
        if (message.spawnRot)
            Vector.internalBinaryWrite(message.spawnRot, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* int32 parent_furniture_index = 4; */
        if (message.parentFurnitureIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.parentFurnitureIndex);
        /* uint32 guid = 3; */
        if (message.guid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.guid);
        /* uint32 version = 12; */
        if (message.version !== 0)
            writer.tag(12, WireType.Varint).uint32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeFurnitureData
 */
export const HomeFurnitureData = new HomeFurnitureData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeFurnitureSuiteData$Type extends MessageType<HomeFurnitureSuiteData> {
    constructor() {
        super("HomeFurnitureSuiteData", [
            { no: 11, name: "suite_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "spawn_pos", kind: "message", T: () => Vector },
            { no: 12, name: "included_furniture_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "guid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_allow_summon", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeFurnitureSuiteData>): HomeFurnitureSuiteData {
        const message = { suiteId: 0, includedFurnitureIndexList: [], guid: 0, isAllowSummon: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeFurnitureSuiteData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeFurnitureSuiteData): HomeFurnitureSuiteData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 suite_id */ 11:
                    message.suiteId = reader.uint32();
                    break;
                case /* Vector spawn_pos */ 14:
                    message.spawnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnPos);
                    break;
                case /* repeated int32 included_furniture_index_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.includedFurnitureIndexList.push(reader.int32());
                    else
                        message.includedFurnitureIndexList.push(reader.int32());
                    break;
                case /* uint32 guid */ 3:
                    message.guid = reader.uint32();
                    break;
                case /* bool is_allow_summon */ 10:
                    message.isAllowSummon = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeFurnitureSuiteData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 suite_id = 11; */
        if (message.suiteId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.suiteId);
        /* Vector spawn_pos = 14; */
        if (message.spawnPos)
            Vector.internalBinaryWrite(message.spawnPos, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 included_furniture_index_list = 12; */
        if (message.includedFurnitureIndexList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.includedFurnitureIndexList.length; i++)
                writer.int32(message.includedFurnitureIndexList[i]);
            writer.join();
        }
        /* uint32 guid = 3; */
        if (message.guid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.guid);
        /* bool is_allow_summon = 10; */
        if (message.isAllowSummon !== false)
            writer.tag(10, WireType.Varint).bool(message.isAllowSummon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeFurnitureSuiteData
 */
export const HomeFurnitureSuiteData = new HomeFurnitureSuiteData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeGetArrangementInfoReq$Type extends MessageType<HomeGetArrangementInfoReq> {
    constructor() {
        super("HomeGetArrangementInfoReq", [
            { no: 6, name: "scene_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeGetArrangementInfoReq>): HomeGetArrangementInfoReq {
        const message = { sceneIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeGetArrangementInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeGetArrangementInfoReq): HomeGetArrangementInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 scene_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sceneIdList.push(reader.uint32());
                    else
                        message.sceneIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeGetArrangementInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 scene_id_list = 6; */
        if (message.sceneIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sceneIdList.length; i++)
                writer.uint32(message.sceneIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeGetArrangementInfoReq
 */
export const HomeGetArrangementInfoReq = new HomeGetArrangementInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeGetArrangementInfoRsp$Type extends MessageType<HomeGetArrangementInfoRsp> {
    constructor() {
        super("HomeGetArrangementInfoRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "scene_arrangement_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeSceneArrangementInfo }
        ]);
    }
    create(value?: PartialMessage<HomeGetArrangementInfoRsp>): HomeGetArrangementInfoRsp {
        const message = { retcode: 0, sceneArrangementInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeGetArrangementInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeGetArrangementInfoRsp): HomeGetArrangementInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* repeated HomeSceneArrangementInfo scene_arrangement_info_list */ 12:
                    message.sceneArrangementInfoList.push(HomeSceneArrangementInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeGetArrangementInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* repeated HomeSceneArrangementInfo scene_arrangement_info_list = 12; */
        for (let i = 0; i < message.sceneArrangementInfoList.length; i++)
            HomeSceneArrangementInfo.internalBinaryWrite(message.sceneArrangementInfoList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeGetArrangementInfoRsp
 */
export const HomeGetArrangementInfoRsp = new HomeGetArrangementInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeGetBasicInfoReq$Type extends MessageType<HomeGetBasicInfoReq> {
    constructor() {
        super("HomeGetBasicInfoReq", []);
    }
    create(value?: PartialMessage<HomeGetBasicInfoReq>): HomeGetBasicInfoReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeGetBasicInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeGetBasicInfoReq): HomeGetBasicInfoReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HomeGetBasicInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeGetBasicInfoReq
 */
export const HomeGetBasicInfoReq = new HomeGetBasicInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeLimitedShopInfo$Type extends MessageType<HomeLimitedShopInfo> {
    constructor() {
        super("HomeLimitedShopInfo", [
            { no: 6, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "next_open_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "next_guest_open_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "next_close_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "djinn_pos", kind: "message", T: () => Vector },
            { no: 3, name: "djinn_rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<HomeLimitedShopInfo>): HomeLimitedShopInfo {
        const message = { uid: 0, nextOpenTime: 0, nextGuestOpenTime: 0, nextCloseTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeLimitedShopInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeLimitedShopInfo): HomeLimitedShopInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 6:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 next_open_time */ 5:
                    message.nextOpenTime = reader.uint32();
                    break;
                case /* uint32 next_guest_open_time */ 1:
                    message.nextGuestOpenTime = reader.uint32();
                    break;
                case /* uint32 next_close_time */ 10:
                    message.nextCloseTime = reader.uint32();
                    break;
                case /* Vector djinn_pos */ 11:
                    message.djinnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.djinnPos);
                    break;
                case /* Vector djinn_rot */ 3:
                    message.djinnRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.djinnRot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeLimitedShopInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 6; */
        if (message.uid !== 0)
            writer.tag(6, WireType.Varint).uint32(message.uid);
        /* uint32 next_open_time = 5; */
        if (message.nextOpenTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.nextOpenTime);
        /* uint32 next_guest_open_time = 1; */
        if (message.nextGuestOpenTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.nextGuestOpenTime);
        /* uint32 next_close_time = 10; */
        if (message.nextCloseTime !== 0)
            writer.tag(10, WireType.Varint).uint32(message.nextCloseTime);
        /* Vector djinn_pos = 11; */
        if (message.djinnPos)
            Vector.internalBinaryWrite(message.djinnPos, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* Vector djinn_rot = 3; */
        if (message.djinnRot)
            Vector.internalBinaryWrite(message.djinnRot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeLimitedShopInfo
 */
export const HomeLimitedShopInfo = new HomeLimitedShopInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeMarkPointFurnitureData$Type extends MessageType<HomeMarkPointFurnitureData> {
    constructor() {
        super("HomeMarkPointFurnitureData", [
            { no: 1, name: "guid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "furniture_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "furniture_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "pos", kind: "message", T: () => Vector },
            { no: 6, name: "npc_data", kind: "message", oneof: "extra", T: () => HomeMarkPointNPCData },
            { no: 7, name: "suite_data", kind: "message", oneof: "extra", T: () => HomeMarkPointSuiteData }
        ]);
    }
    create(value?: PartialMessage<HomeMarkPointFurnitureData>): HomeMarkPointFurnitureData {
        const message = { guid: 0, furnitureId: 0, furnitureType: 0, extra: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeMarkPointFurnitureData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeMarkPointFurnitureData): HomeMarkPointFurnitureData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 guid */ 1:
                    message.guid = reader.uint32();
                    break;
                case /* uint32 furniture_id */ 2:
                    message.furnitureId = reader.uint32();
                    break;
                case /* uint32 furniture_type */ 3:
                    message.furnitureType = reader.uint32();
                    break;
                case /* Vector pos */ 4:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* HomeMarkPointNPCData npc_data */ 6:
                    message.extra = {
                        oneofKind: "npcData",
                        npcData: HomeMarkPointNPCData.internalBinaryRead(reader, reader.uint32(), options, (message.extra as any).npcData)
                    };
                    break;
                case /* HomeMarkPointSuiteData suite_data */ 7:
                    message.extra = {
                        oneofKind: "suiteData",
                        suiteData: HomeMarkPointSuiteData.internalBinaryRead(reader, reader.uint32(), options, (message.extra as any).suiteData)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeMarkPointFurnitureData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 guid = 1; */
        if (message.guid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.guid);
        /* uint32 furniture_id = 2; */
        if (message.furnitureId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.furnitureId);
        /* uint32 furniture_type = 3; */
        if (message.furnitureType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.furnitureType);
        /* Vector pos = 4; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* HomeMarkPointNPCData npc_data = 6; */
        if (message.extra.oneofKind === "npcData")
            HomeMarkPointNPCData.internalBinaryWrite(message.extra.npcData, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* HomeMarkPointSuiteData suite_data = 7; */
        if (message.extra.oneofKind === "suiteData")
            HomeMarkPointSuiteData.internalBinaryWrite(message.extra.suiteData, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeMarkPointFurnitureData
 */
export const HomeMarkPointFurnitureData = new HomeMarkPointFurnitureData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeMarkPointNotify$Type extends MessageType<HomeMarkPointNotify> {
    constructor() {
        super("HomeMarkPointNotify", [
            { no: 13, name: "mark_point_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeMarkPointSceneData }
        ]);
    }
    create(value?: PartialMessage<HomeMarkPointNotify>): HomeMarkPointNotify {
        const message = { markPointDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeMarkPointNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeMarkPointNotify): HomeMarkPointNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated HomeMarkPointSceneData mark_point_data_list */ 13:
                    message.markPointDataList.push(HomeMarkPointSceneData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeMarkPointNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated HomeMarkPointSceneData mark_point_data_list = 13; */
        for (let i = 0; i < message.markPointDataList.length; i++)
            HomeMarkPointSceneData.internalBinaryWrite(message.markPointDataList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeMarkPointNotify
 */
export const HomeMarkPointNotify = new HomeMarkPointNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeMarkPointNPCData$Type extends MessageType<HomeMarkPointNPCData> {
    constructor() {
        super("HomeMarkPointNPCData", [
            { no: 1, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeMarkPointNPCData>): HomeMarkPointNPCData {
        const message = { avatarId: 0, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeMarkPointNPCData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeMarkPointNPCData): HomeMarkPointNPCData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 1:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint32 costume_id */ 2:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeMarkPointNPCData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 1; */
        if (message.avatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.avatarId);
        /* uint32 costume_id = 2; */
        if (message.costumeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeMarkPointNPCData
 */
export const HomeMarkPointNPCData = new HomeMarkPointNPCData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeMarkPointSceneData$Type extends MessageType<HomeMarkPointSceneData> {
    constructor() {
        super("HomeMarkPointSceneData", [
            { no: 1, name: "module_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "furniture_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeMarkPointFurnitureData },
            { no: 10, name: "teapot_spirit_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<HomeMarkPointSceneData>): HomeMarkPointSceneData {
        const message = { moduleId: 0, sceneId: 0, furnitureList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeMarkPointSceneData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeMarkPointSceneData): HomeMarkPointSceneData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 module_id */ 1:
                    message.moduleId = reader.uint32();
                    break;
                case /* uint32 scene_id */ 11:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated HomeMarkPointFurnitureData furniture_list */ 9:
                    message.furnitureList.push(HomeMarkPointFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* Vector teapot_spirit_pos */ 10:
                    message.teapotSpiritPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.teapotSpiritPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeMarkPointSceneData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 module_id = 1; */
        if (message.moduleId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.moduleId);
        /* uint32 scene_id = 11; */
        if (message.sceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sceneId);
        /* repeated HomeMarkPointFurnitureData furniture_list = 9; */
        for (let i = 0; i < message.furnitureList.length; i++)
            HomeMarkPointFurnitureData.internalBinaryWrite(message.furnitureList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* Vector teapot_spirit_pos = 10; */
        if (message.teapotSpiritPos)
            Vector.internalBinaryWrite(message.teapotSpiritPos, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeMarkPointSceneData
 */
export const HomeMarkPointSceneData = new HomeMarkPointSceneData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeMarkPointSuiteData$Type extends MessageType<HomeMarkPointSuiteData> {
    constructor() {
        super("HomeMarkPointSuiteData", [
            { no: 1, name: "suite_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeMarkPointSuiteData>): HomeMarkPointSuiteData {
        const message = { suiteId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeMarkPointSuiteData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeMarkPointSuiteData): HomeMarkPointSuiteData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 suite_id */ 1:
                    message.suiteId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeMarkPointSuiteData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 suite_id = 1; */
        if (message.suiteId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.suiteId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeMarkPointSuiteData
 */
export const HomeMarkPointSuiteData = new HomeMarkPointSuiteData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeModuleComfortInfo$Type extends MessageType<HomeModuleComfortInfo> {
    constructor() {
        super("HomeModuleComfortInfo", [
            { no: 8, name: "module_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "world_scene_block_comfort_value_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "room_scene_comfort_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeModuleComfortInfo>): HomeModuleComfortInfo {
        const message = { moduleId: 0, worldSceneBlockComfortValueList: [], roomSceneComfortValue: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeModuleComfortInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeModuleComfortInfo): HomeModuleComfortInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 module_id */ 8:
                    message.moduleId = reader.uint32();
                    break;
                case /* repeated uint32 world_scene_block_comfort_value_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.worldSceneBlockComfortValueList.push(reader.uint32());
                    else
                        message.worldSceneBlockComfortValueList.push(reader.uint32());
                    break;
                case /* uint32 room_scene_comfort_value */ 2:
                    message.roomSceneComfortValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeModuleComfortInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 module_id = 8; */
        if (message.moduleId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.moduleId);
        /* repeated uint32 world_scene_block_comfort_value_list = 15; */
        if (message.worldSceneBlockComfortValueList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.worldSceneBlockComfortValueList.length; i++)
                writer.uint32(message.worldSceneBlockComfortValueList[i]);
            writer.join();
        }
        /* uint32 room_scene_comfort_value = 2; */
        if (message.roomSceneComfortValue !== 0)
            writer.tag(2, WireType.Varint).uint32(message.roomSceneComfortValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeModuleComfortInfo
 */
export const HomeModuleComfortInfo = new HomeModuleComfortInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeNpcData$Type extends MessageType<HomeNpcData> {
    constructor() {
        super("HomeNpcData", [
            { no: 13, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "spawn_pos", kind: "message", T: () => Vector },
            { no: 4, name: "spawn_rot", kind: "message", T: () => Vector },
            { no: 2, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeNpcData>): HomeNpcData {
        const message = { avatarId: 0, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeNpcData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeNpcData): HomeNpcData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 13:
                    message.avatarId = reader.uint32();
                    break;
                case /* Vector spawn_pos */ 10:
                    message.spawnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnPos);
                    break;
                case /* Vector spawn_rot */ 4:
                    message.spawnRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnRot);
                    break;
                case /* uint32 costume_id */ 2:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeNpcData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 13; */
        if (message.avatarId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.avatarId);
        /* Vector spawn_pos = 10; */
        if (message.spawnPos)
            Vector.internalBinaryWrite(message.spawnPos, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Vector spawn_rot = 4; */
        if (message.spawnRot)
            Vector.internalBinaryWrite(message.spawnRot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 costume_id = 2; */
        if (message.costumeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeNpcData
 */
export const HomeNpcData = new HomeNpcData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeSceneArrangementInfo$Type extends MessageType<HomeSceneArrangementInfo> {
    constructor() {
        super("HomeSceneArrangementInfo", [
            { no: 10, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "block_arrangement_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeBlockArrangementInfo },
            { no: 3, name: "is_set_born_pos", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "born_pos", kind: "message", T: () => Vector },
            { no: 1, name: "born_rot", kind: "message", T: () => Vector },
            { no: 8, name: "door_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureData },
            { no: 6, name: "stair_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureData },
            { no: 9, name: "main_house", kind: "message", T: () => HomeFurnitureData },
            { no: 13, name: "comfort_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "djinn_pos", kind: "message", T: () => Vector },
            { no: 12, name: "tmp_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "CNLMNOEGKME", kind: "scalar", jsonName: "CNLMNOEGKME", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeSceneArrangementInfo>): HomeSceneArrangementInfo {
        const message = { sceneId: 0, blockArrangementInfoList: [], isSetBornPos: false, doorList: [], stairList: [], comfortValue: 0, tmpVersion: 0, cNLMNOEGKME: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeSceneArrangementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeSceneArrangementInfo): HomeSceneArrangementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 10:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated HomeBlockArrangementInfo block_arrangement_info_list */ 11:
                    message.blockArrangementInfoList.push(HomeBlockArrangementInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_set_born_pos */ 3:
                    message.isSetBornPos = reader.bool();
                    break;
                case /* Vector born_pos */ 5:
                    message.bornPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.bornPos);
                    break;
                case /* Vector born_rot */ 1:
                    message.bornRot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.bornRot);
                    break;
                case /* repeated HomeFurnitureData door_list */ 8:
                    message.doorList.push(HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeFurnitureData stair_list */ 6:
                    message.stairList.push(HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* HomeFurnitureData main_house */ 9:
                    message.mainHouse = HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options, message.mainHouse);
                    break;
                case /* uint32 comfort_value */ 13:
                    message.comfortValue = reader.uint32();
                    break;
                case /* Vector djinn_pos */ 7:
                    message.djinnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.djinnPos);
                    break;
                case /* uint32 tmp_version */ 12:
                    message.tmpVersion = reader.uint32();
                    break;
                case /* uint32 CNLMNOEGKME = 15 [json_name = "CNLMNOEGKME"];*/ 15:
                    message.cNLMNOEGKME = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeSceneArrangementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 10; */
        if (message.sceneId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.sceneId);
        /* repeated HomeBlockArrangementInfo block_arrangement_info_list = 11; */
        for (let i = 0; i < message.blockArrangementInfoList.length; i++)
            HomeBlockArrangementInfo.internalBinaryWrite(message.blockArrangementInfoList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool is_set_born_pos = 3; */
        if (message.isSetBornPos !== false)
            writer.tag(3, WireType.Varint).bool(message.isSetBornPos);
        /* Vector born_pos = 5; */
        if (message.bornPos)
            Vector.internalBinaryWrite(message.bornPos, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Vector born_rot = 1; */
        if (message.bornRot)
            Vector.internalBinaryWrite(message.bornRot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeFurnitureData door_list = 8; */
        for (let i = 0; i < message.doorList.length; i++)
            HomeFurnitureData.internalBinaryWrite(message.doorList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeFurnitureData stair_list = 6; */
        for (let i = 0; i < message.stairList.length; i++)
            HomeFurnitureData.internalBinaryWrite(message.stairList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* HomeFurnitureData main_house = 9; */
        if (message.mainHouse)
            HomeFurnitureData.internalBinaryWrite(message.mainHouse, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 comfort_value = 13; */
        if (message.comfortValue !== 0)
            writer.tag(13, WireType.Varint).uint32(message.comfortValue);
        /* Vector djinn_pos = 7; */
        if (message.djinnPos)
            Vector.internalBinaryWrite(message.djinnPos, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 tmp_version = 12; */
        if (message.tmpVersion !== 0)
            writer.tag(12, WireType.Varint).uint32(message.tmpVersion);
        /* uint32 CNLMNOEGKME = 15 [json_name = "CNLMNOEGKME"]; */
        if (message.cNLMNOEGKME !== 0)
            writer.tag(15, WireType.Varint).uint32(message.cNLMNOEGKME);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeSceneArrangementInfo
 */
export const HomeSceneArrangementInfo = new HomeSceneArrangementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeSceneInitFinishReq$Type extends MessageType<HomeSceneInitFinishReq> {
    constructor() {
        super("HomeSceneInitFinishReq", []);
    }
    create(value?: PartialMessage<HomeSceneInitFinishReq>): HomeSceneInitFinishReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeSceneInitFinishReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeSceneInitFinishReq): HomeSceneInitFinishReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HomeSceneInitFinishReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeSceneInitFinishReq
 */
export const HomeSceneInitFinishReq = new HomeSceneInitFinishReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeSceneInitFinishRsp$Type extends MessageType<HomeSceneInitFinishRsp> {
    constructor() {
        super("HomeSceneInitFinishRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeSceneInitFinishRsp>): HomeSceneInitFinishRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeSceneInitFinishRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeSceneInitFinishRsp): HomeSceneInitFinishRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeSceneInitFinishRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeSceneInitFinishRsp
 */
export const HomeSceneInitFinishRsp = new HomeSceneInitFinishRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeSceneJumpReq$Type extends MessageType<HomeSceneJumpReq> {
    constructor() {
        super("HomeSceneJumpReq", [
            { no: 12, name: "is_enter_room_scene", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeSceneJumpReq>): HomeSceneJumpReq {
        const message = { isEnterRoomScene: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeSceneJumpReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeSceneJumpReq): HomeSceneJumpReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_enter_room_scene */ 12:
                    message.isEnterRoomScene = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeSceneJumpReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_enter_room_scene = 12; */
        if (message.isEnterRoomScene !== false)
            writer.tag(12, WireType.Varint).bool(message.isEnterRoomScene);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeSceneJumpReq
 */
export const HomeSceneJumpReq = new HomeSceneJumpReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeSceneJumpRsp$Type extends MessageType<HomeSceneJumpRsp> {
    constructor() {
        super("HomeSceneJumpRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "is_enter_room_scene", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeSceneJumpRsp>): HomeSceneJumpRsp {
        const message = { retcode: 0, isEnterRoomScene: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeSceneJumpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeSceneJumpRsp): HomeSceneJumpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                case /* bool is_enter_room_scene */ 8:
                    message.isEnterRoomScene = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeSceneJumpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        /* bool is_enter_room_scene = 8; */
        if (message.isEnterRoomScene !== false)
            writer.tag(8, WireType.Varint).bool(message.isEnterRoomScene);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeSceneJumpRsp
 */
export const HomeSceneJumpRsp = new HomeSceneJumpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeUnknown1Notify$Type extends MessageType<HomeUnknown1Notify> {
    constructor() {
        super("HomeUnknown1Notify", [
            { no: 12, name: "is_enter_edit_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HomeUnknown1Notify>): HomeUnknown1Notify {
        const message = { isEnterEditMode: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeUnknown1Notify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeUnknown1Notify): HomeUnknown1Notify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_enter_edit_mode */ 12:
                    message.isEnterEditMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeUnknown1Notify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_enter_edit_mode = 12; */
        if (message.isEnterEditMode !== false)
            writer.tag(12, WireType.Varint).bool(message.isEnterEditMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeUnknown1Notify
 */
export const HomeUnknown1Notify = new HomeUnknown1Notify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeUpdateArrangementInfoReq$Type extends MessageType<HomeUpdateArrangementInfoReq> {
    constructor() {
        super("HomeUpdateArrangementInfoReq", [
            { no: 12, name: "scene_arrangement_info", kind: "message", T: () => HomeSceneArrangementInfo }
        ]);
    }
    create(value?: PartialMessage<HomeUpdateArrangementInfoReq>): HomeUpdateArrangementInfoReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeUpdateArrangementInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeUpdateArrangementInfoReq): HomeUpdateArrangementInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* HomeSceneArrangementInfo scene_arrangement_info */ 12:
                    message.sceneArrangementInfo = HomeSceneArrangementInfo.internalBinaryRead(reader, reader.uint32(), options, message.sceneArrangementInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeUpdateArrangementInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* HomeSceneArrangementInfo scene_arrangement_info = 12; */
        if (message.sceneArrangementInfo)
            HomeSceneArrangementInfo.internalBinaryWrite(message.sceneArrangementInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeUpdateArrangementInfoReq
 */
export const HomeUpdateArrangementInfoReq = new HomeUpdateArrangementInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeUpdateArrangementInfoRsp$Type extends MessageType<HomeUpdateArrangementInfoRsp> {
    constructor() {
        super("HomeUpdateArrangementInfoRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HomeUpdateArrangementInfoRsp>): HomeUpdateArrangementInfoRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeUpdateArrangementInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeUpdateArrangementInfoRsp): HomeUpdateArrangementInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeUpdateArrangementInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeUpdateArrangementInfoRsp
 */
export const HomeUpdateArrangementInfoRsp = new HomeUpdateArrangementInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostPlayerNotify$Type extends MessageType<HostPlayerNotify> {
    constructor() {
        super("HostPlayerNotify", [
            { no: 10, name: "host_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "host_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HostPlayerNotify>): HostPlayerNotify {
        const message = { hostUid: 0, hostPeerId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HostPlayerNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostPlayerNotify): HostPlayerNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 host_uid */ 10:
                    message.hostUid = reader.uint32();
                    break;
                case /* uint32 host_peer_id */ 7:
                    message.hostPeerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostPlayerNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 host_uid = 10; */
        if (message.hostUid !== 0)
            writer.tag(10, WireType.Varint).uint32(message.hostUid);
        /* uint32 host_peer_id = 7; */
        if (message.hostPeerId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.hostPeerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HostPlayerNotify
 */
export const HostPlayerNotify = new HostPlayerNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvestigationMonster$Type extends MessageType<InvestigationMonster> {
    constructor() {
        super("InvestigationMonster", [
            { no: 15, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "city_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "next_refresh_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "refresh_interval", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "pos", kind: "message", T: () => Vector },
            { no: 2, name: "lock_state", kind: "enum", T: () => ["InvestigationMonster.LockState", InvestigationMonster_LockState, "LOCK_STATE_"] },
            { no: 12, name: "max_boss_chest_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "boss_chest_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_area_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "next_boss_chest_refresh_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "weekly_boss_resin_discount_info", kind: "message", T: () => WeeklyBossResinDiscountInfo },
            { no: 11, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1014, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1638, name: "monster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InvestigationMonster>): InvestigationMonster {
        const message = { id: 0, cityId: 0, level: 0, isAlive: false, nextRefreshTime: 0, refreshInterval: 0, lockState: 0, maxBossChestNum: 0, bossChestNum: 0, resin: 0, isAreaLocked: false, nextBossChestRefreshTime: 0, sceneId: 0, groupId: 0, monsterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InvestigationMonster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvestigationMonster): InvestigationMonster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 15:
                    message.id = reader.uint32();
                    break;
                case /* uint32 city_id */ 9:
                    message.cityId = reader.uint32();
                    break;
                case /* uint32 level */ 10:
                    message.level = reader.uint32();
                    break;
                case /* bool is_alive */ 4:
                    message.isAlive = reader.bool();
                    break;
                case /* uint32 next_refresh_time */ 3:
                    message.nextRefreshTime = reader.uint32();
                    break;
                case /* uint32 refresh_interval */ 6:
                    message.refreshInterval = reader.uint32();
                    break;
                case /* Vector pos */ 1:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* InvestigationMonster.LockState lock_state */ 2:
                    message.lockState = reader.int32();
                    break;
                case /* uint32 max_boss_chest_num */ 12:
                    message.maxBossChestNum = reader.uint32();
                    break;
                case /* uint32 boss_chest_num */ 7:
                    message.bossChestNum = reader.uint32();
                    break;
                case /* uint32 resin */ 8:
                    message.resin = reader.uint32();
                    break;
                case /* bool is_area_locked */ 13:
                    message.isAreaLocked = reader.bool();
                    break;
                case /* uint32 next_boss_chest_refresh_time */ 5:
                    message.nextBossChestRefreshTime = reader.uint32();
                    break;
                case /* WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info */ 14:
                    message.weeklyBossResinDiscountInfo = WeeklyBossResinDiscountInfo.internalBinaryRead(reader, reader.uint32(), options, message.weeklyBossResinDiscountInfo);
                    break;
                case /* uint32 scene_id */ 11:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 group_id */ 1014:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 monster_id */ 1638:
                    message.monsterId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvestigationMonster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 15; */
        if (message.id !== 0)
            writer.tag(15, WireType.Varint).uint32(message.id);
        /* uint32 city_id = 9; */
        if (message.cityId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.cityId);
        /* uint32 level = 10; */
        if (message.level !== 0)
            writer.tag(10, WireType.Varint).uint32(message.level);
        /* bool is_alive = 4; */
        if (message.isAlive !== false)
            writer.tag(4, WireType.Varint).bool(message.isAlive);
        /* uint32 next_refresh_time = 3; */
        if (message.nextRefreshTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.nextRefreshTime);
        /* uint32 refresh_interval = 6; */
        if (message.refreshInterval !== 0)
            writer.tag(6, WireType.Varint).uint32(message.refreshInterval);
        /* Vector pos = 1; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* InvestigationMonster.LockState lock_state = 2; */
        if (message.lockState !== 0)
            writer.tag(2, WireType.Varint).int32(message.lockState);
        /* uint32 max_boss_chest_num = 12; */
        if (message.maxBossChestNum !== 0)
            writer.tag(12, WireType.Varint).uint32(message.maxBossChestNum);
        /* uint32 boss_chest_num = 7; */
        if (message.bossChestNum !== 0)
            writer.tag(7, WireType.Varint).uint32(message.bossChestNum);
        /* uint32 resin = 8; */
        if (message.resin !== 0)
            writer.tag(8, WireType.Varint).uint32(message.resin);
        /* bool is_area_locked = 13; */
        if (message.isAreaLocked !== false)
            writer.tag(13, WireType.Varint).bool(message.isAreaLocked);
        /* uint32 next_boss_chest_refresh_time = 5; */
        if (message.nextBossChestRefreshTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.nextBossChestRefreshTime);
        /* WeeklyBossResinDiscountInfo weekly_boss_resin_discount_info = 14; */
        if (message.weeklyBossResinDiscountInfo)
            WeeklyBossResinDiscountInfo.internalBinaryWrite(message.weeklyBossResinDiscountInfo, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 scene_id = 11; */
        if (message.sceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sceneId);
        /* uint32 group_id = 1014; */
        if (message.groupId !== 0)
            writer.tag(1014, WireType.Varint).uint32(message.groupId);
        /* uint32 monster_id = 1638; */
        if (message.monsterId !== 0)
            writer.tag(1638, WireType.Varint).uint32(message.monsterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InvestigationMonster
 */
export const InvestigationMonster = new InvestigationMonster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Item$Type extends MessageType<Item> {
    constructor() {
        super("Item", [
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "material", kind: "message", oneof: "detail", T: () => Material },
            { no: 6, name: "equip", kind: "message", oneof: "detail", T: () => Equip },
            { no: 7, name: "furniture", kind: "message", oneof: "detail", T: () => Furniture }
        ]);
    }
    create(value?: PartialMessage<Item>): Item {
        const message = { itemId: 0, guid: 0n, detail: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Item): Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                case /* uint64 guid */ 2:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* Material material */ 5:
                    message.detail = {
                        oneofKind: "material",
                        material: Material.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).material)
                    };
                    break;
                case /* Equip equip */ 6:
                    message.detail = {
                        oneofKind: "equip",
                        equip: Equip.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).equip)
                    };
                    break;
                case /* Furniture furniture */ 7:
                    message.detail = {
                        oneofKind: "furniture",
                        furniture: Furniture.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).furniture)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        /* uint64 guid = 2; */
        if (message.guid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.guid);
        /* Material material = 5; */
        if (message.detail.oneofKind === "material")
            Material.internalBinaryWrite(message.detail.material, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Equip equip = 6; */
        if (message.detail.oneofKind === "equip")
            Equip.internalBinaryWrite(message.detail.equip, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Furniture furniture = 7; */
        if (message.detail.oneofKind === "furniture")
            Furniture.internalBinaryWrite(message.detail.furniture, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Item
 */
export const Item = new Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemAddHintNotify$Type extends MessageType<ItemAddHintNotify> {
    constructor() {
        super("ItemAddHintNotify", [
            { no: 10, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemHint },
            { no: 12, name: "position", kind: "message", T: () => Vector },
            { no: 13, name: "is_position_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "reason", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_transfered_from_avatar_card", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "overflow_transformed_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemHint },
            { no: 7, name: "is_general_reward_hiden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ItemAddHintNotify>): ItemAddHintNotify {
        const message = { itemList: [], isPositionValid: false, reason: 0, questId: 0, isTransferedFromAvatarCard: false, overflowTransformedItemList: [], isGeneralRewardHiden: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemAddHintNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemAddHintNotify): ItemAddHintNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ItemHint item_list */ 10:
                    message.itemList.push(ItemHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* Vector position */ 12:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* bool is_position_valid */ 13:
                    message.isPositionValid = reader.bool();
                    break;
                case /* uint32 reason */ 5:
                    message.reason = reader.uint32();
                    break;
                case /* uint32 quest_id */ 14:
                    message.questId = reader.uint32();
                    break;
                case /* bool is_transfered_from_avatar_card */ 11:
                    message.isTransferedFromAvatarCard = reader.bool();
                    break;
                case /* repeated ItemHint overflow_transformed_item_list */ 3:
                    message.overflowTransformedItemList.push(ItemHint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_general_reward_hiden */ 7:
                    message.isGeneralRewardHiden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemAddHintNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ItemHint item_list = 10; */
        for (let i = 0; i < message.itemList.length; i++)
            ItemHint.internalBinaryWrite(message.itemList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Vector position = 12; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool is_position_valid = 13; */
        if (message.isPositionValid !== false)
            writer.tag(13, WireType.Varint).bool(message.isPositionValid);
        /* uint32 reason = 5; */
        if (message.reason !== 0)
            writer.tag(5, WireType.Varint).uint32(message.reason);
        /* uint32 quest_id = 14; */
        if (message.questId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.questId);
        /* bool is_transfered_from_avatar_card = 11; */
        if (message.isTransferedFromAvatarCard !== false)
            writer.tag(11, WireType.Varint).bool(message.isTransferedFromAvatarCard);
        /* repeated ItemHint overflow_transformed_item_list = 3; */
        for (let i = 0; i < message.overflowTransformedItemList.length; i++)
            ItemHint.internalBinaryWrite(message.overflowTransformedItemList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_general_reward_hiden = 7; */
        if (message.isGeneralRewardHiden !== false)
            writer.tag(7, WireType.Varint).bool(message.isGeneralRewardHiden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemAddHintNotify
 */
export const ItemAddHintNotify = new ItemAddHintNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemGivingReq$Type extends MessageType<ItemGivingReq> {
    constructor() {
        super("ItemGivingReq", [
            { no: 14, name: "giving_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 6, name: "item_guid_count_map", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<ItemGivingReq>): ItemGivingReq {
        const message = { givingId: 0, itemParamList: [], itemGuidCountMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemGivingReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemGivingReq): ItemGivingReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 giving_id */ 14:
                    message.givingId = reader.uint32();
                    break;
                case /* repeated ItemParam item_param_list */ 10:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<uint64, uint32> item_guid_count_map */ 6:
                    this.binaryReadMap6(message.itemGuidCountMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: ItemGivingReq["itemGuidCountMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ItemGivingReq["itemGuidCountMap"] | undefined, val: ItemGivingReq["itemGuidCountMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ItemGivingReq.item_guid_count_map");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    internalBinaryWrite(message: ItemGivingReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 giving_id = 14; */
        if (message.givingId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.givingId);
        /* repeated ItemParam item_param_list = 10; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* map<uint64, uint32> item_guid_count_map = 6; */
        for (let k of Object.keys(message.itemGuidCountMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Varint).uint32(message.itemGuidCountMap[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemGivingReq
 */
export const ItemGivingReq = new ItemGivingReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemGivingRsp$Type extends MessageType<ItemGivingRsp> {
    constructor() {
        super("ItemGivingRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "giving_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemGivingRsp>): ItemGivingRsp {
        const message = { retcode: 0, givingId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemGivingRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemGivingRsp): ItemGivingRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 giving_id */ 6:
                    message.givingId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemGivingRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 giving_id = 6; */
        if (message.givingId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.givingId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemGivingRsp
 */
export const ItemGivingRsp = new ItemGivingRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemHint$Type extends MessageType<ItemHint> {
    constructor() {
        super("ItemHint", [
            { no: 7, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_new", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ItemHint>): ItemHint {
        const message = { itemId: 0, count: 0, isNew: false, guid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemHint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemHint): ItemHint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 7:
                    message.itemId = reader.uint32();
                    break;
                case /* uint32 count */ 14:
                    message.count = reader.uint32();
                    break;
                case /* bool is_new */ 2:
                    message.isNew = reader.bool();
                    break;
                case /* uint64 guid */ 15:
                    message.guid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 7; */
        if (message.itemId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.itemId);
        /* uint32 count = 14; */
        if (message.count !== 0)
            writer.tag(14, WireType.Varint).uint32(message.count);
        /* bool is_new = 2; */
        if (message.isNew !== false)
            writer.tag(2, WireType.Varint).bool(message.isNew);
        /* uint64 guid = 15; */
        if (message.guid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.guid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemHint
 */
export const ItemHint = new ItemHint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemParam$Type extends MessageType<ItemParam> {
    constructor() {
        super("ItemParam", [
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemParam>): ItemParam {
        const message = { itemId: 0, count: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemParam): ItemParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemParam
 */
export const ItemParam = new ItemParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LifeStateChangeNotify$Type extends MessageType<LifeStateChangeNotify> {
    constructor() {
        super("LifeStateChangeNotify", [
            { no: 4, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "life_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "source_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "attack_tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "die_type", kind: "enum", T: () => ["PlayerDieType", PlayerDieType, "PLAYER_DIE_TYPE_"] },
            { no: 9, name: "move_reliable_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff }
        ]);
    }
    create(value?: PartialMessage<LifeStateChangeNotify>): LifeStateChangeNotify {
        const message = { entityId: 0, lifeState: 0, sourceEntityId: 0, attackTag: "", dieType: 0, moveReliableSeq: 0, serverBuffList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LifeStateChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LifeStateChangeNotify): LifeStateChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 life_state */ 6:
                    message.lifeState = reader.uint32();
                    break;
                case /* uint32 source_entity_id */ 5:
                    message.sourceEntityId = reader.uint32();
                    break;
                case /* string attack_tag */ 1:
                    message.attackTag = reader.string();
                    break;
                case /* PlayerDieType die_type */ 13:
                    message.dieType = reader.int32();
                    break;
                case /* uint32 move_reliable_seq */ 9:
                    message.moveReliableSeq = reader.uint32();
                    break;
                case /* repeated ServerBuff server_buff_list */ 14:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LifeStateChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 4; */
        if (message.entityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* uint32 life_state = 6; */
        if (message.lifeState !== 0)
            writer.tag(6, WireType.Varint).uint32(message.lifeState);
        /* uint32 source_entity_id = 5; */
        if (message.sourceEntityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.sourceEntityId);
        /* string attack_tag = 1; */
        if (message.attackTag !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.attackTag);
        /* PlayerDieType die_type = 13; */
        if (message.dieType !== 0)
            writer.tag(13, WireType.Varint).int32(message.dieType);
        /* uint32 move_reliable_seq = 9; */
        if (message.moveReliableSeq !== 0)
            writer.tag(9, WireType.Varint).uint32(message.moveReliableSeq);
        /* repeated ServerBuff server_buff_list = 14; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LifeStateChangeNotify
 */
export const LifeStateChangeNotify = new LifeStateChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockedPersonallineData$Type extends MessageType<LockedPersonallineData> {
    constructor() {
        super("LockedPersonallineData", [
            { no: 1, name: "personal_line_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "lock_reason", kind: "enum", T: () => ["LockedPersonallineData.LockReason", LockedPersonallineData_LockReason, "LOCK_REASON_"] },
            { no: 3, name: "chapter_id", kind: "scalar", oneof: "param", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "level", kind: "scalar", oneof: "param", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LockedPersonallineData>): LockedPersonallineData {
        const message = { personalLineId: 0, lockReason: 0, param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockedPersonallineData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockedPersonallineData): LockedPersonallineData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 personal_line_id */ 1:
                    message.personalLineId = reader.uint32();
                    break;
                case /* LockedPersonallineData.LockReason lock_reason */ 2:
                    message.lockReason = reader.int32();
                    break;
                case /* uint32 chapter_id */ 3:
                    message.param = {
                        oneofKind: "chapterId",
                        chapterId: reader.uint32()
                    };
                    break;
                case /* uint32 level */ 4:
                    message.param = {
                        oneofKind: "level",
                        level: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockedPersonallineData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 personal_line_id = 1; */
        if (message.personalLineId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.personalLineId);
        /* LockedPersonallineData.LockReason lock_reason = 2; */
        if (message.lockReason !== 0)
            writer.tag(2, WireType.Varint).int32(message.lockReason);
        /* uint32 chapter_id = 3; */
        if (message.param.oneofKind === "chapterId")
            writer.tag(3, WireType.Varint).uint32(message.param.chapterId);
        /* uint32 level = 4; */
        if (message.param.oneofKind === "level")
            writer.tag(4, WireType.Varint).uint32(message.param.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockedPersonallineData
 */
export const LockedPersonallineData = new LockedPersonallineData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LunchBoxData$Type extends MessageType<LunchBoxData> {
    constructor() {
        super("LunchBoxData", [
            { no: 5, name: "slot_material_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<LunchBoxData>): LunchBoxData {
        const message = { slotMaterialMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LunchBoxData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LunchBoxData): LunchBoxData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> slot_material_map */ 5:
                    this.binaryReadMap5(message.slotMaterialMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: LunchBoxData["slotMaterialMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LunchBoxData["slotMaterialMap"] | undefined, val: LunchBoxData["slotMaterialMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field LunchBoxData.slot_material_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: LunchBoxData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> slot_material_map = 5; */
        for (let k of Object.keys(message.slotMaterialMap))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.slotMaterialMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LunchBoxData
 */
export const LunchBoxData = new LunchBoxData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MailChangeNotify$Type extends MessageType<MailChangeNotify> {
    constructor() {
        super("MailChangeNotify", [
            { no: 3, name: "mail_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MailData },
            { no: 7, name: "del_mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MailChangeNotify>): MailChangeNotify {
        const message = { mailList: [], delMailIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MailChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MailChangeNotify): MailChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MailData mail_list */ 3:
                    message.mailList.push(MailData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 del_mail_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delMailIdList.push(reader.uint32());
                    else
                        message.delMailIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MailChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MailData mail_list = 3; */
        for (let i = 0; i < message.mailList.length; i++)
            MailData.internalBinaryWrite(message.mailList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 del_mail_id_list = 7; */
        if (message.delMailIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delMailIdList.length; i++)
                writer.uint32(message.delMailIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MailChangeNotify
 */
export const MailChangeNotify = new MailChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MailData$Type extends MessageType<MailData> {
    constructor() {
        super("MailData", [
            { no: 1, name: "mail_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "mail_text_content", kind: "message", T: () => MailTextContent },
            { no: 7, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MailItem },
            { no: 8, name: "send_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "expire_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "importance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_read", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "is_attachment_got", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "argument_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "BHCAHLJIKFF", kind: "enum", jsonName: "BHCAHLJIKFF", T: () => ["CBJEDMGOBPL", CBJEDMGOBPL] }
        ]);
    }
    create(value?: PartialMessage<MailData>): MailData {
        const message = { mailId: 0, itemList: [], sendTime: 0, expireTime: 0, importance: 0, isRead: false, isAttachmentGot: false, configId: 0, argumentList: [], bHCAHLJIKFF: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MailData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MailData): MailData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 mail_id */ 1:
                    message.mailId = reader.uint32();
                    break;
                case /* MailTextContent mail_text_content */ 4:
                    message.mailTextContent = MailTextContent.internalBinaryRead(reader, reader.uint32(), options, message.mailTextContent);
                    break;
                case /* repeated MailItem item_list */ 7:
                    message.itemList.push(MailItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 send_time */ 8:
                    message.sendTime = reader.uint32();
                    break;
                case /* uint32 expire_time */ 9:
                    message.expireTime = reader.uint32();
                    break;
                case /* uint32 importance */ 10:
                    message.importance = reader.uint32();
                    break;
                case /* bool is_read */ 11:
                    message.isRead = reader.bool();
                    break;
                case /* bool is_attachment_got */ 12:
                    message.isAttachmentGot = reader.bool();
                    break;
                case /* uint32 config_id */ 13:
                    message.configId = reader.uint32();
                    break;
                case /* repeated string argument_list */ 14:
                    message.argumentList.push(reader.string());
                    break;
                case /* CBJEDMGOBPL BHCAHLJIKFF = 15 [json_name = "BHCAHLJIKFF"];*/ 15:
                    message.bHCAHLJIKFF = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MailData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 mail_id = 1; */
        if (message.mailId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.mailId);
        /* MailTextContent mail_text_content = 4; */
        if (message.mailTextContent)
            MailTextContent.internalBinaryWrite(message.mailTextContent, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated MailItem item_list = 7; */
        for (let i = 0; i < message.itemList.length; i++)
            MailItem.internalBinaryWrite(message.itemList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 send_time = 8; */
        if (message.sendTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.sendTime);
        /* uint32 expire_time = 9; */
        if (message.expireTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.expireTime);
        /* uint32 importance = 10; */
        if (message.importance !== 0)
            writer.tag(10, WireType.Varint).uint32(message.importance);
        /* bool is_read = 11; */
        if (message.isRead !== false)
            writer.tag(11, WireType.Varint).bool(message.isRead);
        /* bool is_attachment_got = 12; */
        if (message.isAttachmentGot !== false)
            writer.tag(12, WireType.Varint).bool(message.isAttachmentGot);
        /* uint32 config_id = 13; */
        if (message.configId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.configId);
        /* repeated string argument_list = 14; */
        for (let i = 0; i < message.argumentList.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.argumentList[i]);
        /* CBJEDMGOBPL BHCAHLJIKFF = 15 [json_name = "BHCAHLJIKFF"]; */
        if (message.bHCAHLJIKFF !== 0)
            writer.tag(15, WireType.Varint).int32(message.bHCAHLJIKFF);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MailData
 */
export const MailData = new MailData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MailItem$Type extends MessageType<MailItem> {
    constructor() {
        super("MailItem", [
            { no: 1, name: "equip_param", kind: "message", T: () => EquipParam },
            { no: 2, name: "delete_info", kind: "message", T: () => MaterialDeleteInfo }
        ]);
    }
    create(value?: PartialMessage<MailItem>): MailItem {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MailItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MailItem): MailItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EquipParam equip_param */ 1:
                    message.equipParam = EquipParam.internalBinaryRead(reader, reader.uint32(), options, message.equipParam);
                    break;
                case /* MaterialDeleteInfo delete_info */ 2:
                    message.deleteInfo = MaterialDeleteInfo.internalBinaryRead(reader, reader.uint32(), options, message.deleteInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MailItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EquipParam equip_param = 1; */
        if (message.equipParam)
            EquipParam.internalBinaryWrite(message.equipParam, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* MaterialDeleteInfo delete_info = 2; */
        if (message.deleteInfo)
            MaterialDeleteInfo.internalBinaryWrite(message.deleteInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MailItem
 */
export const MailItem = new MailItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MailTextContent$Type extends MessageType<MailTextContent> {
    constructor() {
        super("MailTextContent", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MailTextContent>): MailTextContent {
        const message = { title: "", content: "", sender: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MailTextContent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MailTextContent): MailTextContent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string content */ 2:
                    message.content = reader.string();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MailTextContent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string content = 2; */
        if (message.content !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.content);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MailTextContent
 */
export const MailTextContent = new MailTextContent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapMarkPoint$Type extends MessageType<MapMarkPoint> {
    constructor() {
        super("MapMarkPoint", [
            { no: 1, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pos", kind: "message", T: () => Vector },
            { no: 4, name: "point_type", kind: "enum", T: () => ["MapMarkPointType", MapMarkPointType, "MAP_MARK_POINT_TYPE_"] },
            { no: 5, name: "monster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "from_type", kind: "enum", T: () => ["MapMarkFromType", MapMarkFromType, "MAP_MARK_FROM_TYPE_"] },
            { no: 7, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MapMarkPoint>): MapMarkPoint {
        const message = { sceneId: 0, name: "", pointType: 0, monsterId: 0, fromType: 0, questId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapMarkPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapMarkPoint): MapMarkPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 1:
                    message.sceneId = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* Vector pos */ 3:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* MapMarkPointType point_type */ 4:
                    message.pointType = reader.int32();
                    break;
                case /* uint32 monster_id */ 5:
                    message.monsterId = reader.uint32();
                    break;
                case /* MapMarkFromType from_type */ 6:
                    message.fromType = reader.int32();
                    break;
                case /* uint32 quest_id */ 7:
                    message.questId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapMarkPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 1; */
        if (message.sceneId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sceneId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* Vector pos = 3; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* MapMarkPointType point_type = 4; */
        if (message.pointType !== 0)
            writer.tag(4, WireType.Varint).int32(message.pointType);
        /* uint32 monster_id = 5; */
        if (message.monsterId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.monsterId);
        /* MapMarkFromType from_type = 6; */
        if (message.fromType !== 0)
            writer.tag(6, WireType.Varint).int32(message.fromType);
        /* uint32 quest_id = 7; */
        if (message.questId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.questId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MapMarkPoint
 */
export const MapMarkPoint = new MapMarkPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapMarkTipsInfo$Type extends MessageType<MapMarkTipsInfo> {
    constructor() {
        super("MapMarkTipsInfo", [
            { no: 1, name: "tips_type", kind: "enum", T: () => ["MapMarkTipsType", MapMarkTipsType, "MAP_MARK_TIPS_TYPE_"] },
            { no: 2, name: "point_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MapMarkTipsInfo>): MapMarkTipsInfo {
        const message = { tipsType: 0, pointIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapMarkTipsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapMarkTipsInfo): MapMarkTipsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MapMarkTipsType tips_type */ 1:
                    message.tipsType = reader.int32();
                    break;
                case /* repeated uint32 point_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pointIdList.push(reader.uint32());
                    else
                        message.pointIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapMarkTipsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MapMarkTipsType tips_type = 1; */
        if (message.tipsType !== 0)
            writer.tag(1, WireType.Varint).int32(message.tipsType);
        /* repeated uint32 point_id_list = 2; */
        if (message.pointIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.pointIdList.length; i++)
                writer.uint32(message.pointIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MapMarkTipsInfo
 */
export const MapMarkTipsInfo = new MapMarkTipsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkEntityInMinMapNotify$Type extends MessageType<MarkEntityInMinMapNotify> {
    constructor() {
        super("MarkEntityInMinMapNotify", [
            { no: 5, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "position", kind: "message", T: () => Vector },
            { no: 6, name: "monster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarkEntityInMinMapNotify>): MarkEntityInMinMapNotify {
        const message = { entityId: 0, monsterId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarkEntityInMinMapNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkEntityInMinMapNotify): MarkEntityInMinMapNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 5:
                    message.entityId = reader.uint32();
                    break;
                case /* Vector position */ 13:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* uint32 monster_id */ 6:
                    message.monsterId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkEntityInMinMapNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 5; */
        if (message.entityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.entityId);
        /* Vector position = 13; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 monster_id = 6; */
        if (message.monsterId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.monsterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MarkEntityInMinMapNotify
 */
export const MarkEntityInMinMapNotify = new MarkEntityInMinMapNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkMapReq$Type extends MessageType<MarkMapReq> {
    constructor() {
        super("MarkMapReq", [
            { no: 15, name: "op", kind: "enum", T: () => ["MarkMapReq.Operation", MarkMapReq_Operation, "OPERATION_"] },
            { no: 10, name: "old", kind: "message", T: () => MapMarkPoint },
            { no: 4, name: "mark", kind: "message", T: () => MapMarkPoint }
        ]);
    }
    create(value?: PartialMessage<MarkMapReq>): MarkMapReq {
        const message = { op: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarkMapReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkMapReq): MarkMapReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MarkMapReq.Operation op */ 15:
                    message.op = reader.int32();
                    break;
                case /* MapMarkPoint old */ 10:
                    message.old = MapMarkPoint.internalBinaryRead(reader, reader.uint32(), options, message.old);
                    break;
                case /* MapMarkPoint mark */ 4:
                    message.mark = MapMarkPoint.internalBinaryRead(reader, reader.uint32(), options, message.mark);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkMapReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MarkMapReq.Operation op = 15; */
        if (message.op !== 0)
            writer.tag(15, WireType.Varint).int32(message.op);
        /* MapMarkPoint old = 10; */
        if (message.old)
            MapMarkPoint.internalBinaryWrite(message.old, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* MapMarkPoint mark = 4; */
        if (message.mark)
            MapMarkPoint.internalBinaryWrite(message.mark, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MarkMapReq
 */
export const MarkMapReq = new MarkMapReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkMapRsp$Type extends MessageType<MarkMapRsp> {
    constructor() {
        super("MarkMapRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "mark_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MapMarkPoint }
        ]);
    }
    create(value?: PartialMessage<MarkMapRsp>): MarkMapRsp {
        const message = { retcode: 0, markList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarkMapRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkMapRsp): MarkMapRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* repeated MapMarkPoint mark_list */ 7:
                    message.markList.push(MapMarkPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkMapRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* repeated MapMarkPoint mark_list = 7; */
        for (let i = 0; i < message.markList.length; i++)
            MapMarkPoint.internalBinaryWrite(message.markList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MarkMapRsp
 */
export const MarkMapRsp = new MarkMapRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkNewNotify$Type extends MessageType<MarkNewNotify> {
    constructor() {
        super("MarkNewNotify", [
            { no: 10, name: "mark_new_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarkNewNotify>): MarkNewNotify {
        const message = { markNewType: 0, idList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarkNewNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkNewNotify): MarkNewNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 mark_new_type */ 10:
                    message.markNewType = reader.uint32();
                    break;
                case /* repeated uint32 id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.idList.push(reader.uint32());
                    else
                        message.idList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkNewNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 mark_new_type = 10; */
        if (message.markNewType !== 0)
            writer.tag(10, WireType.Varint).uint32(message.markNewType);
        /* repeated uint32 id_list = 13; */
        if (message.idList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.idList.length; i++)
                writer.uint32(message.idList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MarkNewNotify
 */
export const MarkNewNotify = new MarkNewNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MassivePropParam$Type extends MessageType<MassivePropParam> {
    constructor() {
        super("MassivePropParam", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reaction_info_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "param_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "sync_flag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MassivePropParam>): MassivePropParam {
        const message = { type: 0, reactionInfoList: [], paramList: [], syncFlag: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MassivePropParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MassivePropParam): MassivePropParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated uint32 reaction_info_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reactionInfoList.push(reader.uint32());
                    else
                        message.reactionInfoList.push(reader.uint32());
                    break;
                case /* repeated float param_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.float());
                    else
                        message.paramList.push(reader.float());
                    break;
                case /* uint32 sync_flag */ 4:
                    message.syncFlag = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MassivePropParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* repeated uint32 reaction_info_list = 2; */
        if (message.reactionInfoList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reactionInfoList.length; i++)
                writer.uint32(message.reactionInfoList[i]);
            writer.join();
        }
        /* repeated float param_list = 3; */
        if (message.paramList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.float(message.paramList[i]);
            writer.join();
        }
        /* uint32 sync_flag = 4; */
        if (message.syncFlag !== 0)
            writer.tag(4, WireType.Varint).uint32(message.syncFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MassivePropParam
 */
export const MassivePropParam = new MassivePropParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MassivePropSyncInfo$Type extends MessageType<MassivePropSyncInfo> {
    constructor() {
        super("MassivePropSyncInfo", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "prop_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MassivePropParam }
        ]);
    }
    create(value?: PartialMessage<MassivePropSyncInfo>): MassivePropSyncInfo {
        const message = { id: 0n, propList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MassivePropSyncInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MassivePropSyncInfo): MassivePropSyncInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* repeated MassivePropParam prop_list */ 2:
                    message.propList.push(MassivePropParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MassivePropSyncInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* repeated MassivePropParam prop_list = 2; */
        for (let i = 0; i < message.propList.length; i++)
            MassivePropParam.internalBinaryWrite(message.propList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MassivePropSyncInfo
 */
export const MassivePropSyncInfo = new MassivePropSyncInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Material$Type extends MessageType<Material> {
    constructor() {
        super("Material", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "delete_info", kind: "message", T: () => MaterialDeleteInfo }
        ]);
    }
    create(value?: PartialMessage<Material>): Material {
        const message = { count: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Material>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Material): Material {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                case /* MaterialDeleteInfo delete_info */ 2:
                    message.deleteInfo = MaterialDeleteInfo.internalBinaryRead(reader, reader.uint32(), options, message.deleteInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Material, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        /* MaterialDeleteInfo delete_info = 2; */
        if (message.deleteInfo)
            MaterialDeleteInfo.internalBinaryWrite(message.deleteInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Material
 */
export const Material = new Material$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterialDeleteInfo$Type extends MessageType<MaterialDeleteInfo> {
    constructor() {
        super("MaterialDeleteInfo", [
            { no: 2, name: "count_down_delete", kind: "message", oneof: "deleteInfo", T: () => MaterialDeleteInfo_CountDownDelete },
            { no: 3, name: "date_delete", kind: "message", oneof: "deleteInfo", T: () => MaterialDeleteInfo_DateTimeDelete },
            { no: 4, name: "delay_week_count_down_delete", kind: "message", oneof: "deleteInfo", T: () => MaterialDeleteInfo_DelayWeekCountDownDelete },
            { no: 1, name: "has_delete_config", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MaterialDeleteInfo>): MaterialDeleteInfo {
        const message = { deleteInfo: { oneofKind: undefined }, hasDeleteConfig: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaterialDeleteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterialDeleteInfo): MaterialDeleteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MaterialDeleteInfo.CountDownDelete count_down_delete */ 2:
                    message.deleteInfo = {
                        oneofKind: "countDownDelete",
                        countDownDelete: MaterialDeleteInfo_CountDownDelete.internalBinaryRead(reader, reader.uint32(), options, (message.deleteInfo as any).countDownDelete)
                    };
                    break;
                case /* MaterialDeleteInfo.DateTimeDelete date_delete */ 3:
                    message.deleteInfo = {
                        oneofKind: "dateDelete",
                        dateDelete: MaterialDeleteInfo_DateTimeDelete.internalBinaryRead(reader, reader.uint32(), options, (message.deleteInfo as any).dateDelete)
                    };
                    break;
                case /* MaterialDeleteInfo.DelayWeekCountDownDelete delay_week_count_down_delete */ 4:
                    message.deleteInfo = {
                        oneofKind: "delayWeekCountDownDelete",
                        delayWeekCountDownDelete: MaterialDeleteInfo_DelayWeekCountDownDelete.internalBinaryRead(reader, reader.uint32(), options, (message.deleteInfo as any).delayWeekCountDownDelete)
                    };
                    break;
                case /* bool has_delete_config */ 1:
                    message.hasDeleteConfig = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterialDeleteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MaterialDeleteInfo.CountDownDelete count_down_delete = 2; */
        if (message.deleteInfo.oneofKind === "countDownDelete")
            MaterialDeleteInfo_CountDownDelete.internalBinaryWrite(message.deleteInfo.countDownDelete, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* MaterialDeleteInfo.DateTimeDelete date_delete = 3; */
        if (message.deleteInfo.oneofKind === "dateDelete")
            MaterialDeleteInfo_DateTimeDelete.internalBinaryWrite(message.deleteInfo.dateDelete, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* MaterialDeleteInfo.DelayWeekCountDownDelete delay_week_count_down_delete = 4; */
        if (message.deleteInfo.oneofKind === "delayWeekCountDownDelete")
            MaterialDeleteInfo_DelayWeekCountDownDelete.internalBinaryWrite(message.deleteInfo.delayWeekCountDownDelete, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool has_delete_config = 1; */
        if (message.hasDeleteConfig !== false)
            writer.tag(1, WireType.Varint).bool(message.hasDeleteConfig);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MaterialDeleteInfo
 */
export const MaterialDeleteInfo = new MaterialDeleteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterialDeleteInfo_CountDownDelete$Type extends MessageType<MaterialDeleteInfo_CountDownDelete> {
    constructor() {
        super("MaterialDeleteInfo.CountDownDelete", [
            { no: 1, name: "delete_time_num_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 2, name: "config_count_down_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MaterialDeleteInfo_CountDownDelete>): MaterialDeleteInfo_CountDownDelete {
        const message = { deleteTimeNumMap: {}, configCountDownTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaterialDeleteInfo_CountDownDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterialDeleteInfo_CountDownDelete): MaterialDeleteInfo_CountDownDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> delete_time_num_map */ 1:
                    this.binaryReadMap1(message.deleteTimeNumMap, reader, options);
                    break;
                case /* uint32 config_count_down_time */ 2:
                    message.configCountDownTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MaterialDeleteInfo_CountDownDelete["deleteTimeNumMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MaterialDeleteInfo_CountDownDelete["deleteTimeNumMap"] | undefined, val: MaterialDeleteInfo_CountDownDelete["deleteTimeNumMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field MaterialDeleteInfo.CountDownDelete.delete_time_num_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: MaterialDeleteInfo_CountDownDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> delete_time_num_map = 1; */
        for (let k of Object.keys(message.deleteTimeNumMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.deleteTimeNumMap[k as any]).join();
        /* uint32 config_count_down_time = 2; */
        if (message.configCountDownTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.configCountDownTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MaterialDeleteInfo.CountDownDelete
 */
export const MaterialDeleteInfo_CountDownDelete = new MaterialDeleteInfo_CountDownDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterialDeleteInfo_DateTimeDelete$Type extends MessageType<MaterialDeleteInfo_DateTimeDelete> {
    constructor() {
        super("MaterialDeleteInfo.DateTimeDelete", [
            { no: 1, name: "delete_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MaterialDeleteInfo_DateTimeDelete>): MaterialDeleteInfo_DateTimeDelete {
        const message = { deleteTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaterialDeleteInfo_DateTimeDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterialDeleteInfo_DateTimeDelete): MaterialDeleteInfo_DateTimeDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 delete_time */ 1:
                    message.deleteTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterialDeleteInfo_DateTimeDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 delete_time = 1; */
        if (message.deleteTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.deleteTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MaterialDeleteInfo.DateTimeDelete
 */
export const MaterialDeleteInfo_DateTimeDelete = new MaterialDeleteInfo_DateTimeDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterialDeleteInfo_DelayWeekCountDownDelete$Type extends MessageType<MaterialDeleteInfo_DelayWeekCountDownDelete> {
    constructor() {
        super("MaterialDeleteInfo.DelayWeekCountDownDelete", [
            { no: 1, name: "delete_time_num_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 2, name: "config_delay_week", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "config_count_down_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MaterialDeleteInfo_DelayWeekCountDownDelete>): MaterialDeleteInfo_DelayWeekCountDownDelete {
        const message = { deleteTimeNumMap: {}, configDelayWeek: 0, configCountDownTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaterialDeleteInfo_DelayWeekCountDownDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterialDeleteInfo_DelayWeekCountDownDelete): MaterialDeleteInfo_DelayWeekCountDownDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> delete_time_num_map */ 1:
                    this.binaryReadMap1(message.deleteTimeNumMap, reader, options);
                    break;
                case /* uint32 config_delay_week */ 2:
                    message.configDelayWeek = reader.uint32();
                    break;
                case /* uint32 config_count_down_time */ 3:
                    message.configCountDownTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MaterialDeleteInfo_DelayWeekCountDownDelete["deleteTimeNumMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MaterialDeleteInfo_DelayWeekCountDownDelete["deleteTimeNumMap"] | undefined, val: MaterialDeleteInfo_DelayWeekCountDownDelete["deleteTimeNumMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field MaterialDeleteInfo.DelayWeekCountDownDelete.delete_time_num_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: MaterialDeleteInfo_DelayWeekCountDownDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> delete_time_num_map = 1; */
        for (let k of Object.keys(message.deleteTimeNumMap))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.deleteTimeNumMap[k as any]).join();
        /* uint32 config_delay_week = 2; */
        if (message.configDelayWeek !== 0)
            writer.tag(2, WireType.Varint).uint32(message.configDelayWeek);
        /* uint32 config_count_down_time = 3; */
        if (message.configCountDownTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.configCountDownTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MaterialDeleteInfo.DelayWeekCountDownDelete
 */
export const MaterialDeleteInfo_DelayWeekCountDownDelete = new MaterialDeleteInfo_DelayWeekCountDownDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterialInfo$Type extends MessageType<MaterialInfo> {
    constructor() {
        super("MaterialInfo", [
            { no: 1, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MaterialInfo>): MaterialInfo {
        const message = { guid: 0n, count: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaterialInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterialInfo): MaterialInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 guid */ 1:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterialInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 guid = 1; */
        if (message.guid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.guid);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MaterialInfo
 */
export const MaterialInfo = new MaterialInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MathQuaternion$Type extends MessageType<MathQuaternion> {
    constructor() {
        super("MathQuaternion", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MathQuaternion>): MathQuaternion {
        const message = { x: 0, y: 0, z: 0, w: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MathQuaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MathQuaternion): MathQuaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                case /* float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MathQuaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* float w = 4; */
        if (message.w !== 0)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MathQuaternion
 */
export const MathQuaternion = new MathQuaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McoinExchangeHcoinReq$Type extends MessageType<McoinExchangeHcoinReq> {
    constructor() {
        super("McoinExchangeHcoinReq", [
            { no: 8, name: "mcoin_cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "hcoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<McoinExchangeHcoinReq>): McoinExchangeHcoinReq {
        const message = { mcoinCost: 0, hcoin: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<McoinExchangeHcoinReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McoinExchangeHcoinReq): McoinExchangeHcoinReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 mcoin_cost */ 8:
                    message.mcoinCost = reader.uint32();
                    break;
                case /* uint32 hcoin */ 12:
                    message.hcoin = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McoinExchangeHcoinReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 mcoin_cost = 8; */
        if (message.mcoinCost !== 0)
            writer.tag(8, WireType.Varint).uint32(message.mcoinCost);
        /* uint32 hcoin = 12; */
        if (message.hcoin !== 0)
            writer.tag(12, WireType.Varint).uint32(message.hcoin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message McoinExchangeHcoinReq
 */
export const McoinExchangeHcoinReq = new McoinExchangeHcoinReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McoinExchangeHcoinRsp$Type extends MessageType<McoinExchangeHcoinRsp> {
    constructor() {
        super("McoinExchangeHcoinRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "mcoin_cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "hcoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<McoinExchangeHcoinRsp>): McoinExchangeHcoinRsp {
        const message = { retcode: 0, mcoinCost: 0, hcoin: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<McoinExchangeHcoinRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McoinExchangeHcoinRsp): McoinExchangeHcoinRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 mcoin_cost */ 10:
                    message.mcoinCost = reader.uint32();
                    break;
                case /* uint32 hcoin */ 15:
                    message.hcoin = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McoinExchangeHcoinRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 mcoin_cost = 10; */
        if (message.mcoinCost !== 0)
            writer.tag(10, WireType.Varint).uint32(message.mcoinCost);
        /* uint32 hcoin = 15; */
        if (message.hcoin !== 0)
            writer.tag(15, WireType.Varint).uint32(message.hcoin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message McoinExchangeHcoinRsp
 */
export const McoinExchangeHcoinRsp = new McoinExchangeHcoinRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifierDurability$Type extends MessageType<ModifierDurability> {
    constructor() {
        super("ModifierDurability", [
            { no: 1, name: "reduce_ratio", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "remaining_durability", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ModifierDurability>): ModifierDurability {
        const message = { reduceRatio: 0, remainingDurability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModifierDurability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModifierDurability): ModifierDurability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float reduce_ratio */ 1:
                    message.reduceRatio = reader.float();
                    break;
                case /* float remaining_durability */ 2:
                    message.remainingDurability = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModifierDurability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float reduce_ratio = 1; */
        if (message.reduceRatio !== 0)
            writer.tag(1, WireType.Bit32).float(message.reduceRatio);
        /* float remaining_durability = 2; */
        if (message.remainingDurability !== 0)
            writer.tag(2, WireType.Bit32).float(message.remainingDurability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ModifierDurability
 */
export const ModifierDurability = new ModifierDurability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifierProperty$Type extends MessageType<ModifierProperty> {
    constructor() {
        super("ModifierProperty", [
            { no: 1, name: "key", kind: "message", T: () => AbilityString },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ModifierProperty>): ModifierProperty {
        const message = { value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModifierProperty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModifierProperty): ModifierProperty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* AbilityString key */ 1:
                    message.key = AbilityString.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModifierProperty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* AbilityString key = 1; */
        if (message.key)
            AbilityString.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ModifierProperty
 */
export const ModifierProperty = new ModifierProperty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MonsterRoute$Type extends MessageType<MonsterRoute> {
    constructor() {
        super("MonsterRoute", [
            { no: 1, name: "route_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutePoint },
            { no: 2, name: "speed_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "route_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "arrive_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MonsterRoute>): MonsterRoute {
        const message = { routePoints: [], speedLevel: 0, routeType: 0, arriveRange: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MonsterRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MonsterRoute): MonsterRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated RoutePoint route_points */ 1:
                    message.routePoints.push(RoutePoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 speed_level */ 2:
                    message.speedLevel = reader.uint32();
                    break;
                case /* uint32 route_type */ 3:
                    message.routeType = reader.uint32();
                    break;
                case /* float arrive_range */ 4:
                    message.arriveRange = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MonsterRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated RoutePoint route_points = 1; */
        for (let i = 0; i < message.routePoints.length; i++)
            RoutePoint.internalBinaryWrite(message.routePoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 speed_level = 2; */
        if (message.speedLevel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.speedLevel);
        /* uint32 route_type = 3; */
        if (message.routeType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.routeType);
        /* float arrive_range = 4; */
        if (message.arriveRange !== 0)
            writer.tag(4, WireType.Bit32).float(message.arriveRange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MonsterRoute
 */
export const MonsterRoute = new MonsterRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MotionInfo$Type extends MessageType<MotionInfo> {
    constructor() {
        super("MotionInfo", [
            { no: 1, name: "pos", kind: "message", T: () => Vector },
            { no: 2, name: "rot", kind: "message", T: () => Vector },
            { no: 3, name: "speed", kind: "message", T: () => Vector },
            { no: 4, name: "state", kind: "enum", T: () => ["MotionState", MotionState, "MOTION_STATE_"] },
            { no: 5, name: "params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Vector },
            { no: 6, name: "ref_pos", kind: "message", T: () => Vector },
            { no: 7, name: "ref_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "interval_velocity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MotionInfo>): MotionInfo {
        const message = { state: 0, params: [], refId: 0, sceneTime: 0, intervalVelocity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MotionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MotionInfo): MotionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector pos */ 1:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 2:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* Vector speed */ 3:
                    message.speed = Vector.internalBinaryRead(reader, reader.uint32(), options, message.speed);
                    break;
                case /* MotionState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* repeated Vector params */ 5:
                    message.params.push(Vector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* Vector ref_pos */ 6:
                    message.refPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.refPos);
                    break;
                case /* uint32 ref_id */ 7:
                    message.refId = reader.uint32();
                    break;
                case /* uint32 scene_time */ 8:
                    message.sceneTime = reader.uint32();
                    break;
                case /* uint64 interval_velocity */ 9:
                    message.intervalVelocity = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MotionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector pos = 1; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 2; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Vector speed = 3; */
        if (message.speed)
            Vector.internalBinaryWrite(message.speed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* MotionState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* repeated Vector params = 5; */
        for (let i = 0; i < message.params.length; i++)
            Vector.internalBinaryWrite(message.params[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Vector ref_pos = 6; */
        if (message.refPos)
            Vector.internalBinaryWrite(message.refPos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 ref_id = 7; */
        if (message.refId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.refId);
        /* uint32 scene_time = 8; */
        if (message.sceneTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.sceneTime);
        /* uint64 interval_velocity = 9; */
        if (message.intervalVelocity !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.intervalVelocity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MotionInfo
 */
export const MotionInfo = new MotionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MPLevelEntityInfo$Type extends MessageType<MPLevelEntityInfo> {
    constructor() {
        super("MPLevelEntityInfo", [
            { no: 4, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "authority_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "ability_info", kind: "message", T: () => AbilitySyncStateInfo }
        ]);
    }
    create(value?: PartialMessage<MPLevelEntityInfo>): MPLevelEntityInfo {
        const message = { entityId: 0, authorityPeerId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MPLevelEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MPLevelEntityInfo): MPLevelEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 4:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 authority_peer_id */ 3:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo ability_info */ 12:
                    message.abilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.abilityInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MPLevelEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 4; */
        if (message.entityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.entityId);
        /* uint32 authority_peer_id = 3; */
        if (message.authorityPeerId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.authorityPeerId);
        /* AbilitySyncStateInfo ability_info = 12; */
        if (message.abilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.abilityInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MPLevelEntityInfo
 */
export const MPLevelEntityInfo = new MPLevelEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MpPlayRewardInfo$Type extends MessageType<MpPlayRewardInfo> {
    constructor() {
        super("MpPlayRewardInfo", [
            { no: 1, name: "resin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "remain_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "qualify_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MpPlayRewardInfo>): MpPlayRewardInfo {
        const message = { resin: 0, remainUidList: [], qualifyUidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MpPlayRewardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MpPlayRewardInfo): MpPlayRewardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 resin */ 1:
                    message.resin = reader.uint32();
                    break;
                case /* repeated uint32 remain_uid_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.remainUidList.push(reader.uint32());
                    else
                        message.remainUidList.push(reader.uint32());
                    break;
                case /* repeated uint32 qualify_uid_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.qualifyUidList.push(reader.uint32());
                    else
                        message.qualifyUidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MpPlayRewardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 resin = 1; */
        if (message.resin !== 0)
            writer.tag(1, WireType.Varint).uint32(message.resin);
        /* repeated uint32 remain_uid_list = 2; */
        if (message.remainUidList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.remainUidList.length; i++)
                writer.uint32(message.remainUidList[i]);
            writer.join();
        }
        /* repeated uint32 qualify_uid_list = 3; */
        if (message.qualifyUidList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.qualifyUidList.length; i++)
                writer.uint32(message.qualifyUidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MpPlayRewardInfo
 */
export const MpPlayRewardInfo = new MpPlayRewardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicBeatmap$Type extends MessageType<MusicBeatmap> {
    constructor() {
        super("MusicBeatmap", [
            { no: 1, name: "music_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "beatmap_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MusicBeatmapList }
        ]);
    }
    create(value?: PartialMessage<MusicBeatmap>): MusicBeatmap {
        const message = { musicId: 0, beatmapItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicBeatmap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicBeatmap): MusicBeatmap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 music_id */ 1:
                    message.musicId = reader.uint32();
                    break;
                case /* repeated MusicBeatmapList beatmap_item_list */ 2:
                    message.beatmapItemList.push(MusicBeatmapList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicBeatmap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 music_id = 1; */
        if (message.musicId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.musicId);
        /* repeated MusicBeatmapList beatmap_item_list = 2; */
        for (let i = 0; i < message.beatmapItemList.length; i++)
            MusicBeatmapList.internalBinaryWrite(message.beatmapItemList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicBeatmap
 */
export const MusicBeatmap = new MusicBeatmap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicBeatmapList$Type extends MessageType<MusicBeatmapList> {
    constructor() {
        super("MusicBeatmapList", [
            { no: 1, name: "beatmap_note_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MusicBeatmapNote }
        ]);
    }
    create(value?: PartialMessage<MusicBeatmapList>): MusicBeatmapList {
        const message = { beatmapNoteList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicBeatmapList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicBeatmapList): MusicBeatmapList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MusicBeatmapNote beatmap_note_list */ 1:
                    message.beatmapNoteList.push(MusicBeatmapNote.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicBeatmapList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MusicBeatmapNote beatmap_note_list = 1; */
        for (let i = 0; i < message.beatmapNoteList.length; i++)
            MusicBeatmapNote.internalBinaryWrite(message.beatmapNoteList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicBeatmapList
 */
export const MusicBeatmapList = new MusicBeatmapList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicBeatmapNote$Type extends MessageType<MusicBeatmapNote> {
    constructor() {
        super("MusicBeatmapNote", [
            { no: 1, name: "start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MusicBeatmapNote>): MusicBeatmapNote {
        const message = { startTime: 0, endTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicBeatmapNote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicBeatmapNote): MusicBeatmapNote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 start_time */ 1:
                    message.startTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 2:
                    message.endTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicBeatmapNote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 start_time = 1; */
        if (message.startTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.startTime);
        /* uint32 end_time = 2; */
        if (message.endTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.endTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicBeatmapNote
 */
export const MusicBeatmapNote = new MusicBeatmapNote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicBriefInfo$Type extends MessageType<MusicBriefInfo> {
    constructor() {
        super("MusicBriefInfo", [
            { no: 10, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "music_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "author_nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "music_note_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "max_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "create_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "share_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "settle", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "can_share", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "OAPKHNELBPH", kind: "scalar", jsonName: "OAPKHNELBPH", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "NJHAMJMHPAA", kind: "scalar", jsonName: "NJHAMJMHPAA", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "ADIBIKKNPKK", kind: "scalar", jsonName: "ADIBIKKNPKK", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1684, name: "unknown", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 763, name: "GIDFMAJFIFE", kind: "scalar", jsonName: "GIDFMAJFIFE", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 921, name: "OKBJPAKOLIH", kind: "scalar", jsonName: "OKBJPAKOLIH", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 335, name: "FAOPBAMDFJB", kind: "scalar", jsonName: "FAOPBAMDFJB", T: 13 /*ScalarType.UINT32*/ },
            { no: 938, name: "FELMANEFAOE", kind: "scalar", jsonName: "FELMANEFAOE", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MusicBriefInfo>): MusicBriefInfo {
        const message = { musicShareId: 0n, musicId: 0, authorNickname: "", musicNoteCount: 0, maxScore: 0, score: 0, createTime: 0, shareTime: 0, position: 0, settle: false, version: 0, canShare: false, oAPKHNELBPH: false, nJHAMJMHPAA: false, aDIBIKKNPKK: 0n, unknown: 0, gIDFMAJFIFE: [], oKBJPAKOLIH: [], fAOPBAMDFJB: 0, fELMANEFAOE: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicBriefInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicBriefInfo): MusicBriefInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 music_share_id */ 10:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* uint32 music_id */ 9:
                    message.musicId = reader.uint32();
                    break;
                case /* string author_nickname */ 12:
                    message.authorNickname = reader.string();
                    break;
                case /* uint32 music_note_count */ 8:
                    message.musicNoteCount = reader.uint32();
                    break;
                case /* uint32 max_score */ 3:
                    message.maxScore = reader.uint32();
                    break;
                case /* uint32 score */ 5:
                    message.score = reader.uint32();
                    break;
                case /* uint32 create_time */ 13:
                    message.createTime = reader.uint32();
                    break;
                case /* uint32 share_time */ 14:
                    message.shareTime = reader.uint32();
                    break;
                case /* uint32 position */ 2:
                    message.position = reader.uint32();
                    break;
                case /* bool settle */ 6:
                    message.settle = reader.bool();
                    break;
                case /* uint32 version */ 4:
                    message.version = reader.uint32();
                    break;
                case /* bool can_share */ 15:
                    message.canShare = reader.bool();
                    break;
                case /* bool OAPKHNELBPH = 11 [json_name = "OAPKHNELBPH"];*/ 11:
                    message.oAPKHNELBPH = reader.bool();
                    break;
                case /* bool NJHAMJMHPAA = 7 [json_name = "NJHAMJMHPAA"];*/ 7:
                    message.nJHAMJMHPAA = reader.bool();
                    break;
                case /* uint64 ADIBIKKNPKK = 1 [json_name = "ADIBIKKNPKK"];*/ 1:
                    message.aDIBIKKNPKK = reader.uint64().toBigInt();
                    break;
                case /* uint32 unknown */ 1684:
                    message.unknown = reader.uint32();
                    break;
                case /* repeated uint32 GIDFMAJFIFE = 763 [json_name = "GIDFMAJFIFE"];*/ 763:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.gIDFMAJFIFE.push(reader.uint32());
                    else
                        message.gIDFMAJFIFE.push(reader.uint32());
                    break;
                case /* repeated uint32 OKBJPAKOLIH = 921 [json_name = "OKBJPAKOLIH"];*/ 921:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oKBJPAKOLIH.push(reader.uint32());
                    else
                        message.oKBJPAKOLIH.push(reader.uint32());
                    break;
                case /* uint32 FAOPBAMDFJB = 335 [json_name = "FAOPBAMDFJB"];*/ 335:
                    message.fAOPBAMDFJB = reader.uint32();
                    break;
                case /* uint32 FELMANEFAOE = 938 [json_name = "FELMANEFAOE"];*/ 938:
                    message.fELMANEFAOE = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicBriefInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 music_share_id = 10; */
        if (message.musicShareId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.musicShareId);
        /* uint32 music_id = 9; */
        if (message.musicId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.musicId);
        /* string author_nickname = 12; */
        if (message.authorNickname !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.authorNickname);
        /* uint32 music_note_count = 8; */
        if (message.musicNoteCount !== 0)
            writer.tag(8, WireType.Varint).uint32(message.musicNoteCount);
        /* uint32 max_score = 3; */
        if (message.maxScore !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxScore);
        /* uint32 score = 5; */
        if (message.score !== 0)
            writer.tag(5, WireType.Varint).uint32(message.score);
        /* uint32 create_time = 13; */
        if (message.createTime !== 0)
            writer.tag(13, WireType.Varint).uint32(message.createTime);
        /* uint32 share_time = 14; */
        if (message.shareTime !== 0)
            writer.tag(14, WireType.Varint).uint32(message.shareTime);
        /* uint32 position = 2; */
        if (message.position !== 0)
            writer.tag(2, WireType.Varint).uint32(message.position);
        /* bool settle = 6; */
        if (message.settle !== false)
            writer.tag(6, WireType.Varint).bool(message.settle);
        /* uint32 version = 4; */
        if (message.version !== 0)
            writer.tag(4, WireType.Varint).uint32(message.version);
        /* bool can_share = 15; */
        if (message.canShare !== false)
            writer.tag(15, WireType.Varint).bool(message.canShare);
        /* bool OAPKHNELBPH = 11 [json_name = "OAPKHNELBPH"]; */
        if (message.oAPKHNELBPH !== false)
            writer.tag(11, WireType.Varint).bool(message.oAPKHNELBPH);
        /* bool NJHAMJMHPAA = 7 [json_name = "NJHAMJMHPAA"]; */
        if (message.nJHAMJMHPAA !== false)
            writer.tag(7, WireType.Varint).bool(message.nJHAMJMHPAA);
        /* uint64 ADIBIKKNPKK = 1 [json_name = "ADIBIKKNPKK"]; */
        if (message.aDIBIKKNPKK !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.aDIBIKKNPKK);
        /* uint32 unknown = 1684; */
        if (message.unknown !== 0)
            writer.tag(1684, WireType.Varint).uint32(message.unknown);
        /* repeated uint32 GIDFMAJFIFE = 763 [json_name = "GIDFMAJFIFE"]; */
        if (message.gIDFMAJFIFE.length) {
            writer.tag(763, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.gIDFMAJFIFE.length; i++)
                writer.uint32(message.gIDFMAJFIFE[i]);
            writer.join();
        }
        /* repeated uint32 OKBJPAKOLIH = 921 [json_name = "OKBJPAKOLIH"]; */
        if (message.oKBJPAKOLIH.length) {
            writer.tag(921, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.oKBJPAKOLIH.length; i++)
                writer.uint32(message.oKBJPAKOLIH[i]);
            writer.join();
        }
        /* uint32 FAOPBAMDFJB = 335 [json_name = "FAOPBAMDFJB"]; */
        if (message.fAOPBAMDFJB !== 0)
            writer.tag(335, WireType.Varint).uint32(message.fAOPBAMDFJB);
        /* uint32 FELMANEFAOE = 938 [json_name = "FELMANEFAOE"]; */
        if (message.fELMANEFAOE !== 0)
            writer.tag(938, WireType.Varint).uint32(message.fELMANEFAOE);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicBriefInfo
 */
export const MusicBriefInfo = new MusicBriefInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameActivityDetailInfo$Type extends MessageType<MusicGameActivityDetailInfo> {
    constructor() {
        super("MusicGameActivityDetailInfo", [
            { no: 8, name: "music_game_record_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => MusicGameRecord } },
            { no: 2, name: "person_custom_beatmap", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MusicBriefInfo },
            { no: 12, name: "others_custom_beatmap", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MusicBriefInfo }
        ]);
    }
    create(value?: PartialMessage<MusicGameActivityDetailInfo>): MusicGameActivityDetailInfo {
        const message = { musicGameRecordMap: {}, personCustomBeatmap: [], othersCustomBeatmap: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameActivityDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameActivityDetailInfo): MusicGameActivityDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, MusicGameRecord> music_game_record_map */ 8:
                    this.binaryReadMap8(message.musicGameRecordMap, reader, options);
                    break;
                case /* repeated MusicBriefInfo person_custom_beatmap */ 2:
                    message.personCustomBeatmap.push(MusicBriefInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated MusicBriefInfo others_custom_beatmap */ 12:
                    message.othersCustomBeatmap.push(MusicBriefInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: MusicGameActivityDetailInfo["musicGameRecordMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MusicGameActivityDetailInfo["musicGameRecordMap"] | undefined, val: MusicGameActivityDetailInfo["musicGameRecordMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = MusicGameRecord.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field MusicGameActivityDetailInfo.music_game_record_map");
            }
        }
        map[key ?? 0] = val ?? MusicGameRecord.create();
    }
    internalBinaryWrite(message: MusicGameActivityDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, MusicGameRecord> music_game_record_map = 8; */
        for (let k of Object.keys(message.musicGameRecordMap)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            MusicGameRecord.internalBinaryWrite(message.musicGameRecordMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated MusicBriefInfo person_custom_beatmap = 2; */
        for (let i = 0; i < message.personCustomBeatmap.length; i++)
            MusicBriefInfo.internalBinaryWrite(message.personCustomBeatmap[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated MusicBriefInfo others_custom_beatmap = 12; */
        for (let i = 0; i < message.othersCustomBeatmap.length; i++)
            MusicBriefInfo.internalBinaryWrite(message.othersCustomBeatmap[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameActivityDetailInfo
 */
export const MusicGameActivityDetailInfo = new MusicGameActivityDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameCreateBeatmapReq$Type extends MessageType<MusicGameCreateBeatmapReq> {
    constructor() {
        super("MusicGameCreateBeatmapReq", [
            { no: 12, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 10, name: "music_record", kind: "message", oneof: "beatmap", T: () => MusicBeatmap },
            { no: 1021, name: "music_brief_info", kind: "message", oneof: "briefInfo", T: () => MusicBriefInfo }
        ]);
    }
    create(value?: PartialMessage<MusicGameCreateBeatmapReq>): MusicGameCreateBeatmapReq {
        const message = { unknownEnum1: 0, beatmap: { oneofKind: undefined }, briefInfo: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameCreateBeatmapReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameCreateBeatmapReq): MusicGameCreateBeatmapReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MusicGameUnknown1Enum unknown_enum1 */ 12:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* MusicBeatmap music_record */ 10:
                    message.beatmap = {
                        oneofKind: "musicRecord",
                        musicRecord: MusicBeatmap.internalBinaryRead(reader, reader.uint32(), options, (message.beatmap as any).musicRecord)
                    };
                    break;
                case /* MusicBriefInfo music_brief_info */ 1021:
                    message.briefInfo = {
                        oneofKind: "musicBriefInfo",
                        musicBriefInfo: MusicBriefInfo.internalBinaryRead(reader, reader.uint32(), options, (message.briefInfo as any).musicBriefInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameCreateBeatmapReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MusicGameUnknown1Enum unknown_enum1 = 12; */
        if (message.unknownEnum1 !== 0)
            writer.tag(12, WireType.Varint).int32(message.unknownEnum1);
        /* MusicBeatmap music_record = 10; */
        if (message.beatmap.oneofKind === "musicRecord")
            MusicBeatmap.internalBinaryWrite(message.beatmap.musicRecord, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* MusicBriefInfo music_brief_info = 1021; */
        if (message.briefInfo.oneofKind === "musicBriefInfo")
            MusicBriefInfo.internalBinaryWrite(message.briefInfo.musicBriefInfo, writer.tag(1021, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameCreateBeatmapReq
 */
export const MusicGameCreateBeatmapReq = new MusicGameCreateBeatmapReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameCreateBeatmapRsp$Type extends MessageType<MusicGameCreateBeatmapRsp> {
    constructor() {
        super("MusicGameCreateBeatmapRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 5, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameCreateBeatmapRsp>): MusicGameCreateBeatmapRsp {
        const message = { retcode: 0, unknownEnum1: 0, musicShareId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameCreateBeatmapRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameCreateBeatmapRsp): MusicGameCreateBeatmapRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                case /* MusicGameUnknown1Enum unknown_enum1 */ 12:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* uint64 music_share_id */ 5:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameCreateBeatmapRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        /* MusicGameUnknown1Enum unknown_enum1 = 12; */
        if (message.unknownEnum1 !== 0)
            writer.tag(12, WireType.Varint).int32(message.unknownEnum1);
        /* uint64 music_share_id = 5; */
        if (message.musicShareId !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.musicShareId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameCreateBeatmapRsp
 */
export const MusicGameCreateBeatmapRsp = new MusicGameCreateBeatmapRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameGetBeatmapReq$Type extends MessageType<MusicGameGetBeatmapReq> {
    constructor() {
        super("MusicGameGetBeatmapReq", [
            { no: 1, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 10, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "unknown_enum2", kind: "enum", T: () => ["MusicGameUnknown2Enum", MusicGameUnknown2Enum] },
            { no: 15, name: "CDFOGGDLKNA", kind: "scalar", jsonName: "CDFOGGDLKNA", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "req_type", kind: "enum", T: () => ["MusicGameGetBeatmapReqType", MusicGameGetBeatmapReqType] }
        ]);
    }
    create(value?: PartialMessage<MusicGameGetBeatmapReq>): MusicGameGetBeatmapReq {
        const message = { unknownEnum1: 0, musicShareId: 0n, unknownEnum2: 0, cDFOGGDLKNA: false, reqType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameGetBeatmapReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameGetBeatmapReq): MusicGameGetBeatmapReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MusicGameUnknown1Enum unknown_enum1 */ 1:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* uint64 music_share_id */ 10:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* MusicGameUnknown2Enum unknown_enum2 */ 12:
                    message.unknownEnum2 = reader.int32();
                    break;
                case /* bool CDFOGGDLKNA = 15 [json_name = "CDFOGGDLKNA"];*/ 15:
                    message.cDFOGGDLKNA = reader.bool();
                    break;
                case /* MusicGameGetBeatmapReqType req_type */ 11:
                    message.reqType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameGetBeatmapReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MusicGameUnknown1Enum unknown_enum1 = 1; */
        if (message.unknownEnum1 !== 0)
            writer.tag(1, WireType.Varint).int32(message.unknownEnum1);
        /* uint64 music_share_id = 10; */
        if (message.musicShareId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.musicShareId);
        /* MusicGameUnknown2Enum unknown_enum2 = 12; */
        if (message.unknownEnum2 !== 0)
            writer.tag(12, WireType.Varint).int32(message.unknownEnum2);
        /* bool CDFOGGDLKNA = 15 [json_name = "CDFOGGDLKNA"]; */
        if (message.cDFOGGDLKNA !== false)
            writer.tag(15, WireType.Varint).bool(message.cDFOGGDLKNA);
        /* MusicGameGetBeatmapReqType req_type = 11; */
        if (message.reqType !== 0)
            writer.tag(11, WireType.Varint).int32(message.reqType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameGetBeatmapReq
 */
export const MusicGameGetBeatmapReq = new MusicGameGetBeatmapReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameGetBeatmapRsp$Type extends MessageType<MusicGameGetBeatmapRsp> {
    constructor() {
        super("MusicGameGetBeatmapRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 5, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "req_type", kind: "enum", T: () => ["MusicGameGetBeatmapReqType", MusicGameGetBeatmapReqType] },
            { no: 9, name: "music_record", kind: "message", oneof: "beatmap", T: () => MusicBeatmap },
            { no: 953, name: "music_brief_info", kind: "message", oneof: "briefInfo", T: () => MusicBriefInfo }
        ]);
    }
    create(value?: PartialMessage<MusicGameGetBeatmapRsp>): MusicGameGetBeatmapRsp {
        const message = { retcode: 0, unknownEnum1: 0, musicShareId: 0n, reqType: 0, beatmap: { oneofKind: undefined }, briefInfo: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameGetBeatmapRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameGetBeatmapRsp): MusicGameGetBeatmapRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* MusicGameUnknown1Enum unknown_enum1 */ 1:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* uint64 music_share_id */ 5:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* MusicGameGetBeatmapReqType req_type */ 2:
                    message.reqType = reader.int32();
                    break;
                case /* MusicBeatmap music_record */ 9:
                    message.beatmap = {
                        oneofKind: "musicRecord",
                        musicRecord: MusicBeatmap.internalBinaryRead(reader, reader.uint32(), options, (message.beatmap as any).musicRecord)
                    };
                    break;
                case /* MusicBriefInfo music_brief_info */ 953:
                    message.briefInfo = {
                        oneofKind: "musicBriefInfo",
                        musicBriefInfo: MusicBriefInfo.internalBinaryRead(reader, reader.uint32(), options, (message.briefInfo as any).musicBriefInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameGetBeatmapRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* MusicGameUnknown1Enum unknown_enum1 = 1; */
        if (message.unknownEnum1 !== 0)
            writer.tag(1, WireType.Varint).int32(message.unknownEnum1);
        /* uint64 music_share_id = 5; */
        if (message.musicShareId !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.musicShareId);
        /* MusicGameGetBeatmapReqType req_type = 2; */
        if (message.reqType !== 0)
            writer.tag(2, WireType.Varint).int32(message.reqType);
        /* MusicBeatmap music_record = 9; */
        if (message.beatmap.oneofKind === "musicRecord")
            MusicBeatmap.internalBinaryWrite(message.beatmap.musicRecord, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* MusicBriefInfo music_brief_info = 953; */
        if (message.briefInfo.oneofKind === "musicBriefInfo")
            MusicBriefInfo.internalBinaryWrite(message.briefInfo.musicBriefInfo, writer.tag(953, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameGetBeatmapRsp
 */
export const MusicGameGetBeatmapRsp = new MusicGameGetBeatmapRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameRecord$Type extends MessageType<MusicGameRecord> {
    constructor() {
        super("MusicGameRecord", [
            { no: 3, name: "max_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "max_combo", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_unlock", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameRecord>): MusicGameRecord {
        const message = { maxScore: 0, maxCombo: 0, isUnlock: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameRecord): MusicGameRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_score */ 3:
                    message.maxScore = reader.uint32();
                    break;
                case /* uint32 max_combo */ 12:
                    message.maxCombo = reader.uint32();
                    break;
                case /* bool is_unlock */ 11:
                    message.isUnlock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_score = 3; */
        if (message.maxScore !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxScore);
        /* uint32 max_combo = 12; */
        if (message.maxCombo !== 0)
            writer.tag(12, WireType.Varint).uint32(message.maxCombo);
        /* bool is_unlock = 11; */
        if (message.isUnlock !== false)
            writer.tag(11, WireType.Varint).bool(message.isUnlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameRecord
 */
export const MusicGameRecord = new MusicGameRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameSearchBeatmapReq$Type extends MessageType<MusicGameSearchBeatmapReq> {
    constructor() {
        super("MusicGameSearchBeatmapReq", [
            { no: 10, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 6, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameSearchBeatmapReq>): MusicGameSearchBeatmapReq {
        const message = { unknownEnum1: 0, musicShareId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameSearchBeatmapReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameSearchBeatmapReq): MusicGameSearchBeatmapReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MusicGameUnknown1Enum unknown_enum1 */ 10:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* uint64 music_share_id */ 6:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameSearchBeatmapReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MusicGameUnknown1Enum unknown_enum1 = 10; */
        if (message.unknownEnum1 !== 0)
            writer.tag(10, WireType.Varint).int32(message.unknownEnum1);
        /* uint64 music_share_id = 6; */
        if (message.musicShareId !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.musicShareId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameSearchBeatmapReq
 */
export const MusicGameSearchBeatmapReq = new MusicGameSearchBeatmapReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameSearchBeatmapRsp$Type extends MessageType<MusicGameSearchBeatmapRsp> {
    constructor() {
        super("MusicGameSearchBeatmapRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 4, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "music_brief_info", kind: "message", oneof: "eLBEIFGDBMM", T: () => MusicBriefInfo }
        ]);
    }
    create(value?: PartialMessage<MusicGameSearchBeatmapRsp>): MusicGameSearchBeatmapRsp {
        const message = { retcode: 0, unknownEnum1: 0, musicShareId: 0n, eLBEIFGDBMM: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameSearchBeatmapRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameSearchBeatmapRsp): MusicGameSearchBeatmapRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* MusicGameUnknown1Enum unknown_enum1 */ 3:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* uint64 music_share_id */ 4:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* MusicBriefInfo music_brief_info */ 11:
                    message.eLBEIFGDBMM = {
                        oneofKind: "musicBriefInfo",
                        musicBriefInfo: MusicBriefInfo.internalBinaryRead(reader, reader.uint32(), options, (message.eLBEIFGDBMM as any).musicBriefInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameSearchBeatmapRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* MusicGameUnknown1Enum unknown_enum1 = 3; */
        if (message.unknownEnum1 !== 0)
            writer.tag(3, WireType.Varint).int32(message.unknownEnum1);
        /* uint64 music_share_id = 4; */
        if (message.musicShareId !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.musicShareId);
        /* MusicBriefInfo music_brief_info = 11; */
        if (message.eLBEIFGDBMM.oneofKind === "musicBriefInfo")
            MusicBriefInfo.internalBinaryWrite(message.eLBEIFGDBMM.musicBriefInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameSearchBeatmapRsp
 */
export const MusicGameSearchBeatmapRsp = new MusicGameSearchBeatmapRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameSettleReq$Type extends MessageType<MusicGameSettleReq> {
    constructor() {
        super("MusicGameSettleReq", [
            { no: 14, name: "music_basic_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "combo", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "correct_hit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "KJNDJLBOJLM", kind: "scalar", jsonName: "KJNDJLBOJLM", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "FBELCAFFGIJ", kind: "scalar", jsonName: "FBELCAFFGIJ", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "OOFMAKIDFOL", kind: "scalar", jsonName: "OOFMAKIDFOL", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "HJPDEIMECHB", kind: "scalar", jsonName: "HJPDEIMECHB", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "MNCMGANHCFI", kind: "scalar", jsonName: "MNCMGANHCFI", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "max_combo", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1975, name: "JJADNMELLAH", kind: "scalar", jsonName: "JJADNMELLAH", T: 13 /*ScalarType.UINT32*/ },
            { no: 1171, name: "EIAGEEFABPO", kind: "scalar", jsonName: "EIAGEEFABPO", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1104, name: "CPIFLFBHNJP", kind: "scalar", jsonName: "CPIFLFBHNJP", T: 13 /*ScalarType.UINT32*/ },
            { no: 998, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 268, name: "GGHBOMGJGFP", kind: "scalar", jsonName: "GGHBOMGJGFP", T: 13 /*ScalarType.UINT32*/ },
            { no: 238, name: "PFHCIHKCJFJ", kind: "scalar", jsonName: "PFHCIHKCJFJ", T: 8 /*ScalarType.BOOL*/ },
            { no: 887, name: "speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameSettleReq>): MusicGameSettleReq {
        const message = { musicBasicId: 0, score: 0, combo: 0, correctHit: 0, musicShareId: 0n, kJNDJLBOJLM: false, fBELCAFFGIJ: 0, oOFMAKIDFOL: 0, hJPDEIMECHB: 0, mNCMGANHCFI: [], maxCombo: 0, jJADNMELLAH: 0, eIAGEEFABPO: [], cPIFLFBHNJP: 0, success: false, gGHBOMGJGFP: 0, pFHCIHKCJFJ: false, speed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameSettleReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameSettleReq): MusicGameSettleReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 music_basic_id */ 14:
                    message.musicBasicId = reader.uint32();
                    break;
                case /* uint32 score */ 2:
                    message.score = reader.uint32();
                    break;
                case /* uint32 combo */ 10:
                    message.combo = reader.uint32();
                    break;
                case /* uint32 correct_hit */ 8:
                    message.correctHit = reader.uint32();
                    break;
                case /* uint64 music_share_id */ 11:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* bool KJNDJLBOJLM = 4 [json_name = "KJNDJLBOJLM"];*/ 4:
                    message.kJNDJLBOJLM = reader.bool();
                    break;
                case /* uint32 FBELCAFFGIJ = 3 [json_name = "FBELCAFFGIJ"];*/ 3:
                    message.fBELCAFFGIJ = reader.uint32();
                    break;
                case /* uint32 OOFMAKIDFOL = 15 [json_name = "OOFMAKIDFOL"];*/ 15:
                    message.oOFMAKIDFOL = reader.uint32();
                    break;
                case /* uint32 HJPDEIMECHB = 1 [json_name = "HJPDEIMECHB"];*/ 1:
                    message.hJPDEIMECHB = reader.uint32();
                    break;
                case /* repeated uint32 MNCMGANHCFI = 13 [json_name = "MNCMGANHCFI"];*/ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mNCMGANHCFI.push(reader.uint32());
                    else
                        message.mNCMGANHCFI.push(reader.uint32());
                    break;
                case /* uint32 max_combo */ 9:
                    message.maxCombo = reader.uint32();
                    break;
                case /* uint32 JJADNMELLAH = 1975 [json_name = "JJADNMELLAH"];*/ 1975:
                    message.jJADNMELLAH = reader.uint32();
                    break;
                case /* repeated uint32 EIAGEEFABPO = 1171 [json_name = "EIAGEEFABPO"];*/ 1171:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eIAGEEFABPO.push(reader.uint32());
                    else
                        message.eIAGEEFABPO.push(reader.uint32());
                    break;
                case /* uint32 CPIFLFBHNJP = 1104 [json_name = "CPIFLFBHNJP"];*/ 1104:
                    message.cPIFLFBHNJP = reader.uint32();
                    break;
                case /* bool success */ 998:
                    message.success = reader.bool();
                    break;
                case /* uint32 GGHBOMGJGFP = 268 [json_name = "GGHBOMGJGFP"];*/ 268:
                    message.gGHBOMGJGFP = reader.uint32();
                    break;
                case /* bool PFHCIHKCJFJ = 238 [json_name = "PFHCIHKCJFJ"];*/ 238:
                    message.pFHCIHKCJFJ = reader.bool();
                    break;
                case /* float speed */ 887:
                    message.speed = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameSettleReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 music_basic_id = 14; */
        if (message.musicBasicId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.musicBasicId);
        /* uint32 score = 2; */
        if (message.score !== 0)
            writer.tag(2, WireType.Varint).uint32(message.score);
        /* uint32 combo = 10; */
        if (message.combo !== 0)
            writer.tag(10, WireType.Varint).uint32(message.combo);
        /* uint32 correct_hit = 8; */
        if (message.correctHit !== 0)
            writer.tag(8, WireType.Varint).uint32(message.correctHit);
        /* uint64 music_share_id = 11; */
        if (message.musicShareId !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.musicShareId);
        /* bool KJNDJLBOJLM = 4 [json_name = "KJNDJLBOJLM"]; */
        if (message.kJNDJLBOJLM !== false)
            writer.tag(4, WireType.Varint).bool(message.kJNDJLBOJLM);
        /* uint32 FBELCAFFGIJ = 3 [json_name = "FBELCAFFGIJ"]; */
        if (message.fBELCAFFGIJ !== 0)
            writer.tag(3, WireType.Varint).uint32(message.fBELCAFFGIJ);
        /* uint32 OOFMAKIDFOL = 15 [json_name = "OOFMAKIDFOL"]; */
        if (message.oOFMAKIDFOL !== 0)
            writer.tag(15, WireType.Varint).uint32(message.oOFMAKIDFOL);
        /* uint32 HJPDEIMECHB = 1 [json_name = "HJPDEIMECHB"]; */
        if (message.hJPDEIMECHB !== 0)
            writer.tag(1, WireType.Varint).uint32(message.hJPDEIMECHB);
        /* repeated uint32 MNCMGANHCFI = 13 [json_name = "MNCMGANHCFI"]; */
        if (message.mNCMGANHCFI.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mNCMGANHCFI.length; i++)
                writer.uint32(message.mNCMGANHCFI[i]);
            writer.join();
        }
        /* uint32 max_combo = 9; */
        if (message.maxCombo !== 0)
            writer.tag(9, WireType.Varint).uint32(message.maxCombo);
        /* uint32 JJADNMELLAH = 1975 [json_name = "JJADNMELLAH"]; */
        if (message.jJADNMELLAH !== 0)
            writer.tag(1975, WireType.Varint).uint32(message.jJADNMELLAH);
        /* repeated uint32 EIAGEEFABPO = 1171 [json_name = "EIAGEEFABPO"]; */
        if (message.eIAGEEFABPO.length) {
            writer.tag(1171, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.eIAGEEFABPO.length; i++)
                writer.uint32(message.eIAGEEFABPO[i]);
            writer.join();
        }
        /* uint32 CPIFLFBHNJP = 1104 [json_name = "CPIFLFBHNJP"]; */
        if (message.cPIFLFBHNJP !== 0)
            writer.tag(1104, WireType.Varint).uint32(message.cPIFLFBHNJP);
        /* bool success = 998; */
        if (message.success !== false)
            writer.tag(998, WireType.Varint).bool(message.success);
        /* uint32 GGHBOMGJGFP = 268 [json_name = "GGHBOMGJGFP"]; */
        if (message.gGHBOMGJGFP !== 0)
            writer.tag(268, WireType.Varint).uint32(message.gGHBOMGJGFP);
        /* bool PFHCIHKCJFJ = 238 [json_name = "PFHCIHKCJFJ"]; */
        if (message.pFHCIHKCJFJ !== false)
            writer.tag(238, WireType.Varint).bool(message.pFHCIHKCJFJ);
        /* float speed = 887; */
        if (message.speed !== 0)
            writer.tag(887, WireType.Bit32).float(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameSettleReq
 */
export const MusicGameSettleReq = new MusicGameSettleReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameSettleRsp$Type extends MessageType<MusicGameSettleRsp> {
    constructor() {
        super("MusicGameSettleRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "music_basic_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "is_unlock_next_level", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_new_record", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameSettleRsp>): MusicGameSettleRsp {
        const message = { retcode: 0, musicBasicId: 0, isUnlockNextLevel: false, isNewRecord: false, musicShareId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameSettleRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameSettleRsp): MusicGameSettleRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 music_basic_id */ 9:
                    message.musicBasicId = reader.uint32();
                    break;
                case /* bool is_unlock_next_level */ 1:
                    message.isUnlockNextLevel = reader.bool();
                    break;
                case /* bool is_new_record */ 3:
                    message.isNewRecord = reader.bool();
                    break;
                case /* uint64 music_share_id */ 11:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameSettleRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 music_basic_id = 9; */
        if (message.musicBasicId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.musicBasicId);
        /* bool is_unlock_next_level = 1; */
        if (message.isUnlockNextLevel !== false)
            writer.tag(1, WireType.Varint).bool(message.isUnlockNextLevel);
        /* bool is_new_record = 3; */
        if (message.isNewRecord !== false)
            writer.tag(3, WireType.Varint).bool(message.isNewRecord);
        /* uint64 music_share_id = 11; */
        if (message.musicShareId !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.musicShareId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameSettleRsp
 */
export const MusicGameSettleRsp = new MusicGameSettleRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameStartReq$Type extends MessageType<MusicGameStartReq> {
    constructor() {
        super("MusicGameStartReq", [
            { no: 10, name: "music_basic_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "KJNDJLBOJLM", kind: "scalar", jsonName: "KJNDJLBOJLM", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameStartReq>): MusicGameStartReq {
        const message = { musicBasicId: 0, musicShareId: 0n, kJNDJLBOJLM: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameStartReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameStartReq): MusicGameStartReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 music_basic_id */ 10:
                    message.musicBasicId = reader.uint32();
                    break;
                case /* uint64 music_share_id */ 8:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                case /* bool KJNDJLBOJLM = 5 [json_name = "KJNDJLBOJLM"];*/ 5:
                    message.kJNDJLBOJLM = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameStartReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 music_basic_id = 10; */
        if (message.musicBasicId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.musicBasicId);
        /* uint64 music_share_id = 8; */
        if (message.musicShareId !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.musicShareId);
        /* bool KJNDJLBOJLM = 5 [json_name = "KJNDJLBOJLM"]; */
        if (message.kJNDJLBOJLM !== false)
            writer.tag(5, WireType.Varint).bool(message.kJNDJLBOJLM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameStartReq
 */
export const MusicGameStartReq = new MusicGameStartReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameStartRsp$Type extends MessageType<MusicGameStartRsp> {
    constructor() {
        super("MusicGameStartRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "music_basic_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "music_share_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameStartRsp>): MusicGameStartRsp {
        const message = { retcode: 0, musicBasicId: 0, musicShareId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameStartRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameStartRsp): MusicGameStartRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 music_basic_id */ 14:
                    message.musicBasicId = reader.uint32();
                    break;
                case /* uint64 music_share_id */ 12:
                    message.musicShareId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameStartRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint32 music_basic_id = 14; */
        if (message.musicBasicId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.musicBasicId);
        /* uint64 music_share_id = 12; */
        if (message.musicShareId !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.musicShareId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameStartRsp
 */
export const MusicGameStartRsp = new MusicGameStartRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameStartToPlayOthersBeatmapReq$Type extends MessageType<MusicGameStartToPlayOthersBeatmapReq> {
    constructor() {
        super("MusicGameStartToPlayOthersBeatmapReq", [
            { no: 12, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] }
        ]);
    }
    create(value?: PartialMessage<MusicGameStartToPlayOthersBeatmapReq>): MusicGameStartToPlayOthersBeatmapReq {
        const message = { unknownEnum1: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameStartToPlayOthersBeatmapReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameStartToPlayOthersBeatmapReq): MusicGameStartToPlayOthersBeatmapReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* MusicGameUnknown1Enum unknown_enum1 */ 12:
                    message.unknownEnum1 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameStartToPlayOthersBeatmapReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* MusicGameUnknown1Enum unknown_enum1 = 12; */
        if (message.unknownEnum1 !== 0)
            writer.tag(12, WireType.Varint).int32(message.unknownEnum1);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameStartToPlayOthersBeatmapReq
 */
export const MusicGameStartToPlayOthersBeatmapReq = new MusicGameStartToPlayOthersBeatmapReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MusicGameStartToPlayOthersBeatmapRsp$Type extends MessageType<MusicGameStartToPlayOthersBeatmapRsp> {
    constructor() {
        super("MusicGameStartToPlayOthersBeatmapRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "unknown_enum1", kind: "enum", T: () => ["MusicGameUnknown1Enum", MusicGameUnknown1Enum] },
            { no: 6, name: "AMNODOLNOIM", kind: "scalar", jsonName: "AMNODOLNOIM", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MusicGameStartToPlayOthersBeatmapRsp>): MusicGameStartToPlayOthersBeatmapRsp {
        const message = { retcode: 0, unknownEnum1: 0, aMNODOLNOIM: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MusicGameStartToPlayOthersBeatmapRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MusicGameStartToPlayOthersBeatmapRsp): MusicGameStartToPlayOthersBeatmapRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* MusicGameUnknown1Enum unknown_enum1 */ 11:
                    message.unknownEnum1 = reader.int32();
                    break;
                case /* repeated uint64 AMNODOLNOIM = 6 [json_name = "AMNODOLNOIM"];*/ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.aMNODOLNOIM.push(reader.uint64().toBigInt());
                    else
                        message.aMNODOLNOIM.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MusicGameStartToPlayOthersBeatmapRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* MusicGameUnknown1Enum unknown_enum1 = 11; */
        if (message.unknownEnum1 !== 0)
            writer.tag(11, WireType.Varint).int32(message.unknownEnum1);
        /* repeated uint64 AMNODOLNOIM = 6 [json_name = "AMNODOLNOIM"]; */
        if (message.aMNODOLNOIM.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.aMNODOLNOIM.length; i++)
                writer.uint64(message.aMNODOLNOIM[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MusicGameStartToPlayOthersBeatmapRsp
 */
export const MusicGameStartToPlayOthersBeatmapRsp = new MusicGameStartToPlayOthersBeatmapRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NpcTalkReq$Type extends MessageType<NpcTalkReq> {
    constructor() {
        super("NpcTalkReq", [
            { no: 5, name: "npc_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "talk_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<NpcTalkReq>): NpcTalkReq {
        const message = { npcEntityId: 0, talkId: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NpcTalkReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NpcTalkReq): NpcTalkReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 npc_entity_id */ 5:
                    message.npcEntityId = reader.uint32();
                    break;
                case /* uint32 talk_id */ 7:
                    message.talkId = reader.uint32();
                    break;
                case /* uint32 entity_id */ 6:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NpcTalkReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 npc_entity_id = 5; */
        if (message.npcEntityId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.npcEntityId);
        /* uint32 talk_id = 7; */
        if (message.talkId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.talkId);
        /* uint32 entity_id = 6; */
        if (message.entityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NpcTalkReq
 */
export const NpcTalkReq = new NpcTalkReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NpcTalkRsp$Type extends MessageType<NpcTalkRsp> {
    constructor() {
        super("NpcTalkRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "npc_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "cur_talk_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<NpcTalkRsp>): NpcTalkRsp {
        const message = { retcode: 0, npcEntityId: 0, curTalkId: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NpcTalkRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NpcTalkRsp): NpcTalkRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 npc_entity_id */ 9:
                    message.npcEntityId = reader.uint32();
                    break;
                case /* uint32 cur_talk_id */ 6:
                    message.curTalkId = reader.uint32();
                    break;
                case /* uint32 entity_id */ 7:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NpcTalkRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint32 npc_entity_id = 9; */
        if (message.npcEntityId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.npcEntityId);
        /* uint32 cur_talk_id = 6; */
        if (message.curTalkId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.curTalkId);
        /* uint32 entity_id = 7; */
        if (message.entityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NpcTalkRsp
 */
export const NpcTalkRsp = new NpcTalkRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OfferingInfo$Type extends MessageType<OfferingInfo> {
    constructor() {
        super("OfferingInfo", [
            { no: 1, name: "offering_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OfferingInfo>): OfferingInfo {
        const message = { offeringId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OfferingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OfferingInfo): OfferingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 offering_id */ 1:
                    message.offeringId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OfferingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 offering_id = 1; */
        if (message.offeringId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.offeringId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OfferingInfo
 */
export const OfferingInfo = new OfferingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneoffGatherPointDetectorData$Type extends MessageType<OneoffGatherPointDetectorData> {
    constructor() {
        super("OneoffGatherPointDetectorData", [
            { no: 1, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_all_collected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_hint_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "hint_center_pos", kind: "message", T: () => Vector },
            { no: 5, name: "hint_radius", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OneoffGatherPointDetectorData>): OneoffGatherPointDetectorData {
        const message = { materialId: 0, isAllCollected: false, isHintValid: false, hintRadius: 0, groupId: 0, configId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OneoffGatherPointDetectorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneoffGatherPointDetectorData): OneoffGatherPointDetectorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 1:
                    message.materialId = reader.uint32();
                    break;
                case /* bool is_all_collected */ 2:
                    message.isAllCollected = reader.bool();
                    break;
                case /* bool is_hint_valid */ 3:
                    message.isHintValid = reader.bool();
                    break;
                case /* Vector hint_center_pos */ 4:
                    message.hintCenterPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hintCenterPos);
                    break;
                case /* uint32 hint_radius */ 5:
                    message.hintRadius = reader.uint32();
                    break;
                case /* uint32 group_id */ 6:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 config_id */ 7:
                    message.configId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneoffGatherPointDetectorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 1; */
        if (message.materialId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.materialId);
        /* bool is_all_collected = 2; */
        if (message.isAllCollected !== false)
            writer.tag(2, WireType.Varint).bool(message.isAllCollected);
        /* bool is_hint_valid = 3; */
        if (message.isHintValid !== false)
            writer.tag(3, WireType.Varint).bool(message.isHintValid);
        /* Vector hint_center_pos = 4; */
        if (message.hintCenterPos)
            Vector.internalBinaryWrite(message.hintCenterPos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 hint_radius = 5; */
        if (message.hintRadius !== 0)
            writer.tag(5, WireType.Varint).uint32(message.hintRadius);
        /* uint32 group_id = 6; */
        if (message.groupId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.groupId);
        /* uint32 config_id = 7; */
        if (message.configId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.configId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OneoffGatherPointDetectorData
 */
export const OneoffGatherPointDetectorData = new OneoffGatherPointDetectorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneoffGatherPointDetectorDataNotify$Type extends MessageType<OneoffGatherPointDetectorDataNotify> {
    constructor() {
        super("OneoffGatherPointDetectorDataNotify", [
            { no: 6, name: "oneoff_gather_point_detector_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OneoffGatherPointDetectorData }
        ]);
    }
    create(value?: PartialMessage<OneoffGatherPointDetectorDataNotify>): OneoffGatherPointDetectorDataNotify {
        const message = { oneoffGatherPointDetectorDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OneoffGatherPointDetectorDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneoffGatherPointDetectorDataNotify): OneoffGatherPointDetectorDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list */ 6:
                    message.oneoffGatherPointDetectorDataList.push(OneoffGatherPointDetectorData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneoffGatherPointDetectorDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated OneoffGatherPointDetectorData oneoff_gather_point_detector_data_list = 6; */
        for (let i = 0; i < message.oneoffGatherPointDetectorDataList.length; i++)
            OneoffGatherPointDetectorData.internalBinaryWrite(message.oneoffGatherPointDetectorDataList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OneoffGatherPointDetectorDataNotify
 */
export const OneoffGatherPointDetectorDataNotify = new OneoffGatherPointDetectorDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneofGatherPointDetectorData$Type extends MessageType<OneofGatherPointDetectorData> {
    constructor() {
        super("OneofGatherPointDetectorData", [
            { no: 7, name: "hint_center_pos", kind: "message", T: () => Vector },
            { no: 14, name: "hint_radius", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_all_collected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "is_hint_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OneofGatherPointDetectorData>): OneofGatherPointDetectorData {
        const message = { hintRadius: 0, materialId: 0, configId: 0, groupId: 0, isAllCollected: false, isHintValid: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OneofGatherPointDetectorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneofGatherPointDetectorData): OneofGatherPointDetectorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector hint_center_pos */ 7:
                    message.hintCenterPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hintCenterPos);
                    break;
                case /* uint32 hint_radius */ 14:
                    message.hintRadius = reader.uint32();
                    break;
                case /* uint32 material_id */ 10:
                    message.materialId = reader.uint32();
                    break;
                case /* uint32 config_id */ 6:
                    message.configId = reader.uint32();
                    break;
                case /* uint32 group_id */ 13:
                    message.groupId = reader.uint32();
                    break;
                case /* bool is_all_collected */ 4:
                    message.isAllCollected = reader.bool();
                    break;
                case /* bool is_hint_valid */ 15:
                    message.isHintValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneofGatherPointDetectorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector hint_center_pos = 7; */
        if (message.hintCenterPos)
            Vector.internalBinaryWrite(message.hintCenterPos, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 hint_radius = 14; */
        if (message.hintRadius !== 0)
            writer.tag(14, WireType.Varint).uint32(message.hintRadius);
        /* uint32 material_id = 10; */
        if (message.materialId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.materialId);
        /* uint32 config_id = 6; */
        if (message.configId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.configId);
        /* uint32 group_id = 13; */
        if (message.groupId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.groupId);
        /* bool is_all_collected = 4; */
        if (message.isAllCollected !== false)
            writer.tag(4, WireType.Varint).bool(message.isAllCollected);
        /* bool is_hint_valid = 15; */
        if (message.isHintValid !== false)
            writer.tag(15, WireType.Varint).bool(message.isHintValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OneofGatherPointDetectorData
 */
export const OneofGatherPointDetectorData = new OneofGatherPointDetectorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneofGatherPointDetectorDataNotify$Type extends MessageType<OneofGatherPointDetectorDataNotify> {
    constructor() {
        super("OneofGatherPointDetectorDataNotify", [
            { no: 3, name: "oneof_gather_point_detector_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OneofGatherPointDetectorData }
        ]);
    }
    create(value?: PartialMessage<OneofGatherPointDetectorDataNotify>): OneofGatherPointDetectorDataNotify {
        const message = { oneofGatherPointDetectorDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OneofGatherPointDetectorDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneofGatherPointDetectorDataNotify): OneofGatherPointDetectorDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated OneofGatherPointDetectorData oneof_gather_point_detector_data_list */ 3:
                    message.oneofGatherPointDetectorDataList.push(OneofGatherPointDetectorData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneofGatherPointDetectorDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated OneofGatherPointDetectorData oneof_gather_point_detector_data_list = 3; */
        for (let i = 0; i < message.oneofGatherPointDetectorDataList.length; i++)
            OneofGatherPointDetectorData.internalBinaryWrite(message.oneofGatherPointDetectorDataList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OneofGatherPointDetectorDataNotify
 */
export const OneofGatherPointDetectorDataNotify = new OneofGatherPointDetectorDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnlinePlayerInfo$Type extends MessageType<OnlinePlayerInfo> {
    constructor() {
        super("OnlinePlayerInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "mp_setting_type", kind: "enum", T: () => ["MpSettingType", MpSettingType, "MP_SETTING_TYPE_"] },
            { no: 6, name: "cur_player_num_in_world", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "world_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "online_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "blacklist_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "profile_picture", kind: "message", T: () => ProfilePicture },
            { no: 13, name: "psn_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OnlinePlayerInfo>): OnlinePlayerInfo {
        const message = { uid: 0, nickname: "", playerLevel: 0, avatarId: 0, mpSettingType: 0, curPlayerNumInWorld: 0, worldLevel: 0, onlineId: "", nameCardId: 0, blacklistUidList: [], signature: "", psnId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OnlinePlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnlinePlayerInfo): OnlinePlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* string nickname */ 2:
                    message.nickname = reader.string();
                    break;
                case /* uint32 player_level */ 3:
                    message.playerLevel = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 4:
                    message.avatarId = reader.uint32();
                    break;
                case /* MpSettingType mp_setting_type */ 5:
                    message.mpSettingType = reader.int32();
                    break;
                case /* uint32 cur_player_num_in_world */ 6:
                    message.curPlayerNumInWorld = reader.uint32();
                    break;
                case /* uint32 world_level */ 7:
                    message.worldLevel = reader.uint32();
                    break;
                case /* string online_id */ 8:
                    message.onlineId = reader.string();
                    break;
                case /* uint32 name_card_id */ 9:
                    message.nameCardId = reader.uint32();
                    break;
                case /* repeated uint32 blacklist_uid_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blacklistUidList.push(reader.uint32());
                    else
                        message.blacklistUidList.push(reader.uint32());
                    break;
                case /* string signature */ 11:
                    message.signature = reader.string();
                    break;
                case /* ProfilePicture profile_picture */ 12:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                case /* string psn_id */ 13:
                    message.psnId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnlinePlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* string nickname = 2; */
        if (message.nickname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nickname);
        /* uint32 player_level = 3; */
        if (message.playerLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.playerLevel);
        /* uint32 avatar_id = 4; */
        if (message.avatarId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.avatarId);
        /* MpSettingType mp_setting_type = 5; */
        if (message.mpSettingType !== 0)
            writer.tag(5, WireType.Varint).int32(message.mpSettingType);
        /* uint32 cur_player_num_in_world = 6; */
        if (message.curPlayerNumInWorld !== 0)
            writer.tag(6, WireType.Varint).uint32(message.curPlayerNumInWorld);
        /* uint32 world_level = 7; */
        if (message.worldLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.worldLevel);
        /* string online_id = 8; */
        if (message.onlineId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.onlineId);
        /* uint32 name_card_id = 9; */
        if (message.nameCardId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.nameCardId);
        /* repeated uint32 blacklist_uid_list = 10; */
        if (message.blacklistUidList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.blacklistUidList.length; i++)
                writer.uint32(message.blacklistUidList[i]);
            writer.join();
        }
        /* string signature = 11; */
        if (message.signature !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.signature);
        /* ProfilePicture profile_picture = 12; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string psn_id = 13; */
        if (message.psnId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.psnId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OnlinePlayerInfo
 */
export const OnlinePlayerInfo = new OnlinePlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenStateUpdateNotify$Type extends MessageType<OpenStateUpdateNotify> {
    constructor() {
        super("OpenStateUpdateNotify", [
            { no: 12, name: "open_state_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<OpenStateUpdateNotify>): OpenStateUpdateNotify {
        const message = { openStateMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenStateUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenStateUpdateNotify): OpenStateUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> open_state_map */ 12:
                    this.binaryReadMap12(message.openStateMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap12(map: OpenStateUpdateNotify["openStateMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof OpenStateUpdateNotify["openStateMap"] | undefined, val: OpenStateUpdateNotify["openStateMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field OpenStateUpdateNotify.open_state_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: OpenStateUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> open_state_map = 12; */
        for (let k of Object.keys(message.openStateMap))
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.openStateMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OpenStateUpdateNotify
 */
export const OpenStateUpdateNotify = new OpenStateUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PacketHead$Type extends MessageType<PacketHead> {
    constructor() {
        super("PacketHead", [
            { no: 3, name: "client_sequence_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PacketHead>): PacketHead {
        const message = { clientSequenceId: 0, timestamp: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PacketHead>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PacketHead): PacketHead {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 client_sequence_id */ 3:
                    message.clientSequenceId = reader.uint32();
                    break;
                case /* uint64 timestamp */ 6:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PacketHead, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 client_sequence_id = 3; */
        if (message.clientSequenceId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.clientSequenceId);
        /* uint64 timestamp = 6; */
        if (message.timestamp !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PacketHead
 */
export const PacketHead = new PacketHead$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParamList$Type extends MessageType<ParamList> {
    constructor() {
        super("ParamList", [
            { no: 1, name: "param_list_", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ParamList>): ParamList {
        const message = { paramList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParamList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParamList): ParamList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 param_list_ */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.uint32());
                    else
                        message.paramList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParamList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 param_list_ = 1; */
        if (message.paramList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.uint32(message.paramList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ParamList
 */
export const ParamList = new ParamList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParentQuest$Type extends MessageType<ParentQuest> {
    constructor() {
        super("ParentQuest", [
            { no: 1, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "child_quest_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChildQuest },
            { no: 3, name: "is_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_random", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "random_info", kind: "message", T: () => ParentQuestRandomInfo },
            { no: 6, name: "quest_var", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "parent_quest_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "quest_var_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "time_var_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<ParentQuest>): ParentQuest {
        const message = { parentQuestId: 0, childQuestList: [], isFinished: false, isRandom: false, questVar: [], parentQuestState: 0, questVarSeq: 0, timeVarMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParentQuest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParentQuest): ParentQuest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 parent_quest_id */ 1:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* repeated ChildQuest child_quest_list */ 2:
                    message.childQuestList.push(ChildQuest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_finished */ 3:
                    message.isFinished = reader.bool();
                    break;
                case /* bool is_random */ 4:
                    message.isRandom = reader.bool();
                    break;
                case /* ParentQuestRandomInfo random_info */ 5:
                    message.randomInfo = ParentQuestRandomInfo.internalBinaryRead(reader, reader.uint32(), options, message.randomInfo);
                    break;
                case /* repeated int32 quest_var */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.questVar.push(reader.int32());
                    else
                        message.questVar.push(reader.int32());
                    break;
                case /* uint32 parent_quest_state */ 7:
                    message.parentQuestState = reader.uint32();
                    break;
                case /* uint32 quest_var_seq */ 8:
                    message.questVarSeq = reader.uint32();
                    break;
                case /* map<uint32, uint32> time_var_map */ 9:
                    this.binaryReadMap9(message.timeVarMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: ParentQuest["timeVarMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ParentQuest["timeVarMap"] | undefined, val: ParentQuest["timeVarMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ParentQuest.time_var_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: ParentQuest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 parent_quest_id = 1; */
        if (message.parentQuestId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.parentQuestId);
        /* repeated ChildQuest child_quest_list = 2; */
        for (let i = 0; i < message.childQuestList.length; i++)
            ChildQuest.internalBinaryWrite(message.childQuestList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool is_finished = 3; */
        if (message.isFinished !== false)
            writer.tag(3, WireType.Varint).bool(message.isFinished);
        /* bool is_random = 4; */
        if (message.isRandom !== false)
            writer.tag(4, WireType.Varint).bool(message.isRandom);
        /* ParentQuestRandomInfo random_info = 5; */
        if (message.randomInfo)
            ParentQuestRandomInfo.internalBinaryWrite(message.randomInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 quest_var = 6; */
        if (message.questVar.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.questVar.length; i++)
                writer.int32(message.questVar[i]);
            writer.join();
        }
        /* uint32 parent_quest_state = 7; */
        if (message.parentQuestState !== 0)
            writer.tag(7, WireType.Varint).uint32(message.parentQuestState);
        /* uint32 quest_var_seq = 8; */
        if (message.questVarSeq !== 0)
            writer.tag(8, WireType.Varint).uint32(message.questVarSeq);
        /* map<uint32, uint32> time_var_map = 9; */
        for (let k of Object.keys(message.timeVarMap))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.timeVarMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ParentQuest
 */
export const ParentQuest = new ParentQuest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParentQuestRandomInfo$Type extends MessageType<ParentQuestRandomInfo> {
    constructor() {
        super("ParentQuestRandomInfo", [
            { no: 1, name: "entrance_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "template_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "factor_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ParentQuestRandomInfo>): ParentQuestRandomInfo {
        const message = { entranceId: 0, templateId: 0, factorList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParentQuestRandomInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParentQuestRandomInfo): ParentQuestRandomInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entrance_id */ 1:
                    message.entranceId = reader.uint32();
                    break;
                case /* uint32 template_id */ 2:
                    message.templateId = reader.uint32();
                    break;
                case /* repeated uint32 factor_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.factorList.push(reader.uint32());
                    else
                        message.factorList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParentQuestRandomInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entrance_id = 1; */
        if (message.entranceId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entranceId);
        /* uint32 template_id = 2; */
        if (message.templateId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.templateId);
        /* repeated uint32 factor_list = 3; */
        if (message.factorList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.factorList.length; i++)
                writer.uint32(message.factorList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ParentQuestRandomInfo
 */
export const ParentQuestRandomInfo = new ParentQuestRandomInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PersonalLineAllDataReq$Type extends MessageType<PersonalLineAllDataReq> {
    constructor() {
        super("PersonalLineAllDataReq", []);
    }
    create(value?: PartialMessage<PersonalLineAllDataReq>): PersonalLineAllDataReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PersonalLineAllDataReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PersonalLineAllDataReq): PersonalLineAllDataReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PersonalLineAllDataReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PersonalLineAllDataReq
 */
export const PersonalLineAllDataReq = new PersonalLineAllDataReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PersonalLineAllDataRsp$Type extends MessageType<PersonalLineAllDataRsp> {
    constructor() {
        super("PersonalLineAllDataRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "cur_finished_daily_task_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "legendary_key_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "ongoing_personal_line_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "can_be_unlocked_personal_line_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "locked_personal_line_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LockedPersonallineData }
        ]);
    }
    create(value?: PartialMessage<PersonalLineAllDataRsp>): PersonalLineAllDataRsp {
        const message = { retcode: 0, curFinishedDailyTaskCount: 0, legendaryKeyCount: 0, ongoingPersonalLineList: [], canBeUnlockedPersonalLineList: [], lockedPersonalLineList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PersonalLineAllDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PersonalLineAllDataRsp): PersonalLineAllDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 cur_finished_daily_task_count */ 4:
                    message.curFinishedDailyTaskCount = reader.uint32();
                    break;
                case /* uint32 legendary_key_count */ 3:
                    message.legendaryKeyCount = reader.uint32();
                    break;
                case /* repeated uint32 ongoing_personal_line_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ongoingPersonalLineList.push(reader.uint32());
                    else
                        message.ongoingPersonalLineList.push(reader.uint32());
                    break;
                case /* repeated uint32 can_be_unlocked_personal_line_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.canBeUnlockedPersonalLineList.push(reader.uint32());
                    else
                        message.canBeUnlockedPersonalLineList.push(reader.uint32());
                    break;
                case /* repeated LockedPersonallineData locked_personal_line_list */ 14:
                    message.lockedPersonalLineList.push(LockedPersonallineData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PersonalLineAllDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* uint32 cur_finished_daily_task_count = 4; */
        if (message.curFinishedDailyTaskCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.curFinishedDailyTaskCount);
        /* uint32 legendary_key_count = 3; */
        if (message.legendaryKeyCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.legendaryKeyCount);
        /* repeated uint32 ongoing_personal_line_list = 13; */
        if (message.ongoingPersonalLineList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ongoingPersonalLineList.length; i++)
                writer.uint32(message.ongoingPersonalLineList[i]);
            writer.join();
        }
        /* repeated uint32 can_be_unlocked_personal_line_list = 12; */
        if (message.canBeUnlockedPersonalLineList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.canBeUnlockedPersonalLineList.length; i++)
                writer.uint32(message.canBeUnlockedPersonalLineList[i]);
            writer.join();
        }
        /* repeated LockedPersonallineData locked_personal_line_list = 14; */
        for (let i = 0; i < message.lockedPersonalLineList.length; i++)
            LockedPersonallineData.internalBinaryWrite(message.lockedPersonalLineList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PersonalLineAllDataRsp
 */
export const PersonalLineAllDataRsp = new PersonalLineAllDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PersonalSceneJumpReq$Type extends MessageType<PersonalSceneJumpReq> {
    constructor() {
        super("PersonalSceneJumpReq", [
            { no: 2, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PersonalSceneJumpReq>): PersonalSceneJumpReq {
        const message = { pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PersonalSceneJumpReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PersonalSceneJumpReq): PersonalSceneJumpReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 point_id */ 2:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PersonalSceneJumpReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 point_id = 2; */
        if (message.pointId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PersonalSceneJumpReq
 */
export const PersonalSceneJumpReq = new PersonalSceneJumpReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PersonalSceneJumpRsp$Type extends MessageType<PersonalSceneJumpRsp> {
    constructor() {
        super("PersonalSceneJumpRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dest_scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "dest_pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<PersonalSceneJumpRsp>): PersonalSceneJumpRsp {
        const message = { retcode: 0, destSceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PersonalSceneJumpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PersonalSceneJumpRsp): PersonalSceneJumpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 dest_scene_id */ 2:
                    message.destSceneId = reader.uint32();
                    break;
                case /* Vector dest_pos */ 6:
                    message.destPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.destPos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PersonalSceneJumpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 dest_scene_id = 2; */
        if (message.destSceneId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.destSceneId);
        /* Vector dest_pos = 6; */
        if (message.destPos)
            Vector.internalBinaryWrite(message.destPos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PersonalSceneJumpRsp
 */
export const PersonalSceneJumpRsp = new PersonalSceneJumpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingReq$Type extends MessageType<PingReq> {
    constructor() {
        super("PingReq", [
            { no: 2, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "client_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "sc_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 15, name: "ue_time", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "total_tick_time", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PingReq>): PingReq {
        const message = { seq: 0, clientTime: 0, scData: new Uint8Array(0), ueTime: 0, totalTickTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingReq): PingReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seq */ 2:
                    message.seq = reader.uint32();
                    break;
                case /* uint32 client_time */ 14:
                    message.clientTime = reader.uint32();
                    break;
                case /* bytes sc_data */ 11:
                    message.scData = reader.bytes();
                    break;
                case /* float ue_time */ 15:
                    message.ueTime = reader.float();
                    break;
                case /* double total_tick_time */ 12:
                    message.totalTickTime = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seq = 2; */
        if (message.seq !== 0)
            writer.tag(2, WireType.Varint).uint32(message.seq);
        /* uint32 client_time = 14; */
        if (message.clientTime !== 0)
            writer.tag(14, WireType.Varint).uint32(message.clientTime);
        /* bytes sc_data = 11; */
        if (message.scData.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.scData);
        /* float ue_time = 15; */
        if (message.ueTime !== 0)
            writer.tag(15, WireType.Bit32).float(message.ueTime);
        /* double total_tick_time = 12; */
        if (message.totalTickTime !== 0)
            writer.tag(12, WireType.Bit64).double(message.totalTickTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingReq
 */
export const PingReq = new PingReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingRsp$Type extends MessageType<PingRsp> {
    constructor() {
        super("PingRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "client_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PingRsp>): PingRsp {
        const message = { retcode: 0, seq: 0, clientTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingRsp): PingRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 seq */ 4:
                    message.seq = reader.uint32();
                    break;
                case /* uint32 client_time */ 8:
                    message.clientTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 seq = 4; */
        if (message.seq !== 0)
            writer.tag(4, WireType.Varint).uint32(message.seq);
        /* uint32 client_time = 8; */
        if (message.clientTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.clientTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingRsp
 */
export const PingRsp = new PingRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlatformInfo$Type extends MessageType<PlatformInfo> {
    constructor() {
        super("PlatformInfo", [
            { no: 1, name: "route_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "start_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_route_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "start_pos", kind: "message", T: () => Vector },
            { no: 8, name: "is_started", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "start_rot", kind: "message", T: () => MathQuaternion },
            { no: 10, name: "stop_scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "pos_offset", kind: "message", T: () => Vector },
            { no: 12, name: "rot_offset", kind: "message", T: () => MathQuaternion },
            { no: 13, name: "moving_platform_type", kind: "enum", T: () => ["MovingPlatformType", MovingPlatformType, "MOVING_PLATFORM_TYPE_"] },
            { no: 14, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "route", kind: "message", T: () => Route },
            { no: 16, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlatformInfo>): PlatformInfo {
        const message = { routeId: 0, startIndex: 0, startRouteTime: 0, startSceneTime: 0, isStarted: false, stopSceneTime: 0, movingPlatformType: 0, isActive: false, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlatformInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlatformInfo): PlatformInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 route_id */ 1:
                    message.routeId = reader.uint32();
                    break;
                case /* int32 start_index */ 2:
                    message.startIndex = reader.int32();
                    break;
                case /* uint32 start_route_time */ 3:
                    message.startRouteTime = reader.uint32();
                    break;
                case /* uint32 start_scene_time */ 4:
                    message.startSceneTime = reader.uint32();
                    break;
                case /* Vector start_pos */ 7:
                    message.startPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.startPos);
                    break;
                case /* bool is_started */ 8:
                    message.isStarted = reader.bool();
                    break;
                case /* MathQuaternion start_rot */ 9:
                    message.startRot = MathQuaternion.internalBinaryRead(reader, reader.uint32(), options, message.startRot);
                    break;
                case /* uint32 stop_scene_time */ 10:
                    message.stopSceneTime = reader.uint32();
                    break;
                case /* Vector pos_offset */ 11:
                    message.posOffset = Vector.internalBinaryRead(reader, reader.uint32(), options, message.posOffset);
                    break;
                case /* MathQuaternion rot_offset */ 12:
                    message.rotOffset = MathQuaternion.internalBinaryRead(reader, reader.uint32(), options, message.rotOffset);
                    break;
                case /* MovingPlatformType moving_platform_type */ 13:
                    message.movingPlatformType = reader.int32();
                    break;
                case /* bool is_active */ 14:
                    message.isActive = reader.bool();
                    break;
                case /* Route route */ 15:
                    message.route = Route.internalBinaryRead(reader, reader.uint32(), options, message.route);
                    break;
                case /* uint32 point_id */ 16:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlatformInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 route_id = 1; */
        if (message.routeId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.routeId);
        /* int32 start_index = 2; */
        if (message.startIndex !== 0)
            writer.tag(2, WireType.Varint).int32(message.startIndex);
        /* uint32 start_route_time = 3; */
        if (message.startRouteTime !== 0)
            writer.tag(3, WireType.Varint).uint32(message.startRouteTime);
        /* uint32 start_scene_time = 4; */
        if (message.startSceneTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.startSceneTime);
        /* Vector start_pos = 7; */
        if (message.startPos)
            Vector.internalBinaryWrite(message.startPos, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool is_started = 8; */
        if (message.isStarted !== false)
            writer.tag(8, WireType.Varint).bool(message.isStarted);
        /* MathQuaternion start_rot = 9; */
        if (message.startRot)
            MathQuaternion.internalBinaryWrite(message.startRot, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 stop_scene_time = 10; */
        if (message.stopSceneTime !== 0)
            writer.tag(10, WireType.Varint).uint32(message.stopSceneTime);
        /* Vector pos_offset = 11; */
        if (message.posOffset)
            Vector.internalBinaryWrite(message.posOffset, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* MathQuaternion rot_offset = 12; */
        if (message.rotOffset)
            MathQuaternion.internalBinaryWrite(message.rotOffset, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* MovingPlatformType moving_platform_type = 13; */
        if (message.movingPlatformType !== 0)
            writer.tag(13, WireType.Varint).int32(message.movingPlatformType);
        /* bool is_active = 14; */
        if (message.isActive !== false)
            writer.tag(14, WireType.Varint).bool(message.isActive);
        /* Route route = 15; */
        if (message.route)
            Route.internalBinaryWrite(message.route, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* uint32 point_id = 16; */
        if (message.pointId !== 0)
            writer.tag(16, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlatformInfo
 */
export const PlatformInfo = new PlatformInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpNotify$Type extends MessageType<PlayerApplyEnterMpNotify> {
    constructor() {
        super("PlayerApplyEnterMpNotify", [
            { no: 11, name: "src_player_info", kind: "message", T: () => OnlinePlayerInfo },
            { no: 6, name: "src_app_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "src_thread_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpNotify>): PlayerApplyEnterMpNotify {
        const message = { srcAppId: 0, srcThreadIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpNotify): PlayerApplyEnterMpNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* OnlinePlayerInfo src_player_info */ 11:
                    message.srcPlayerInfo = OnlinePlayerInfo.internalBinaryRead(reader, reader.uint32(), options, message.srcPlayerInfo);
                    break;
                case /* uint32 src_app_id */ 6:
                    message.srcAppId = reader.uint32();
                    break;
                case /* uint32 src_thread_index */ 13:
                    message.srcThreadIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* OnlinePlayerInfo src_player_info = 11; */
        if (message.srcPlayerInfo)
            OnlinePlayerInfo.internalBinaryWrite(message.srcPlayerInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 src_app_id = 6; */
        if (message.srcAppId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.srcAppId);
        /* uint32 src_thread_index = 13; */
        if (message.srcThreadIndex !== 0)
            writer.tag(13, WireType.Varint).uint32(message.srcThreadIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpNotify
 */
export const PlayerApplyEnterMpNotify = new PlayerApplyEnterMpNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpReq$Type extends MessageType<PlayerApplyEnterMpReq> {
    constructor() {
        super("PlayerApplyEnterMpReq", [
            { no: 3, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpReq>): PlayerApplyEnterMpReq {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpReq): PlayerApplyEnterMpReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 3:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 3; */
        if (message.targetUid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpReq
 */
export const PlayerApplyEnterMpReq = new PlayerApplyEnterMpReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpResultNotify$Type extends MessageType<PlayerApplyEnterMpResultNotify> {
    constructor() {
        super("PlayerApplyEnterMpResultNotify", [
            { no: 7, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_agreed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "reason", kind: "enum", T: () => ["PlayerApplyEnterMpResultNotify.Reason", PlayerApplyEnterMpResultNotify_Reason, "REASON_"] },
            { no: 5, name: "target_nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpResultNotify>): PlayerApplyEnterMpResultNotify {
        const message = { targetUid: 0, isAgreed: false, reason: 0, targetNickname: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpResultNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpResultNotify): PlayerApplyEnterMpResultNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 7:
                    message.targetUid = reader.uint32();
                    break;
                case /* bool is_agreed */ 4:
                    message.isAgreed = reader.bool();
                    break;
                case /* PlayerApplyEnterMpResultNotify.Reason reason */ 14:
                    message.reason = reader.int32();
                    break;
                case /* string target_nickname */ 5:
                    message.targetNickname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpResultNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 7; */
        if (message.targetUid !== 0)
            writer.tag(7, WireType.Varint).uint32(message.targetUid);
        /* bool is_agreed = 4; */
        if (message.isAgreed !== false)
            writer.tag(4, WireType.Varint).bool(message.isAgreed);
        /* PlayerApplyEnterMpResultNotify.Reason reason = 14; */
        if (message.reason !== 0)
            writer.tag(14, WireType.Varint).int32(message.reason);
        /* string target_nickname = 5; */
        if (message.targetNickname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.targetNickname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpResultNotify
 */
export const PlayerApplyEnterMpResultNotify = new PlayerApplyEnterMpResultNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpResultReq$Type extends MessageType<PlayerApplyEnterMpResultReq> {
    constructor() {
        super("PlayerApplyEnterMpResultReq", [
            { no: 15, name: "apply_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_agreed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpResultReq>): PlayerApplyEnterMpResultReq {
        const message = { applyUid: 0, isAgreed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpResultReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpResultReq): PlayerApplyEnterMpResultReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 apply_uid */ 15:
                    message.applyUid = reader.uint32();
                    break;
                case /* bool is_agreed */ 9:
                    message.isAgreed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpResultReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 apply_uid = 15; */
        if (message.applyUid !== 0)
            writer.tag(15, WireType.Varint).uint32(message.applyUid);
        /* bool is_agreed = 9; */
        if (message.isAgreed !== false)
            writer.tag(9, WireType.Varint).bool(message.isAgreed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpResultReq
 */
export const PlayerApplyEnterMpResultReq = new PlayerApplyEnterMpResultReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpResultRsp$Type extends MessageType<PlayerApplyEnterMpResultRsp> {
    constructor() {
        super("PlayerApplyEnterMpResultRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "apply_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "is_agreed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpResultRsp>): PlayerApplyEnterMpResultRsp {
        const message = { retcode: 0, applyUid: 0, isAgreed: false, param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpResultRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpResultRsp): PlayerApplyEnterMpResultRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 apply_uid */ 4:
                    message.applyUid = reader.uint32();
                    break;
                case /* bool is_agreed */ 12:
                    message.isAgreed = reader.bool();
                    break;
                case /* uint32 param */ 9:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpResultRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* uint32 apply_uid = 4; */
        if (message.applyUid !== 0)
            writer.tag(4, WireType.Varint).uint32(message.applyUid);
        /* bool is_agreed = 12; */
        if (message.isAgreed !== false)
            writer.tag(12, WireType.Varint).bool(message.isAgreed);
        /* uint32 param = 9; */
        if (message.param !== 0)
            writer.tag(9, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpResultRsp
 */
export const PlayerApplyEnterMpResultRsp = new PlayerApplyEnterMpResultRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerApplyEnterMpRsp$Type extends MessageType<PlayerApplyEnterMpRsp> {
    constructor() {
        super("PlayerApplyEnterMpRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerApplyEnterMpRsp>): PlayerApplyEnterMpRsp {
        const message = { retcode: 0, targetUid: 0, param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerApplyEnterMpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerApplyEnterMpRsp): PlayerApplyEnterMpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 4:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint32 param */ 9:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerApplyEnterMpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 4; */
        if (message.targetUid !== 0)
            writer.tag(4, WireType.Varint).uint32(message.targetUid);
        /* uint32 param = 9; */
        if (message.param !== 0)
            writer.tag(9, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerApplyEnterMpRsp
 */
export const PlayerApplyEnterMpRsp = new PlayerApplyEnterMpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerChatNotify$Type extends MessageType<PlayerChatNotify> {
    constructor() {
        super("PlayerChatNotify", [
            { no: 14, name: "channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "chat_info", kind: "message", T: () => ChatInfo }
        ]);
    }
    create(value?: PartialMessage<PlayerChatNotify>): PlayerChatNotify {
        const message = { channelId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerChatNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerChatNotify): PlayerChatNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 channel_id */ 14:
                    message.channelId = reader.uint32();
                    break;
                case /* ChatInfo chat_info */ 12:
                    message.chatInfo = ChatInfo.internalBinaryRead(reader, reader.uint32(), options, message.chatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerChatNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 channel_id = 14; */
        if (message.channelId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.channelId);
        /* ChatInfo chat_info = 12; */
        if (message.chatInfo)
            ChatInfo.internalBinaryWrite(message.chatInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerChatNotify
 */
export const PlayerChatNotify = new PlayerChatNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerChatReq$Type extends MessageType<PlayerChatReq> {
    constructor() {
        super("PlayerChatReq", [
            { no: 9, name: "channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "chat_info", kind: "message", T: () => ChatInfo }
        ]);
    }
    create(value?: PartialMessage<PlayerChatReq>): PlayerChatReq {
        const message = { channelId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerChatReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerChatReq): PlayerChatReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 channel_id */ 9:
                    message.channelId = reader.uint32();
                    break;
                case /* ChatInfo chat_info */ 1:
                    message.chatInfo = ChatInfo.internalBinaryRead(reader, reader.uint32(), options, message.chatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerChatReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 channel_id = 9; */
        if (message.channelId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.channelId);
        /* ChatInfo chat_info = 1; */
        if (message.chatInfo)
            ChatInfo.internalBinaryWrite(message.chatInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerChatReq
 */
export const PlayerChatReq = new PlayerChatReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerChatRsp$Type extends MessageType<PlayerChatRsp> {
    constructor() {
        super("PlayerChatRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "chat_forbidden_endtime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerChatRsp>): PlayerChatRsp {
        const message = { retcode: 0, chatForbiddenEndtime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerChatRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerChatRsp): PlayerChatRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 chat_forbidden_endtime */ 15:
                    message.chatForbiddenEndtime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerChatRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* uint32 chat_forbidden_endtime = 15; */
        if (message.chatForbiddenEndtime !== 0)
            writer.tag(15, WireType.Varint).uint32(message.chatForbiddenEndtime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerChatRsp
 */
export const PlayerChatRsp = new PlayerChatRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerCookArgsReq$Type extends MessageType<PlayerCookArgsReq> {
    constructor() {
        super("PlayerCookArgsReq", [
            { no: 3, name: "recipe_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "assist_avatar", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerCookArgsReq>): PlayerCookArgsReq {
        const message = { recipeId: 0, assistAvatar: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerCookArgsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerCookArgsReq): PlayerCookArgsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 recipe_id */ 3:
                    message.recipeId = reader.uint32();
                    break;
                case /* uint32 assist_avatar */ 15:
                    message.assistAvatar = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerCookArgsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 recipe_id = 3; */
        if (message.recipeId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.recipeId);
        /* uint32 assist_avatar = 15; */
        if (message.assistAvatar !== 0)
            writer.tag(15, WireType.Varint).uint32(message.assistAvatar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerCookArgsReq
 */
export const PlayerCookArgsReq = new PlayerCookArgsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerCookArgsRsp$Type extends MessageType<PlayerCookArgsRsp> {
    constructor() {
        super("PlayerCookArgsRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "qte_range_ratio", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerCookArgsRsp>): PlayerCookArgsRsp {
        const message = { retcode: 0, qteRangeRatio: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerCookArgsRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerCookArgsRsp): PlayerCookArgsRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* float qte_range_ratio */ 15:
                    message.qteRangeRatio = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerCookArgsRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* float qte_range_ratio = 15; */
        if (message.qteRangeRatio !== 0)
            writer.tag(15, WireType.Bit32).float(message.qteRangeRatio);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerCookArgsRsp
 */
export const PlayerCookArgsRsp = new PlayerCookArgsRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerCookReq$Type extends MessageType<PlayerCookReq> {
    constructor() {
        super("PlayerCookReq", [
            { no: 6, name: "recipe_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "qte_quality", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "assist_avatar", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cook_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerCookReq>): PlayerCookReq {
        const message = { recipeId: 0, qteQuality: 0, assistAvatar: 0, cookCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerCookReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerCookReq): PlayerCookReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 recipe_id */ 6:
                    message.recipeId = reader.uint32();
                    break;
                case /* uint32 qte_quality */ 2:
                    message.qteQuality = reader.uint32();
                    break;
                case /* uint32 assist_avatar */ 11:
                    message.assistAvatar = reader.uint32();
                    break;
                case /* uint32 cook_count */ 7:
                    message.cookCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerCookReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 recipe_id = 6; */
        if (message.recipeId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.recipeId);
        /* uint32 qte_quality = 2; */
        if (message.qteQuality !== 0)
            writer.tag(2, WireType.Varint).uint32(message.qteQuality);
        /* uint32 assist_avatar = 11; */
        if (message.assistAvatar !== 0)
            writer.tag(11, WireType.Varint).uint32(message.assistAvatar);
        /* uint32 cook_count = 7; */
        if (message.cookCount !== 0)
            writer.tag(7, WireType.Varint).uint32(message.cookCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerCookReq
 */
export const PlayerCookReq = new PlayerCookReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerCookRsp$Type extends MessageType<PlayerCookRsp> {
    constructor() {
        super("PlayerCookRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "recipe_data", kind: "message", T: () => CookRecipeData },
            { no: 13, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 11, name: "qte_quality", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "cook_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "extral_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<PlayerCookRsp>): PlayerCookRsp {
        const message = { retcode: 0, itemList: [], qteQuality: 0, cookCount: 0, extralItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerCookRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerCookRsp): PlayerCookRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* CookRecipeData recipe_data */ 14:
                    message.recipeData = CookRecipeData.internalBinaryRead(reader, reader.uint32(), options, message.recipeData);
                    break;
                case /* repeated ItemParam item_list */ 13:
                    message.itemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 qte_quality */ 11:
                    message.qteQuality = reader.uint32();
                    break;
                case /* uint32 cook_count */ 15:
                    message.cookCount = reader.uint32();
                    break;
                case /* repeated ItemParam extral_item_list */ 3:
                    message.extralItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerCookRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* CookRecipeData recipe_data = 14; */
        if (message.recipeData)
            CookRecipeData.internalBinaryWrite(message.recipeData, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam item_list = 13; */
        for (let i = 0; i < message.itemList.length; i++)
            ItemParam.internalBinaryWrite(message.itemList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 qte_quality = 11; */
        if (message.qteQuality !== 0)
            writer.tag(11, WireType.Varint).uint32(message.qteQuality);
        /* uint32 cook_count = 15; */
        if (message.cookCount !== 0)
            writer.tag(15, WireType.Varint).uint32(message.cookCount);
        /* repeated ItemParam extral_item_list = 3; */
        for (let i = 0; i < message.extralItemList.length; i++)
            ItemParam.internalBinaryWrite(message.extralItemList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerCookRsp
 */
export const PlayerCookRsp = new PlayerCookRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerDataNotify$Type extends MessageType<PlayerDataNotify> {
    constructor() {
        super("PlayerDataNotify", [
            { no: 15, name: "nick_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "server_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "is_first_login_today", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "region_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } }
        ]);
    }
    create(value?: PartialMessage<PlayerDataNotify>): PlayerDataNotify {
        const message = { nickName: "", serverTime: 0n, isFirstLoginToday: false, regionId: 0, propMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerDataNotify): PlayerDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string nick_name */ 15:
                    message.nickName = reader.string();
                    break;
                case /* uint64 server_time */ 2:
                    message.serverTime = reader.uint64().toBigInt();
                    break;
                case /* bool is_first_login_today */ 11:
                    message.isFirstLoginToday = reader.bool();
                    break;
                case /* uint32 region_id */ 9:
                    message.regionId = reader.uint32();
                    break;
                case /* map<uint32, PropValue> prop_map */ 8:
                    this.binaryReadMap8(message.propMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: PlayerDataNotify["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerDataNotify["propMap"] | undefined, val: PlayerDataNotify["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field PlayerDataNotify.prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    internalBinaryWrite(message: PlayerDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string nick_name = 15; */
        if (message.nickName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.nickName);
        /* uint64 server_time = 2; */
        if (message.serverTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.serverTime);
        /* bool is_first_login_today = 11; */
        if (message.isFirstLoginToday !== false)
            writer.tag(11, WireType.Varint).bool(message.isFirstLoginToday);
        /* uint32 region_id = 9; */
        if (message.regionId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.regionId);
        /* map<uint32, PropValue> prop_map = 8; */
        for (let k of Object.keys(message.propMap)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.propMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerDataNotify
 */
export const PlayerDataNotify = new PlayerDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerEnterDungeonReq$Type extends MessageType<PlayerEnterDungeonReq> {
    constructor() {
        super("PlayerEnterDungeonReq", [
            { no: 5, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerEnterDungeonReq>): PlayerEnterDungeonReq {
        const message = { pointId: 0, dungeonId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerEnterDungeonReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerEnterDungeonReq): PlayerEnterDungeonReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 point_id */ 5:
                    message.pointId = reader.uint32();
                    break;
                case /* uint32 dungeon_id */ 12:
                    message.dungeonId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerEnterDungeonReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 point_id = 5; */
        if (message.pointId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.pointId);
        /* uint32 dungeon_id = 12; */
        if (message.dungeonId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.dungeonId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerEnterDungeonReq
 */
export const PlayerEnterDungeonReq = new PlayerEnterDungeonReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerEnterDungeonRsp$Type extends MessageType<PlayerEnterDungeonRsp> {
    constructor() {
        super("PlayerEnterDungeonRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerEnterDungeonRsp>): PlayerEnterDungeonRsp {
        const message = { retcode: 0, pointId: 0, dungeonId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerEnterDungeonRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerEnterDungeonRsp): PlayerEnterDungeonRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 point_id */ 1:
                    message.pointId = reader.uint32();
                    break;
                case /* uint32 dungeon_id */ 13:
                    message.dungeonId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerEnterDungeonRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint32 point_id = 1; */
        if (message.pointId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.pointId);
        /* uint32 dungeon_id = 13; */
        if (message.dungeonId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.dungeonId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerEnterDungeonRsp
 */
export const PlayerEnterDungeonRsp = new PlayerEnterDungeonRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerEnterSceneInfoNotify$Type extends MessageType<PlayerEnterSceneInfoNotify> {
    constructor() {
        super("PlayerEnterSceneInfoNotify", [
            { no: 8, name: "cur_avatar_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "avatar_enter_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AvatarEnterSceneInfo },
            { no: 9, name: "team_enter_info", kind: "message", T: () => TeamEnterSceneInfo },
            { no: 5, name: "mp_level_entity_info", kind: "message", T: () => MPLevelEntityInfo },
            { no: 7, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerEnterSceneInfoNotify>): PlayerEnterSceneInfoNotify {
        const message = { curAvatarEntityId: 0, avatarEnterInfo: [], enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerEnterSceneInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerEnterSceneInfoNotify): PlayerEnterSceneInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cur_avatar_entity_id */ 8:
                    message.curAvatarEntityId = reader.uint32();
                    break;
                case /* repeated AvatarEnterSceneInfo avatar_enter_info */ 14:
                    message.avatarEnterInfo.push(AvatarEnterSceneInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TeamEnterSceneInfo team_enter_info */ 9:
                    message.teamEnterInfo = TeamEnterSceneInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamEnterInfo);
                    break;
                case /* MPLevelEntityInfo mp_level_entity_info */ 5:
                    message.mpLevelEntityInfo = MPLevelEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.mpLevelEntityInfo);
                    break;
                case /* uint32 enter_scene_token */ 7:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerEnterSceneInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cur_avatar_entity_id = 8; */
        if (message.curAvatarEntityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.curAvatarEntityId);
        /* repeated AvatarEnterSceneInfo avatar_enter_info = 14; */
        for (let i = 0; i < message.avatarEnterInfo.length; i++)
            AvatarEnterSceneInfo.internalBinaryWrite(message.avatarEnterInfo[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* TeamEnterSceneInfo team_enter_info = 9; */
        if (message.teamEnterInfo)
            TeamEnterSceneInfo.internalBinaryWrite(message.teamEnterInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* MPLevelEntityInfo mp_level_entity_info = 5; */
        if (message.mpLevelEntityInfo)
            MPLevelEntityInfo.internalBinaryWrite(message.mpLevelEntityInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 enter_scene_token = 7; */
        if (message.enterSceneToken !== 0)
            writer.tag(7, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerEnterSceneInfoNotify
 */
export const PlayerEnterSceneInfoNotify = new PlayerEnterSceneInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerEnterSceneNotify$Type extends MessageType<PlayerEnterSceneNotify> {
    constructor() {
        super("PlayerEnterSceneNotify", [
            { no: 14, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "pos", kind: "message", T: () => Vector },
            { no: 12, name: "scene_begin_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["EnterType", EnterType, "ENTER_TYPE_"] },
            { no: 4, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "prev_scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "prev_pos", kind: "message", T: () => Vector },
            { no: 13, name: "dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "world_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_first_login_enter_scene", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "scene_tag_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 1430, name: "is_skip_ui", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1982, name: "enter_reason", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1067, name: "world_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1081, name: "scene_transaction", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerEnterSceneNotify>): PlayerEnterSceneNotify {
        const message = { sceneId: 0, sceneBeginTime: 0n, type: 0, targetUid: 0, prevSceneId: 0, dungeonId: 0, worldLevel: 0, enterSceneToken: 0, isFirstLoginEnterScene: false, sceneTagIdList: [], isSkipUi: false, enterReason: 0, worldType: 0, sceneTransaction: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerEnterSceneNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerEnterSceneNotify): PlayerEnterSceneNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 14:
                    message.sceneId = reader.uint32();
                    break;
                case /* Vector pos */ 15:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* uint64 scene_begin_time */ 12:
                    message.sceneBeginTime = reader.uint64().toBigInt();
                    break;
                case /* EnterType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* uint32 target_uid */ 4:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint32 prev_scene_id */ 7:
                    message.prevSceneId = reader.uint32();
                    break;
                case /* Vector prev_pos */ 6:
                    message.prevPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.prevPos);
                    break;
                case /* uint32 dungeon_id */ 13:
                    message.dungeonId = reader.uint32();
                    break;
                case /* uint32 world_level */ 3:
                    message.worldLevel = reader.uint32();
                    break;
                case /* uint32 enter_scene_token */ 9:
                    message.enterSceneToken = reader.uint32();
                    break;
                case /* bool is_first_login_enter_scene */ 11:
                    message.isFirstLoginEnterScene = reader.bool();
                    break;
                case /* repeated uint32 scene_tag_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sceneTagIdList.push(reader.uint32());
                    else
                        message.sceneTagIdList.push(reader.uint32());
                    break;
                case /* bool is_skip_ui */ 1430:
                    message.isSkipUi = reader.bool();
                    break;
                case /* uint32 enter_reason */ 1982:
                    message.enterReason = reader.uint32();
                    break;
                case /* uint32 world_type */ 1067:
                    message.worldType = reader.uint32();
                    break;
                case /* string scene_transaction */ 1081:
                    message.sceneTransaction = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerEnterSceneNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 14; */
        if (message.sceneId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.sceneId);
        /* Vector pos = 15; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* uint64 scene_begin_time = 12; */
        if (message.sceneBeginTime !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.sceneBeginTime);
        /* EnterType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* uint32 target_uid = 4; */
        if (message.targetUid !== 0)
            writer.tag(4, WireType.Varint).uint32(message.targetUid);
        /* uint32 prev_scene_id = 7; */
        if (message.prevSceneId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.prevSceneId);
        /* Vector prev_pos = 6; */
        if (message.prevPos)
            Vector.internalBinaryWrite(message.prevPos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dungeon_id = 13; */
        if (message.dungeonId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.dungeonId);
        /* uint32 world_level = 3; */
        if (message.worldLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.worldLevel);
        /* uint32 enter_scene_token = 9; */
        if (message.enterSceneToken !== 0)
            writer.tag(9, WireType.Varint).uint32(message.enterSceneToken);
        /* bool is_first_login_enter_scene = 11; */
        if (message.isFirstLoginEnterScene !== false)
            writer.tag(11, WireType.Varint).bool(message.isFirstLoginEnterScene);
        /* repeated uint32 scene_tag_id_list = 1; */
        if (message.sceneTagIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sceneTagIdList.length; i++)
                writer.uint32(message.sceneTagIdList[i]);
            writer.join();
        }
        /* bool is_skip_ui = 1430; */
        if (message.isSkipUi !== false)
            writer.tag(1430, WireType.Varint).bool(message.isSkipUi);
        /* uint32 enter_reason = 1982; */
        if (message.enterReason !== 0)
            writer.tag(1982, WireType.Varint).uint32(message.enterReason);
        /* uint32 world_type = 1067; */
        if (message.worldType !== 0)
            writer.tag(1067, WireType.Varint).uint32(message.worldType);
        /* string scene_transaction = 1081; */
        if (message.sceneTransaction !== "")
            writer.tag(1081, WireType.LengthDelimited).string(message.sceneTransaction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerEnterSceneNotify
 */
export const PlayerEnterSceneNotify = new PlayerEnterSceneNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerGameTimeNotify$Type extends MessageType<PlayerGameTimeNotify> {
    constructor() {
        super("PlayerGameTimeNotify", [
            { no: 7, name: "game_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "is_home", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerGameTimeNotify>): PlayerGameTimeNotify {
        const message = { gameTime: 0, uid: 0, isHome: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerGameTimeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerGameTimeNotify): PlayerGameTimeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 game_time */ 7:
                    message.gameTime = reader.uint32();
                    break;
                case /* uint32 uid */ 13:
                    message.uid = reader.uint32();
                    break;
                case /* bool is_home */ 12:
                    message.isHome = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerGameTimeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 game_time = 7; */
        if (message.gameTime !== 0)
            writer.tag(7, WireType.Varint).uint32(message.gameTime);
        /* uint32 uid = 13; */
        if (message.uid !== 0)
            writer.tag(13, WireType.Varint).uint32(message.uid);
        /* bool is_home = 12; */
        if (message.isHome !== false)
            writer.tag(12, WireType.Varint).bool(message.isHome);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerGameTimeNotify
 */
export const PlayerGameTimeNotify = new PlayerGameTimeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerGetForceQuitBanInfoRsp$Type extends MessageType<PlayerGetForceQuitBanInfoRsp> {
    constructor() {
        super("PlayerGetForceQuitBanInfoRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "match_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "expire_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerGetForceQuitBanInfoRsp>): PlayerGetForceQuitBanInfoRsp {
        const message = { retcode: 0, matchId: 0, expireTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerGetForceQuitBanInfoRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerGetForceQuitBanInfoRsp): PlayerGetForceQuitBanInfoRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 match_id */ 8:
                    message.matchId = reader.uint32();
                    break;
                case /* uint32 expire_time */ 5:
                    message.expireTime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerGetForceQuitBanInfoRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint32 match_id = 8; */
        if (message.matchId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.matchId);
        /* uint32 expire_time = 5; */
        if (message.expireTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.expireTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerGetForceQuitBanInfoRsp
 */
export const PlayerGetForceQuitBanInfoRsp = new PlayerGetForceQuitBanInfoRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerHomeCompInfo$Type extends MessageType<PlayerHomeCompInfo> {
    constructor() {
        super("PlayerHomeCompInfo", [
            { no: 5, name: "friend_enter_home_option", kind: "enum", T: () => ["FriendEnterHomeOption", FriendEnterHomeOption, "FRIEND_ENTER_HOME_OPTION_"] },
            { no: 1, name: "unlocked_module_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "levelup_reward_got_level_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "seen_module_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerHomeCompInfo>): PlayerHomeCompInfo {
        const message = { friendEnterHomeOption: 0, unlockedModuleIdList: [], levelupRewardGotLevelList: [], seenModuleIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerHomeCompInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerHomeCompInfo): PlayerHomeCompInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* FriendEnterHomeOption friend_enter_home_option */ 5:
                    message.friendEnterHomeOption = reader.int32();
                    break;
                case /* repeated uint32 unlocked_module_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockedModuleIdList.push(reader.uint32());
                    else
                        message.unlockedModuleIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 levelup_reward_got_level_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.levelupRewardGotLevelList.push(reader.uint32());
                    else
                        message.levelupRewardGotLevelList.push(reader.uint32());
                    break;
                case /* repeated uint32 seen_module_id_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.seenModuleIdList.push(reader.uint32());
                    else
                        message.seenModuleIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerHomeCompInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* FriendEnterHomeOption friend_enter_home_option = 5; */
        if (message.friendEnterHomeOption !== 0)
            writer.tag(5, WireType.Varint).int32(message.friendEnterHomeOption);
        /* repeated uint32 unlocked_module_id_list = 1; */
        if (message.unlockedModuleIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.unlockedModuleIdList.length; i++)
                writer.uint32(message.unlockedModuleIdList[i]);
            writer.join();
        }
        /* repeated uint32 levelup_reward_got_level_list = 10; */
        if (message.levelupRewardGotLevelList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.levelupRewardGotLevelList.length; i++)
                writer.uint32(message.levelupRewardGotLevelList[i]);
            writer.join();
        }
        /* repeated uint32 seen_module_id_list = 14; */
        if (message.seenModuleIdList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.seenModuleIdList.length; i++)
                writer.uint32(message.seenModuleIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerHomeCompInfo
 */
export const PlayerHomeCompInfo = new PlayerHomeCompInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerHomeCompInfoNotify$Type extends MessageType<PlayerHomeCompInfoNotify> {
    constructor() {
        super("PlayerHomeCompInfoNotify", [
            { no: 2, name: "comp_info", kind: "message", T: () => PlayerHomeCompInfo }
        ]);
    }
    create(value?: PartialMessage<PlayerHomeCompInfoNotify>): PlayerHomeCompInfoNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerHomeCompInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerHomeCompInfoNotify): PlayerHomeCompInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PlayerHomeCompInfo comp_info */ 2:
                    message.compInfo = PlayerHomeCompInfo.internalBinaryRead(reader, reader.uint32(), options, message.compInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerHomeCompInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PlayerHomeCompInfo comp_info = 2; */
        if (message.compInfo)
            PlayerHomeCompInfo.internalBinaryWrite(message.compInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerHomeCompInfoNotify
 */
export const PlayerHomeCompInfoNotify = new PlayerHomeCompInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLevelRewardUpdateNotify$Type extends MessageType<PlayerLevelRewardUpdateNotify> {
    constructor() {
        super("PlayerLevelRewardUpdateNotify", [
            { no: 14, name: "level_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLevelRewardUpdateNotify>): PlayerLevelRewardUpdateNotify {
        const message = { levelList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerLevelRewardUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLevelRewardUpdateNotify): PlayerLevelRewardUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 level_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.levelList.push(reader.uint32());
                    else
                        message.levelList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLevelRewardUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 level_list = 14; */
        if (message.levelList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.levelList.length; i++)
                writer.uint32(message.levelList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerLevelRewardUpdateNotify
 */
export const PlayerLevelRewardUpdateNotify = new PlayerLevelRewardUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLocationInfo$Type extends MessageType<PlayerLocationInfo> {
    constructor() {
        super("PlayerLocationInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "pos", kind: "message", T: () => Vector },
            { no: 3, name: "rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<PlayerLocationInfo>): PlayerLocationInfo {
        const message = { uid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLocationInfo): PlayerLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* Vector pos */ 2:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 3:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* Vector pos = 2; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 3; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerLocationInfo
 */
export const PlayerLocationInfo = new PlayerLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLoginReq$Type extends MessageType<PlayerLoginReq> {
    constructor() {
        super("PlayerLoginReq", [
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "client_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "system_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "device_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "device_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "login_rand", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "is_editor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "language_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "account_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "account_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "device_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "platform_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "is_guest", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 233, name: "cloud_client_ip", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1423, name: "gm_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 485, name: "checksum", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1974, name: "online_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 133, name: "client_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 96, name: "security_cmd_reply", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 814, name: "extra_bin_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 467, name: "cps", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2028, name: "channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1571, name: "sub_channel_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1844, name: "checksum_client_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 843, name: "tag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1882, name: "tracking_io_info", kind: "message", T: () => TrackingIOInfo },
            { no: 1060, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1570, name: "client_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1303, name: "environment_error_code", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 1054, name: "target_home_owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 921, name: "psn_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1972, name: "client_verison_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1918, name: "is_transfer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 167, name: "reg_platform", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1129, name: "target_home_param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 280, name: "adjust_tracking_info", kind: "message", T: () => AdjustTrackingInfo },
            { no: 174, name: "birthday", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLoginReq>): PlayerLoginReq {
        const message = { token: "", clientVersion: "", systemVersion: "", deviceName: "", deviceUuid: "", targetUid: 0, loginRand: 0n, isEditor: false, languageType: 0, accountType: 0, accountUid: "", platform: "", deviceInfo: "", platformType: 0, isGuest: false, cloudClientIp: 0, gmUid: 0, checksum: "", onlineId: "", clientToken: 0, securityCmdReply: new Uint8Array(0), extraBinData: new Uint8Array(0), cps: "", channelId: 0, subChannelId: 0, checksumClientVersion: "", tag: 0, countryCode: "", clientDataVersion: 0, environmentErrorCode: new Uint8Array(0), targetHomeOwnerUid: 0, psnId: "", clientVerisonHash: "", isTransfer: false, regPlatform: 0, targetHomeParam: 0, birthday: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerLoginReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLoginReq): PlayerLoginReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                case /* string client_version */ 7:
                    message.clientVersion = reader.string();
                    break;
                case /* string system_version */ 12:
                    message.systemVersion = reader.string();
                    break;
                case /* string device_name */ 3:
                    message.deviceName = reader.string();
                    break;
                case /* string device_uuid */ 14:
                    message.deviceUuid = reader.string();
                    break;
                case /* uint32 target_uid */ 15:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint64 login_rand */ 11:
                    message.loginRand = reader.uint64().toBigInt();
                    break;
                case /* bool is_editor */ 2:
                    message.isEditor = reader.bool();
                    break;
                case /* uint32 language_type */ 13:
                    message.languageType = reader.uint32();
                    break;
                case /* uint32 account_type */ 1:
                    message.accountType = reader.uint32();
                    break;
                case /* string account_uid */ 8:
                    message.accountUid = reader.string();
                    break;
                case /* string platform */ 6:
                    message.platform = reader.string();
                    break;
                case /* string device_info */ 4:
                    message.deviceInfo = reader.string();
                    break;
                case /* uint32 platform_type */ 10:
                    message.platformType = reader.uint32();
                    break;
                case /* bool is_guest */ 9:
                    message.isGuest = reader.bool();
                    break;
                case /* uint32 cloud_client_ip */ 233:
                    message.cloudClientIp = reader.uint32();
                    break;
                case /* uint32 gm_uid */ 1423:
                    message.gmUid = reader.uint32();
                    break;
                case /* string checksum */ 485:
                    message.checksum = reader.string();
                    break;
                case /* string online_id */ 1974:
                    message.onlineId = reader.string();
                    break;
                case /* uint32 client_token */ 133:
                    message.clientToken = reader.uint32();
                    break;
                case /* bytes security_cmd_reply */ 96:
                    message.securityCmdReply = reader.bytes();
                    break;
                case /* bytes extra_bin_data */ 814:
                    message.extraBinData = reader.bytes();
                    break;
                case /* string cps */ 467:
                    message.cps = reader.string();
                    break;
                case /* uint32 channel_id */ 2028:
                    message.channelId = reader.uint32();
                    break;
                case /* uint32 sub_channel_id */ 1571:
                    message.subChannelId = reader.uint32();
                    break;
                case /* string checksum_client_version */ 1844:
                    message.checksumClientVersion = reader.string();
                    break;
                case /* uint32 tag */ 843:
                    message.tag = reader.uint32();
                    break;
                case /* TrackingIOInfo tracking_io_info */ 1882:
                    message.trackingIoInfo = TrackingIOInfo.internalBinaryRead(reader, reader.uint32(), options, message.trackingIoInfo);
                    break;
                case /* string country_code */ 1060:
                    message.countryCode = reader.string();
                    break;
                case /* uint32 client_data_version */ 1570:
                    message.clientDataVersion = reader.uint32();
                    break;
                case /* bytes environment_error_code */ 1303:
                    message.environmentErrorCode = reader.bytes();
                    break;
                case /* uint32 target_home_owner_uid */ 1054:
                    message.targetHomeOwnerUid = reader.uint32();
                    break;
                case /* string psn_id */ 921:
                    message.psnId = reader.string();
                    break;
                case /* string client_verison_hash */ 1972:
                    message.clientVerisonHash = reader.string();
                    break;
                case /* bool is_transfer */ 1918:
                    message.isTransfer = reader.bool();
                    break;
                case /* uint32 reg_platform */ 167:
                    message.regPlatform = reader.uint32();
                    break;
                case /* uint32 target_home_param */ 1129:
                    message.targetHomeParam = reader.uint32();
                    break;
                case /* AdjustTrackingInfo adjust_tracking_info */ 280:
                    message.adjustTrackingInfo = AdjustTrackingInfo.internalBinaryRead(reader, reader.uint32(), options, message.adjustTrackingInfo);
                    break;
                case /* string birthday */ 174:
                    message.birthday = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLoginReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        /* string client_version = 7; */
        if (message.clientVersion !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.clientVersion);
        /* string system_version = 12; */
        if (message.systemVersion !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.systemVersion);
        /* string device_name = 3; */
        if (message.deviceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.deviceName);
        /* string device_uuid = 14; */
        if (message.deviceUuid !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.deviceUuid);
        /* uint32 target_uid = 15; */
        if (message.targetUid !== 0)
            writer.tag(15, WireType.Varint).uint32(message.targetUid);
        /* uint64 login_rand = 11; */
        if (message.loginRand !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.loginRand);
        /* bool is_editor = 2; */
        if (message.isEditor !== false)
            writer.tag(2, WireType.Varint).bool(message.isEditor);
        /* uint32 language_type = 13; */
        if (message.languageType !== 0)
            writer.tag(13, WireType.Varint).uint32(message.languageType);
        /* uint32 account_type = 1; */
        if (message.accountType !== 0)
            writer.tag(1, WireType.Varint).uint32(message.accountType);
        /* string account_uid = 8; */
        if (message.accountUid !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.accountUid);
        /* string platform = 6; */
        if (message.platform !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.platform);
        /* string device_info = 4; */
        if (message.deviceInfo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.deviceInfo);
        /* uint32 platform_type = 10; */
        if (message.platformType !== 0)
            writer.tag(10, WireType.Varint).uint32(message.platformType);
        /* bool is_guest = 9; */
        if (message.isGuest !== false)
            writer.tag(9, WireType.Varint).bool(message.isGuest);
        /* uint32 cloud_client_ip = 233; */
        if (message.cloudClientIp !== 0)
            writer.tag(233, WireType.Varint).uint32(message.cloudClientIp);
        /* uint32 gm_uid = 1423; */
        if (message.gmUid !== 0)
            writer.tag(1423, WireType.Varint).uint32(message.gmUid);
        /* string checksum = 485; */
        if (message.checksum !== "")
            writer.tag(485, WireType.LengthDelimited).string(message.checksum);
        /* string online_id = 1974; */
        if (message.onlineId !== "")
            writer.tag(1974, WireType.LengthDelimited).string(message.onlineId);
        /* uint32 client_token = 133; */
        if (message.clientToken !== 0)
            writer.tag(133, WireType.Varint).uint32(message.clientToken);
        /* bytes security_cmd_reply = 96; */
        if (message.securityCmdReply.length)
            writer.tag(96, WireType.LengthDelimited).bytes(message.securityCmdReply);
        /* bytes extra_bin_data = 814; */
        if (message.extraBinData.length)
            writer.tag(814, WireType.LengthDelimited).bytes(message.extraBinData);
        /* string cps = 467; */
        if (message.cps !== "")
            writer.tag(467, WireType.LengthDelimited).string(message.cps);
        /* uint32 channel_id = 2028; */
        if (message.channelId !== 0)
            writer.tag(2028, WireType.Varint).uint32(message.channelId);
        /* uint32 sub_channel_id = 1571; */
        if (message.subChannelId !== 0)
            writer.tag(1571, WireType.Varint).uint32(message.subChannelId);
        /* string checksum_client_version = 1844; */
        if (message.checksumClientVersion !== "")
            writer.tag(1844, WireType.LengthDelimited).string(message.checksumClientVersion);
        /* uint32 tag = 843; */
        if (message.tag !== 0)
            writer.tag(843, WireType.Varint).uint32(message.tag);
        /* TrackingIOInfo tracking_io_info = 1882; */
        if (message.trackingIoInfo)
            TrackingIOInfo.internalBinaryWrite(message.trackingIoInfo, writer.tag(1882, WireType.LengthDelimited).fork(), options).join();
        /* string country_code = 1060; */
        if (message.countryCode !== "")
            writer.tag(1060, WireType.LengthDelimited).string(message.countryCode);
        /* uint32 client_data_version = 1570; */
        if (message.clientDataVersion !== 0)
            writer.tag(1570, WireType.Varint).uint32(message.clientDataVersion);
        /* bytes environment_error_code = 1303; */
        if (message.environmentErrorCode.length)
            writer.tag(1303, WireType.LengthDelimited).bytes(message.environmentErrorCode);
        /* uint32 target_home_owner_uid = 1054; */
        if (message.targetHomeOwnerUid !== 0)
            writer.tag(1054, WireType.Varint).uint32(message.targetHomeOwnerUid);
        /* string psn_id = 921; */
        if (message.psnId !== "")
            writer.tag(921, WireType.LengthDelimited).string(message.psnId);
        /* string client_verison_hash = 1972; */
        if (message.clientVerisonHash !== "")
            writer.tag(1972, WireType.LengthDelimited).string(message.clientVerisonHash);
        /* bool is_transfer = 1918; */
        if (message.isTransfer !== false)
            writer.tag(1918, WireType.Varint).bool(message.isTransfer);
        /* uint32 reg_platform = 167; */
        if (message.regPlatform !== 0)
            writer.tag(167, WireType.Varint).uint32(message.regPlatform);
        /* uint32 target_home_param = 1129; */
        if (message.targetHomeParam !== 0)
            writer.tag(1129, WireType.Varint).uint32(message.targetHomeParam);
        /* AdjustTrackingInfo adjust_tracking_info = 280; */
        if (message.adjustTrackingInfo)
            AdjustTrackingInfo.internalBinaryWrite(message.adjustTrackingInfo, writer.tag(280, WireType.LengthDelimited).fork(), options).join();
        /* string birthday = 174; */
        if (message.birthday !== "")
            writer.tag(174, WireType.LengthDelimited).string(message.birthday);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerLoginReq
 */
export const PlayerLoginReq = new PlayerLoginReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLoginRsp$Type extends MessageType<PlayerLoginRsp> {
    constructor() {
        super("PlayerLoginRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "player_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "is_new_player", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "login_rand", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "is_use_ability_hash", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "ability_hash_code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "ability_hash_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 14, name: "client_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_relogin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "client_silence_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "game_biz", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "player_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1706, name: "client_md_5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 271, name: "client_silence_md_5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 933, name: "res_version_config", kind: "message", T: () => ResVersionConfig },
            { no: 1156, name: "block_info_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => BlockInfo } },
            { no: 1984, name: "client_version_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 49, name: "client_silence_version_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 364, name: "short_ability_hash_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShortAbilityHashPair },
            { no: 2014, name: "sc_info", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 1545, name: "is_audit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1974, name: "is_sc_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 715, name: "register_cps", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 408, name: "feature_block_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FeatureBlockInfo },
            { no: 110, name: "is_data_need_relogin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1306, name: "country_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 749, name: "next_res_version_config", kind: "message", T: () => ResVersionConfig },
            { no: 1744, name: "next_resource_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 945, name: "target_home_owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 713, name: "is_enable_client_hash_debug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 138, name: "is_transfer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1923, name: "total_tick_time", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 1977, name: "birthday", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLoginRsp>): PlayerLoginRsp {
        const message = { retcode: 0, playerData: new Uint8Array(0), isNewPlayer: false, targetUid: 0, loginRand: 0n, isUseAbilityHash: false, abilityHashCode: 0, abilityHashMap: {}, clientDataVersion: 0, isRelogin: false, clientSilenceDataVersion: 0, gameBiz: "", playerDataVersion: 0, clientMd5: "", clientSilenceMd5: "", blockInfoMap: {}, clientVersionSuffix: "", clientSilenceVersionSuffix: "", shortAbilityHashMap: [], scInfo: new Uint8Array(0), isAudit: false, isScOpen: false, registerCps: "", featureBlockInfoList: [], isDataNeedRelogin: false, countryCode: "", nextResourceUrl: "", targetHomeOwnerUid: 0, isEnableClientHashDebug: false, isTransfer: false, totalTickTime: 0, birthday: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerLoginRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLoginRsp): PlayerLoginRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* bytes player_data */ 6:
                    message.playerData = reader.bytes();
                    break;
                case /* bool is_new_player */ 11:
                    message.isNewPlayer = reader.bool();
                    break;
                case /* uint32 target_uid */ 15:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint64 login_rand */ 12:
                    message.loginRand = reader.uint64().toBigInt();
                    break;
                case /* bool is_use_ability_hash */ 3:
                    message.isUseAbilityHash = reader.bool();
                    break;
                case /* int32 ability_hash_code */ 7:
                    message.abilityHashCode = reader.int32();
                    break;
                case /* map<string, int32> ability_hash_map */ 13:
                    this.binaryReadMap13(message.abilityHashMap, reader, options);
                    break;
                case /* uint32 client_data_version */ 14:
                    message.clientDataVersion = reader.uint32();
                    break;
                case /* bool is_relogin */ 2:
                    message.isRelogin = reader.bool();
                    break;
                case /* uint32 client_silence_data_version */ 10:
                    message.clientSilenceDataVersion = reader.uint32();
                    break;
                case /* string game_biz */ 9:
                    message.gameBiz = reader.string();
                    break;
                case /* uint32 player_data_version */ 8:
                    message.playerDataVersion = reader.uint32();
                    break;
                case /* string client_md_5 */ 1706:
                    message.clientMd5 = reader.string();
                    break;
                case /* string client_silence_md_5 */ 271:
                    message.clientSilenceMd5 = reader.string();
                    break;
                case /* ResVersionConfig res_version_config */ 933:
                    message.resVersionConfig = ResVersionConfig.internalBinaryRead(reader, reader.uint32(), options, message.resVersionConfig);
                    break;
                case /* map<uint32, BlockInfo> block_info_map */ 1156:
                    this.binaryReadMap1156(message.blockInfoMap, reader, options);
                    break;
                case /* string client_version_suffix */ 1984:
                    message.clientVersionSuffix = reader.string();
                    break;
                case /* string client_silence_version_suffix */ 49:
                    message.clientSilenceVersionSuffix = reader.string();
                    break;
                case /* repeated ShortAbilityHashPair short_ability_hash_map */ 364:
                    message.shortAbilityHashMap.push(ShortAbilityHashPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes sc_info */ 2014:
                    message.scInfo = reader.bytes();
                    break;
                case /* bool is_audit */ 1545:
                    message.isAudit = reader.bool();
                    break;
                case /* bool is_sc_open */ 1974:
                    message.isScOpen = reader.bool();
                    break;
                case /* string register_cps */ 715:
                    message.registerCps = reader.string();
                    break;
                case /* repeated FeatureBlockInfo feature_block_info_list */ 408:
                    message.featureBlockInfoList.push(FeatureBlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_data_need_relogin */ 110:
                    message.isDataNeedRelogin = reader.bool();
                    break;
                case /* string country_code */ 1306:
                    message.countryCode = reader.string();
                    break;
                case /* ResVersionConfig next_res_version_config */ 749:
                    message.nextResVersionConfig = ResVersionConfig.internalBinaryRead(reader, reader.uint32(), options, message.nextResVersionConfig);
                    break;
                case /* string next_resource_url */ 1744:
                    message.nextResourceUrl = reader.string();
                    break;
                case /* uint32 target_home_owner_uid */ 945:
                    message.targetHomeOwnerUid = reader.uint32();
                    break;
                case /* bool is_enable_client_hash_debug */ 713:
                    message.isEnableClientHashDebug = reader.bool();
                    break;
                case /* bool is_transfer */ 138:
                    message.isTransfer = reader.bool();
                    break;
                case /* double total_tick_time */ 1923:
                    message.totalTickTime = reader.double();
                    break;
                case /* string birthday */ 1977:
                    message.birthday = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: PlayerLoginRsp["abilityHashMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerLoginRsp["abilityHashMap"] | undefined, val: PlayerLoginRsp["abilityHashMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field PlayerLoginRsp.ability_hash_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap1156(map: PlayerLoginRsp["blockInfoMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerLoginRsp["blockInfoMap"] | undefined, val: PlayerLoginRsp["blockInfoMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = BlockInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field PlayerLoginRsp.block_info_map");
            }
        }
        map[key ?? 0] = val ?? BlockInfo.create();
    }
    internalBinaryWrite(message: PlayerLoginRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* bytes player_data = 6; */
        if (message.playerData.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.playerData);
        /* bool is_new_player = 11; */
        if (message.isNewPlayer !== false)
            writer.tag(11, WireType.Varint).bool(message.isNewPlayer);
        /* uint32 target_uid = 15; */
        if (message.targetUid !== 0)
            writer.tag(15, WireType.Varint).uint32(message.targetUid);
        /* uint64 login_rand = 12; */
        if (message.loginRand !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.loginRand);
        /* bool is_use_ability_hash = 3; */
        if (message.isUseAbilityHash !== false)
            writer.tag(3, WireType.Varint).bool(message.isUseAbilityHash);
        /* int32 ability_hash_code = 7; */
        if (message.abilityHashCode !== 0)
            writer.tag(7, WireType.Varint).int32(message.abilityHashCode);
        /* map<string, int32> ability_hash_map = 13; */
        for (let k of Object.keys(message.abilityHashMap))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.abilityHashMap[k]).join();
        /* uint32 client_data_version = 14; */
        if (message.clientDataVersion !== 0)
            writer.tag(14, WireType.Varint).uint32(message.clientDataVersion);
        /* bool is_relogin = 2; */
        if (message.isRelogin !== false)
            writer.tag(2, WireType.Varint).bool(message.isRelogin);
        /* uint32 client_silence_data_version = 10; */
        if (message.clientSilenceDataVersion !== 0)
            writer.tag(10, WireType.Varint).uint32(message.clientSilenceDataVersion);
        /* string game_biz = 9; */
        if (message.gameBiz !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.gameBiz);
        /* uint32 player_data_version = 8; */
        if (message.playerDataVersion !== 0)
            writer.tag(8, WireType.Varint).uint32(message.playerDataVersion);
        /* string client_md_5 = 1706; */
        if (message.clientMd5 !== "")
            writer.tag(1706, WireType.LengthDelimited).string(message.clientMd5);
        /* string client_silence_md_5 = 271; */
        if (message.clientSilenceMd5 !== "")
            writer.tag(271, WireType.LengthDelimited).string(message.clientSilenceMd5);
        /* ResVersionConfig res_version_config = 933; */
        if (message.resVersionConfig)
            ResVersionConfig.internalBinaryWrite(message.resVersionConfig, writer.tag(933, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, BlockInfo> block_info_map = 1156; */
        for (let k of Object.keys(message.blockInfoMap)) {
            writer.tag(1156, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            BlockInfo.internalBinaryWrite(message.blockInfoMap[k as any], writer, options);
            writer.join().join();
        }
        /* string client_version_suffix = 1984; */
        if (message.clientVersionSuffix !== "")
            writer.tag(1984, WireType.LengthDelimited).string(message.clientVersionSuffix);
        /* string client_silence_version_suffix = 49; */
        if (message.clientSilenceVersionSuffix !== "")
            writer.tag(49, WireType.LengthDelimited).string(message.clientSilenceVersionSuffix);
        /* repeated ShortAbilityHashPair short_ability_hash_map = 364; */
        for (let i = 0; i < message.shortAbilityHashMap.length; i++)
            ShortAbilityHashPair.internalBinaryWrite(message.shortAbilityHashMap[i], writer.tag(364, WireType.LengthDelimited).fork(), options).join();
        /* bytes sc_info = 2014; */
        if (message.scInfo.length)
            writer.tag(2014, WireType.LengthDelimited).bytes(message.scInfo);
        /* bool is_audit = 1545; */
        if (message.isAudit !== false)
            writer.tag(1545, WireType.Varint).bool(message.isAudit);
        /* bool is_sc_open = 1974; */
        if (message.isScOpen !== false)
            writer.tag(1974, WireType.Varint).bool(message.isScOpen);
        /* string register_cps = 715; */
        if (message.registerCps !== "")
            writer.tag(715, WireType.LengthDelimited).string(message.registerCps);
        /* repeated FeatureBlockInfo feature_block_info_list = 408; */
        for (let i = 0; i < message.featureBlockInfoList.length; i++)
            FeatureBlockInfo.internalBinaryWrite(message.featureBlockInfoList[i], writer.tag(408, WireType.LengthDelimited).fork(), options).join();
        /* bool is_data_need_relogin = 110; */
        if (message.isDataNeedRelogin !== false)
            writer.tag(110, WireType.Varint).bool(message.isDataNeedRelogin);
        /* string country_code = 1306; */
        if (message.countryCode !== "")
            writer.tag(1306, WireType.LengthDelimited).string(message.countryCode);
        /* ResVersionConfig next_res_version_config = 749; */
        if (message.nextResVersionConfig)
            ResVersionConfig.internalBinaryWrite(message.nextResVersionConfig, writer.tag(749, WireType.LengthDelimited).fork(), options).join();
        /* string next_resource_url = 1744; */
        if (message.nextResourceUrl !== "")
            writer.tag(1744, WireType.LengthDelimited).string(message.nextResourceUrl);
        /* uint32 target_home_owner_uid = 945; */
        if (message.targetHomeOwnerUid !== 0)
            writer.tag(945, WireType.Varint).uint32(message.targetHomeOwnerUid);
        /* bool is_enable_client_hash_debug = 713; */
        if (message.isEnableClientHashDebug !== false)
            writer.tag(713, WireType.Varint).bool(message.isEnableClientHashDebug);
        /* bool is_transfer = 138; */
        if (message.isTransfer !== false)
            writer.tag(138, WireType.Varint).bool(message.isTransfer);
        /* double total_tick_time = 1923; */
        if (message.totalTickTime !== 0)
            writer.tag(1923, WireType.Bit64).double(message.totalTickTime);
        /* string birthday = 1977; */
        if (message.birthday !== "")
            writer.tag(1977, WireType.LengthDelimited).string(message.birthday);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerLoginRsp
 */
export const PlayerLoginRsp = new PlayerLoginRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerPropNotify$Type extends MessageType<PlayerPropNotify> {
    constructor() {
        super("PlayerPropNotify", [
            { no: 10, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } }
        ]);
    }
    create(value?: PartialMessage<PlayerPropNotify>): PlayerPropNotify {
        const message = { propMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerPropNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerPropNotify): PlayerPropNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, PropValue> prop_map */ 10:
                    this.binaryReadMap10(message.propMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: PlayerPropNotify["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerPropNotify["propMap"] | undefined, val: PlayerPropNotify["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field PlayerPropNotify.prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    internalBinaryWrite(message: PlayerPropNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, PropValue> prop_map = 10; */
        for (let k of Object.keys(message.propMap)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.propMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerPropNotify
 */
export const PlayerPropNotify = new PlayerPropNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerQuitDungeonReq$Type extends MessageType<PlayerQuitDungeonReq> {
    constructor() {
        super("PlayerQuitDungeonReq", [
            { no: 12, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_quit_immediately", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerQuitDungeonReq>): PlayerQuitDungeonReq {
        const message = { pointId: 0, isQuitImmediately: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerQuitDungeonReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerQuitDungeonReq): PlayerQuitDungeonReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 point_id */ 12:
                    message.pointId = reader.uint32();
                    break;
                case /* bool is_quit_immediately */ 4:
                    message.isQuitImmediately = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerQuitDungeonReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 point_id = 12; */
        if (message.pointId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.pointId);
        /* bool is_quit_immediately = 4; */
        if (message.isQuitImmediately !== false)
            writer.tag(4, WireType.Varint).bool(message.isQuitImmediately);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerQuitDungeonReq
 */
export const PlayerQuitDungeonReq = new PlayerQuitDungeonReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerQuitDungeonRsp$Type extends MessageType<PlayerQuitDungeonRsp> {
    constructor() {
        super("PlayerQuitDungeonRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerQuitDungeonRsp>): PlayerQuitDungeonRsp {
        const message = { retcode: 0, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerQuitDungeonRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerQuitDungeonRsp): PlayerQuitDungeonRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 point_id */ 6:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerQuitDungeonRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint32 point_id = 6; */
        if (message.pointId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerQuitDungeonRsp
 */
export const PlayerQuitDungeonRsp = new PlayerQuitDungeonRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerRTTInfo$Type extends MessageType<PlayerRTTInfo> {
    constructor() {
        super("PlayerRTTInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rtt", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerRTTInfo>): PlayerRTTInfo {
        const message = { uid: 0, rtt: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerRTTInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerRTTInfo): PlayerRTTInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 rtt */ 2:
                    message.rtt = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerRTTInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint32 rtt = 2; */
        if (message.rtt !== 0)
            writer.tag(2, WireType.Varint).uint32(message.rtt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerRTTInfo
 */
export const PlayerRTTInfo = new PlayerRTTInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerSetPauseReq$Type extends MessageType<PlayerSetPauseReq> {
    constructor() {
        super("PlayerSetPauseReq", [
            { no: 7, name: "is_paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerSetPauseReq>): PlayerSetPauseReq {
        const message = { isPaused: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerSetPauseReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerSetPauseReq): PlayerSetPauseReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_paused */ 7:
                    message.isPaused = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerSetPauseReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_paused = 7; */
        if (message.isPaused !== false)
            writer.tag(7, WireType.Varint).bool(message.isPaused);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerSetPauseReq
 */
export const PlayerSetPauseReq = new PlayerSetPauseReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerStoreNotify$Type extends MessageType<PlayerStoreNotify> {
    constructor() {
        super("PlayerStoreNotify", [
            { no: 4, name: "store_type", kind: "enum", T: () => ["StoreType", StoreType, "STORE_TYPE_"] },
            { no: 3, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Item },
            { no: 15, name: "weight_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerStoreNotify>): PlayerStoreNotify {
        const message = { storeType: 0, itemList: [], weightLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerStoreNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerStoreNotify): PlayerStoreNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StoreType store_type */ 4:
                    message.storeType = reader.int32();
                    break;
                case /* repeated Item item_list */ 3:
                    message.itemList.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 weight_limit */ 15:
                    message.weightLimit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerStoreNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StoreType store_type = 4; */
        if (message.storeType !== 0)
            writer.tag(4, WireType.Varint).int32(message.storeType);
        /* repeated Item item_list = 3; */
        for (let i = 0; i < message.itemList.length; i++)
            Item.internalBinaryWrite(message.itemList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 weight_limit = 15; */
        if (message.weightLimit !== 0)
            writer.tag(15, WireType.Varint).uint32(message.weightLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerStoreNotify
 */
export const PlayerStoreNotify = new PlayerStoreNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerTimeNotify$Type extends MessageType<PlayerTimeNotify> {
    constructor() {
        super("PlayerTimeNotify", [
            { no: 8, name: "is_paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "player_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "server_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerTimeNotify>): PlayerTimeNotify {
        const message = { isPaused: false, playerTime: 0n, serverTime: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerTimeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerTimeNotify): PlayerTimeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_paused */ 8:
                    message.isPaused = reader.bool();
                    break;
                case /* uint64 player_time */ 4:
                    message.playerTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 server_time */ 14:
                    message.serverTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerTimeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_paused = 8; */
        if (message.isPaused !== false)
            writer.tag(8, WireType.Varint).bool(message.isPaused);
        /* uint64 player_time = 4; */
        if (message.playerTime !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.playerTime);
        /* uint64 server_time = 14; */
        if (message.serverTime !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.serverTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerTimeNotify
 */
export const PlayerTimeNotify = new PlayerTimeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerWorldLocationInfo$Type extends MessageType<PlayerWorldLocationInfo> {
    constructor() {
        super("PlayerWorldLocationInfo", [
            { no: 1, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_loc", kind: "message", T: () => PlayerLocationInfo }
        ]);
    }
    create(value?: PartialMessage<PlayerWorldLocationInfo>): PlayerWorldLocationInfo {
        const message = { sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerWorldLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerWorldLocationInfo): PlayerWorldLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 1:
                    message.sceneId = reader.uint32();
                    break;
                case /* PlayerLocationInfo player_loc */ 2:
                    message.playerLoc = PlayerLocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.playerLoc);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerWorldLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 1; */
        if (message.sceneId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sceneId);
        /* PlayerLocationInfo player_loc = 2; */
        if (message.playerLoc)
            PlayerLocationInfo.internalBinaryWrite(message.playerLoc, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerWorldLocationInfo
 */
export const PlayerWorldLocationInfo = new PlayerWorldLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerWorldSceneInfo$Type extends MessageType<PlayerWorldSceneInfo> {
    constructor() {
        super("PlayerWorldSceneInfo", [
            { no: 13, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "scene_tag_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerWorldSceneInfo>): PlayerWorldSceneInfo {
        const message = { sceneId: 0, isLocked: false, sceneTagIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerWorldSceneInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerWorldSceneInfo): PlayerWorldSceneInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 13:
                    message.sceneId = reader.uint32();
                    break;
                case /* bool is_locked */ 6:
                    message.isLocked = reader.bool();
                    break;
                case /* repeated uint32 scene_tag_id_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sceneTagIdList.push(reader.uint32());
                    else
                        message.sceneTagIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerWorldSceneInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 13; */
        if (message.sceneId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.sceneId);
        /* bool is_locked = 6; */
        if (message.isLocked !== false)
            writer.tag(6, WireType.Varint).bool(message.isLocked);
        /* repeated uint32 scene_tag_id_list = 9; */
        if (message.sceneTagIdList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sceneTagIdList.length; i++)
                writer.uint32(message.sceneTagIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerWorldSceneInfo
 */
export const PlayerWorldSceneInfo = new PlayerWorldSceneInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerWorldSceneInfoListNotify$Type extends MessageType<PlayerWorldSceneInfoListNotify> {
    constructor() {
        super("PlayerWorldSceneInfoListNotify", [
            { no: 5, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayerWorldSceneInfo }
        ]);
    }
    create(value?: PartialMessage<PlayerWorldSceneInfoListNotify>): PlayerWorldSceneInfoListNotify {
        const message = { infoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerWorldSceneInfoListNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerWorldSceneInfoListNotify): PlayerWorldSceneInfoListNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PlayerWorldSceneInfo info_list */ 5:
                    message.infoList.push(PlayerWorldSceneInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerWorldSceneInfoListNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PlayerWorldSceneInfo info_list = 5; */
        for (let i = 0; i < message.infoList.length; i++)
            PlayerWorldSceneInfo.internalBinaryWrite(message.infoList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerWorldSceneInfoListNotify
 */
export const PlayerWorldSceneInfoListNotify = new PlayerWorldSceneInfoListNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayTeamEntityInfo$Type extends MessageType<PlayTeamEntityInfo> {
    constructor() {
        super("PlayTeamEntityInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "authority_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gadget_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "ability_info", kind: "message", T: () => AbilitySyncStateInfo }
        ]);
    }
    create(value?: PartialMessage<PlayTeamEntityInfo>): PlayTeamEntityInfo {
        const message = { entityId: 0, playerUid: 0, authorityPeerId: 0, gadgetConfigId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayTeamEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayTeamEntityInfo): PlayTeamEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 player_uid */ 2:
                    message.playerUid = reader.uint32();
                    break;
                case /* uint32 authority_peer_id */ 3:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* uint32 gadget_config_id */ 5:
                    message.gadgetConfigId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo ability_info */ 6:
                    message.abilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.abilityInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayTeamEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* uint32 player_uid = 2; */
        if (message.playerUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.playerUid);
        /* uint32 authority_peer_id = 3; */
        if (message.authorityPeerId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.authorityPeerId);
        /* uint32 gadget_config_id = 5; */
        if (message.gadgetConfigId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.gadgetConfigId);
        /* AbilitySyncStateInfo ability_info = 6; */
        if (message.abilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.abilityInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayTeamEntityInfo
 */
export const PlayTeamEntityInfo = new PlayTeamEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostEnterSceneRsp$Type extends MessageType<PostEnterSceneRsp> {
    constructor() {
        super("PostEnterSceneRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PostEnterSceneRsp>): PostEnterSceneRsp {
        const message = { retcode: 0, enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostEnterSceneRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostEnterSceneRsp): PostEnterSceneRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 enter_scene_token */ 15:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostEnterSceneRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 enter_scene_token = 15; */
        if (message.enterSceneToken !== 0)
            writer.tag(15, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PostEnterSceneRsp
 */
export const PostEnterSceneRsp = new PostEnterSceneRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PotionDungeonResultInfo$Type extends MessageType<PotionDungeonResultInfo> {
    constructor() {
        super("PotionDungeonResultInfo", [
            { no: 8, name: "final_score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "left_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "Unk2700_FHEHGDABALE", kind: "scalar", jsonName: "Unk2700FHEHGDABALE", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "Unk2700_HKFEBBCMBHL", kind: "scalar", jsonName: "Unk2700HKFEBBCMBHL", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "level_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stage_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PotionDungeonResultInfo>): PotionDungeonResultInfo {
        const message = { finalScore: 0, leftTime: 0, unk2700FHEHGDABALE: 0, unk2700HKFEBBCMBHL: 0, levelId: 0, stageId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PotionDungeonResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PotionDungeonResultInfo): PotionDungeonResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 final_score */ 8:
                    message.finalScore = reader.uint32();
                    break;
                case /* uint32 left_time */ 9:
                    message.leftTime = reader.uint32();
                    break;
                case /* uint32 Unk2700_FHEHGDABALE = 14 [json_name = "Unk2700FHEHGDABALE"];*/ 14:
                    message.unk2700FHEHGDABALE = reader.uint32();
                    break;
                case /* uint32 Unk2700_HKFEBBCMBHL = 11 [json_name = "Unk2700HKFEBBCMBHL"];*/ 11:
                    message.unk2700HKFEBBCMBHL = reader.uint32();
                    break;
                case /* uint32 level_id */ 4:
                    message.levelId = reader.uint32();
                    break;
                case /* uint32 stage_id */ 2:
                    message.stageId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PotionDungeonResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 final_score = 8; */
        if (message.finalScore !== 0)
            writer.tag(8, WireType.Varint).uint32(message.finalScore);
        /* uint32 left_time = 9; */
        if (message.leftTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.leftTime);
        /* uint32 Unk2700_FHEHGDABALE = 14 [json_name = "Unk2700FHEHGDABALE"]; */
        if (message.unk2700FHEHGDABALE !== 0)
            writer.tag(14, WireType.Varint).uint32(message.unk2700FHEHGDABALE);
        /* uint32 Unk2700_HKFEBBCMBHL = 11 [json_name = "Unk2700HKFEBBCMBHL"]; */
        if (message.unk2700HKFEBBCMBHL !== 0)
            writer.tag(11, WireType.Varint).uint32(message.unk2700HKFEBBCMBHL);
        /* uint32 level_id = 4; */
        if (message.levelId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.levelId);
        /* uint32 stage_id = 2; */
        if (message.stageId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.stageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PotionDungeonResultInfo
 */
export const PotionDungeonResultInfo = new PotionDungeonResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateChatNotify$Type extends MessageType<PrivateChatNotify> {
    constructor() {
        super("PrivateChatNotify", [
            { no: 1, name: "chat_info", kind: "message", T: () => ChatInfo }
        ]);
    }
    create(value?: PartialMessage<PrivateChatNotify>): PrivateChatNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PrivateChatNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateChatNotify): PrivateChatNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ChatInfo chat_info */ 1:
                    message.chatInfo = ChatInfo.internalBinaryRead(reader, reader.uint32(), options, message.chatInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateChatNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ChatInfo chat_info = 1; */
        if (message.chatInfo)
            ChatInfo.internalBinaryWrite(message.chatInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PrivateChatNotify
 */
export const PrivateChatNotify = new PrivateChatNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateChatReq$Type extends MessageType<PrivateChatReq> {
    constructor() {
        super("PrivateChatReq", [
            { no: 2, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "text", kind: "scalar", oneof: "content", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "icon", kind: "scalar", oneof: "content", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PrivateChatReq>): PrivateChatReq {
        const message = { targetUid: 0, content: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PrivateChatReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateChatReq): PrivateChatReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 2:
                    message.targetUid = reader.uint32();
                    break;
                case /* string text */ 8:
                    message.content = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* uint32 icon */ 6:
                    message.content = {
                        oneofKind: "icon",
                        icon: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateChatReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 2; */
        if (message.targetUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetUid);
        /* string text = 8; */
        if (message.content.oneofKind === "text")
            writer.tag(8, WireType.LengthDelimited).string(message.content.text);
        /* uint32 icon = 6; */
        if (message.content.oneofKind === "icon")
            writer.tag(6, WireType.Varint).uint32(message.content.icon);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PrivateChatReq
 */
export const PrivateChatReq = new PrivateChatReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateChatRsp$Type extends MessageType<PrivateChatRsp> {
    constructor() {
        super("PrivateChatRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "chat_forbidden_endtime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PrivateChatRsp>): PrivateChatRsp {
        const message = { retcode: 0, chatForbiddenEndtime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PrivateChatRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateChatRsp): PrivateChatRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 chat_forbidden_endtime */ 10:
                    message.chatForbiddenEndtime = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateChatRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint32 chat_forbidden_endtime = 10; */
        if (message.chatForbiddenEndtime !== 0)
            writer.tag(10, WireType.Varint).uint32(message.chatForbiddenEndtime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PrivateChatRsp
 */
export const PrivateChatRsp = new PrivateChatRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProfilePicture$Type extends MessageType<ProfilePicture> {
    constructor() {
        super("ProfilePicture", [
            { no: 1, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProfilePicture>): ProfilePicture {
        const message = { avatarId: 0, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProfilePicture>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProfilePicture): ProfilePicture {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 1:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint32 costume_id */ 2:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProfilePicture, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 1; */
        if (message.avatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.avatarId);
        /* uint32 costume_id = 2; */
        if (message.costumeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProfilePicture
 */
export const ProfilePicture = new ProfilePicture$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropPair$Type extends MessageType<PropPair> {
    constructor() {
        super("PropPair", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "prop_value", kind: "message", T: () => PropValue }
        ]);
    }
    create(value?: PartialMessage<PropPair>): PropPair {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropPair): PropPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* PropValue prop_value */ 2:
                    message.propValue = PropValue.internalBinaryRead(reader, reader.uint32(), options, message.propValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* PropValue prop_value = 2; */
        if (message.propValue)
            PropValue.internalBinaryWrite(message.propValue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PropPair
 */
export const PropPair = new PropPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropValue$Type extends MessageType<PropValue> {
    constructor() {
        super("PropValue", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "val", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ival", kind: "scalar", oneof: "value", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "fval", kind: "scalar", oneof: "value", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PropValue>): PropValue {
        const message = { type: 0, val: 0n, value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PropValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PropValue): PropValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* int64 val */ 4:
                    message.val = reader.int64().toBigInt();
                    break;
                case /* int64 ival */ 2:
                    message.value = {
                        oneofKind: "ival",
                        ival: reader.int64().toBigInt()
                    };
                    break;
                case /* float fval */ 3:
                    message.value = {
                        oneofKind: "fval",
                        fval: reader.float()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PropValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* int64 val = 4; */
        if (message.val !== 0n)
            writer.tag(4, WireType.Varint).int64(message.val);
        /* int64 ival = 2; */
        if (message.value.oneofKind === "ival")
            writer.tag(2, WireType.Varint).int64(message.value.ival);
        /* float fval = 3; */
        if (message.value.oneofKind === "fval")
            writer.tag(3, WireType.Bit32).float(message.value.fval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PropValue
 */
export const PropValue = new PropValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProudSkillChangeNotify$Type extends MessageType<ProudSkillChangeNotify> {
    constructor() {
        super("ProudSkillChangeNotify", [
            { no: 12, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "proud_skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProudSkillChangeNotify>): ProudSkillChangeNotify {
        const message = { avatarGuid: 0n, entityId: 0, skillDepotId: 0, proudSkillList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProudSkillChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProudSkillChangeNotify): ProudSkillChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 12:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 entity_id */ 11:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 skill_depot_id */ 7:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* repeated uint32 proud_skill_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.proudSkillList.push(reader.uint32());
                    else
                        message.proudSkillList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProudSkillChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 12; */
        if (message.avatarGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 entity_id = 11; */
        if (message.entityId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.entityId);
        /* uint32 skill_depot_id = 7; */
        if (message.skillDepotId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.skillDepotId);
        /* repeated uint32 proud_skill_list = 4; */
        if (message.proudSkillList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.proudSkillList.length; i++)
                writer.uint32(message.proudSkillList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProudSkillChangeNotify
 */
export const ProudSkillChangeNotify = new ProudSkillChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProudSkillExtraLevelNotify$Type extends MessageType<ProudSkillExtraLevelNotify> {
    constructor() {
        super("ProudSkillExtraLevelNotify", [
            { no: 14, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "talent_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "talent_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "extra_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProudSkillExtraLevelNotify>): ProudSkillExtraLevelNotify {
        const message = { avatarGuid: 0n, talentType: 0, talentIndex: 0, extraLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProudSkillExtraLevelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProudSkillExtraLevelNotify): ProudSkillExtraLevelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 14:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 talent_type */ 10:
                    message.talentType = reader.uint32();
                    break;
                case /* uint32 talent_index */ 4:
                    message.talentIndex = reader.uint32();
                    break;
                case /* uint32 extra_level */ 5:
                    message.extraLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProudSkillExtraLevelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 14; */
        if (message.avatarGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 talent_type = 10; */
        if (message.talentType !== 0)
            writer.tag(10, WireType.Varint).uint32(message.talentType);
        /* uint32 talent_index = 4; */
        if (message.talentIndex !== 0)
            writer.tag(4, WireType.Varint).uint32(message.talentIndex);
        /* uint32 extra_level = 5; */
        if (message.extraLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.extraLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProudSkillExtraLevelNotify
 */
export const ProudSkillExtraLevelNotify = new ProudSkillExtraLevelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PullPrivateChatReq$Type extends MessageType<PullPrivateChatReq> {
    constructor() {
        super("PullPrivateChatReq", [
            { no: 2, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "from_sequence", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "pull_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PullPrivateChatReq>): PullPrivateChatReq {
        const message = { targetUid: 0, fromSequence: 0, pullNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PullPrivateChatReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PullPrivateChatReq): PullPrivateChatReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 2:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint32 from_sequence */ 7:
                    message.fromSequence = reader.uint32();
                    break;
                case /* uint32 pull_num */ 5:
                    message.pullNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PullPrivateChatReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 2; */
        if (message.targetUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetUid);
        /* uint32 from_sequence = 7; */
        if (message.fromSequence !== 0)
            writer.tag(7, WireType.Varint).uint32(message.fromSequence);
        /* uint32 pull_num = 5; */
        if (message.pullNum !== 0)
            writer.tag(5, WireType.Varint).uint32(message.pullNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PullPrivateChatReq
 */
export const PullPrivateChatReq = new PullPrivateChatReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PullPrivateChatRsp$Type extends MessageType<PullPrivateChatRsp> {
    constructor() {
        super("PullPrivateChatRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "chat_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChatInfo }
        ]);
    }
    create(value?: PartialMessage<PullPrivateChatRsp>): PullPrivateChatRsp {
        const message = { retcode: 0, chatInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PullPrivateChatRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PullPrivateChatRsp): PullPrivateChatRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* repeated ChatInfo chat_info */ 12:
                    message.chatInfo.push(ChatInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PullPrivateChatRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* repeated ChatInfo chat_info = 12; */
        for (let i = 0; i < message.chatInfo.length; i++)
            ChatInfo.internalBinaryWrite(message.chatInfo[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PullPrivateChatRsp
 */
export const PullPrivateChatRsp = new PullPrivateChatRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PullRecentChatRsp$Type extends MessageType<PullRecentChatRsp> {
    constructor() {
        super("PullRecentChatRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "chat_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChatInfo }
        ]);
    }
    create(value?: PartialMessage<PullRecentChatRsp>): PullRecentChatRsp {
        const message = { retcode: 0, chatInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PullRecentChatRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PullRecentChatRsp): PullRecentChatRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* repeated ChatInfo chat_info */ 12:
                    message.chatInfo.push(ChatInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PullRecentChatRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* repeated ChatInfo chat_info = 12; */
        for (let i = 0; i < message.chatInfo.length; i++)
            ChatInfo.internalBinaryWrite(message.chatInfo[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PullRecentChatRsp
 */
export const PullRecentChatRsp = new PullRecentChatRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCodexMonsterBeKilledNumReq$Type extends MessageType<QueryCodexMonsterBeKilledNumReq> {
    constructor() {
        super("QueryCodexMonsterBeKilledNumReq", [
            { no: 11, name: "codex_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryCodexMonsterBeKilledNumReq>): QueryCodexMonsterBeKilledNumReq {
        const message = { codexIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCodexMonsterBeKilledNumReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCodexMonsterBeKilledNumReq): QueryCodexMonsterBeKilledNumReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 codex_id_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.codexIdList.push(reader.uint32());
                    else
                        message.codexIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCodexMonsterBeKilledNumReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 codex_id_list = 11; */
        if (message.codexIdList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.codexIdList.length; i++)
                writer.uint32(message.codexIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryCodexMonsterBeKilledNumReq
 */
export const QueryCodexMonsterBeKilledNumReq = new QueryCodexMonsterBeKilledNumReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCodexMonsterBeKilledNumRsp$Type extends MessageType<QueryCodexMonsterBeKilledNumRsp> {
    constructor() {
        super("QueryCodexMonsterBeKilledNumRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "codex_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "be_killed_num_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "CHPBKCLKPCJ", kind: "scalar", jsonName: "CHPBKCLKPCJ", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryCodexMonsterBeKilledNumRsp>): QueryCodexMonsterBeKilledNumRsp {
        const message = { retcode: 0, codexIdList: [], beKilledNumList: [], cHPBKCLKPCJ: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCodexMonsterBeKilledNumRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCodexMonsterBeKilledNumRsp): QueryCodexMonsterBeKilledNumRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 codex_id_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.codexIdList.push(reader.uint32());
                    else
                        message.codexIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 be_killed_num_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.beKilledNumList.push(reader.uint32());
                    else
                        message.beKilledNumList.push(reader.uint32());
                    break;
                case /* repeated uint32 CHPBKCLKPCJ = 2 [json_name = "CHPBKCLKPCJ"];*/ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cHPBKCLKPCJ.push(reader.uint32());
                    else
                        message.cHPBKCLKPCJ.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCodexMonsterBeKilledNumRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* repeated uint32 codex_id_list = 4; */
        if (message.codexIdList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.codexIdList.length; i++)
                writer.uint32(message.codexIdList[i]);
            writer.join();
        }
        /* repeated uint32 be_killed_num_list = 11; */
        if (message.beKilledNumList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.beKilledNumList.length; i++)
                writer.uint32(message.beKilledNumList[i]);
            writer.join();
        }
        /* repeated uint32 CHPBKCLKPCJ = 2 [json_name = "CHPBKCLKPCJ"]; */
        if (message.cHPBKCLKPCJ.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cHPBKCLKPCJ.length; i++)
                writer.uint32(message.cHPBKCLKPCJ[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryCodexMonsterBeKilledNumRsp
 */
export const QueryCodexMonsterBeKilledNumRsp = new QueryCodexMonsterBeKilledNumRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCurrRegionHttpRsp$Type extends MessageType<QueryCurrRegionHttpRsp> {
    constructor() {
        super("QueryCurrRegionHttpRsp", [
            { no: 4, name: "force_udpate", kind: "message", oneof: "detail", T: () => ForceUpdateInfo },
            { no: 5, name: "stop_server", kind: "message", oneof: "detail", T: () => StopServerInfo },
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "region_info", kind: "message", T: () => RegionInfo },
            { no: 11, name: "client_secret_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "region_custom_config_encrypted", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 13, name: "client_region_custom_config_encrypted", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<QueryCurrRegionHttpRsp>): QueryCurrRegionHttpRsp {
        const message = { detail: { oneofKind: undefined }, retcode: 0, msg: "", clientSecretKey: new Uint8Array(0), regionCustomConfigEncrypted: new Uint8Array(0), clientRegionCustomConfigEncrypted: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCurrRegionHttpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCurrRegionHttpRsp): QueryCurrRegionHttpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ForceUpdateInfo force_udpate */ 4:
                    message.detail = {
                        oneofKind: "forceUdpate",
                        forceUdpate: ForceUpdateInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).forceUdpate)
                    };
                    break;
                case /* StopServerInfo stop_server */ 5:
                    message.detail = {
                        oneofKind: "stopServer",
                        stopServer: StopServerInfo.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).stopServer)
                    };
                    break;
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                case /* RegionInfo region_info */ 3:
                    message.regionInfo = RegionInfo.internalBinaryRead(reader, reader.uint32(), options, message.regionInfo);
                    break;
                case /* bytes client_secret_key */ 11:
                    message.clientSecretKey = reader.bytes();
                    break;
                case /* bytes region_custom_config_encrypted */ 12:
                    message.regionCustomConfigEncrypted = reader.bytes();
                    break;
                case /* bytes client_region_custom_config_encrypted */ 13:
                    message.clientRegionCustomConfigEncrypted = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCurrRegionHttpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ForceUpdateInfo force_udpate = 4; */
        if (message.detail.oneofKind === "forceUdpate")
            ForceUpdateInfo.internalBinaryWrite(message.detail.forceUdpate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* StopServerInfo stop_server = 5; */
        if (message.detail.oneofKind === "stopServer")
            StopServerInfo.internalBinaryWrite(message.detail.stopServer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        /* RegionInfo region_info = 3; */
        if (message.regionInfo)
            RegionInfo.internalBinaryWrite(message.regionInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes client_secret_key = 11; */
        if (message.clientSecretKey.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.clientSecretKey);
        /* bytes region_custom_config_encrypted = 12; */
        if (message.regionCustomConfigEncrypted.length)
            writer.tag(12, WireType.LengthDelimited).bytes(message.regionCustomConfigEncrypted);
        /* bytes client_region_custom_config_encrypted = 13; */
        if (message.clientRegionCustomConfigEncrypted.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.clientRegionCustomConfigEncrypted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryCurrRegionHttpRsp
 */
export const QueryCurrRegionHttpRsp = new QueryCurrRegionHttpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryFilter$Type extends MessageType<QueryFilter> {
    constructor() {
        super("QueryFilter", [
            { no: 2, name: "type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "area_mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryFilter>): QueryFilter {
        const message = { typeId: 0, areaMask: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryFilter): QueryFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* int32 area_mask */ 14:
                    message.areaMask = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type_id = 2; */
        if (message.typeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.typeId);
        /* int32 area_mask = 14; */
        if (message.areaMask !== 0)
            writer.tag(14, WireType.Varint).int32(message.areaMask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryFilter
 */
export const QueryFilter = new QueryFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPathReq$Type extends MessageType<QueryPathReq> {
    constructor() {
        super("QueryPathReq", [
            { no: 9, name: "query_type", kind: "enum", T: () => ["QueryPathReq.OptionType", QueryPathReq_OptionType, "OPTION_TYPE_"] },
            { no: 4, name: "query_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "source_pos", kind: "message", T: () => Vector },
            { no: 11, name: "destination_pos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Vector },
            { no: 5, name: "filter", kind: "message", T: () => QueryFilter },
            { no: 7, name: "destination_extend", kind: "message", T: () => Vector3Int },
            { no: 15, name: "source_extend", kind: "message", T: () => Vector3Int }
        ]);
    }
    create(value?: PartialMessage<QueryPathReq>): QueryPathReq {
        const message = { queryType: 0, queryId: 0, sceneId: 0, destinationPos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPathReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPathReq): QueryPathReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* QueryPathReq.OptionType query_type */ 9:
                    message.queryType = reader.int32();
                    break;
                case /* int32 query_id */ 4:
                    message.queryId = reader.int32();
                    break;
                case /* uint32 scene_id */ 8:
                    message.sceneId = reader.uint32();
                    break;
                case /* Vector source_pos */ 14:
                    message.sourcePos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.sourcePos);
                    break;
                case /* repeated Vector destination_pos */ 11:
                    message.destinationPos.push(Vector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* QueryFilter filter */ 5:
                    message.filter = QueryFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* Vector3Int destination_extend */ 7:
                    message.destinationExtend = Vector3Int.internalBinaryRead(reader, reader.uint32(), options, message.destinationExtend);
                    break;
                case /* Vector3Int source_extend */ 15:
                    message.sourceExtend = Vector3Int.internalBinaryRead(reader, reader.uint32(), options, message.sourceExtend);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPathReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* QueryPathReq.OptionType query_type = 9; */
        if (message.queryType !== 0)
            writer.tag(9, WireType.Varint).int32(message.queryType);
        /* int32 query_id = 4; */
        if (message.queryId !== 0)
            writer.tag(4, WireType.Varint).int32(message.queryId);
        /* uint32 scene_id = 8; */
        if (message.sceneId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.sceneId);
        /* Vector source_pos = 14; */
        if (message.sourcePos)
            Vector.internalBinaryWrite(message.sourcePos, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated Vector destination_pos = 11; */
        for (let i = 0; i < message.destinationPos.length; i++)
            Vector.internalBinaryWrite(message.destinationPos[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* QueryFilter filter = 5; */
        if (message.filter)
            QueryFilter.internalBinaryWrite(message.filter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Vector3Int destination_extend = 7; */
        if (message.destinationExtend)
            Vector3Int.internalBinaryWrite(message.destinationExtend, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* Vector3Int source_extend = 15; */
        if (message.sourceExtend)
            Vector3Int.internalBinaryWrite(message.sourceExtend, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryPathReq
 */
export const QueryPathReq = new QueryPathReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPathRsp$Type extends MessageType<QueryPathRsp> {
    constructor() {
        super("QueryPathRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "query_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "query_status", kind: "enum", T: () => ["QueryPathRsp.PathStatusType", QueryPathRsp_PathStatusType, "PATH_STATUS_TYPE_"] },
            { no: 12, name: "corners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<QueryPathRsp>): QueryPathRsp {
        const message = { retcode: 0, queryId: 0, queryStatus: 0, corners: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPathRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPathRsp): QueryPathRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* int32 query_id */ 2:
                    message.queryId = reader.int32();
                    break;
                case /* QueryPathRsp.PathStatusType query_status */ 5:
                    message.queryStatus = reader.int32();
                    break;
                case /* repeated Vector corners */ 12:
                    message.corners.push(Vector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPathRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* int32 query_id = 2; */
        if (message.queryId !== 0)
            writer.tag(2, WireType.Varint).int32(message.queryId);
        /* QueryPathRsp.PathStatusType query_status = 5; */
        if (message.queryStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.queryStatus);
        /* repeated Vector corners = 12; */
        for (let i = 0; i < message.corners.length; i++)
            Vector.internalBinaryWrite(message.corners[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryPathRsp
 */
export const QueryPathRsp = new QueryPathRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRegionListHttpRsp$Type extends MessageType<QueryRegionListHttpRsp> {
    constructor() {
        super("QueryRegionListHttpRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "region_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RegionSimpleInfo },
            { no: 5, name: "client_secret_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "client_custom_config_encrypted", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "enable_login_pc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRegionListHttpRsp>): QueryRegionListHttpRsp {
        const message = { retcode: 0, regionList: [], clientSecretKey: new Uint8Array(0), clientCustomConfigEncrypted: new Uint8Array(0), enableLoginPc: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryRegionListHttpRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRegionListHttpRsp): QueryRegionListHttpRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* repeated RegionSimpleInfo region_list */ 2:
                    message.regionList.push(RegionSimpleInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes client_secret_key */ 5:
                    message.clientSecretKey = reader.bytes();
                    break;
                case /* bytes client_custom_config_encrypted */ 6:
                    message.clientCustomConfigEncrypted = reader.bytes();
                    break;
                case /* bool enable_login_pc */ 7:
                    message.enableLoginPc = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRegionListHttpRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* repeated RegionSimpleInfo region_list = 2; */
        for (let i = 0; i < message.regionList.length; i++)
            RegionSimpleInfo.internalBinaryWrite(message.regionList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes client_secret_key = 5; */
        if (message.clientSecretKey.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.clientSecretKey);
        /* bytes client_custom_config_encrypted = 6; */
        if (message.clientCustomConfigEncrypted.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.clientCustomConfigEncrypted);
        /* bool enable_login_pc = 7; */
        if (message.enableLoginPc !== false)
            writer.tag(7, WireType.Varint).bool(message.enableLoginPc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryRegionListHttpRsp
 */
export const QueryRegionListHttpRsp = new QueryRegionListHttpRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quest$Type extends MessageType<Quest> {
    constructor() {
        super("Quest", [
            { no: 1, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_random", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "quest_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "start_game_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "accept_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "lacked_npc_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "finish_progress_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "fail_progress_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "lacked_npc_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 14, name: "lacked_place_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "lacked_place_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<Quest>): Quest {
        const message = { questId: 0, state: 0, startTime: 0, isRandom: false, parentQuestId: 0, questConfigId: 0, startGameTime: 0, acceptTime: 0, lackedNpcList: [], finishProgressList: [], failProgressList: [], lackedNpcMap: {}, lackedPlaceList: [], lackedPlaceMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Quest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quest): Quest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 1:
                    message.questId = reader.uint32();
                    break;
                case /* uint32 state */ 2:
                    message.state = reader.uint32();
                    break;
                case /* uint32 start_time */ 4:
                    message.startTime = reader.uint32();
                    break;
                case /* bool is_random */ 5:
                    message.isRandom = reader.bool();
                    break;
                case /* uint32 parent_quest_id */ 6:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* uint32 quest_config_id */ 7:
                    message.questConfigId = reader.uint32();
                    break;
                case /* uint32 start_game_time */ 8:
                    message.startGameTime = reader.uint32();
                    break;
                case /* uint32 accept_time */ 9:
                    message.acceptTime = reader.uint32();
                    break;
                case /* repeated uint32 lacked_npc_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lackedNpcList.push(reader.uint32());
                    else
                        message.lackedNpcList.push(reader.uint32());
                    break;
                case /* repeated uint32 finish_progress_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishProgressList.push(reader.uint32());
                    else
                        message.finishProgressList.push(reader.uint32());
                    break;
                case /* repeated uint32 fail_progress_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.failProgressList.push(reader.uint32());
                    else
                        message.failProgressList.push(reader.uint32());
                    break;
                case /* map<uint32, uint32> lacked_npc_map */ 13:
                    this.binaryReadMap13(message.lackedNpcMap, reader, options);
                    break;
                case /* repeated uint32 lacked_place_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lackedPlaceList.push(reader.uint32());
                    else
                        message.lackedPlaceList.push(reader.uint32());
                    break;
                case /* map<uint32, uint32> lacked_place_map */ 15:
                    this.binaryReadMap15(message.lackedPlaceMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: Quest["lackedNpcMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Quest["lackedNpcMap"] | undefined, val: Quest["lackedNpcMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Quest.lacked_npc_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap15(map: Quest["lackedPlaceMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Quest["lackedPlaceMap"] | undefined, val: Quest["lackedPlaceMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Quest.lacked_place_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: Quest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 1; */
        if (message.questId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.questId);
        /* uint32 state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).uint32(message.state);
        /* uint32 start_time = 4; */
        if (message.startTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.startTime);
        /* bool is_random = 5; */
        if (message.isRandom !== false)
            writer.tag(5, WireType.Varint).bool(message.isRandom);
        /* uint32 parent_quest_id = 6; */
        if (message.parentQuestId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.parentQuestId);
        /* uint32 quest_config_id = 7; */
        if (message.questConfigId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.questConfigId);
        /* uint32 start_game_time = 8; */
        if (message.startGameTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.startGameTime);
        /* uint32 accept_time = 9; */
        if (message.acceptTime !== 0)
            writer.tag(9, WireType.Varint).uint32(message.acceptTime);
        /* repeated uint32 lacked_npc_list = 10; */
        if (message.lackedNpcList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lackedNpcList.length; i++)
                writer.uint32(message.lackedNpcList[i]);
            writer.join();
        }
        /* repeated uint32 finish_progress_list = 11; */
        if (message.finishProgressList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishProgressList.length; i++)
                writer.uint32(message.finishProgressList[i]);
            writer.join();
        }
        /* repeated uint32 fail_progress_list = 12; */
        if (message.failProgressList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.failProgressList.length; i++)
                writer.uint32(message.failProgressList[i]);
            writer.join();
        }
        /* map<uint32, uint32> lacked_npc_map = 13; */
        for (let k of Object.keys(message.lackedNpcMap))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.lackedNpcMap[k as any]).join();
        /* repeated uint32 lacked_place_list = 14; */
        if (message.lackedPlaceList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lackedPlaceList.length; i++)
                writer.uint32(message.lackedPlaceList[i]);
            writer.join();
        }
        /* map<uint32, uint32> lacked_place_map = 15; */
        for (let k of Object.keys(message.lackedPlaceMap))
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.lackedPlaceMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Quest
 */
export const Quest = new Quest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestDelNotify$Type extends MessageType<QuestDelNotify> {
    constructor() {
        super("QuestDelNotify", [
            { no: 12, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestDelNotify>): QuestDelNotify {
        const message = { questId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestDelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestDelNotify): QuestDelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 12:
                    message.questId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestDelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 12; */
        if (message.questId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.questId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestDelNotify
 */
export const QuestDelNotify = new QuestDelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestGlobalVar$Type extends MessageType<QuestGlobalVar> {
    constructor() {
        super("QuestGlobalVar", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestGlobalVar>): QuestGlobalVar {
        const message = { key: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestGlobalVar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestGlobalVar): QuestGlobalVar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestGlobalVar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestGlobalVar
 */
export const QuestGlobalVar = new QuestGlobalVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestGlobalVarNotify$Type extends MessageType<QuestGlobalVarNotify> {
    constructor() {
        super("QuestGlobalVarNotify", [
            { no: 9, name: "var_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuestGlobalVar }
        ]);
    }
    create(value?: PartialMessage<QuestGlobalVarNotify>): QuestGlobalVarNotify {
        const message = { varList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestGlobalVarNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestGlobalVarNotify): QuestGlobalVarNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated QuestGlobalVar var_list */ 9:
                    message.varList.push(QuestGlobalVar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestGlobalVarNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated QuestGlobalVar var_list = 9; */
        for (let i = 0; i < message.varList.length; i++)
            QuestGlobalVar.internalBinaryWrite(message.varList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestGlobalVarNotify
 */
export const QuestGlobalVarNotify = new QuestGlobalVarNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestListNotify$Type extends MessageType<QuestListNotify> {
    constructor() {
        super("QuestListNotify", [
            { no: 12, name: "quest_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Quest }
        ]);
    }
    create(value?: PartialMessage<QuestListNotify>): QuestListNotify {
        const message = { questList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestListNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestListNotify): QuestListNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Quest quest_list */ 12:
                    message.questList.push(Quest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestListNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Quest quest_list = 12; */
        for (let i = 0; i < message.questList.length; i++)
            Quest.internalBinaryWrite(message.questList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestListNotify
 */
export const QuestListNotify = new QuestListNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestListUpdateNotify$Type extends MessageType<QuestListUpdateNotify> {
    constructor() {
        super("QuestListUpdateNotify", [
            { no: 13, name: "quest_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Quest }
        ]);
    }
    create(value?: PartialMessage<QuestListUpdateNotify>): QuestListUpdateNotify {
        const message = { questList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestListUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestListUpdateNotify): QuestListUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Quest quest_list */ 13:
                    message.questList.push(Quest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestListUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Quest quest_list = 13; */
        for (let i = 0; i < message.questList.length; i++)
            Quest.internalBinaryWrite(message.questList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestListUpdateNotify
 */
export const QuestListUpdateNotify = new QuestListUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestProgressUpdateNotify$Type extends MessageType<QuestProgressUpdateNotify> {
    constructor() {
        super("QuestProgressUpdateNotify", [
            { no: 14, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "finish_progress_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "fail_progress_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestProgressUpdateNotify>): QuestProgressUpdateNotify {
        const message = { questId: 0, finishProgressList: [], failProgressList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestProgressUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestProgressUpdateNotify): QuestProgressUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 14:
                    message.questId = reader.uint32();
                    break;
                case /* repeated uint32 finish_progress_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishProgressList.push(reader.uint32());
                    else
                        message.finishProgressList.push(reader.uint32());
                    break;
                case /* repeated uint32 fail_progress_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.failProgressList.push(reader.uint32());
                    else
                        message.failProgressList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestProgressUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 14; */
        if (message.questId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.questId);
        /* repeated uint32 finish_progress_list = 7; */
        if (message.finishProgressList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishProgressList.length; i++)
                writer.uint32(message.finishProgressList[i]);
            writer.join();
        }
        /* repeated uint32 fail_progress_list = 12; */
        if (message.failProgressList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.failProgressList.length; i++)
                writer.uint32(message.failProgressList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestProgressUpdateNotify
 */
export const QuestProgressUpdateNotify = new QuestProgressUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestUpdateQuestVarNotify$Type extends MessageType<QuestUpdateQuestVarNotify> {
    constructor() {
        super("QuestUpdateQuestVarNotify", [
            { no: 3, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "quest_var", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "parent_quest_var_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestUpdateQuestVarNotify>): QuestUpdateQuestVarNotify {
        const message = { parentQuestId: 0, questVar: [], parentQuestVarSeq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestUpdateQuestVarNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestUpdateQuestVarNotify): QuestUpdateQuestVarNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 parent_quest_id */ 3:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* repeated int32 quest_var */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.questVar.push(reader.int32());
                    else
                        message.questVar.push(reader.int32());
                    break;
                case /* uint32 parent_quest_var_seq */ 15:
                    message.parentQuestVarSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestUpdateQuestVarNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 parent_quest_id = 3; */
        if (message.parentQuestId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.parentQuestId);
        /* repeated int32 quest_var = 6; */
        if (message.questVar.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.questVar.length; i++)
                writer.int32(message.questVar[i]);
            writer.join();
        }
        /* uint32 parent_quest_var_seq = 15; */
        if (message.parentQuestVarSeq !== 0)
            writer.tag(15, WireType.Varint).uint32(message.parentQuestVarSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestUpdateQuestVarNotify
 */
export const QuestUpdateQuestVarNotify = new QuestUpdateQuestVarNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestUpdateQuestVarReq$Type extends MessageType<QuestUpdateQuestVarReq> {
    constructor() {
        super("QuestUpdateQuestVarReq", [
            { no: 15, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "quest_var_op_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuestVarOp },
            { no: 3, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "parent_quest_var_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestUpdateQuestVarReq>): QuestUpdateQuestVarReq {
        const message = { questId: 0, questVarOpList: [], parentQuestId: 0, parentQuestVarSeq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestUpdateQuestVarReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestUpdateQuestVarReq): QuestUpdateQuestVarReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 15:
                    message.questId = reader.uint32();
                    break;
                case /* repeated QuestVarOp quest_var_op_list */ 11:
                    message.questVarOpList.push(QuestVarOp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 parent_quest_id */ 3:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* uint32 parent_quest_var_seq */ 8:
                    message.parentQuestVarSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestUpdateQuestVarReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 15; */
        if (message.questId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.questId);
        /* repeated QuestVarOp quest_var_op_list = 11; */
        for (let i = 0; i < message.questVarOpList.length; i++)
            QuestVarOp.internalBinaryWrite(message.questVarOpList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 parent_quest_id = 3; */
        if (message.parentQuestId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.parentQuestId);
        /* uint32 parent_quest_var_seq = 8; */
        if (message.parentQuestVarSeq !== 0)
            writer.tag(8, WireType.Varint).uint32(message.parentQuestVarSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestUpdateQuestVarReq
 */
export const QuestUpdateQuestVarReq = new QuestUpdateQuestVarReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestUpdateQuestVarRsp$Type extends MessageType<QuestUpdateQuestVarRsp> {
    constructor() {
        super("QuestUpdateQuestVarRsp", [
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "parent_quest_var_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestUpdateQuestVarRsp>): QuestUpdateQuestVarRsp {
        const message = { retcode: 0, questId: 0, parentQuestId: 0, parentQuestVarSeq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestUpdateQuestVarRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestUpdateQuestVarRsp): QuestUpdateQuestVarRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 quest_id */ 7:
                    message.questId = reader.uint32();
                    break;
                case /* uint32 parent_quest_id */ 12:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* uint32 parent_quest_var_seq */ 3:
                    message.parentQuestVarSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestUpdateQuestVarRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* uint32 quest_id = 7; */
        if (message.questId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.questId);
        /* uint32 parent_quest_id = 12; */
        if (message.parentQuestId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.parentQuestId);
        /* uint32 parent_quest_var_seq = 3; */
        if (message.parentQuestVarSeq !== 0)
            writer.tag(3, WireType.Varint).uint32(message.parentQuestVarSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestUpdateQuestVarRsp
 */
export const QuestUpdateQuestVarRsp = new QuestUpdateQuestVarRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestVarOp$Type extends MessageType<QuestVarOp> {
    constructor() {
        super("QuestVarOp", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_add", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QuestVarOp>): QuestVarOp {
        const message = { index: 0, value: 0, isAdd: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuestVarOp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestVarOp): QuestVarOp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                case /* bool is_add */ 3:
                    message.isAdd = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestVarOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.index);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        /* bool is_add = 3; */
        if (message.isAdd !== false)
            writer.tag(3, WireType.Varint).bool(message.isAdd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuestVarOp
 */
export const QuestVarOp = new QuestVarOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuickUseWidgetReq$Type extends MessageType<QuickUseWidgetReq> {
    constructor() {
        super("QuickUseWidgetReq", [
            { no: 1800, name: "location_info", kind: "message", oneof: "param", T: () => WidgetCreateLocationInfo },
            { no: 479, name: "camera_info", kind: "message", oneof: "param", T: () => WidgetCameraInfo },
            { no: 1204, name: "creator_info", kind: "message", oneof: "param", T: () => WidgetCreatorInfo },
            { no: 1198, name: "thunder_bird_feather_info", kind: "message", oneof: "param", T: () => WidgetThunderBirdFeatherInfo }
        ]);
    }
    create(value?: PartialMessage<QuickUseWidgetReq>): QuickUseWidgetReq {
        const message = { param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuickUseWidgetReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuickUseWidgetReq): QuickUseWidgetReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetCreateLocationInfo location_info */ 1800:
                    message.param = {
                        oneofKind: "locationInfo",
                        locationInfo: WidgetCreateLocationInfo.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).locationInfo)
                    };
                    break;
                case /* WidgetCameraInfo camera_info */ 479:
                    message.param = {
                        oneofKind: "cameraInfo",
                        cameraInfo: WidgetCameraInfo.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).cameraInfo)
                    };
                    break;
                case /* WidgetCreatorInfo creator_info */ 1204:
                    message.param = {
                        oneofKind: "creatorInfo",
                        creatorInfo: WidgetCreatorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).creatorInfo)
                    };
                    break;
                case /* WidgetThunderBirdFeatherInfo thunder_bird_feather_info */ 1198:
                    message.param = {
                        oneofKind: "thunderBirdFeatherInfo",
                        thunderBirdFeatherInfo: WidgetThunderBirdFeatherInfo.internalBinaryRead(reader, reader.uint32(), options, (message.param as any).thunderBirdFeatherInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuickUseWidgetReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetCreateLocationInfo location_info = 1800; */
        if (message.param.oneofKind === "locationInfo")
            WidgetCreateLocationInfo.internalBinaryWrite(message.param.locationInfo, writer.tag(1800, WireType.LengthDelimited).fork(), options).join();
        /* WidgetCameraInfo camera_info = 479; */
        if (message.param.oneofKind === "cameraInfo")
            WidgetCameraInfo.internalBinaryWrite(message.param.cameraInfo, writer.tag(479, WireType.LengthDelimited).fork(), options).join();
        /* WidgetCreatorInfo creator_info = 1204; */
        if (message.param.oneofKind === "creatorInfo")
            WidgetCreatorInfo.internalBinaryWrite(message.param.creatorInfo, writer.tag(1204, WireType.LengthDelimited).fork(), options).join();
        /* WidgetThunderBirdFeatherInfo thunder_bird_feather_info = 1198; */
        if (message.param.oneofKind === "thunderBirdFeatherInfo")
            WidgetThunderBirdFeatherInfo.internalBinaryWrite(message.param.thunderBirdFeatherInfo, writer.tag(1198, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuickUseWidgetReq
 */
export const QuickUseWidgetReq = new QuickUseWidgetReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuickUseWidgetRsp$Type extends MessageType<QuickUseWidgetRsp> {
    constructor() {
        super("QuickUseWidgetRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "detector_data", kind: "message", T: () => OneoffGatherPointDetectorData },
            { no: 4, name: "client_collector_data", kind: "message", T: () => ClientCollectorData }
        ]);
    }
    create(value?: PartialMessage<QuickUseWidgetRsp>): QuickUseWidgetRsp {
        const message = { retcode: 0, materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QuickUseWidgetRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuickUseWidgetRsp): QuickUseWidgetRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 material_id */ 1:
                    message.materialId = reader.uint32();
                    break;
                case /* OneoffGatherPointDetectorData detector_data */ 3:
                    message.detectorData = OneoffGatherPointDetectorData.internalBinaryRead(reader, reader.uint32(), options, message.detectorData);
                    break;
                case /* ClientCollectorData client_collector_data */ 4:
                    message.clientCollectorData = ClientCollectorData.internalBinaryRead(reader, reader.uint32(), options, message.clientCollectorData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuickUseWidgetRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 material_id = 1; */
        if (message.materialId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.materialId);
        /* OneoffGatherPointDetectorData detector_data = 3; */
        if (message.detectorData)
            OneoffGatherPointDetectorData.internalBinaryWrite(message.detectorData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ClientCollectorData client_collector_data = 4; */
        if (message.clientCollectorData)
            ClientCollectorData.internalBinaryWrite(message.clientCollectorData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QuickUseWidgetRsp
 */
export const QuickUseWidgetRsp = new QuickUseWidgetRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadMailNotify$Type extends MessageType<ReadMailNotify> {
    constructor() {
        super("ReadMailNotify", [
            { no: 9, name: "mail_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReadMailNotify>): ReadMailNotify {
        const message = { mailIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadMailNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadMailNotify): ReadMailNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 mail_id_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mailIdList.push(reader.uint32());
                    else
                        message.mailIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadMailNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 mail_id_list = 9; */
        if (message.mailIdList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mailIdList.length; i++)
                writer.uint32(message.mailIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReadMailNotify
 */
export const ReadMailNotify = new ReadMailNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionInfo$Type extends MessageType<RegionInfo> {
    constructor() {
        super("RegionInfo", [
            { no: 1, name: "gateserver_ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gateserver_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "pay_callback_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "area_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "resource_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "data_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "feedback_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "bulletin_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "resource_url_bak", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "data_url_bak", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "client_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "handbook_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "client_silence_data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "client_data_md5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "client_silence_data_md5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "res_version_config", kind: "message", T: () => ResVersionConfig },
            { no: 23, name: "secret_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 24, name: "official_community_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "client_version_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "client_silence_version_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "use_gateserver_domain_name", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "gateserver_domain_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "user_center_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "account_bind_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "cdkey_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "privacy_policy_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "next_resource_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "next_res_version_config", kind: "message", T: () => ResVersionConfig }
        ]);
    }
    create(value?: PartialMessage<RegionInfo>): RegionInfo {
        const message = { gateserverIp: "", gateserverPort: 0, payCallbackUrl: "", areaType: "", resourceUrl: "", dataUrl: "", feedbackUrl: "", bulletinUrl: "", resourceUrlBak: "", dataUrlBak: "", clientDataVersion: 0, handbookUrl: "", clientSilenceDataVersion: 0, clientDataMd5: "", clientSilenceDataMd5: "", secretKey: new Uint8Array(0), officialCommunityUrl: "", clientVersionSuffix: "", clientSilenceVersionSuffix: "", useGateserverDomainName: false, gateserverDomainName: "", userCenterUrl: "", accountBindUrl: "", cdkeyUrl: "", privacyPolicyUrl: "", nextResourceUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegionInfo): RegionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string gateserver_ip */ 1:
                    message.gateserverIp = reader.string();
                    break;
                case /* uint32 gateserver_port */ 2:
                    message.gateserverPort = reader.uint32();
                    break;
                case /* string pay_callback_url */ 3:
                    message.payCallbackUrl = reader.string();
                    break;
                case /* string area_type */ 7:
                    message.areaType = reader.string();
                    break;
                case /* string resource_url */ 8:
                    message.resourceUrl = reader.string();
                    break;
                case /* string data_url */ 9:
                    message.dataUrl = reader.string();
                    break;
                case /* string feedback_url */ 10:
                    message.feedbackUrl = reader.string();
                    break;
                case /* string bulletin_url */ 11:
                    message.bulletinUrl = reader.string();
                    break;
                case /* string resource_url_bak */ 12:
                    message.resourceUrlBak = reader.string();
                    break;
                case /* string data_url_bak */ 13:
                    message.dataUrlBak = reader.string();
                    break;
                case /* uint32 client_data_version */ 14:
                    message.clientDataVersion = reader.uint32();
                    break;
                case /* string handbook_url */ 16:
                    message.handbookUrl = reader.string();
                    break;
                case /* uint32 client_silence_data_version */ 18:
                    message.clientSilenceDataVersion = reader.uint32();
                    break;
                case /* string client_data_md5 */ 19:
                    message.clientDataMd5 = reader.string();
                    break;
                case /* string client_silence_data_md5 */ 20:
                    message.clientSilenceDataMd5 = reader.string();
                    break;
                case /* ResVersionConfig res_version_config */ 22:
                    message.resVersionConfig = ResVersionConfig.internalBinaryRead(reader, reader.uint32(), options, message.resVersionConfig);
                    break;
                case /* bytes secret_key */ 23:
                    message.secretKey = reader.bytes();
                    break;
                case /* string official_community_url */ 24:
                    message.officialCommunityUrl = reader.string();
                    break;
                case /* string client_version_suffix */ 26:
                    message.clientVersionSuffix = reader.string();
                    break;
                case /* string client_silence_version_suffix */ 27:
                    message.clientSilenceVersionSuffix = reader.string();
                    break;
                case /* bool use_gateserver_domain_name */ 28:
                    message.useGateserverDomainName = reader.bool();
                    break;
                case /* string gateserver_domain_name */ 29:
                    message.gateserverDomainName = reader.string();
                    break;
                case /* string user_center_url */ 30:
                    message.userCenterUrl = reader.string();
                    break;
                case /* string account_bind_url */ 31:
                    message.accountBindUrl = reader.string();
                    break;
                case /* string cdkey_url */ 32:
                    message.cdkeyUrl = reader.string();
                    break;
                case /* string privacy_policy_url */ 33:
                    message.privacyPolicyUrl = reader.string();
                    break;
                case /* string next_resource_url */ 34:
                    message.nextResourceUrl = reader.string();
                    break;
                case /* ResVersionConfig next_res_version_config */ 35:
                    message.nextResVersionConfig = ResVersionConfig.internalBinaryRead(reader, reader.uint32(), options, message.nextResVersionConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string gateserver_ip = 1; */
        if (message.gateserverIp !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.gateserverIp);
        /* uint32 gateserver_port = 2; */
        if (message.gateserverPort !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gateserverPort);
        /* string pay_callback_url = 3; */
        if (message.payCallbackUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payCallbackUrl);
        /* string area_type = 7; */
        if (message.areaType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.areaType);
        /* string resource_url = 8; */
        if (message.resourceUrl !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.resourceUrl);
        /* string data_url = 9; */
        if (message.dataUrl !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.dataUrl);
        /* string feedback_url = 10; */
        if (message.feedbackUrl !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.feedbackUrl);
        /* string bulletin_url = 11; */
        if (message.bulletinUrl !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.bulletinUrl);
        /* string resource_url_bak = 12; */
        if (message.resourceUrlBak !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.resourceUrlBak);
        /* string data_url_bak = 13; */
        if (message.dataUrlBak !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.dataUrlBak);
        /* uint32 client_data_version = 14; */
        if (message.clientDataVersion !== 0)
            writer.tag(14, WireType.Varint).uint32(message.clientDataVersion);
        /* string handbook_url = 16; */
        if (message.handbookUrl !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.handbookUrl);
        /* uint32 client_silence_data_version = 18; */
        if (message.clientSilenceDataVersion !== 0)
            writer.tag(18, WireType.Varint).uint32(message.clientSilenceDataVersion);
        /* string client_data_md5 = 19; */
        if (message.clientDataMd5 !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.clientDataMd5);
        /* string client_silence_data_md5 = 20; */
        if (message.clientSilenceDataMd5 !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.clientSilenceDataMd5);
        /* ResVersionConfig res_version_config = 22; */
        if (message.resVersionConfig)
            ResVersionConfig.internalBinaryWrite(message.resVersionConfig, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* bytes secret_key = 23; */
        if (message.secretKey.length)
            writer.tag(23, WireType.LengthDelimited).bytes(message.secretKey);
        /* string official_community_url = 24; */
        if (message.officialCommunityUrl !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.officialCommunityUrl);
        /* string client_version_suffix = 26; */
        if (message.clientVersionSuffix !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.clientVersionSuffix);
        /* string client_silence_version_suffix = 27; */
        if (message.clientSilenceVersionSuffix !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.clientSilenceVersionSuffix);
        /* bool use_gateserver_domain_name = 28; */
        if (message.useGateserverDomainName !== false)
            writer.tag(28, WireType.Varint).bool(message.useGateserverDomainName);
        /* string gateserver_domain_name = 29; */
        if (message.gateserverDomainName !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.gateserverDomainName);
        /* string user_center_url = 30; */
        if (message.userCenterUrl !== "")
            writer.tag(30, WireType.LengthDelimited).string(message.userCenterUrl);
        /* string account_bind_url = 31; */
        if (message.accountBindUrl !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.accountBindUrl);
        /* string cdkey_url = 32; */
        if (message.cdkeyUrl !== "")
            writer.tag(32, WireType.LengthDelimited).string(message.cdkeyUrl);
        /* string privacy_policy_url = 33; */
        if (message.privacyPolicyUrl !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.privacyPolicyUrl);
        /* string next_resource_url = 34; */
        if (message.nextResourceUrl !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.nextResourceUrl);
        /* ResVersionConfig next_res_version_config = 35; */
        if (message.nextResVersionConfig)
            ResVersionConfig.internalBinaryWrite(message.nextResVersionConfig, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RegionInfo
 */
export const RegionInfo = new RegionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionSimpleInfo$Type extends MessageType<RegionSimpleInfo> {
    constructor() {
        super("RegionSimpleInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dispatch_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegionSimpleInfo>): RegionSimpleInfo {
        const message = { name: "", title: "", type: "", dispatchUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegionSimpleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegionSimpleInfo): RegionSimpleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* string dispatch_url */ 4:
                    message.dispatchUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegionSimpleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* string dispatch_url = 4; */
        if (message.dispatchUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dispatchUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RegionSimpleInfo
 */
export const RegionSimpleInfo = new RegionSimpleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reliquary$Type extends MessageType<Reliquary> {
    constructor() {
        super("Reliquary", [
            { no: 1, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "exp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "main_prop_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "append_prop_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Reliquary>): Reliquary {
        const message = { level: 0, exp: 0, promoteLevel: 0, mainPropId: 0, appendPropIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reliquary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reliquary): Reliquary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                case /* uint32 exp */ 2:
                    message.exp = reader.uint32();
                    break;
                case /* uint32 promote_level */ 3:
                    message.promoteLevel = reader.uint32();
                    break;
                case /* uint32 main_prop_id */ 4:
                    message.mainPropId = reader.uint32();
                    break;
                case /* repeated uint32 append_prop_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appendPropIdList.push(reader.uint32());
                    else
                        message.appendPropIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reliquary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).uint32(message.level);
        /* uint32 exp = 2; */
        if (message.exp !== 0)
            writer.tag(2, WireType.Varint).uint32(message.exp);
        /* uint32 promote_level = 3; */
        if (message.promoteLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.promoteLevel);
        /* uint32 main_prop_id = 4; */
        if (message.mainPropId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.mainPropId);
        /* repeated uint32 append_prop_id_list = 5; */
        if (message.appendPropIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.appendPropIdList.length; i++)
                writer.uint32(message.appendPropIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Reliquary
 */
export const Reliquary = new Reliquary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryDecomposeReq$Type extends MessageType<ReliquaryDecomposeReq> {
    constructor() {
        super("ReliquaryDecomposeReq", [
            { no: 1, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "target_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReliquaryDecomposeReq>): ReliquaryDecomposeReq {
        const message = { configId: 0, targetCount: 0, guidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryDecomposeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryDecomposeReq): ReliquaryDecomposeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 config_id */ 1:
                    message.configId = reader.uint32();
                    break;
                case /* uint32 target_count */ 4:
                    message.targetCount = reader.uint32();
                    break;
                case /* repeated uint64 guid_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guidList.push(reader.uint64().toBigInt());
                    else
                        message.guidList.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryDecomposeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 config_id = 1; */
        if (message.configId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.configId);
        /* uint32 target_count = 4; */
        if (message.targetCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.targetCount);
        /* repeated uint64 guid_list = 15; */
        if (message.guidList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guidList.length; i++)
                writer.uint64(message.guidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryDecomposeReq
 */
export const ReliquaryDecomposeReq = new ReliquaryDecomposeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryDecomposeRsp$Type extends MessageType<ReliquaryDecomposeRsp> {
    constructor() {
        super("ReliquaryDecomposeRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReliquaryDecomposeRsp>): ReliquaryDecomposeRsp {
        const message = { retcode: 0, guidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryDecomposeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryDecomposeRsp): ReliquaryDecomposeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint64 guid_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guidList.push(reader.uint64().toBigInt());
                    else
                        message.guidList.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryDecomposeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* repeated uint64 guid_list = 14; */
        if (message.guidList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guidList.length; i++)
                writer.uint64(message.guidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryDecomposeRsp
 */
export const ReliquaryDecomposeRsp = new ReliquaryDecomposeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryPromoteReq$Type extends MessageType<ReliquaryPromoteReq> {
    constructor() {
        super("ReliquaryPromoteReq", [
            { no: 4, name: "target_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "item_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReliquaryPromoteReq>): ReliquaryPromoteReq {
        const message = { targetGuid: 0n, itemGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryPromoteReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryPromoteReq): ReliquaryPromoteReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_guid */ 4:
                    message.targetGuid = reader.uint64().toBigInt();
                    break;
                case /* uint64 item_guid */ 14:
                    message.itemGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryPromoteReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_guid = 4; */
        if (message.targetGuid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.targetGuid);
        /* uint64 item_guid = 14; */
        if (message.itemGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.itemGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryPromoteReq
 */
export const ReliquaryPromoteReq = new ReliquaryPromoteReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryPromoteRsp$Type extends MessageType<ReliquaryPromoteRsp> {
    constructor() {
        super("ReliquaryPromoteRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "target_reliquary_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "old_promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "cur_promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "old_append_prop_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "cur_append_prop_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReliquaryPromoteRsp>): ReliquaryPromoteRsp {
        const message = { retcode: 0, targetReliquaryGuid: 0n, oldPromoteLevel: 0, curPromoteLevel: 0, oldAppendPropList: [], curAppendPropList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryPromoteRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryPromoteRsp): ReliquaryPromoteRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_reliquary_guid */ 4:
                    message.targetReliquaryGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 old_promote_level */ 11:
                    message.oldPromoteLevel = reader.uint32();
                    break;
                case /* uint32 cur_promote_level */ 14:
                    message.curPromoteLevel = reader.uint32();
                    break;
                case /* repeated uint32 old_append_prop_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldAppendPropList.push(reader.uint32());
                    else
                        message.oldAppendPropList.push(reader.uint32());
                    break;
                case /* repeated uint32 cur_append_prop_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.curAppendPropList.push(reader.uint32());
                    else
                        message.curAppendPropList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryPromoteRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint64 target_reliquary_guid = 4; */
        if (message.targetReliquaryGuid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.targetReliquaryGuid);
        /* uint32 old_promote_level = 11; */
        if (message.oldPromoteLevel !== 0)
            writer.tag(11, WireType.Varint).uint32(message.oldPromoteLevel);
        /* uint32 cur_promote_level = 14; */
        if (message.curPromoteLevel !== 0)
            writer.tag(14, WireType.Varint).uint32(message.curPromoteLevel);
        /* repeated uint32 old_append_prop_list = 3; */
        if (message.oldAppendPropList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.oldAppendPropList.length; i++)
                writer.uint32(message.oldAppendPropList[i]);
            writer.join();
        }
        /* repeated uint32 cur_append_prop_list = 13; */
        if (message.curAppendPropList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.curAppendPropList.length; i++)
                writer.uint32(message.curAppendPropList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryPromoteRsp
 */
export const ReliquaryPromoteRsp = new ReliquaryPromoteRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryUpgradeReq$Type extends MessageType<ReliquaryUpgradeReq> {
    constructor() {
        super("ReliquaryUpgradeReq", [
            { no: 5, name: "target_reliquary_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "food_reliquary_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<ReliquaryUpgradeReq>): ReliquaryUpgradeReq {
        const message = { targetReliquaryGuid: 0n, foodReliquaryGuidList: [], itemParamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryUpgradeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryUpgradeReq): ReliquaryUpgradeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_reliquary_guid */ 5:
                    message.targetReliquaryGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 food_reliquary_guid_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.foodReliquaryGuidList.push(reader.uint64().toBigInt());
                    else
                        message.foodReliquaryGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated ItemParam item_param_list */ 13:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryUpgradeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_reliquary_guid = 5; */
        if (message.targetReliquaryGuid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.targetReliquaryGuid);
        /* repeated uint64 food_reliquary_guid_list = 15; */
        if (message.foodReliquaryGuidList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.foodReliquaryGuidList.length; i++)
                writer.uint64(message.foodReliquaryGuidList[i]);
            writer.join();
        }
        /* repeated ItemParam item_param_list = 13; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryUpgradeReq
 */
export const ReliquaryUpgradeReq = new ReliquaryUpgradeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReliquaryUpgradeRsp$Type extends MessageType<ReliquaryUpgradeRsp> {
    constructor() {
        super("ReliquaryUpgradeRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "target_reliquary_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "power_up_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "old_append_prop_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "cur_append_prop_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReliquaryUpgradeRsp>): ReliquaryUpgradeRsp {
        const message = { retcode: 0, targetReliquaryGuid: 0n, oldLevel: 0, curLevel: 0, powerUpRate: 0, oldAppendPropList: [], curAppendPropList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReliquaryUpgradeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReliquaryUpgradeRsp): ReliquaryUpgradeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_reliquary_guid */ 10:
                    message.targetReliquaryGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 old_level */ 5:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 cur_level */ 6:
                    message.curLevel = reader.uint32();
                    break;
                case /* uint32 power_up_rate */ 2:
                    message.powerUpRate = reader.uint32();
                    break;
                case /* repeated uint32 old_append_prop_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldAppendPropList.push(reader.uint32());
                    else
                        message.oldAppendPropList.push(reader.uint32());
                    break;
                case /* repeated uint32 cur_append_prop_list */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.curAppendPropList.push(reader.uint32());
                    else
                        message.curAppendPropList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReliquaryUpgradeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        /* uint64 target_reliquary_guid = 10; */
        if (message.targetReliquaryGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.targetReliquaryGuid);
        /* uint32 old_level = 5; */
        if (message.oldLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oldLevel);
        /* uint32 cur_level = 6; */
        if (message.curLevel !== 0)
            writer.tag(6, WireType.Varint).uint32(message.curLevel);
        /* uint32 power_up_rate = 2; */
        if (message.powerUpRate !== 0)
            writer.tag(2, WireType.Varint).uint32(message.powerUpRate);
        /* repeated uint32 old_append_prop_list = 7; */
        if (message.oldAppendPropList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.oldAppendPropList.length; i++)
                writer.uint32(message.oldAppendPropList[i]);
            writer.join();
        }
        /* repeated uint32 cur_append_prop_list = 14; */
        if (message.curAppendPropList.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.curAppendPropList.length; i++)
                writer.uint32(message.curAppendPropList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReliquaryUpgradeRsp
 */
export const ReliquaryUpgradeRsp = new ReliquaryUpgradeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResinCard$Type extends MessageType<ResinCard> {
    constructor() {
        super("ResinCard", [
            { no: 1, name: "baseItemList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "perDayItemList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<ResinCard>): ResinCard {
        const message = { baseItemList: [], perDayItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResinCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResinCard): ResinCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ItemParam baseItemList */ 1:
                    message.baseItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam perDayItemList */ 2:
                    message.perDayItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResinCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ItemParam baseItemList = 1; */
        for (let i = 0; i < message.baseItemList.length; i++)
            ItemParam.internalBinaryWrite(message.baseItemList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam perDayItemList = 2; */
        for (let i = 0; i < message.perDayItemList.length; i++)
            ItemParam.internalBinaryWrite(message.perDayItemList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResinCard
 */
export const ResinCard = new ResinCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResinChangeNotify$Type extends MessageType<ResinChangeNotify> {
    constructor() {
        super("ResinChangeNotify", [
            { no: 4, name: "cur_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "next_add_timestamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cur_buy_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResinChangeNotify>): ResinChangeNotify {
        const message = { curValue: 0, nextAddTimestamp: 0, curBuyCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResinChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResinChangeNotify): ResinChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cur_value */ 4:
                    message.curValue = reader.uint32();
                    break;
                case /* uint32 next_add_timestamp */ 2:
                    message.nextAddTimestamp = reader.uint32();
                    break;
                case /* uint32 cur_buy_count */ 3:
                    message.curBuyCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResinChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cur_value = 4; */
        if (message.curValue !== 0)
            writer.tag(4, WireType.Varint).uint32(message.curValue);
        /* uint32 next_add_timestamp = 2; */
        if (message.nextAddTimestamp !== 0)
            writer.tag(2, WireType.Varint).uint32(message.nextAddTimestamp);
        /* uint32 cur_buy_count = 3; */
        if (message.curBuyCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.curBuyCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResinChangeNotify
 */
export const ResinChangeNotify = new ResinChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResVersionConfig$Type extends MessageType<ResVersionConfig> {
    constructor() {
        super("ResVersionConfig", [
            { no: 1, name: "version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "relogin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "md_5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "release_total_size", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "branch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "next_script_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResVersionConfig>): ResVersionConfig {
        const message = { version: 0, relogin: false, md5: "", releaseTotalSize: "", versionSuffix: "", branch: "", nextScriptVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResVersionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResVersionConfig): ResVersionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* bool relogin */ 2:
                    message.relogin = reader.bool();
                    break;
                case /* string md_5 */ 3:
                    message.md5 = reader.string();
                    break;
                case /* string release_total_size */ 4:
                    message.releaseTotalSize = reader.string();
                    break;
                case /* string version_suffix */ 5:
                    message.versionSuffix = reader.string();
                    break;
                case /* string branch */ 6:
                    message.branch = reader.string();
                    break;
                case /* string next_script_version */ 7:
                    message.nextScriptVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResVersionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* bool relogin = 2; */
        if (message.relogin !== false)
            writer.tag(2, WireType.Varint).bool(message.relogin);
        /* string md_5 = 3; */
        if (message.md5 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.md5);
        /* string release_total_size = 4; */
        if (message.releaseTotalSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.releaseTotalSize);
        /* string version_suffix = 5; */
        if (message.versionSuffix !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.versionSuffix);
        /* string branch = 6; */
        if (message.branch !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.branch);
        /* string next_script_version = 7; */
        if (message.nextScriptVersion !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.nextScriptVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResVersionConfig
 */
export const ResVersionConfig = new ResVersionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoguelikeDungeonSettleInfo$Type extends MessageType<RoguelikeDungeonSettleInfo> {
    constructor() {
        super("RoguelikeDungeonSettleInfo", [
            { no: 1, name: "stage_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "finished_challenge_cell_num_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => RoguelikeSettleCoinInfo } },
            { no: 4, name: "is_final_level", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "total_coin_b_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "total_coin_c_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_coin_c_reach_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RoguelikeDungeonSettleInfo>): RoguelikeDungeonSettleInfo {
        const message = { stageId: 0, curLevel: 0, finishedChallengeCellNumMap: {}, isFinalLevel: false, totalCoinBNum: 0, totalCoinCNum: 0, isCoinCReachLimit: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoguelikeDungeonSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoguelikeDungeonSettleInfo): RoguelikeDungeonSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 stage_id */ 1:
                    message.stageId = reader.uint32();
                    break;
                case /* uint32 cur_level */ 2:
                    message.curLevel = reader.uint32();
                    break;
                case /* map<uint32, RoguelikeSettleCoinInfo> finished_challenge_cell_num_map */ 3:
                    this.binaryReadMap3(message.finishedChallengeCellNumMap, reader, options);
                    break;
                case /* bool is_final_level */ 4:
                    message.isFinalLevel = reader.bool();
                    break;
                case /* uint32 total_coin_b_num */ 5:
                    message.totalCoinBNum = reader.uint32();
                    break;
                case /* uint32 total_coin_c_num */ 6:
                    message.totalCoinCNum = reader.uint32();
                    break;
                case /* bool is_coin_c_reach_limit */ 7:
                    message.isCoinCReachLimit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: RoguelikeDungeonSettleInfo["finishedChallengeCellNumMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RoguelikeDungeonSettleInfo["finishedChallengeCellNumMap"] | undefined, val: RoguelikeDungeonSettleInfo["finishedChallengeCellNumMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = RoguelikeSettleCoinInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field RoguelikeDungeonSettleInfo.finished_challenge_cell_num_map");
            }
        }
        map[key ?? 0] = val ?? RoguelikeSettleCoinInfo.create();
    }
    internalBinaryWrite(message: RoguelikeDungeonSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 stage_id = 1; */
        if (message.stageId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.stageId);
        /* uint32 cur_level = 2; */
        if (message.curLevel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.curLevel);
        /* map<uint32, RoguelikeSettleCoinInfo> finished_challenge_cell_num_map = 3; */
        for (let k of Object.keys(message.finishedChallengeCellNumMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            RoguelikeSettleCoinInfo.internalBinaryWrite(message.finishedChallengeCellNumMap[k as any], writer, options);
            writer.join().join();
        }
        /* bool is_final_level = 4; */
        if (message.isFinalLevel !== false)
            writer.tag(4, WireType.Varint).bool(message.isFinalLevel);
        /* uint32 total_coin_b_num = 5; */
        if (message.totalCoinBNum !== 0)
            writer.tag(5, WireType.Varint).uint32(message.totalCoinBNum);
        /* uint32 total_coin_c_num = 6; */
        if (message.totalCoinCNum !== 0)
            writer.tag(6, WireType.Varint).uint32(message.totalCoinCNum);
        /* bool is_coin_c_reach_limit = 7; */
        if (message.isCoinCReachLimit !== false)
            writer.tag(7, WireType.Varint).bool(message.isCoinCReachLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoguelikeDungeonSettleInfo
 */
export const RoguelikeDungeonSettleInfo = new RoguelikeDungeonSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoguelikeGadgetInfo$Type extends MessageType<RoguelikeGadgetInfo> {
    constructor() {
        super("RoguelikeGadgetInfo", [
            { no: 1, name: "cell_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cell_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cell_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RoguelikeGadgetInfo>): RoguelikeGadgetInfo {
        const message = { cellConfigId: 0, cellType: 0, cellState: 0, cellId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoguelikeGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoguelikeGadgetInfo): RoguelikeGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cell_config_id */ 1:
                    message.cellConfigId = reader.uint32();
                    break;
                case /* uint32 cell_type */ 2:
                    message.cellType = reader.uint32();
                    break;
                case /* uint32 cell_state */ 3:
                    message.cellState = reader.uint32();
                    break;
                case /* uint32 cell_id */ 4:
                    message.cellId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoguelikeGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cell_config_id = 1; */
        if (message.cellConfigId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.cellConfigId);
        /* uint32 cell_type = 2; */
        if (message.cellType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.cellType);
        /* uint32 cell_state = 3; */
        if (message.cellState !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cellState);
        /* uint32 cell_id = 4; */
        if (message.cellId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.cellId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoguelikeGadgetInfo
 */
export const RoguelikeGadgetInfo = new RoguelikeGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoguelikeSettleCoinInfo$Type extends MessageType<RoguelikeSettleCoinInfo> {
    constructor() {
        super("RoguelikeSettleCoinInfo", [
            { no: 1, name: "cell_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "coin_b", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "coin_c", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RoguelikeSettleCoinInfo>): RoguelikeSettleCoinInfo {
        const message = { cellNum: 0, coinB: 0, coinC: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoguelikeSettleCoinInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoguelikeSettleCoinInfo): RoguelikeSettleCoinInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cell_num */ 1:
                    message.cellNum = reader.uint32();
                    break;
                case /* uint32 coin_b */ 2:
                    message.coinB = reader.uint32();
                    break;
                case /* uint32 coin_c */ 3:
                    message.coinC = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoguelikeSettleCoinInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cell_num = 1; */
        if (message.cellNum !== 0)
            writer.tag(1, WireType.Varint).uint32(message.cellNum);
        /* uint32 coin_b = 2; */
        if (message.coinB !== 0)
            writer.tag(2, WireType.Varint).uint32(message.coinB);
        /* uint32 coin_c = 3; */
        if (message.coinC !== 0)
            writer.tag(3, WireType.Varint).uint32(message.coinC);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoguelikeSettleCoinInfo
 */
export const RoguelikeSettleCoinInfo = new RoguelikeSettleCoinInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Route$Type extends MessageType<Route> {
    constructor() {
        super("Route", [
            { no: 1, name: "route_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutePoint },
            { no: 2, name: "route_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Route>): Route {
        const message = { routePoints: [], routeType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated RoutePoint route_points */ 1:
                    message.routePoints.push(RoutePoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 route_type */ 2:
                    message.routeType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated RoutePoint route_points = 1; */
        for (let i = 0; i < message.routePoints.length; i++)
            RoutePoint.internalBinaryWrite(message.routePoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 route_type = 2; */
        if (message.routeType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.routeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Route
 */
export const Route = new Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutePoint$Type extends MessageType<RoutePoint> {
    constructor() {
        super("RoutePoint", [
            { no: 1, name: "position", kind: "message", T: () => Vector },
            { no: 2, name: "arrive_range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "velocity", kind: "scalar", oneof: "moveParams", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "time", kind: "scalar", oneof: "moveParams", T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "rotation", kind: "message", oneof: "rotateParams", T: () => Vector },
            { no: 22, name: "rotation_speed", kind: "message", oneof: "rotateParams", T: () => MathQuaternion },
            { no: 23, name: "axis_speed", kind: "message", oneof: "rotateParams", T: () => MathQuaternion }
        ]);
    }
    create(value?: PartialMessage<RoutePoint>): RoutePoint {
        const message = { arriveRange: 0, moveParams: { oneofKind: undefined }, rotateParams: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoutePoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutePoint): RoutePoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector position */ 1:
                    message.position = Vector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* float arrive_range */ 2:
                    message.arriveRange = reader.float();
                    break;
                case /* float velocity */ 11:
                    message.moveParams = {
                        oneofKind: "velocity",
                        velocity: reader.float()
                    };
                    break;
                case /* float time */ 12:
                    message.moveParams = {
                        oneofKind: "time",
                        time: reader.float()
                    };
                    break;
                case /* Vector rotation */ 21:
                    message.rotateParams = {
                        oneofKind: "rotation",
                        rotation: Vector.internalBinaryRead(reader, reader.uint32(), options, (message.rotateParams as any).rotation)
                    };
                    break;
                case /* MathQuaternion rotation_speed */ 22:
                    message.rotateParams = {
                        oneofKind: "rotationSpeed",
                        rotationSpeed: MathQuaternion.internalBinaryRead(reader, reader.uint32(), options, (message.rotateParams as any).rotationSpeed)
                    };
                    break;
                case /* MathQuaternion axis_speed */ 23:
                    message.rotateParams = {
                        oneofKind: "axisSpeed",
                        axisSpeed: MathQuaternion.internalBinaryRead(reader, reader.uint32(), options, (message.rotateParams as any).axisSpeed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutePoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector position = 1; */
        if (message.position)
            Vector.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* float arrive_range = 2; */
        if (message.arriveRange !== 0)
            writer.tag(2, WireType.Bit32).float(message.arriveRange);
        /* float velocity = 11; */
        if (message.moveParams.oneofKind === "velocity")
            writer.tag(11, WireType.Bit32).float(message.moveParams.velocity);
        /* float time = 12; */
        if (message.moveParams.oneofKind === "time")
            writer.tag(12, WireType.Bit32).float(message.moveParams.time);
        /* Vector rotation = 21; */
        if (message.rotateParams.oneofKind === "rotation")
            Vector.internalBinaryWrite(message.rotateParams.rotation, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* MathQuaternion rotation_speed = 22; */
        if (message.rotateParams.oneofKind === "rotationSpeed")
            MathQuaternion.internalBinaryWrite(message.rotateParams.rotationSpeed, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* MathQuaternion axis_speed = 23; */
        if (message.rotateParams.oneofKind === "axisSpeed")
            MathQuaternion.internalBinaryWrite(message.rotateParams.axisSpeed, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoutePoint
 */
export const RoutePoint = new RoutePoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneAreaWeatherNotify$Type extends MessageType<SceneAreaWeatherNotify> {
    constructor() {
        super("SceneAreaWeatherNotify", [
            { no: 13, name: "weather_gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "weather_value_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "weather_area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "climate_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "trans_duration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SceneAreaWeatherNotify>): SceneAreaWeatherNotify {
        const message = { weatherGadgetId: 0, weatherValueMap: {}, weatherAreaId: 0, climateType: 0, transDuration: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneAreaWeatherNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneAreaWeatherNotify): SceneAreaWeatherNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 weather_gadget_id */ 13:
                    message.weatherGadgetId = reader.uint32();
                    break;
                case /* map<uint32, string> weather_value_map */ 10:
                    this.binaryReadMap10(message.weatherValueMap, reader, options);
                    break;
                case /* uint32 weather_area_id */ 15:
                    message.weatherAreaId = reader.uint32();
                    break;
                case /* uint32 climate_type */ 14:
                    message.climateType = reader.uint32();
                    break;
                case /* float trans_duration */ 11:
                    message.transDuration = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: SceneAreaWeatherNotify["weatherValueMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneAreaWeatherNotify["weatherValueMap"] | undefined, val: SceneAreaWeatherNotify["weatherValueMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneAreaWeatherNotify.weather_value_map");
            }
        }
        map[key ?? 0] = val ?? "";
    }
    internalBinaryWrite(message: SceneAreaWeatherNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 weather_gadget_id = 13; */
        if (message.weatherGadgetId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.weatherGadgetId);
        /* map<uint32, string> weather_value_map = 10; */
        for (let k of Object.keys(message.weatherValueMap))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.LengthDelimited).string(message.weatherValueMap[k as any]).join();
        /* uint32 weather_area_id = 15; */
        if (message.weatherAreaId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.weatherAreaId);
        /* uint32 climate_type = 14; */
        if (message.climateType !== 0)
            writer.tag(14, WireType.Varint).uint32(message.climateType);
        /* float trans_duration = 11; */
        if (message.transDuration !== 0)
            writer.tag(11, WireType.Bit32).float(message.transDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneAreaWeatherNotify
 */
export const SceneAreaWeatherNotify = new SceneAreaWeatherNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneAvatarInfo$Type extends MessageType<SceneAvatarInfo> {
    constructor() {
        super("SceneAvatarInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "equip_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "talent_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "weapon", kind: "message", T: () => SceneWeaponInfo },
            { no: 9, name: "reliquary_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SceneReliquaryInfo },
            { no: 11, name: "core_proud_skill_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "inherent_proud_skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "skill_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 14, name: "proud_skill_extra_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 15, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff },
            { no: 16, name: "team_resonance_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "wearing_flycloak_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "born_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "cur_vehicle_info", kind: "message", T: () => CurVehicleInfo },
            { no: 21, name: "excel_info", kind: "message", T: () => AvatarExcelInfo },
            { no: 22, name: "anim_hash", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneAvatarInfo>): SceneAvatarInfo {
        const message = { uid: 0, avatarId: 0, guid: 0n, peerId: 0, equipIdList: [], skillDepotId: 0, talentIdList: [], reliquaryList: [], coreProudSkillLevel: 0, inherentProudSkillList: [], skillLevelMap: {}, proudSkillExtraLevelMap: {}, serverBuffList: [], teamResonanceList: [], wearingFlycloakId: 0, bornTime: 0, costumeId: 0, animHash: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneAvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneAvatarInfo): SceneAvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 2:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint64 guid */ 3:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 peer_id */ 4:
                    message.peerId = reader.uint32();
                    break;
                case /* repeated uint32 equip_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipIdList.push(reader.uint32());
                    else
                        message.equipIdList.push(reader.uint32());
                    break;
                case /* uint32 skill_depot_id */ 6:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* repeated uint32 talent_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.talentIdList.push(reader.uint32());
                    else
                        message.talentIdList.push(reader.uint32());
                    break;
                case /* SceneWeaponInfo weapon */ 8:
                    message.weapon = SceneWeaponInfo.internalBinaryRead(reader, reader.uint32(), options, message.weapon);
                    break;
                case /* repeated SceneReliquaryInfo reliquary_list */ 9:
                    message.reliquaryList.push(SceneReliquaryInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 core_proud_skill_level */ 11:
                    message.coreProudSkillLevel = reader.uint32();
                    break;
                case /* repeated uint32 inherent_proud_skill_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inherentProudSkillList.push(reader.uint32());
                    else
                        message.inherentProudSkillList.push(reader.uint32());
                    break;
                case /* map<uint32, uint32> skill_level_map */ 13:
                    this.binaryReadMap13(message.skillLevelMap, reader, options);
                    break;
                case /* map<uint32, uint32> proud_skill_extra_level_map */ 14:
                    this.binaryReadMap14(message.proudSkillExtraLevelMap, reader, options);
                    break;
                case /* repeated ServerBuff server_buff_list */ 15:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 team_resonance_list */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.teamResonanceList.push(reader.uint32());
                    else
                        message.teamResonanceList.push(reader.uint32());
                    break;
                case /* uint32 wearing_flycloak_id */ 17:
                    message.wearingFlycloakId = reader.uint32();
                    break;
                case /* uint32 born_time */ 18:
                    message.bornTime = reader.uint32();
                    break;
                case /* uint32 costume_id */ 19:
                    message.costumeId = reader.uint32();
                    break;
                case /* CurVehicleInfo cur_vehicle_info */ 20:
                    message.curVehicleInfo = CurVehicleInfo.internalBinaryRead(reader, reader.uint32(), options, message.curVehicleInfo);
                    break;
                case /* AvatarExcelInfo excel_info */ 21:
                    message.excelInfo = AvatarExcelInfo.internalBinaryRead(reader, reader.uint32(), options, message.excelInfo);
                    break;
                case /* uint32 anim_hash */ 22:
                    message.animHash = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: SceneAvatarInfo["skillLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneAvatarInfo["skillLevelMap"] | undefined, val: SceneAvatarInfo["skillLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneAvatarInfo.skill_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap14(map: SceneAvatarInfo["proudSkillExtraLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneAvatarInfo["proudSkillExtraLevelMap"] | undefined, val: SceneAvatarInfo["proudSkillExtraLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneAvatarInfo.proud_skill_extra_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: SceneAvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint32 avatar_id = 2; */
        if (message.avatarId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.avatarId);
        /* uint64 guid = 3; */
        if (message.guid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.guid);
        /* uint32 peer_id = 4; */
        if (message.peerId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.peerId);
        /* repeated uint32 equip_id_list = 5; */
        if (message.equipIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.equipIdList.length; i++)
                writer.uint32(message.equipIdList[i]);
            writer.join();
        }
        /* uint32 skill_depot_id = 6; */
        if (message.skillDepotId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.skillDepotId);
        /* repeated uint32 talent_id_list = 7; */
        if (message.talentIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.talentIdList.length; i++)
                writer.uint32(message.talentIdList[i]);
            writer.join();
        }
        /* SceneWeaponInfo weapon = 8; */
        if (message.weapon)
            SceneWeaponInfo.internalBinaryWrite(message.weapon, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated SceneReliquaryInfo reliquary_list = 9; */
        for (let i = 0; i < message.reliquaryList.length; i++)
            SceneReliquaryInfo.internalBinaryWrite(message.reliquaryList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 core_proud_skill_level = 11; */
        if (message.coreProudSkillLevel !== 0)
            writer.tag(11, WireType.Varint).uint32(message.coreProudSkillLevel);
        /* repeated uint32 inherent_proud_skill_list = 12; */
        if (message.inherentProudSkillList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.inherentProudSkillList.length; i++)
                writer.uint32(message.inherentProudSkillList[i]);
            writer.join();
        }
        /* map<uint32, uint32> skill_level_map = 13; */
        for (let k of Object.keys(message.skillLevelMap))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillLevelMap[k as any]).join();
        /* map<uint32, uint32> proud_skill_extra_level_map = 14; */
        for (let k of Object.keys(message.proudSkillExtraLevelMap))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.proudSkillExtraLevelMap[k as any]).join();
        /* repeated ServerBuff server_buff_list = 15; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 team_resonance_list = 16; */
        if (message.teamResonanceList.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.teamResonanceList.length; i++)
                writer.uint32(message.teamResonanceList[i]);
            writer.join();
        }
        /* uint32 wearing_flycloak_id = 17; */
        if (message.wearingFlycloakId !== 0)
            writer.tag(17, WireType.Varint).uint32(message.wearingFlycloakId);
        /* uint32 born_time = 18; */
        if (message.bornTime !== 0)
            writer.tag(18, WireType.Varint).uint32(message.bornTime);
        /* uint32 costume_id = 19; */
        if (message.costumeId !== 0)
            writer.tag(19, WireType.Varint).uint32(message.costumeId);
        /* CurVehicleInfo cur_vehicle_info = 20; */
        if (message.curVehicleInfo)
            CurVehicleInfo.internalBinaryWrite(message.curVehicleInfo, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* AvatarExcelInfo excel_info = 21; */
        if (message.excelInfo)
            AvatarExcelInfo.internalBinaryWrite(message.excelInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* uint32 anim_hash = 22; */
        if (message.animHash !== 0)
            writer.tag(22, WireType.Varint).uint32(message.animHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneAvatarInfo
 */
export const SceneAvatarInfo = new SceneAvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityAiInfo$Type extends MessageType<SceneEntityAiInfo> {
    constructor() {
        super("SceneEntityAiInfo", [
            { no: 1, name: "is_ai_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "born_pos", kind: "message", T: () => Vector },
            { no: 3, name: "skill_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 4, name: "servant_info", kind: "message", T: () => ServantInfo },
            { no: 5, name: "ai_threat_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 6, name: "skill_group_cd_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 7, name: "cur_tactic", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityAiInfo>): SceneEntityAiInfo {
        const message = { isAiOpen: false, skillCdMap: {}, aiThreatMap: {}, skillGroupCdMap: {}, curTactic: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityAiInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityAiInfo): SceneEntityAiInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_ai_open */ 1:
                    message.isAiOpen = reader.bool();
                    break;
                case /* Vector born_pos */ 2:
                    message.bornPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.bornPos);
                    break;
                case /* map<uint32, uint32> skill_cd_map */ 3:
                    this.binaryReadMap3(message.skillCdMap, reader, options);
                    break;
                case /* ServantInfo servant_info */ 4:
                    message.servantInfo = ServantInfo.internalBinaryRead(reader, reader.uint32(), options, message.servantInfo);
                    break;
                case /* map<uint32, uint32> ai_threat_map */ 5:
                    this.binaryReadMap5(message.aiThreatMap, reader, options);
                    break;
                case /* map<uint32, uint32> skill_group_cd_map */ 6:
                    this.binaryReadMap6(message.skillGroupCdMap, reader, options);
                    break;
                case /* uint32 cur_tactic */ 7:
                    message.curTactic = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: SceneEntityAiInfo["skillCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneEntityAiInfo["skillCdMap"] | undefined, val: SceneEntityAiInfo["skillCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneEntityAiInfo.skill_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap5(map: SceneEntityAiInfo["aiThreatMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneEntityAiInfo["aiThreatMap"] | undefined, val: SceneEntityAiInfo["aiThreatMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneEntityAiInfo.ai_threat_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap6(map: SceneEntityAiInfo["skillGroupCdMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneEntityAiInfo["skillGroupCdMap"] | undefined, val: SceneEntityAiInfo["skillGroupCdMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneEntityAiInfo.skill_group_cd_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: SceneEntityAiInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_ai_open = 1; */
        if (message.isAiOpen !== false)
            writer.tag(1, WireType.Varint).bool(message.isAiOpen);
        /* Vector born_pos = 2; */
        if (message.bornPos)
            Vector.internalBinaryWrite(message.bornPos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, uint32> skill_cd_map = 3; */
        for (let k of Object.keys(message.skillCdMap))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillCdMap[k as any]).join();
        /* ServantInfo servant_info = 4; */
        if (message.servantInfo)
            ServantInfo.internalBinaryWrite(message.servantInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, uint32> ai_threat_map = 5; */
        for (let k of Object.keys(message.aiThreatMap))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.aiThreatMap[k as any]).join();
        /* map<uint32, uint32> skill_group_cd_map = 6; */
        for (let k of Object.keys(message.skillGroupCdMap))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillGroupCdMap[k as any]).join();
        /* uint32 cur_tactic = 7; */
        if (message.curTactic !== 0)
            writer.tag(7, WireType.Varint).uint32(message.curTactic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityAiInfo
 */
export const SceneEntityAiInfo = new SceneEntityAiInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityAppearNotify$Type extends MessageType<SceneEntityAppearNotify> {
    constructor() {
        super("SceneEntityAppearNotify", [
            { no: 6, name: "entity_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SceneEntityInfo },
            { no: 8, name: "appear_type", kind: "enum", T: () => ["VisionType", VisionType, "VISION_TYPE_"] },
            { no: 11, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityAppearNotify>): SceneEntityAppearNotify {
        const message = { entityList: [], appearType: 0, param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityAppearNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityAppearNotify): SceneEntityAppearNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SceneEntityInfo entity_list */ 6:
                    message.entityList.push(SceneEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* VisionType appear_type */ 8:
                    message.appearType = reader.int32();
                    break;
                case /* uint32 param */ 11:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityAppearNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SceneEntityInfo entity_list = 6; */
        for (let i = 0; i < message.entityList.length; i++)
            SceneEntityInfo.internalBinaryWrite(message.entityList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* VisionType appear_type = 8; */
        if (message.appearType !== 0)
            writer.tag(8, WireType.Varint).int32(message.appearType);
        /* uint32 param = 11; */
        if (message.param !== 0)
            writer.tag(11, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityAppearNotify
 */
export const SceneEntityAppearNotify = new SceneEntityAppearNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityDisappearNotify$Type extends MessageType<SceneEntityDisappearNotify> {
    constructor() {
        super("SceneEntityDisappearNotify", [
            { no: 9, name: "entity_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "disappear_type", kind: "enum", T: () => ["VisionType", VisionType, "VISION_TYPE_"] },
            { no: 6, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityDisappearNotify>): SceneEntityDisappearNotify {
        const message = { entityList: [], disappearType: 0, param: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityDisappearNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityDisappearNotify): SceneEntityDisappearNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 entity_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.entityList.push(reader.uint32());
                    else
                        message.entityList.push(reader.uint32());
                    break;
                case /* VisionType disappear_type */ 10:
                    message.disappearType = reader.int32();
                    break;
                case /* uint32 param */ 6:
                    message.param = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityDisappearNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 entity_list = 9; */
        if (message.entityList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.entityList.length; i++)
                writer.uint32(message.entityList[i]);
            writer.join();
        }
        /* VisionType disappear_type = 10; */
        if (message.disappearType !== 0)
            writer.tag(10, WireType.Varint).int32(message.disappearType);
        /* uint32 param = 6; */
        if (message.param !== 0)
            writer.tag(6, WireType.Varint).uint32(message.param);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityDisappearNotify
 */
export const SceneEntityDisappearNotify = new SceneEntityDisappearNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityDrownReq$Type extends MessageType<SceneEntityDrownReq> {
    constructor() {
        super("SceneEntityDrownReq", [
            { no: 14, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityDrownReq>): SceneEntityDrownReq {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityDrownReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityDrownReq): SceneEntityDrownReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityDrownReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 14; */
        if (message.entityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityDrownReq
 */
export const SceneEntityDrownReq = new SceneEntityDrownReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityDrownRsp$Type extends MessageType<SceneEntityDrownRsp> {
    constructor() {
        super("SceneEntityDrownRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityDrownRsp>): SceneEntityDrownRsp {
        const message = { retcode: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityDrownRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityDrownRsp): SceneEntityDrownRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityDrownRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint32 entity_id = 10; */
        if (message.entityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityDrownRsp
 */
export const SceneEntityDrownRsp = new SceneEntityDrownRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityInfo$Type extends MessageType<SceneEntityInfo> {
    constructor() {
        super("SceneEntityInfo", [
            { no: 10, name: "avatar", kind: "message", oneof: "entity", T: () => SceneAvatarInfo },
            { no: 11, name: "monster", kind: "message", oneof: "entity", T: () => SceneMonsterInfo },
            { no: 12, name: "npc", kind: "message", oneof: "entity", T: () => SceneNpcInfo },
            { no: 13, name: "gadget", kind: "message", oneof: "entity", T: () => SceneGadgetInfo },
            { no: 1, name: "entity_type", kind: "enum", T: () => ["ProtEntityType", ProtEntityType, "PROT_ENTITY_TYPE_"] },
            { no: 2, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "motion_info", kind: "message", T: () => MotionInfo },
            { no: 5, name: "prop_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropPair },
            { no: 6, name: "fight_prop_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FightPropPair },
            { no: 7, name: "life_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "animator_para_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnimatorParameterValueInfoPair },
            { no: 17, name: "last_move_scene_time_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "last_move_reliable_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "entity_client_data", kind: "message", T: () => EntityClientData },
            { no: 20, name: "entity_environment_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EntityEnvironmentInfo },
            { no: 21, name: "entity_authority_info", kind: "message", T: () => EntityAuthorityInfo },
            { no: 22, name: "tag_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff }
        ]);
    }
    create(value?: PartialMessage<SceneEntityInfo>): SceneEntityInfo {
        const message = { entity: { oneofKind: undefined }, entityType: 0, entityId: 0, name: "", propList: [], fightPropList: [], lifeState: 0, animatorParaList: [], lastMoveSceneTimeMs: 0, lastMoveReliableSeq: 0, entityEnvironmentInfoList: [], tagList: [], serverBuffList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityInfo): SceneEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SceneAvatarInfo avatar */ 10:
                    message.entity = {
                        oneofKind: "avatar",
                        avatar: SceneAvatarInfo.internalBinaryRead(reader, reader.uint32(), options, (message.entity as any).avatar)
                    };
                    break;
                case /* SceneMonsterInfo monster */ 11:
                    message.entity = {
                        oneofKind: "monster",
                        monster: SceneMonsterInfo.internalBinaryRead(reader, reader.uint32(), options, (message.entity as any).monster)
                    };
                    break;
                case /* SceneNpcInfo npc */ 12:
                    message.entity = {
                        oneofKind: "npc",
                        npc: SceneNpcInfo.internalBinaryRead(reader, reader.uint32(), options, (message.entity as any).npc)
                    };
                    break;
                case /* SceneGadgetInfo gadget */ 13:
                    message.entity = {
                        oneofKind: "gadget",
                        gadget: SceneGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.entity as any).gadget)
                    };
                    break;
                case /* ProtEntityType entity_type */ 1:
                    message.entityType = reader.int32();
                    break;
                case /* uint32 entity_id */ 2:
                    message.entityId = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* MotionInfo motion_info */ 4:
                    message.motionInfo = MotionInfo.internalBinaryRead(reader, reader.uint32(), options, message.motionInfo);
                    break;
                case /* repeated PropPair prop_list */ 5:
                    message.propList.push(PropPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightPropPair fight_prop_list */ 6:
                    message.fightPropList.push(FightPropPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 life_state */ 7:
                    message.lifeState = reader.uint32();
                    break;
                case /* repeated AnimatorParameterValueInfoPair animator_para_list */ 9:
                    message.animatorParaList.push(AnimatorParameterValueInfoPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 last_move_scene_time_ms */ 17:
                    message.lastMoveSceneTimeMs = reader.uint32();
                    break;
                case /* uint32 last_move_reliable_seq */ 18:
                    message.lastMoveReliableSeq = reader.uint32();
                    break;
                case /* EntityClientData entity_client_data */ 19:
                    message.entityClientData = EntityClientData.internalBinaryRead(reader, reader.uint32(), options, message.entityClientData);
                    break;
                case /* repeated EntityEnvironmentInfo entity_environment_info_list */ 20:
                    message.entityEnvironmentInfoList.push(EntityEnvironmentInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* EntityAuthorityInfo entity_authority_info */ 21:
                    message.entityAuthorityInfo = EntityAuthorityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entityAuthorityInfo);
                    break;
                case /* repeated string tag_list */ 22:
                    message.tagList.push(reader.string());
                    break;
                case /* repeated ServerBuff server_buff_list */ 23:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SceneAvatarInfo avatar = 10; */
        if (message.entity.oneofKind === "avatar")
            SceneAvatarInfo.internalBinaryWrite(message.entity.avatar, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* SceneMonsterInfo monster = 11; */
        if (message.entity.oneofKind === "monster")
            SceneMonsterInfo.internalBinaryWrite(message.entity.monster, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* SceneNpcInfo npc = 12; */
        if (message.entity.oneofKind === "npc")
            SceneNpcInfo.internalBinaryWrite(message.entity.npc, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* SceneGadgetInfo gadget = 13; */
        if (message.entity.oneofKind === "gadget")
            SceneGadgetInfo.internalBinaryWrite(message.entity.gadget, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* ProtEntityType entity_type = 1; */
        if (message.entityType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entityType);
        /* uint32 entity_id = 2; */
        if (message.entityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.entityId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* MotionInfo motion_info = 4; */
        if (message.motionInfo)
            MotionInfo.internalBinaryWrite(message.motionInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated PropPair prop_list = 5; */
        for (let i = 0; i < message.propList.length; i++)
            PropPair.internalBinaryWrite(message.propList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightPropPair fight_prop_list = 6; */
        for (let i = 0; i < message.fightPropList.length; i++)
            FightPropPair.internalBinaryWrite(message.fightPropList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 life_state = 7; */
        if (message.lifeState !== 0)
            writer.tag(7, WireType.Varint).uint32(message.lifeState);
        /* repeated AnimatorParameterValueInfoPair animator_para_list = 9; */
        for (let i = 0; i < message.animatorParaList.length; i++)
            AnimatorParameterValueInfoPair.internalBinaryWrite(message.animatorParaList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 last_move_scene_time_ms = 17; */
        if (message.lastMoveSceneTimeMs !== 0)
            writer.tag(17, WireType.Varint).uint32(message.lastMoveSceneTimeMs);
        /* uint32 last_move_reliable_seq = 18; */
        if (message.lastMoveReliableSeq !== 0)
            writer.tag(18, WireType.Varint).uint32(message.lastMoveReliableSeq);
        /* EntityClientData entity_client_data = 19; */
        if (message.entityClientData)
            EntityClientData.internalBinaryWrite(message.entityClientData, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated EntityEnvironmentInfo entity_environment_info_list = 20; */
        for (let i = 0; i < message.entityEnvironmentInfoList.length; i++)
            EntityEnvironmentInfo.internalBinaryWrite(message.entityEnvironmentInfoList[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* EntityAuthorityInfo entity_authority_info = 21; */
        if (message.entityAuthorityInfo)
            EntityAuthorityInfo.internalBinaryWrite(message.entityAuthorityInfo, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tag_list = 22; */
        for (let i = 0; i < message.tagList.length; i++)
            writer.tag(22, WireType.LengthDelimited).string(message.tagList[i]);
        /* repeated ServerBuff server_buff_list = 23; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityInfo
 */
export const SceneEntityInfo = new SceneEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneEntityMoveNotify$Type extends MessageType<SceneEntityMoveNotify> {
    constructor() {
        super("SceneEntityMoveNotify", [
            { no: 10, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "motion_info", kind: "message", T: () => MotionInfo },
            { no: 12, name: "scene_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "reliable_seq", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneEntityMoveNotify>): SceneEntityMoveNotify {
        const message = { entityId: 0, sceneTime: 0, reliableSeq: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneEntityMoveNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneEntityMoveNotify): SceneEntityMoveNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 10:
                    message.entityId = reader.uint32();
                    break;
                case /* MotionInfo motion_info */ 3:
                    message.motionInfo = MotionInfo.internalBinaryRead(reader, reader.uint32(), options, message.motionInfo);
                    break;
                case /* uint32 scene_time */ 12:
                    message.sceneTime = reader.uint32();
                    break;
                case /* uint32 reliable_seq */ 11:
                    message.reliableSeq = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneEntityMoveNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 10; */
        if (message.entityId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.entityId);
        /* MotionInfo motion_info = 3; */
        if (message.motionInfo)
            MotionInfo.internalBinaryWrite(message.motionInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 scene_time = 12; */
        if (message.sceneTime !== 0)
            writer.tag(12, WireType.Varint).uint32(message.sceneTime);
        /* uint32 reliable_seq = 11; */
        if (message.reliableSeq !== 0)
            writer.tag(11, WireType.Varint).uint32(message.reliableSeq);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneEntityMoveNotify
 */
export const SceneEntityMoveNotify = new SceneEntityMoveNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneFishInfo$Type extends MessageType<SceneFishInfo> {
    constructor() {
        super("SceneFishInfo", [
            { no: 1, name: "fish_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fish_pool_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "fish_pool_pos", kind: "message", T: () => Vector },
            { no: 4, name: "fish_pool_gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneFishInfo>): SceneFishInfo {
        const message = { fishId: 0, fishPoolEntityId: 0, fishPoolGadgetId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneFishInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneFishInfo): SceneFishInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fish_id */ 1:
                    message.fishId = reader.uint32();
                    break;
                case /* uint32 fish_pool_entity_id */ 2:
                    message.fishPoolEntityId = reader.uint32();
                    break;
                case /* Vector fish_pool_pos */ 3:
                    message.fishPoolPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.fishPoolPos);
                    break;
                case /* uint32 fish_pool_gadget_id */ 4:
                    message.fishPoolGadgetId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneFishInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fish_id = 1; */
        if (message.fishId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fishId);
        /* uint32 fish_pool_entity_id = 2; */
        if (message.fishPoolEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fishPoolEntityId);
        /* Vector fish_pool_pos = 3; */
        if (message.fishPoolPos)
            Vector.internalBinaryWrite(message.fishPoolPos, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 fish_pool_gadget_id = 4; */
        if (message.fishPoolGadgetId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.fishPoolGadgetId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneFishInfo
 */
export const SceneFishInfo = new SceneFishInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneForceUnlockNotify$Type extends MessageType<SceneForceUnlockNotify> {
    constructor() {
        super("SceneForceUnlockNotify", [
            { no: 1, name: "force_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_add", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SceneForceUnlockNotify>): SceneForceUnlockNotify {
        const message = { forceIdList: [], isAdd: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneForceUnlockNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneForceUnlockNotify): SceneForceUnlockNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 force_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.forceIdList.push(reader.uint32());
                    else
                        message.forceIdList.push(reader.uint32());
                    break;
                case /* bool is_add */ 5:
                    message.isAdd = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneForceUnlockNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 force_id_list = 1; */
        if (message.forceIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.forceIdList.length; i++)
                writer.uint32(message.forceIdList[i]);
            writer.join();
        }
        /* bool is_add = 5; */
        if (message.isAdd !== false)
            writer.tag(5, WireType.Varint).bool(message.isAdd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneForceUnlockNotify
 */
export const SceneForceUnlockNotify = new SceneForceUnlockNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneGadgetInfo$Type extends MessageType<SceneGadgetInfo> {
    constructor() {
        super("SceneGadgetInfo", [
            { no: 1, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "born_type", kind: "enum", T: () => ["GadgetBornType", GadgetBornType, "GADGET_BORN_TYPE_"] },
            { no: 6, name: "gadget_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "gadget_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_show_cutscene", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "authority_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "is_enable_interact", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "interact_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "mark_flag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "prop_owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "platform", kind: "message", T: () => PlatformInfo },
            { no: 24, name: "interact_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "draft_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "gadget_talk_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 100, name: "play_info", kind: "message", T: () => GadgetPlayInfo },
            { no: 12, name: "trifle_item", kind: "message", oneof: "content", T: () => Item },
            { no: 13, name: "gather_gadget", kind: "message", oneof: "content", T: () => GatherGadgetInfo },
            { no: 14, name: "worktop", kind: "message", oneof: "content", T: () => WorktopInfo },
            { no: 15, name: "client_gadget", kind: "message", oneof: "content", T: () => ClientGadgetInfo },
            { no: 17, name: "weather", kind: "message", oneof: "content", T: () => WeatherInfo },
            { no: 18, name: "ability_gadget", kind: "message", oneof: "content", T: () => AbilityGadgetInfo },
            { no: 19, name: "statue_gadget", kind: "message", oneof: "content", T: () => StatueGadgetInfo },
            { no: 20, name: "boss_chest", kind: "message", oneof: "content", T: () => BossChestInfo },
            { no: 41, name: "blossom_chest", kind: "message", oneof: "content", T: () => BlossomChestInfo },
            { no: 42, name: "mp_play_reward", kind: "message", oneof: "content", T: () => MpPlayRewardInfo },
            { no: 43, name: "general_reward", kind: "message", oneof: "content", T: () => GadgetGeneralRewardInfo },
            { no: 44, name: "offering_info", kind: "message", oneof: "content", T: () => OfferingInfo },
            { no: 45, name: "foundation_info", kind: "message", oneof: "content", T: () => FoundationInfo },
            { no: 46, name: "vehicle_info", kind: "message", oneof: "content", T: () => VehicleInfo },
            { no: 47, name: "shell_info", kind: "message", oneof: "content", T: () => EchoShellInfo },
            { no: 48, name: "screen_info", kind: "message", oneof: "content", T: () => ScreenInfo },
            { no: 59, name: "fish_pool_info", kind: "message", oneof: "content", T: () => FishPoolInfo },
            { no: 60, name: "custom_gadget_tree_info", kind: "message", oneof: "content", T: () => CustomGadgetTreeInfo },
            { no: 61, name: "roguelike_gadget_info", kind: "message", oneof: "content", T: () => RoguelikeGadgetInfo }
        ]);
    }
    create(value?: PartialMessage<SceneGadgetInfo>): SceneGadgetInfo {
        const message = { gadgetId: 0, groupId: 0, configId: 0, ownerEntityId: 0, bornType: 0, gadgetState: 0, gadgetType: 0, isShowCutscene: false, authorityPeerId: 0, isEnableInteract: false, interactId: 0, markFlag: 0, propOwnerEntityId: 0, interactUidList: [], draftId: 0, gadgetTalkState: 0, content: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneGadgetInfo): SceneGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_id */ 1:
                    message.gadgetId = reader.uint32();
                    break;
                case /* uint32 group_id */ 2:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 config_id */ 3:
                    message.configId = reader.uint32();
                    break;
                case /* uint32 owner_entity_id */ 4:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* GadgetBornType born_type */ 5:
                    message.bornType = reader.int32();
                    break;
                case /* uint32 gadget_state */ 6:
                    message.gadgetState = reader.uint32();
                    break;
                case /* uint32 gadget_type */ 7:
                    message.gadgetType = reader.uint32();
                    break;
                case /* bool is_show_cutscene */ 8:
                    message.isShowCutscene = reader.bool();
                    break;
                case /* uint32 authority_peer_id */ 9:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* bool is_enable_interact */ 10:
                    message.isEnableInteract = reader.bool();
                    break;
                case /* uint32 interact_id */ 11:
                    message.interactId = reader.uint32();
                    break;
                case /* uint32 mark_flag */ 21:
                    message.markFlag = reader.uint32();
                    break;
                case /* uint32 prop_owner_entity_id */ 22:
                    message.propOwnerEntityId = reader.uint32();
                    break;
                case /* PlatformInfo platform */ 23:
                    message.platform = PlatformInfo.internalBinaryRead(reader, reader.uint32(), options, message.platform);
                    break;
                case /* repeated uint32 interact_uid_list */ 24:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.interactUidList.push(reader.uint32());
                    else
                        message.interactUidList.push(reader.uint32());
                    break;
                case /* uint32 draft_id */ 25:
                    message.draftId = reader.uint32();
                    break;
                case /* uint32 gadget_talk_state */ 26:
                    message.gadgetTalkState = reader.uint32();
                    break;
                case /* GadgetPlayInfo play_info */ 100:
                    message.playInfo = GadgetPlayInfo.internalBinaryRead(reader, reader.uint32(), options, message.playInfo);
                    break;
                case /* Item trifle_item */ 12:
                    message.content = {
                        oneofKind: "trifleItem",
                        trifleItem: Item.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).trifleItem)
                    };
                    break;
                case /* GatherGadgetInfo gather_gadget */ 13:
                    message.content = {
                        oneofKind: "gatherGadget",
                        gatherGadget: GatherGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).gatherGadget)
                    };
                    break;
                case /* WorktopInfo worktop */ 14:
                    message.content = {
                        oneofKind: "worktop",
                        worktop: WorktopInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).worktop)
                    };
                    break;
                case /* ClientGadgetInfo client_gadget */ 15:
                    message.content = {
                        oneofKind: "clientGadget",
                        clientGadget: ClientGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).clientGadget)
                    };
                    break;
                case /* WeatherInfo weather */ 17:
                    message.content = {
                        oneofKind: "weather",
                        weather: WeatherInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).weather)
                    };
                    break;
                case /* AbilityGadgetInfo ability_gadget */ 18:
                    message.content = {
                        oneofKind: "abilityGadget",
                        abilityGadget: AbilityGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).abilityGadget)
                    };
                    break;
                case /* StatueGadgetInfo statue_gadget */ 19:
                    message.content = {
                        oneofKind: "statueGadget",
                        statueGadget: StatueGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).statueGadget)
                    };
                    break;
                case /* BossChestInfo boss_chest */ 20:
                    message.content = {
                        oneofKind: "bossChest",
                        bossChest: BossChestInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).bossChest)
                    };
                    break;
                case /* BlossomChestInfo blossom_chest */ 41:
                    message.content = {
                        oneofKind: "blossomChest",
                        blossomChest: BlossomChestInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).blossomChest)
                    };
                    break;
                case /* MpPlayRewardInfo mp_play_reward */ 42:
                    message.content = {
                        oneofKind: "mpPlayReward",
                        mpPlayReward: MpPlayRewardInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).mpPlayReward)
                    };
                    break;
                case /* GadgetGeneralRewardInfo general_reward */ 43:
                    message.content = {
                        oneofKind: "generalReward",
                        generalReward: GadgetGeneralRewardInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).generalReward)
                    };
                    break;
                case /* OfferingInfo offering_info */ 44:
                    message.content = {
                        oneofKind: "offeringInfo",
                        offeringInfo: OfferingInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).offeringInfo)
                    };
                    break;
                case /* FoundationInfo foundation_info */ 45:
                    message.content = {
                        oneofKind: "foundationInfo",
                        foundationInfo: FoundationInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).foundationInfo)
                    };
                    break;
                case /* VehicleInfo vehicle_info */ 46:
                    message.content = {
                        oneofKind: "vehicleInfo",
                        vehicleInfo: VehicleInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).vehicleInfo)
                    };
                    break;
                case /* EchoShellInfo shell_info */ 47:
                    message.content = {
                        oneofKind: "shellInfo",
                        shellInfo: EchoShellInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).shellInfo)
                    };
                    break;
                case /* ScreenInfo screen_info */ 48:
                    message.content = {
                        oneofKind: "screenInfo",
                        screenInfo: ScreenInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).screenInfo)
                    };
                    break;
                case /* FishPoolInfo fish_pool_info */ 59:
                    message.content = {
                        oneofKind: "fishPoolInfo",
                        fishPoolInfo: FishPoolInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).fishPoolInfo)
                    };
                    break;
                case /* CustomGadgetTreeInfo custom_gadget_tree_info */ 60:
                    message.content = {
                        oneofKind: "customGadgetTreeInfo",
                        customGadgetTreeInfo: CustomGadgetTreeInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).customGadgetTreeInfo)
                    };
                    break;
                case /* RoguelikeGadgetInfo roguelike_gadget_info */ 61:
                    message.content = {
                        oneofKind: "roguelikeGadgetInfo",
                        roguelikeGadgetInfo: RoguelikeGadgetInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).roguelikeGadgetInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_id = 1; */
        if (message.gadgetId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.gadgetId);
        /* uint32 group_id = 2; */
        if (message.groupId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.groupId);
        /* uint32 config_id = 3; */
        if (message.configId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.configId);
        /* uint32 owner_entity_id = 4; */
        if (message.ownerEntityId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.ownerEntityId);
        /* GadgetBornType born_type = 5; */
        if (message.bornType !== 0)
            writer.tag(5, WireType.Varint).int32(message.bornType);
        /* uint32 gadget_state = 6; */
        if (message.gadgetState !== 0)
            writer.tag(6, WireType.Varint).uint32(message.gadgetState);
        /* uint32 gadget_type = 7; */
        if (message.gadgetType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.gadgetType);
        /* bool is_show_cutscene = 8; */
        if (message.isShowCutscene !== false)
            writer.tag(8, WireType.Varint).bool(message.isShowCutscene);
        /* uint32 authority_peer_id = 9; */
        if (message.authorityPeerId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.authorityPeerId);
        /* bool is_enable_interact = 10; */
        if (message.isEnableInteract !== false)
            writer.tag(10, WireType.Varint).bool(message.isEnableInteract);
        /* uint32 interact_id = 11; */
        if (message.interactId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.interactId);
        /* uint32 mark_flag = 21; */
        if (message.markFlag !== 0)
            writer.tag(21, WireType.Varint).uint32(message.markFlag);
        /* uint32 prop_owner_entity_id = 22; */
        if (message.propOwnerEntityId !== 0)
            writer.tag(22, WireType.Varint).uint32(message.propOwnerEntityId);
        /* PlatformInfo platform = 23; */
        if (message.platform)
            PlatformInfo.internalBinaryWrite(message.platform, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 interact_uid_list = 24; */
        if (message.interactUidList.length) {
            writer.tag(24, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.interactUidList.length; i++)
                writer.uint32(message.interactUidList[i]);
            writer.join();
        }
        /* uint32 draft_id = 25; */
        if (message.draftId !== 0)
            writer.tag(25, WireType.Varint).uint32(message.draftId);
        /* uint32 gadget_talk_state = 26; */
        if (message.gadgetTalkState !== 0)
            writer.tag(26, WireType.Varint).uint32(message.gadgetTalkState);
        /* GadgetPlayInfo play_info = 100; */
        if (message.playInfo)
            GadgetPlayInfo.internalBinaryWrite(message.playInfo, writer.tag(100, WireType.LengthDelimited).fork(), options).join();
        /* Item trifle_item = 12; */
        if (message.content.oneofKind === "trifleItem")
            Item.internalBinaryWrite(message.content.trifleItem, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* GatherGadgetInfo gather_gadget = 13; */
        if (message.content.oneofKind === "gatherGadget")
            GatherGadgetInfo.internalBinaryWrite(message.content.gatherGadget, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* WorktopInfo worktop = 14; */
        if (message.content.oneofKind === "worktop")
            WorktopInfo.internalBinaryWrite(message.content.worktop, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* ClientGadgetInfo client_gadget = 15; */
        if (message.content.oneofKind === "clientGadget")
            ClientGadgetInfo.internalBinaryWrite(message.content.clientGadget, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* WeatherInfo weather = 17; */
        if (message.content.oneofKind === "weather")
            WeatherInfo.internalBinaryWrite(message.content.weather, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* AbilityGadgetInfo ability_gadget = 18; */
        if (message.content.oneofKind === "abilityGadget")
            AbilityGadgetInfo.internalBinaryWrite(message.content.abilityGadget, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* StatueGadgetInfo statue_gadget = 19; */
        if (message.content.oneofKind === "statueGadget")
            StatueGadgetInfo.internalBinaryWrite(message.content.statueGadget, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* BossChestInfo boss_chest = 20; */
        if (message.content.oneofKind === "bossChest")
            BossChestInfo.internalBinaryWrite(message.content.bossChest, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* BlossomChestInfo blossom_chest = 41; */
        if (message.content.oneofKind === "blossomChest")
            BlossomChestInfo.internalBinaryWrite(message.content.blossomChest, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* MpPlayRewardInfo mp_play_reward = 42; */
        if (message.content.oneofKind === "mpPlayReward")
            MpPlayRewardInfo.internalBinaryWrite(message.content.mpPlayReward, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* GadgetGeneralRewardInfo general_reward = 43; */
        if (message.content.oneofKind === "generalReward")
            GadgetGeneralRewardInfo.internalBinaryWrite(message.content.generalReward, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* OfferingInfo offering_info = 44; */
        if (message.content.oneofKind === "offeringInfo")
            OfferingInfo.internalBinaryWrite(message.content.offeringInfo, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* FoundationInfo foundation_info = 45; */
        if (message.content.oneofKind === "foundationInfo")
            FoundationInfo.internalBinaryWrite(message.content.foundationInfo, writer.tag(45, WireType.LengthDelimited).fork(), options).join();
        /* VehicleInfo vehicle_info = 46; */
        if (message.content.oneofKind === "vehicleInfo")
            VehicleInfo.internalBinaryWrite(message.content.vehicleInfo, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* EchoShellInfo shell_info = 47; */
        if (message.content.oneofKind === "shellInfo")
            EchoShellInfo.internalBinaryWrite(message.content.shellInfo, writer.tag(47, WireType.LengthDelimited).fork(), options).join();
        /* ScreenInfo screen_info = 48; */
        if (message.content.oneofKind === "screenInfo")
            ScreenInfo.internalBinaryWrite(message.content.screenInfo, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* FishPoolInfo fish_pool_info = 59; */
        if (message.content.oneofKind === "fishPoolInfo")
            FishPoolInfo.internalBinaryWrite(message.content.fishPoolInfo, writer.tag(59, WireType.LengthDelimited).fork(), options).join();
        /* CustomGadgetTreeInfo custom_gadget_tree_info = 60; */
        if (message.content.oneofKind === "customGadgetTreeInfo")
            CustomGadgetTreeInfo.internalBinaryWrite(message.content.customGadgetTreeInfo, writer.tag(60, WireType.LengthDelimited).fork(), options).join();
        /* RoguelikeGadgetInfo roguelike_gadget_info = 61; */
        if (message.content.oneofKind === "roguelikeGadgetInfo")
            RoguelikeGadgetInfo.internalBinaryWrite(message.content.roguelikeGadgetInfo, writer.tag(61, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneGadgetInfo
 */
export const SceneGadgetInfo = new SceneGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneInitFinishRsp$Type extends MessageType<SceneInitFinishRsp> {
    constructor() {
        super("SceneInitFinishRsp", [
            { no: 10, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "enter_scene_token", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneInitFinishRsp>): SceneInitFinishRsp {
        const message = { retcode: 0, enterSceneToken: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneInitFinishRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneInitFinishRsp): SceneInitFinishRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 10:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 enter_scene_token */ 15:
                    message.enterSceneToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneInitFinishRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 10; */
        if (message.retcode !== 0)
            writer.tag(10, WireType.Varint).int32(message.retcode);
        /* uint32 enter_scene_token = 15; */
        if (message.enterSceneToken !== 0)
            writer.tag(15, WireType.Varint).uint32(message.enterSceneToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneInitFinishRsp
 */
export const SceneInitFinishRsp = new SceneInitFinishRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneKickPlayerNotify$Type extends MessageType<SceneKickPlayerNotify> {
    constructor() {
        super("SceneKickPlayerNotify", [
            { no: 9, name: "kicker_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneKickPlayerNotify>): SceneKickPlayerNotify {
        const message = { kickerUid: 0, targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneKickPlayerNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneKickPlayerNotify): SceneKickPlayerNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 kicker_uid */ 9:
                    message.kickerUid = reader.uint32();
                    break;
                case /* uint32 target_uid */ 13:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneKickPlayerNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 kicker_uid = 9; */
        if (message.kickerUid !== 0)
            writer.tag(9, WireType.Varint).uint32(message.kickerUid);
        /* uint32 target_uid = 13; */
        if (message.targetUid !== 0)
            writer.tag(13, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneKickPlayerNotify
 */
export const SceneKickPlayerNotify = new SceneKickPlayerNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneKickPlayerReq$Type extends MessageType<SceneKickPlayerReq> {
    constructor() {
        super("SceneKickPlayerReq", [
            { no: 12, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneKickPlayerReq>): SceneKickPlayerReq {
        const message = { targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneKickPlayerReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneKickPlayerReq): SceneKickPlayerReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 12:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneKickPlayerReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 12; */
        if (message.targetUid !== 0)
            writer.tag(12, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneKickPlayerReq
 */
export const SceneKickPlayerReq = new SceneKickPlayerReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneKickPlayerRsp$Type extends MessageType<SceneKickPlayerRsp> {
    constructor() {
        super("SceneKickPlayerRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneKickPlayerRsp>): SceneKickPlayerRsp {
        const message = { retcode: 0, targetUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneKickPlayerRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneKickPlayerRsp): SceneKickPlayerRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 12:
                    message.targetUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneKickPlayerRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 12; */
        if (message.targetUid !== 0)
            writer.tag(12, WireType.Varint).uint32(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneKickPlayerRsp
 */
export const SceneKickPlayerRsp = new SceneKickPlayerRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneMonsterInfo$Type extends MessageType<SceneMonsterInfo> {
    constructor() {
        super("SceneMonsterInfo", [
            { no: 50, name: "fish_info", kind: "message", oneof: "content", T: () => SceneFishInfo },
            { no: 1, name: "monster_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "weapon_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SceneWeaponInfo },
            { no: 5, name: "authority_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "affix_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_elite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "owner_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "summoned_tag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "summon_tag_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 11, name: "pose_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "born_type", kind: "enum", T: () => ["MonsterBornType", MonsterBornType, "MONSTER_BORN_TYPE_"] },
            { no: 13, name: "block_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "mark_flag", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "title_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "special_name_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "attack_target_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "monster_route", kind: "message", T: () => MonsterRoute },
            { no: 19, name: "ai_config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "level_route_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "init_pose_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneMonsterInfo>): SceneMonsterInfo {
        const message = { content: { oneofKind: undefined }, monsterId: 0, groupId: 0, configId: 0, weaponList: [], authorityPeerId: 0, affixList: [], isElite: false, ownerEntityId: 0, summonedTag: 0, summonTagMap: {}, poseId: 0, bornType: 0, blockId: 0, markFlag: 0, titleId: 0, specialNameId: 0, attackTargetId: 0, aiConfigId: 0, levelRouteId: 0, initPoseId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneMonsterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneMonsterInfo): SceneMonsterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SceneFishInfo fish_info */ 50:
                    message.content = {
                        oneofKind: "fishInfo",
                        fishInfo: SceneFishInfo.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).fishInfo)
                    };
                    break;
                case /* uint32 monster_id */ 1:
                    message.monsterId = reader.uint32();
                    break;
                case /* uint32 group_id */ 2:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 config_id */ 3:
                    message.configId = reader.uint32();
                    break;
                case /* repeated SceneWeaponInfo weapon_list */ 4:
                    message.weaponList.push(SceneWeaponInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 authority_peer_id */ 5:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* repeated uint32 affix_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.affixList.push(reader.uint32());
                    else
                        message.affixList.push(reader.uint32());
                    break;
                case /* bool is_elite */ 7:
                    message.isElite = reader.bool();
                    break;
                case /* uint32 owner_entity_id */ 8:
                    message.ownerEntityId = reader.uint32();
                    break;
                case /* uint32 summoned_tag */ 9:
                    message.summonedTag = reader.uint32();
                    break;
                case /* map<uint32, uint32> summon_tag_map */ 10:
                    this.binaryReadMap10(message.summonTagMap, reader, options);
                    break;
                case /* uint32 pose_id */ 11:
                    message.poseId = reader.uint32();
                    break;
                case /* MonsterBornType born_type */ 12:
                    message.bornType = reader.int32();
                    break;
                case /* uint32 block_id */ 13:
                    message.blockId = reader.uint32();
                    break;
                case /* uint32 mark_flag */ 14:
                    message.markFlag = reader.uint32();
                    break;
                case /* uint32 title_id */ 15:
                    message.titleId = reader.uint32();
                    break;
                case /* uint32 special_name_id */ 16:
                    message.specialNameId = reader.uint32();
                    break;
                case /* uint32 attack_target_id */ 17:
                    message.attackTargetId = reader.uint32();
                    break;
                case /* MonsterRoute monster_route */ 18:
                    message.monsterRoute = MonsterRoute.internalBinaryRead(reader, reader.uint32(), options, message.monsterRoute);
                    break;
                case /* uint32 ai_config_id */ 19:
                    message.aiConfigId = reader.uint32();
                    break;
                case /* uint32 level_route_id */ 20:
                    message.levelRouteId = reader.uint32();
                    break;
                case /* uint32 init_pose_id */ 21:
                    message.initPoseId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: SceneMonsterInfo["summonTagMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneMonsterInfo["summonTagMap"] | undefined, val: SceneMonsterInfo["summonTagMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneMonsterInfo.summon_tag_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: SceneMonsterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SceneFishInfo fish_info = 50; */
        if (message.content.oneofKind === "fishInfo")
            SceneFishInfo.internalBinaryWrite(message.content.fishInfo, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* uint32 monster_id = 1; */
        if (message.monsterId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.monsterId);
        /* uint32 group_id = 2; */
        if (message.groupId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.groupId);
        /* uint32 config_id = 3; */
        if (message.configId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.configId);
        /* repeated SceneWeaponInfo weapon_list = 4; */
        for (let i = 0; i < message.weaponList.length; i++)
            SceneWeaponInfo.internalBinaryWrite(message.weaponList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 authority_peer_id = 5; */
        if (message.authorityPeerId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.authorityPeerId);
        /* repeated uint32 affix_list = 6; */
        if (message.affixList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.affixList.length; i++)
                writer.uint32(message.affixList[i]);
            writer.join();
        }
        /* bool is_elite = 7; */
        if (message.isElite !== false)
            writer.tag(7, WireType.Varint).bool(message.isElite);
        /* uint32 owner_entity_id = 8; */
        if (message.ownerEntityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.ownerEntityId);
        /* uint32 summoned_tag = 9; */
        if (message.summonedTag !== 0)
            writer.tag(9, WireType.Varint).uint32(message.summonedTag);
        /* map<uint32, uint32> summon_tag_map = 10; */
        for (let k of Object.keys(message.summonTagMap))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.summonTagMap[k as any]).join();
        /* uint32 pose_id = 11; */
        if (message.poseId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.poseId);
        /* MonsterBornType born_type = 12; */
        if (message.bornType !== 0)
            writer.tag(12, WireType.Varint).int32(message.bornType);
        /* uint32 block_id = 13; */
        if (message.blockId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.blockId);
        /* uint32 mark_flag = 14; */
        if (message.markFlag !== 0)
            writer.tag(14, WireType.Varint).uint32(message.markFlag);
        /* uint32 title_id = 15; */
        if (message.titleId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.titleId);
        /* uint32 special_name_id = 16; */
        if (message.specialNameId !== 0)
            writer.tag(16, WireType.Varint).uint32(message.specialNameId);
        /* uint32 attack_target_id = 17; */
        if (message.attackTargetId !== 0)
            writer.tag(17, WireType.Varint).uint32(message.attackTargetId);
        /* MonsterRoute monster_route = 18; */
        if (message.monsterRoute)
            MonsterRoute.internalBinaryWrite(message.monsterRoute, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* uint32 ai_config_id = 19; */
        if (message.aiConfigId !== 0)
            writer.tag(19, WireType.Varint).uint32(message.aiConfigId);
        /* uint32 level_route_id = 20; */
        if (message.levelRouteId !== 0)
            writer.tag(20, WireType.Varint).uint32(message.levelRouteId);
        /* uint32 init_pose_id = 21; */
        if (message.initPoseId !== 0)
            writer.tag(21, WireType.Varint).uint32(message.initPoseId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneMonsterInfo
 */
export const SceneMonsterInfo = new SceneMonsterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneNpcInfo$Type extends MessageType<SceneNpcInfo> {
    constructor() {
        super("SceneNpcInfo", [
            { no: 1, name: "npc_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "room_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "block_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneNpcInfo>): SceneNpcInfo {
        const message = { npcId: 0, roomId: 0, parentQuestId: 0, blockId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneNpcInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneNpcInfo): SceneNpcInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 npc_id */ 1:
                    message.npcId = reader.uint32();
                    break;
                case /* uint32 room_id */ 2:
                    message.roomId = reader.uint32();
                    break;
                case /* uint32 parent_quest_id */ 3:
                    message.parentQuestId = reader.uint32();
                    break;
                case /* uint32 block_id */ 4:
                    message.blockId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneNpcInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 npc_id = 1; */
        if (message.npcId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.npcId);
        /* uint32 room_id = 2; */
        if (message.roomId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.roomId);
        /* uint32 parent_quest_id = 3; */
        if (message.parentQuestId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.parentQuestId);
        /* uint32 block_id = 4; */
        if (message.blockId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.blockId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneNpcInfo
 */
export const SceneNpcInfo = new SceneNpcInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScenePlayerInfo$Type extends MessageType<ScenePlayerInfo> {
    constructor() {
        super("ScenePlayerInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "online_player_info", kind: "message", T: () => OnlinePlayerInfo }
        ]);
    }
    create(value?: PartialMessage<ScenePlayerInfo>): ScenePlayerInfo {
        const message = { uid: 0, peerId: 0, name: "", isConnected: false, sceneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScenePlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScenePlayerInfo): ScenePlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 peer_id */ 2:
                    message.peerId = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* bool is_connected */ 4:
                    message.isConnected = reader.bool();
                    break;
                case /* uint32 scene_id */ 5:
                    message.sceneId = reader.uint32();
                    break;
                case /* OnlinePlayerInfo online_player_info */ 6:
                    message.onlinePlayerInfo = OnlinePlayerInfo.internalBinaryRead(reader, reader.uint32(), options, message.onlinePlayerInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScenePlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint32 peer_id = 2; */
        if (message.peerId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.peerId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* bool is_connected = 4; */
        if (message.isConnected !== false)
            writer.tag(4, WireType.Varint).bool(message.isConnected);
        /* uint32 scene_id = 5; */
        if (message.sceneId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.sceneId);
        /* OnlinePlayerInfo online_player_info = 6; */
        if (message.onlinePlayerInfo)
            OnlinePlayerInfo.internalBinaryWrite(message.onlinePlayerInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ScenePlayerInfo
 */
export const ScenePlayerInfo = new ScenePlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScenePlayerInfoNotify$Type extends MessageType<ScenePlayerInfoNotify> {
    constructor() {
        super("ScenePlayerInfoNotify", [
            { no: 11, name: "player_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScenePlayerInfo }
        ]);
    }
    create(value?: PartialMessage<ScenePlayerInfoNotify>): ScenePlayerInfoNotify {
        const message = { playerInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScenePlayerInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScenePlayerInfoNotify): ScenePlayerInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ScenePlayerInfo player_info_list */ 11:
                    message.playerInfoList.push(ScenePlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScenePlayerInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ScenePlayerInfo player_info_list = 11; */
        for (let i = 0; i < message.playerInfoList.length; i++)
            ScenePlayerInfo.internalBinaryWrite(message.playerInfoList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ScenePlayerInfoNotify
 */
export const ScenePlayerInfoNotify = new ScenePlayerInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScenePlayerLocationNotify$Type extends MessageType<ScenePlayerLocationNotify> {
    constructor() {
        super("ScenePlayerLocationNotify", [
            { no: 1, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "player_loc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayerLocationInfo },
            { no: 5, name: "vehicle_loc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VehicleLocationInfo }
        ]);
    }
    create(value?: PartialMessage<ScenePlayerLocationNotify>): ScenePlayerLocationNotify {
        const message = { sceneId: 0, playerLocList: [], vehicleLocList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScenePlayerLocationNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScenePlayerLocationNotify): ScenePlayerLocationNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 1:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated PlayerLocationInfo player_loc_list */ 8:
                    message.playerLocList.push(PlayerLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated VehicleLocationInfo vehicle_loc_list */ 5:
                    message.vehicleLocList.push(VehicleLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScenePlayerLocationNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 1; */
        if (message.sceneId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sceneId);
        /* repeated PlayerLocationInfo player_loc_list = 8; */
        for (let i = 0; i < message.playerLocList.length; i++)
            PlayerLocationInfo.internalBinaryWrite(message.playerLocList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated VehicleLocationInfo vehicle_loc_list = 5; */
        for (let i = 0; i < message.vehicleLocList.length; i++)
            VehicleLocationInfo.internalBinaryWrite(message.vehicleLocList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ScenePlayerLocationNotify
 */
export const ScenePlayerLocationNotify = new ScenePlayerLocationNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneReliquaryInfo$Type extends MessageType<SceneReliquaryInfo> {
    constructor() {
        super("SceneReliquaryInfo", [
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneReliquaryInfo>): SceneReliquaryInfo {
        const message = { itemId: 0, guid: 0n, level: 0, promoteLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneReliquaryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneReliquaryInfo): SceneReliquaryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                case /* uint64 guid */ 2:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* uint32 promote_level */ 4:
                    message.promoteLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneReliquaryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        /* uint64 guid = 2; */
        if (message.guid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.guid);
        /* uint32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* uint32 promote_level = 4; */
        if (message.promoteLevel !== 0)
            writer.tag(4, WireType.Varint).uint32(message.promoteLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneReliquaryInfo
 */
export const SceneReliquaryInfo = new SceneReliquaryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneTeamAvatar$Type extends MessageType<SceneTeamAvatar> {
    constructor() {
        super("SceneTeamAvatar", [
            { no: 7, name: "player_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "avatar_info", kind: "message", T: () => AvatarInfo },
            { no: 4, name: "scene_avatar_info", kind: "message", T: () => SceneAvatarInfo },
            { no: 9, name: "avatar_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 14, name: "server_buff_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServerBuff },
            { no: 11, name: "scene_entity_info", kind: "message", T: () => SceneEntityInfo },
            { no: 15, name: "weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "weapon_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "weapon_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 10, name: "ability_control_block", kind: "message", T: () => AbilityControlBlock },
            { no: 12, name: "is_reconnect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "is_player_cur_avatar", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 311, name: "is_on_scene", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SceneTeamAvatar>): SceneTeamAvatar {
        const message = { playerUid: 0, avatarGuid: 0n, sceneId: 0, entityId: 0, serverBuffList: [], weaponGuid: 0n, weaponEntityId: 0, isReconnect: false, isPlayerCurAvatar: false, isOnScene: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneTeamAvatar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneTeamAvatar): SceneTeamAvatar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 player_uid */ 7:
                    message.playerUid = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 5:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 scene_id */ 2:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* AvatarInfo avatar_info */ 1:
                    message.avatarInfo = AvatarInfo.internalBinaryRead(reader, reader.uint32(), options, message.avatarInfo);
                    break;
                case /* SceneAvatarInfo scene_avatar_info */ 4:
                    message.sceneAvatarInfo = SceneAvatarInfo.internalBinaryRead(reader, reader.uint32(), options, message.sceneAvatarInfo);
                    break;
                case /* AbilitySyncStateInfo avatar_ability_info */ 9:
                    message.avatarAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.avatarAbilityInfo);
                    break;
                case /* repeated ServerBuff server_buff_list */ 14:
                    message.serverBuffList.push(ServerBuff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* SceneEntityInfo scene_entity_info */ 11:
                    message.sceneEntityInfo = SceneEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.sceneEntityInfo);
                    break;
                case /* uint64 weapon_guid */ 15:
                    message.weaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 weapon_entity_id */ 6:
                    message.weaponEntityId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo weapon_ability_info */ 3:
                    message.weaponAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.weaponAbilityInfo);
                    break;
                case /* AbilityControlBlock ability_control_block */ 10:
                    message.abilityControlBlock = AbilityControlBlock.internalBinaryRead(reader, reader.uint32(), options, message.abilityControlBlock);
                    break;
                case /* bool is_reconnect */ 12:
                    message.isReconnect = reader.bool();
                    break;
                case /* bool is_player_cur_avatar */ 13:
                    message.isPlayerCurAvatar = reader.bool();
                    break;
                case /* bool is_on_scene */ 311:
                    message.isOnScene = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneTeamAvatar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 player_uid = 7; */
        if (message.playerUid !== 0)
            writer.tag(7, WireType.Varint).uint32(message.playerUid);
        /* uint64 avatar_guid = 5; */
        if (message.avatarGuid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 scene_id = 2; */
        if (message.sceneId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.sceneId);
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* AvatarInfo avatar_info = 1; */
        if (message.avatarInfo)
            AvatarInfo.internalBinaryWrite(message.avatarInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* SceneAvatarInfo scene_avatar_info = 4; */
        if (message.sceneAvatarInfo)
            SceneAvatarInfo.internalBinaryWrite(message.sceneAvatarInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* AbilitySyncStateInfo avatar_ability_info = 9; */
        if (message.avatarAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.avatarAbilityInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated ServerBuff server_buff_list = 14; */
        for (let i = 0; i < message.serverBuffList.length; i++)
            ServerBuff.internalBinaryWrite(message.serverBuffList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* SceneEntityInfo scene_entity_info = 11; */
        if (message.sceneEntityInfo)
            SceneEntityInfo.internalBinaryWrite(message.sceneEntityInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint64 weapon_guid = 15; */
        if (message.weaponGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.weaponGuid);
        /* uint32 weapon_entity_id = 6; */
        if (message.weaponEntityId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.weaponEntityId);
        /* AbilitySyncStateInfo weapon_ability_info = 3; */
        if (message.weaponAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.weaponAbilityInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* AbilityControlBlock ability_control_block = 10; */
        if (message.abilityControlBlock)
            AbilityControlBlock.internalBinaryWrite(message.abilityControlBlock, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool is_reconnect = 12; */
        if (message.isReconnect !== false)
            writer.tag(12, WireType.Varint).bool(message.isReconnect);
        /* bool is_player_cur_avatar = 13; */
        if (message.isPlayerCurAvatar !== false)
            writer.tag(13, WireType.Varint).bool(message.isPlayerCurAvatar);
        /* bool is_on_scene = 311; */
        if (message.isOnScene !== false)
            writer.tag(311, WireType.Varint).bool(message.isOnScene);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneTeamAvatar
 */
export const SceneTeamAvatar = new SceneTeamAvatar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneTeamUpdateNotify$Type extends MessageType<SceneTeamUpdateNotify> {
    constructor() {
        super("SceneTeamUpdateNotify", [
            { no: 11, name: "scene_team_avatar_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SceneTeamAvatar },
            { no: 1, name: "is_in_mp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SceneTeamUpdateNotify>): SceneTeamUpdateNotify {
        const message = { sceneTeamAvatarList: [], isInMp: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneTeamUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneTeamUpdateNotify): SceneTeamUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SceneTeamAvatar scene_team_avatar_list */ 11:
                    message.sceneTeamAvatarList.push(SceneTeamAvatar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_in_mp */ 1:
                    message.isInMp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneTeamUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SceneTeamAvatar scene_team_avatar_list = 11; */
        for (let i = 0; i < message.sceneTeamAvatarList.length; i++)
            SceneTeamAvatar.internalBinaryWrite(message.sceneTeamAvatarList[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool is_in_mp = 1; */
        if (message.isInMp !== false)
            writer.tag(1, WireType.Varint).bool(message.isInMp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneTeamUpdateNotify
 */
export const SceneTeamUpdateNotify = new SceneTeamUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneTimeNotify$Type extends MessageType<SceneTimeNotify> {
    constructor() {
        super("SceneTimeNotify", [
            { no: 3, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "scene_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SceneTimeNotify>): SceneTimeNotify {
        const message = { sceneId: 0, isPaused: false, sceneTime: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneTimeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneTimeNotify): SceneTimeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 3:
                    message.sceneId = reader.uint32();
                    break;
                case /* bool is_paused */ 5:
                    message.isPaused = reader.bool();
                    break;
                case /* uint64 scene_time */ 14:
                    message.sceneTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneTimeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 3; */
        if (message.sceneId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sceneId);
        /* bool is_paused = 5; */
        if (message.isPaused !== false)
            writer.tag(5, WireType.Varint).bool(message.isPaused);
        /* uint64 scene_time = 14; */
        if (message.sceneTime !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.sceneTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneTimeNotify
 */
export const SceneTimeNotify = new SceneTimeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneTransToPointReq$Type extends MessageType<SceneTransToPointReq> {
    constructor() {
        super("SceneTransToPointReq", [
            { no: 12, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneTransToPointReq>): SceneTransToPointReq {
        const message = { sceneId: 0, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneTransToPointReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneTransToPointReq): SceneTransToPointReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 12:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 point_id */ 4:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneTransToPointReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 12; */
        if (message.sceneId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.sceneId);
        /* uint32 point_id = 4; */
        if (message.pointId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneTransToPointReq
 */
export const SceneTransToPointReq = new SceneTransToPointReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneTransToPointRsp$Type extends MessageType<SceneTransToPointRsp> {
    constructor() {
        super("SceneTransToPointRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneTransToPointRsp>): SceneTransToPointRsp {
        const message = { retcode: 0, sceneId: 0, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneTransToPointRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneTransToPointRsp): SceneTransToPointRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 scene_id */ 11:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 point_id */ 13:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneTransToPointRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* uint32 scene_id = 11; */
        if (message.sceneId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sceneId);
        /* uint32 point_id = 13; */
        if (message.pointId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneTransToPointRsp
 */
export const SceneTransToPointRsp = new SceneTransToPointRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneUnlockInfo$Type extends MessageType<SceneUnlockInfo> {
    constructor() {
        super("SceneUnlockInfo", [
            { no: 1, name: "sceneId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "isLocked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sceneTagIdList", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SceneUnlockInfo>): SceneUnlockInfo {
        const message = { sceneId: 0, isLocked: false, sceneTagIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneUnlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneUnlockInfo): SceneUnlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sceneId */ 1:
                    message.sceneId = reader.uint32();
                    break;
                case /* bool isLocked */ 2:
                    message.isLocked = reader.bool();
                    break;
                case /* repeated uint32 sceneTagIdList */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sceneTagIdList.push(reader.uint32());
                    else
                        message.sceneTagIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SceneUnlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sceneId = 1; */
        if (message.sceneId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sceneId);
        /* bool isLocked = 2; */
        if (message.isLocked !== false)
            writer.tag(2, WireType.Varint).bool(message.isLocked);
        /* repeated uint32 sceneTagIdList = 3; */
        if (message.sceneTagIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sceneTagIdList.length; i++)
                writer.uint32(message.sceneTagIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneUnlockInfo
 */
export const SceneUnlockInfo = new SceneUnlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SceneWeaponInfo$Type extends MessageType<SceneWeaponInfo> {
    constructor() {
        super("SceneWeaponInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 8, name: "affix_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 9, name: "renderer_changed_info", kind: "message", T: () => EntityRendererChangedInfo }
        ]);
    }
    create(value?: PartialMessage<SceneWeaponInfo>): SceneWeaponInfo {
        const message = { entityId: 0, gadgetId: 0, itemId: 0, guid: 0n, level: 0, promoteLevel: 0, affixMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SceneWeaponInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SceneWeaponInfo): SceneWeaponInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 gadget_id */ 2:
                    message.gadgetId = reader.uint32();
                    break;
                case /* uint32 item_id */ 3:
                    message.itemId = reader.uint32();
                    break;
                case /* uint64 guid */ 4:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 level */ 5:
                    message.level = reader.uint32();
                    break;
                case /* uint32 promote_level */ 6:
                    message.promoteLevel = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo ability_info */ 7:
                    message.abilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.abilityInfo);
                    break;
                case /* map<uint32, uint32> affix_map */ 8:
                    this.binaryReadMap8(message.affixMap, reader, options);
                    break;
                case /* EntityRendererChangedInfo renderer_changed_info */ 9:
                    message.rendererChangedInfo = EntityRendererChangedInfo.internalBinaryRead(reader, reader.uint32(), options, message.rendererChangedInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: SceneWeaponInfo["affixMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SceneWeaponInfo["affixMap"] | undefined, val: SceneWeaponInfo["affixMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field SceneWeaponInfo.affix_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: SceneWeaponInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* uint32 gadget_id = 2; */
        if (message.gadgetId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gadgetId);
        /* uint32 item_id = 3; */
        if (message.itemId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.itemId);
        /* uint64 guid = 4; */
        if (message.guid !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.guid);
        /* uint32 level = 5; */
        if (message.level !== 0)
            writer.tag(5, WireType.Varint).uint32(message.level);
        /* uint32 promote_level = 6; */
        if (message.promoteLevel !== 0)
            writer.tag(6, WireType.Varint).uint32(message.promoteLevel);
        /* AbilitySyncStateInfo ability_info = 7; */
        if (message.abilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.abilityInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* map<uint32, uint32> affix_map = 8; */
        for (let k of Object.keys(message.affixMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.affixMap[k as any]).join();
        /* EntityRendererChangedInfo renderer_changed_info = 9; */
        if (message.rendererChangedInfo)
            EntityRendererChangedInfo.internalBinaryWrite(message.rendererChangedInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SceneWeaponInfo
 */
export const SceneWeaponInfo = new SceneWeaponInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScreenInfo$Type extends MessageType<ScreenInfo> {
    constructor() {
        super("ScreenInfo", [
            { no: 1, name: "live_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "projector_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ScreenInfo>): ScreenInfo {
        const message = { liveId: 0, projectorEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScreenInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScreenInfo): ScreenInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 live_id */ 1:
                    message.liveId = reader.uint32();
                    break;
                case /* uint32 projector_entity_id */ 2:
                    message.projectorEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScreenInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 live_id = 1; */
        if (message.liveId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.liveId);
        /* uint32 projector_entity_id = 2; */
        if (message.projectorEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.projectorEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ScreenInfo
 */
export const ScreenInfo = new ScreenInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectWorktopOptionReq$Type extends MessageType<SelectWorktopOptionReq> {
    constructor() {
        super("SelectWorktopOptionReq", [
            { no: 2, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "option_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SelectWorktopOptionReq>): SelectWorktopOptionReq {
        const message = { gadgetEntityId: 0, optionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectWorktopOptionReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectWorktopOptionReq): SelectWorktopOptionReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_entity_id */ 2:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* uint32 option_id */ 5:
                    message.optionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectWorktopOptionReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_entity_id = 2; */
        if (message.gadgetEntityId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gadgetEntityId);
        /* uint32 option_id = 5; */
        if (message.optionId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.optionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectWorktopOptionReq
 */
export const SelectWorktopOptionReq = new SelectWorktopOptionReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectWorktopOptionRsp$Type extends MessageType<SelectWorktopOptionRsp> {
    constructor() {
        super("SelectWorktopOptionRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "option_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SelectWorktopOptionRsp>): SelectWorktopOptionRsp {
        const message = { retcode: 0, gadgetEntityId: 0, optionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectWorktopOptionRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectWorktopOptionRsp): SelectWorktopOptionRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 gadget_entity_id */ 12:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* uint32 option_id */ 10:
                    message.optionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectWorktopOptionRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 gadget_entity_id = 12; */
        if (message.gadgetEntityId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.gadgetEntityId);
        /* uint32 option_id = 10; */
        if (message.optionId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.optionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectWorktopOptionRsp
 */
export const SelectWorktopOptionRsp = new SelectWorktopOptionRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServantInfo$Type extends MessageType<ServantInfo> {
    constructor() {
        super("ServantInfo", [
            { no: 1, name: "master_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "born_slot_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServantInfo>): ServantInfo {
        const message = { masterEntityId: 0, bornSlotIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServantInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServantInfo): ServantInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 master_entity_id */ 1:
                    message.masterEntityId = reader.uint32();
                    break;
                case /* uint32 born_slot_index */ 2:
                    message.bornSlotIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServantInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 master_entity_id = 1; */
        if (message.masterEntityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.masterEntityId);
        /* uint32 born_slot_index = 2; */
        if (message.bornSlotIndex !== 0)
            writer.tag(2, WireType.Varint).uint32(message.bornSlotIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServantInfo
 */
export const ServantInfo = new ServantInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerAnnounceNotify$Type extends MessageType<ServerAnnounceNotify> {
    constructor() {
        super("ServerAnnounceNotify", [
            { no: 8, name: "announce_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AnnounceData }
        ]);
    }
    create(value?: PartialMessage<ServerAnnounceNotify>): ServerAnnounceNotify {
        const message = { announceDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerAnnounceNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerAnnounceNotify): ServerAnnounceNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AnnounceData announce_data_list */ 8:
                    message.announceDataList.push(AnnounceData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerAnnounceNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AnnounceData announce_data_list = 8; */
        for (let i = 0; i < message.announceDataList.length; i++)
            AnnounceData.internalBinaryWrite(message.announceDataList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerAnnounceNotify
 */
export const ServerAnnounceNotify = new ServerAnnounceNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerAnnounceRevokeNotify$Type extends MessageType<ServerAnnounceRevokeNotify> {
    constructor() {
        super("ServerAnnounceRevokeNotify", [
            { no: 15, name: "config_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServerAnnounceRevokeNotify>): ServerAnnounceRevokeNotify {
        const message = { configIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerAnnounceRevokeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerAnnounceRevokeNotify): ServerAnnounceRevokeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 config_id_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.configIdList.push(reader.uint32());
                    else
                        message.configIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerAnnounceRevokeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 config_id_list = 15; */
        if (message.configIdList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.configIdList.length; i++)
                writer.uint32(message.configIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerAnnounceRevokeNotify
 */
export const ServerAnnounceRevokeNotify = new ServerAnnounceRevokeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerBuff$Type extends MessageType<ServerBuff> {
    constructor() {
        super("ServerBuff", [
            { no: 1, name: "server_buff_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_buff_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "server_buff_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "instanced_modifier_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_modifier_added", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ServerBuff>): ServerBuff {
        const message = { serverBuffUid: 0, serverBuffId: 0, serverBuffType: 0, instancedModifierId: 0, isModifierAdded: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerBuff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerBuff): ServerBuff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 server_buff_uid */ 1:
                    message.serverBuffUid = reader.uint32();
                    break;
                case /* uint32 server_buff_id */ 2:
                    message.serverBuffId = reader.uint32();
                    break;
                case /* uint32 server_buff_type */ 3:
                    message.serverBuffType = reader.uint32();
                    break;
                case /* uint32 instanced_modifier_id */ 4:
                    message.instancedModifierId = reader.uint32();
                    break;
                case /* bool is_modifier_added */ 5:
                    message.isModifierAdded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerBuff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 server_buff_uid = 1; */
        if (message.serverBuffUid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serverBuffUid);
        /* uint32 server_buff_id = 2; */
        if (message.serverBuffId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serverBuffId);
        /* uint32 server_buff_type = 3; */
        if (message.serverBuffType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.serverBuffType);
        /* uint32 instanced_modifier_id = 4; */
        if (message.instancedModifierId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.instancedModifierId);
        /* bool is_modifier_added = 5; */
        if (message.isModifierAdded !== false)
            writer.tag(5, WireType.Varint).bool(message.isModifierAdded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerBuff
 */
export const ServerBuff = new ServerBuff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerCondMeetQuestListUpdateNotify$Type extends MessageType<ServerCondMeetQuestListUpdateNotify> {
    constructor() {
        super("ServerCondMeetQuestListUpdateNotify", [
            { no: 9, name: "add_quest_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "del_quest_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServerCondMeetQuestListUpdateNotify>): ServerCondMeetQuestListUpdateNotify {
        const message = { addQuestIdList: [], delQuestIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerCondMeetQuestListUpdateNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerCondMeetQuestListUpdateNotify): ServerCondMeetQuestListUpdateNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 add_quest_id_list */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.addQuestIdList.push(reader.uint32());
                    else
                        message.addQuestIdList.push(reader.uint32());
                    break;
                case /* repeated uint32 del_quest_id_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.delQuestIdList.push(reader.uint32());
                    else
                        message.delQuestIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerCondMeetQuestListUpdateNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 add_quest_id_list = 9; */
        if (message.addQuestIdList.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.addQuestIdList.length; i++)
                writer.uint32(message.addQuestIdList[i]);
            writer.join();
        }
        /* repeated uint32 del_quest_id_list = 6; */
        if (message.delQuestIdList.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.delQuestIdList.length; i++)
                writer.uint32(message.delQuestIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerCondMeetQuestListUpdateNotify
 */
export const ServerCondMeetQuestListUpdateNotify = new ServerCondMeetQuestListUpdateNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerTimeNotify$Type extends MessageType<ServerTimeNotify> {
    constructor() {
        super("ServerTimeNotify", [
            { no: 15, name: "server_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ServerTimeNotify>): ServerTimeNotify {
        const message = { serverTime: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerTimeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerTimeNotify): ServerTimeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 server_time */ 15:
                    message.serverTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerTimeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 server_time = 15; */
        if (message.serverTime !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.serverTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServerTimeNotify
 */
export const ServerTimeNotify = new ServerTimeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBattlePassViewedReq$Type extends MessageType<SetBattlePassViewedReq> {
    constructor() {
        super("SetBattlePassViewedReq", [
            { no: 6, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetBattlePassViewedReq>): SetBattlePassViewedReq {
        const message = { scheduleId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetBattlePassViewedReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBattlePassViewedReq): SetBattlePassViewedReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 schedule_id */ 6:
                    message.scheduleId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBattlePassViewedReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 schedule_id = 6; */
        if (message.scheduleId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.scheduleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetBattlePassViewedReq
 */
export const SetBattlePassViewedReq = new SetBattlePassViewedReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBattlePassViewedRsp$Type extends MessageType<SetBattlePassViewedRsp> {
    constructor() {
        super("SetBattlePassViewedRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetBattlePassViewedRsp>): SetBattlePassViewedRsp {
        const message = { retcode: 0, scheduleId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetBattlePassViewedRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBattlePassViewedRsp): SetBattlePassViewedRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 schedule_id */ 10:
                    message.scheduleId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBattlePassViewedRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 schedule_id = 10; */
        if (message.scheduleId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.scheduleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetBattlePassViewedRsp
 */
export const SetBattlePassViewedRsp = new SetBattlePassViewedRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEntityClientDataNotify$Type extends MessageType<SetEntityClientDataNotify> {
    constructor() {
        super("SetEntityClientDataNotify", [
            { no: 13, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "entity_client_data", kind: "message", T: () => EntityClientData }
        ]);
    }
    create(value?: PartialMessage<SetEntityClientDataNotify>): SetEntityClientDataNotify {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetEntityClientDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEntityClientDataNotify): SetEntityClientDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 13:
                    message.entityId = reader.uint32();
                    break;
                case /* EntityClientData entity_client_data */ 1:
                    message.entityClientData = EntityClientData.internalBinaryRead(reader, reader.uint32(), options, message.entityClientData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEntityClientDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 13; */
        if (message.entityId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.entityId);
        /* EntityClientData entity_client_data = 1; */
        if (message.entityClientData)
            EntityClientData.internalBinaryWrite(message.entityClientData, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetEntityClientDataNotify
 */
export const SetEntityClientDataNotify = new SetEntityClientDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEquipLockStateReq$Type extends MessageType<SetEquipLockStateReq> {
    constructor() {
        super("SetEquipLockStateReq", [
            { no: 10, name: "target_equip_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetEquipLockStateReq>): SetEquipLockStateReq {
        const message = { targetEquipGuid: 0n, isLocked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetEquipLockStateReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEquipLockStateReq): SetEquipLockStateReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_equip_guid */ 10:
                    message.targetEquipGuid = reader.uint64().toBigInt();
                    break;
                case /* bool is_locked */ 11:
                    message.isLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEquipLockStateReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_equip_guid = 10; */
        if (message.targetEquipGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.targetEquipGuid);
        /* bool is_locked = 11; */
        if (message.isLocked !== false)
            writer.tag(11, WireType.Varint).bool(message.isLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetEquipLockStateReq
 */
export const SetEquipLockStateReq = new SetEquipLockStateReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEquipLockStateRsp$Type extends MessageType<SetEquipLockStateRsp> {
    constructor() {
        super("SetEquipLockStateRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "target_equip_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "is_locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetEquipLockStateRsp>): SetEquipLockStateRsp {
        const message = { retcode: 0, targetEquipGuid: 0n, isLocked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetEquipLockStateRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetEquipLockStateRsp): SetEquipLockStateRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_equip_guid */ 13:
                    message.targetEquipGuid = reader.uint64().toBigInt();
                    break;
                case /* bool is_locked */ 5:
                    message.isLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetEquipLockStateRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint64 target_equip_guid = 13; */
        if (message.targetEquipGuid !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.targetEquipGuid);
        /* bool is_locked = 5; */
        if (message.isLocked !== false)
            writer.tag(5, WireType.Varint).bool(message.isLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetEquipLockStateRsp
 */
export const SetEquipLockStateRsp = new SetEquipLockStateRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetNameCardReq$Type extends MessageType<SetNameCardReq> {
    constructor() {
        super("SetNameCardReq", [
            { no: 4, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetNameCardReq>): SetNameCardReq {
        const message = { nameCardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetNameCardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetNameCardReq): SetNameCardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 name_card_id */ 4:
                    message.nameCardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetNameCardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 name_card_id = 4; */
        if (message.nameCardId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.nameCardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetNameCardReq
 */
export const SetNameCardReq = new SetNameCardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetNameCardRsp$Type extends MessageType<SetNameCardRsp> {
    constructor() {
        super("SetNameCardRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetNameCardRsp>): SetNameCardRsp {
        const message = { retcode: 0, nameCardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetNameCardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetNameCardRsp): SetNameCardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 name_card_id */ 2:
                    message.nameCardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetNameCardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint32 name_card_id = 2; */
        if (message.nameCardId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.nameCardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetNameCardRsp
 */
export const SetNameCardRsp = new SetNameCardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerBirthdayReq$Type extends MessageType<SetPlayerBirthdayReq> {
    constructor() {
        super("SetPlayerBirthdayReq", [
            { no: 10, name: "birthday", kind: "message", T: () => Birthday }
        ]);
    }
    create(value?: PartialMessage<SetPlayerBirthdayReq>): SetPlayerBirthdayReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerBirthdayReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerBirthdayReq): SetPlayerBirthdayReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Birthday birthday */ 10:
                    message.birthday = Birthday.internalBinaryRead(reader, reader.uint32(), options, message.birthday);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerBirthdayReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Birthday birthday = 10; */
        if (message.birthday)
            Birthday.internalBinaryWrite(message.birthday, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerBirthdayReq
 */
export const SetPlayerBirthdayReq = new SetPlayerBirthdayReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerBirthdayRsp$Type extends MessageType<SetPlayerBirthdayRsp> {
    constructor() {
        super("SetPlayerBirthdayRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "birthday", kind: "message", T: () => Birthday }
        ]);
    }
    create(value?: PartialMessage<SetPlayerBirthdayRsp>): SetPlayerBirthdayRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerBirthdayRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerBirthdayRsp): SetPlayerBirthdayRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* Birthday birthday */ 14:
                    message.birthday = Birthday.internalBinaryRead(reader, reader.uint32(), options, message.birthday);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerBirthdayRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* Birthday birthday = 14; */
        if (message.birthday)
            Birthday.internalBinaryWrite(message.birthday, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerBirthdayRsp
 */
export const SetPlayerBirthdayRsp = new SetPlayerBirthdayRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerBornDataReq$Type extends MessageType<SetPlayerBornDataReq> {
    constructor() {
        super("SetPlayerBornDataReq", [
            { no: 3, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "nick_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerBornDataReq>): SetPlayerBornDataReq {
        const message = { avatarId: 0, nickName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerBornDataReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerBornDataReq): SetPlayerBornDataReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 3:
                    message.avatarId = reader.uint32();
                    break;
                case /* string nick_name */ 12:
                    message.nickName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerBornDataReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 3; */
        if (message.avatarId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.avatarId);
        /* string nick_name = 12; */
        if (message.nickName !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.nickName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerBornDataReq
 */
export const SetPlayerBornDataReq = new SetPlayerBornDataReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerBornDataRsp$Type extends MessageType<SetPlayerBornDataRsp> {
    constructor() {
        super("SetPlayerBornDataRsp", [
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerBornDataRsp>): SetPlayerBornDataRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerBornDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerBornDataRsp): SetPlayerBornDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerBornDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerBornDataRsp
 */
export const SetPlayerBornDataRsp = new SetPlayerBornDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerHeadImageReq$Type extends MessageType<SetPlayerHeadImageReq> {
    constructor() {
        super("SetPlayerHeadImageReq", [
            { no: 4, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerHeadImageReq>): SetPlayerHeadImageReq {
        const message = { avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerHeadImageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerHeadImageReq): SetPlayerHeadImageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 4:
                    message.avatarId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerHeadImageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 4; */
        if (message.avatarId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.avatarId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerHeadImageReq
 */
export const SetPlayerHeadImageReq = new SetPlayerHeadImageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerHeadImageRsp$Type extends MessageType<SetPlayerHeadImageRsp> {
    constructor() {
        super("SetPlayerHeadImageRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "profile_picture", kind: "message", T: () => ProfilePicture }
        ]);
    }
    create(value?: PartialMessage<SetPlayerHeadImageRsp>): SetPlayerHeadImageRsp {
        const message = { retcode: 0, avatarId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerHeadImageRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerHeadImageRsp): SetPlayerHeadImageRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 avatar_id */ 3:
                    message.avatarId = reader.uint32();
                    break;
                case /* ProfilePicture profile_picture */ 5:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerHeadImageRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 avatar_id = 3; */
        if (message.avatarId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.avatarId);
        /* ProfilePicture profile_picture = 5; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerHeadImageRsp
 */
export const SetPlayerHeadImageRsp = new SetPlayerHeadImageRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerNameReq$Type extends MessageType<SetPlayerNameReq> {
    constructor() {
        super("SetPlayerNameReq", [
            { no: 8, name: "nick_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerNameReq>): SetPlayerNameReq {
        const message = { nickName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerNameReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerNameReq): SetPlayerNameReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string nick_name */ 8:
                    message.nickName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerNameReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string nick_name = 8; */
        if (message.nickName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.nickName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerNameReq
 */
export const SetPlayerNameReq = new SetPlayerNameReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerNameRsp$Type extends MessageType<SetPlayerNameRsp> {
    constructor() {
        super("SetPlayerNameRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "nick_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerNameRsp>): SetPlayerNameRsp {
        const message = { retcode: 0, nickName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerNameRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerNameRsp): SetPlayerNameRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* string nick_name */ 6:
                    message.nickName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerNameRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* string nick_name = 6; */
        if (message.nickName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.nickName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerNameRsp
 */
export const SetPlayerNameRsp = new SetPlayerNameRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerPropReq$Type extends MessageType<SetPlayerPropReq> {
    constructor() {
        super("SetPlayerPropReq", [
            { no: 14, name: "prop_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PropValue }
        ]);
    }
    create(value?: PartialMessage<SetPlayerPropReq>): SetPlayerPropReq {
        const message = { propList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerPropReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerPropReq): SetPlayerPropReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PropValue prop_list */ 14:
                    message.propList.push(PropValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerPropReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PropValue prop_list = 14; */
        for (let i = 0; i < message.propList.length; i++)
            PropValue.internalBinaryWrite(message.propList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerPropReq
 */
export const SetPlayerPropReq = new SetPlayerPropReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerPropRsp$Type extends MessageType<SetPlayerPropRsp> {
    constructor() {
        super("SetPlayerPropRsp", [
            { no: 5, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerPropRsp>): SetPlayerPropRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerPropRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerPropRsp): SetPlayerPropRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 5:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerPropRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 5; */
        if (message.retcode !== 0)
            writer.tag(5, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerPropRsp
 */
export const SetPlayerPropRsp = new SetPlayerPropRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerSignatureReq$Type extends MessageType<SetPlayerSignatureReq> {
    constructor() {
        super("SetPlayerSignatureReq", [
            { no: 15, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerSignatureReq>): SetPlayerSignatureReq {
        const message = { signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerSignatureReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerSignatureReq): SetPlayerSignatureReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signature */ 15:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerSignatureReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signature = 15; */
        if (message.signature !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerSignatureReq
 */
export const SetPlayerSignatureReq = new SetPlayerSignatureReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlayerSignatureRsp$Type extends MessageType<SetPlayerSignatureRsp> {
    constructor() {
        super("SetPlayerSignatureRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlayerSignatureRsp>): SetPlayerSignatureRsp {
        const message = { retcode: 0, signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetPlayerSignatureRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlayerSignatureRsp): SetPlayerSignatureRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* string signature */ 6:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlayerSignatureRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* string signature = 6; */
        if (message.signature !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlayerSignatureRsp
 */
export const SetPlayerSignatureRsp = new SetPlayerSignatureRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpAvatarTeamReq$Type extends MessageType<SetUpAvatarTeamReq> {
    constructor() {
        super("SetUpAvatarTeamReq", [
            { no: 10, name: "team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "avatar_team_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cur_avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetUpAvatarTeamReq>): SetUpAvatarTeamReq {
        const message = { teamId: 0, avatarTeamGuidList: [], curAvatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetUpAvatarTeamReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpAvatarTeamReq): SetUpAvatarTeamReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 team_id */ 10:
                    message.teamId = reader.uint32();
                    break;
                case /* repeated uint64 avatar_team_guid_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarTeamGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarTeamGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* uint64 cur_avatar_guid */ 2:
                    message.curAvatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpAvatarTeamReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 team_id = 10; */
        if (message.teamId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.teamId);
        /* repeated uint64 avatar_team_guid_list = 1; */
        if (message.avatarTeamGuidList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarTeamGuidList.length; i++)
                writer.uint64(message.avatarTeamGuidList[i]);
            writer.join();
        }
        /* uint64 cur_avatar_guid = 2; */
        if (message.curAvatarGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.curAvatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpAvatarTeamReq
 */
export const SetUpAvatarTeamReq = new SetUpAvatarTeamReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpAvatarTeamRsp$Type extends MessageType<SetUpAvatarTeamRsp> {
    constructor() {
        super("SetUpAvatarTeamRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "avatar_team_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "cur_avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetUpAvatarTeamRsp>): SetUpAvatarTeamRsp {
        const message = { retcode: 0, teamId: 0, avatarTeamGuidList: [], curAvatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetUpAvatarTeamRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpAvatarTeamRsp): SetUpAvatarTeamRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 team_id */ 5:
                    message.teamId = reader.uint32();
                    break;
                case /* repeated uint64 avatar_team_guid_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarTeamGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarTeamGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* uint64 cur_avatar_guid */ 3:
                    message.curAvatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpAvatarTeamRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint32 team_id = 5; */
        if (message.teamId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.teamId);
        /* repeated uint64 avatar_team_guid_list = 12; */
        if (message.avatarTeamGuidList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarTeamGuidList.length; i++)
                writer.uint64(message.avatarTeamGuidList[i]);
            writer.join();
        }
        /* uint64 cur_avatar_guid = 3; */
        if (message.curAvatarGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.curAvatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpAvatarTeamRsp
 */
export const SetUpAvatarTeamRsp = new SetUpAvatarTeamRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpLunchBoxWidgetReq$Type extends MessageType<SetUpLunchBoxWidgetReq> {
    constructor() {
        super("SetUpLunchBoxWidgetReq", [
            { no: 12, name: "lunch_box_data", kind: "message", T: () => LunchBoxData }
        ]);
    }
    create(value?: PartialMessage<SetUpLunchBoxWidgetReq>): SetUpLunchBoxWidgetReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetUpLunchBoxWidgetReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpLunchBoxWidgetReq): SetUpLunchBoxWidgetReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LunchBoxData lunch_box_data */ 12:
                    message.lunchBoxData = LunchBoxData.internalBinaryRead(reader, reader.uint32(), options, message.lunchBoxData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpLunchBoxWidgetReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* LunchBoxData lunch_box_data = 12; */
        if (message.lunchBoxData)
            LunchBoxData.internalBinaryWrite(message.lunchBoxData, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpLunchBoxWidgetReq
 */
export const SetUpLunchBoxWidgetReq = new SetUpLunchBoxWidgetReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpLunchBoxWidgetRsp$Type extends MessageType<SetUpLunchBoxWidgetRsp> {
    constructor() {
        super("SetUpLunchBoxWidgetRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lunch_box_data", kind: "message", T: () => LunchBoxData }
        ]);
    }
    create(value?: PartialMessage<SetUpLunchBoxWidgetRsp>): SetUpLunchBoxWidgetRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetUpLunchBoxWidgetRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpLunchBoxWidgetRsp): SetUpLunchBoxWidgetRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* LunchBoxData lunch_box_data */ 3:
                    message.lunchBoxData = LunchBoxData.internalBinaryRead(reader, reader.uint32(), options, message.lunchBoxData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpLunchBoxWidgetRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* LunchBoxData lunch_box_data = 3; */
        if (message.lunchBoxData)
            LunchBoxData.internalBinaryWrite(message.lunchBoxData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpLunchBoxWidgetRsp
 */
export const SetUpLunchBoxWidgetRsp = new SetUpLunchBoxWidgetRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWidgetSlotReq$Type extends MessageType<SetWidgetSlotReq> {
    constructor() {
        super("SetWidgetSlotReq", [
            { no: 4, name: "op", kind: "enum", T: () => ["WidgetSlotOp", WidgetSlotOp, "WIDGET_SLOT_OP_"] },
            { no: 11, name: "tag_list", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["WidgetSlotTag", WidgetSlotTag, "WIDGET_SLOT_TAG_"] },
            { no: 9, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetWidgetSlotReq>): SetWidgetSlotReq {
        const message = { op: 0, tagList: [], materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetWidgetSlotReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWidgetSlotReq): SetWidgetSlotReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetSlotOp op */ 4:
                    message.op = reader.int32();
                    break;
                case /* repeated WidgetSlotTag tag_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagList.push(reader.int32());
                    else
                        message.tagList.push(reader.int32());
                    break;
                case /* uint32 material_id */ 9:
                    message.materialId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetWidgetSlotReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetSlotOp op = 4; */
        if (message.op !== 0)
            writer.tag(4, WireType.Varint).int32(message.op);
        /* repeated WidgetSlotTag tag_list = 11; */
        if (message.tagList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tagList.length; i++)
                writer.int32(message.tagList[i]);
            writer.join();
        }
        /* uint32 material_id = 9; */
        if (message.materialId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.materialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetWidgetSlotReq
 */
export const SetWidgetSlotReq = new SetWidgetSlotReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWidgetSlotRsp$Type extends MessageType<SetWidgetSlotRsp> {
    constructor() {
        super("SetWidgetSlotRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "op", kind: "enum", T: () => ["WidgetSlotOp", WidgetSlotOp, "WIDGET_SLOT_OP_"] },
            { no: 4, name: "tag_list", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["WidgetSlotTag", WidgetSlotTag, "WIDGET_SLOT_TAG_"] },
            { no: 9, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetWidgetSlotRsp>): SetWidgetSlotRsp {
        const message = { retcode: 0, op: 0, tagList: [], materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetWidgetSlotRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWidgetSlotRsp): SetWidgetSlotRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* WidgetSlotOp op */ 14:
                    message.op = reader.int32();
                    break;
                case /* repeated WidgetSlotTag tag_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagList.push(reader.int32());
                    else
                        message.tagList.push(reader.int32());
                    break;
                case /* uint32 material_id */ 9:
                    message.materialId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetWidgetSlotRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* WidgetSlotOp op = 14; */
        if (message.op !== 0)
            writer.tag(14, WireType.Varint).int32(message.op);
        /* repeated WidgetSlotTag tag_list = 4; */
        if (message.tagList.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tagList.length; i++)
                writer.int32(message.tagList[i]);
            writer.join();
        }
        /* uint32 material_id = 9; */
        if (message.materialId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.materialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetWidgetSlotRsp
 */
export const SetWidgetSlotRsp = new SetWidgetSlotRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shop$Type extends MessageType<Shop> {
    constructor() {
        super("Shop", [
            { no: 13, name: "shop_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "goods_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopGoods },
            { no: 2, name: "mcoin_product_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopMcoinProduct },
            { no: 10, name: "card_product_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopCardProduct },
            { no: 6, name: "next_refresh_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "city_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "city_reputation_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "concert_product_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShopConcertProduct }
        ]);
    }
    create(value?: PartialMessage<Shop>): Shop {
        const message = { shopType: 0, goodsList: [], mcoinProductList: [], cardProductList: [], nextRefreshTime: 0, cityId: 0, cityReputationLevel: 0, concertProductList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Shop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shop): Shop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 shop_type */ 13:
                    message.shopType = reader.uint32();
                    break;
                case /* repeated ShopGoods goods_list */ 1:
                    message.goodsList.push(ShopGoods.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ShopMcoinProduct mcoin_product_list */ 2:
                    message.mcoinProductList.push(ShopMcoinProduct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ShopCardProduct card_product_list */ 10:
                    message.cardProductList.push(ShopCardProduct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 next_refresh_time */ 6:
                    message.nextRefreshTime = reader.uint32();
                    break;
                case /* uint32 city_id */ 7:
                    message.cityId = reader.uint32();
                    break;
                case /* uint32 city_reputation_level */ 14:
                    message.cityReputationLevel = reader.uint32();
                    break;
                case /* repeated ShopConcertProduct concert_product_list */ 3:
                    message.concertProductList.push(ShopConcertProduct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 shop_type = 13; */
        if (message.shopType !== 0)
            writer.tag(13, WireType.Varint).uint32(message.shopType);
        /* repeated ShopGoods goods_list = 1; */
        for (let i = 0; i < message.goodsList.length; i++)
            ShopGoods.internalBinaryWrite(message.goodsList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ShopMcoinProduct mcoin_product_list = 2; */
        for (let i = 0; i < message.mcoinProductList.length; i++)
            ShopMcoinProduct.internalBinaryWrite(message.mcoinProductList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ShopCardProduct card_product_list = 10; */
        for (let i = 0; i < message.cardProductList.length; i++)
            ShopCardProduct.internalBinaryWrite(message.cardProductList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* uint32 next_refresh_time = 6; */
        if (message.nextRefreshTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.nextRefreshTime);
        /* uint32 city_id = 7; */
        if (message.cityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.cityId);
        /* uint32 city_reputation_level = 14; */
        if (message.cityReputationLevel !== 0)
            writer.tag(14, WireType.Varint).uint32(message.cityReputationLevel);
        /* repeated ShopConcertProduct concert_product_list = 3; */
        for (let i = 0; i < message.concertProductList.length; i++)
            ShopConcertProduct.internalBinaryWrite(message.concertProductList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Shop
 */
export const Shop = new Shop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopCardProduct$Type extends MessageType<ShopCardProduct> {
    constructor() {
        super("ShopCardProduct", [
            { no: 101, name: "resin_card", kind: "message", oneof: "extraCardData", T: () => ShopCardProduct_ResinCard },
            { no: 1, name: "product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mcoin_base", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hcoin_per_day", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "days", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "remain_reward_days", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "card_product_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopCardProduct>): ShopCardProduct {
        const message = { extraCardData: { oneofKind: undefined }, productId: "", priceTier: "", mcoinBase: 0, hcoinPerDay: 0, days: 0, remainRewardDays: 0, cardProductType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopCardProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopCardProduct): ShopCardProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ShopCardProduct.ResinCard resin_card */ 101:
                    message.extraCardData = {
                        oneofKind: "resinCard",
                        resinCard: ShopCardProduct_ResinCard.internalBinaryRead(reader, reader.uint32(), options, (message.extraCardData as any).resinCard)
                    };
                    break;
                case /* string product_id */ 1:
                    message.productId = reader.string();
                    break;
                case /* string price_tier */ 2:
                    message.priceTier = reader.string();
                    break;
                case /* uint32 mcoin_base */ 3:
                    message.mcoinBase = reader.uint32();
                    break;
                case /* uint32 hcoin_per_day */ 4:
                    message.hcoinPerDay = reader.uint32();
                    break;
                case /* uint32 days */ 5:
                    message.days = reader.uint32();
                    break;
                case /* uint32 remain_reward_days */ 6:
                    message.remainRewardDays = reader.uint32();
                    break;
                case /* uint32 card_product_type */ 7:
                    message.cardProductType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopCardProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ShopCardProduct.ResinCard resin_card = 101; */
        if (message.extraCardData.oneofKind === "resinCard")
            ShopCardProduct_ResinCard.internalBinaryWrite(message.extraCardData.resinCard, writer.tag(101, WireType.LengthDelimited).fork(), options).join();
        /* string product_id = 1; */
        if (message.productId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.productId);
        /* string price_tier = 2; */
        if (message.priceTier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.priceTier);
        /* uint32 mcoin_base = 3; */
        if (message.mcoinBase !== 0)
            writer.tag(3, WireType.Varint).uint32(message.mcoinBase);
        /* uint32 hcoin_per_day = 4; */
        if (message.hcoinPerDay !== 0)
            writer.tag(4, WireType.Varint).uint32(message.hcoinPerDay);
        /* uint32 days = 5; */
        if (message.days !== 0)
            writer.tag(5, WireType.Varint).uint32(message.days);
        /* uint32 remain_reward_days = 6; */
        if (message.remainRewardDays !== 0)
            writer.tag(6, WireType.Varint).uint32(message.remainRewardDays);
        /* uint32 card_product_type = 7; */
        if (message.cardProductType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.cardProductType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShopCardProduct
 */
export const ShopCardProduct = new ShopCardProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopCardProduct_ResinCard$Type extends MessageType<ShopCardProduct_ResinCard> {
    constructor() {
        super("ShopCardProduct.ResinCard", [
            { no: 1, name: "base_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "per_day_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<ShopCardProduct_ResinCard>): ShopCardProduct_ResinCard {
        const message = { baseItemList: [], perDayItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopCardProduct_ResinCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopCardProduct_ResinCard): ShopCardProduct_ResinCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ItemParam base_item_list */ 1:
                    message.baseItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam per_day_item_list */ 2:
                    message.perDayItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopCardProduct_ResinCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ItemParam base_item_list = 1; */
        for (let i = 0; i < message.baseItemList.length; i++)
            ItemParam.internalBinaryWrite(message.baseItemList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam per_day_item_list = 2; */
        for (let i = 0; i < message.perDayItemList.length; i++)
            ItemParam.internalBinaryWrite(message.perDayItemList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShopCardProduct.ResinCard
 */
export const ShopCardProduct_ResinCard = new ShopCardProduct_ResinCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopConcertProduct$Type extends MessageType<ShopConcertProduct> {
    constructor() {
        super("ShopConcertProduct", [
            { no: 1, name: "product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "obtain_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "obtain_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "buy_times", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopConcertProduct>): ShopConcertProduct {
        const message = { productId: "", priceTier: "", obtainCount: 0, obtainLimit: 0, beginTime: 0, endTime: 0, buyTimes: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopConcertProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopConcertProduct): ShopConcertProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string product_id */ 1:
                    message.productId = reader.string();
                    break;
                case /* string price_tier */ 2:
                    message.priceTier = reader.string();
                    break;
                case /* uint32 obtain_count */ 3:
                    message.obtainCount = reader.uint32();
                    break;
                case /* uint32 obtain_limit */ 4:
                    message.obtainLimit = reader.uint32();
                    break;
                case /* uint32 begin_time */ 5:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 6:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 buy_times */ 7:
                    message.buyTimes = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopConcertProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string product_id = 1; */
        if (message.productId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.productId);
        /* string price_tier = 2; */
        if (message.priceTier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.priceTier);
        /* uint32 obtain_count = 3; */
        if (message.obtainCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.obtainCount);
        /* uint32 obtain_limit = 4; */
        if (message.obtainLimit !== 0)
            writer.tag(4, WireType.Varint).uint32(message.obtainLimit);
        /* uint32 begin_time = 5; */
        if (message.beginTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 6; */
        if (message.endTime !== 0)
            writer.tag(6, WireType.Varint).uint32(message.endTime);
        /* uint32 buy_times = 7; */
        if (message.buyTimes !== 0)
            writer.tag(7, WireType.Varint).uint32(message.buyTimes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShopConcertProduct
 */
export const ShopConcertProduct = new ShopConcertProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopGoods$Type extends MessageType<ShopGoods> {
    constructor() {
        super("ShopGoods", [
            { no: 2, name: "goods_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "goods_item", kind: "message", T: () => ItemParam },
            { no: 6, name: "scoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "hcoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "cost_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 5, name: "bought_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "buy_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "next_refresh_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "min_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "max_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "pre_goods_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "mcoin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "disable_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 320, name: "secondary_sheet_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 868, name: "discount_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 922, name: "discount_begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1847, name: "discount_end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1654, name: "single_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopGoods>): ShopGoods {
        const message = { goodsId: 0, scoin: 0, hcoin: 0, costItemList: [], boughtNum: 0, buyLimit: 0, beginTime: 0, endTime: 0, nextRefreshTime: 0, minLevel: 0, maxLevel: 0, preGoodsIdList: [], mcoin: 0, disableType: 0, secondarySheetId: 0, discountId: 0, discountBeginTime: 0, discountEndTime: 0, singleLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopGoods>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopGoods): ShopGoods {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 goods_id */ 2:
                    message.goodsId = reader.uint32();
                    break;
                case /* ItemParam goods_item */ 15:
                    message.goodsItem = ItemParam.internalBinaryRead(reader, reader.uint32(), options, message.goodsItem);
                    break;
                case /* uint32 scoin */ 6:
                    message.scoin = reader.uint32();
                    break;
                case /* uint32 hcoin */ 10:
                    message.hcoin = reader.uint32();
                    break;
                case /* repeated ItemParam cost_item_list */ 14:
                    message.costItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 bought_num */ 5:
                    message.boughtNum = reader.uint32();
                    break;
                case /* uint32 buy_limit */ 13:
                    message.buyLimit = reader.uint32();
                    break;
                case /* uint32 begin_time */ 1:
                    message.beginTime = reader.uint32();
                    break;
                case /* uint32 end_time */ 4:
                    message.endTime = reader.uint32();
                    break;
                case /* uint32 next_refresh_time */ 8:
                    message.nextRefreshTime = reader.uint32();
                    break;
                case /* uint32 min_level */ 3:
                    message.minLevel = reader.uint32();
                    break;
                case /* uint32 max_level */ 11:
                    message.maxLevel = reader.uint32();
                    break;
                case /* repeated uint32 pre_goods_id_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.preGoodsIdList.push(reader.uint32());
                    else
                        message.preGoodsIdList.push(reader.uint32());
                    break;
                case /* uint32 mcoin */ 7:
                    message.mcoin = reader.uint32();
                    break;
                case /* uint32 disable_type */ 9:
                    message.disableType = reader.uint32();
                    break;
                case /* uint32 secondary_sheet_id */ 320:
                    message.secondarySheetId = reader.uint32();
                    break;
                case /* uint32 discount_id */ 868:
                    message.discountId = reader.uint32();
                    break;
                case /* uint32 discount_begin_time */ 922:
                    message.discountBeginTime = reader.uint32();
                    break;
                case /* uint32 discount_end_time */ 1847:
                    message.discountEndTime = reader.uint32();
                    break;
                case /* uint32 single_limit */ 1654:
                    message.singleLimit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopGoods, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 goods_id = 2; */
        if (message.goodsId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.goodsId);
        /* ItemParam goods_item = 15; */
        if (message.goodsItem)
            ItemParam.internalBinaryWrite(message.goodsItem, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* uint32 scoin = 6; */
        if (message.scoin !== 0)
            writer.tag(6, WireType.Varint).uint32(message.scoin);
        /* uint32 hcoin = 10; */
        if (message.hcoin !== 0)
            writer.tag(10, WireType.Varint).uint32(message.hcoin);
        /* repeated ItemParam cost_item_list = 14; */
        for (let i = 0; i < message.costItemList.length; i++)
            ItemParam.internalBinaryWrite(message.costItemList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 bought_num = 5; */
        if (message.boughtNum !== 0)
            writer.tag(5, WireType.Varint).uint32(message.boughtNum);
        /* uint32 buy_limit = 13; */
        if (message.buyLimit !== 0)
            writer.tag(13, WireType.Varint).uint32(message.buyLimit);
        /* uint32 begin_time = 1; */
        if (message.beginTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.beginTime);
        /* uint32 end_time = 4; */
        if (message.endTime !== 0)
            writer.tag(4, WireType.Varint).uint32(message.endTime);
        /* uint32 next_refresh_time = 8; */
        if (message.nextRefreshTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.nextRefreshTime);
        /* uint32 min_level = 3; */
        if (message.minLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.minLevel);
        /* uint32 max_level = 11; */
        if (message.maxLevel !== 0)
            writer.tag(11, WireType.Varint).uint32(message.maxLevel);
        /* repeated uint32 pre_goods_id_list = 12; */
        if (message.preGoodsIdList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.preGoodsIdList.length; i++)
                writer.uint32(message.preGoodsIdList[i]);
            writer.join();
        }
        /* uint32 mcoin = 7; */
        if (message.mcoin !== 0)
            writer.tag(7, WireType.Varint).uint32(message.mcoin);
        /* uint32 disable_type = 9; */
        if (message.disableType !== 0)
            writer.tag(9, WireType.Varint).uint32(message.disableType);
        /* uint32 secondary_sheet_id = 320; */
        if (message.secondarySheetId !== 0)
            writer.tag(320, WireType.Varint).uint32(message.secondarySheetId);
        /* uint32 discount_id = 868; */
        if (message.discountId !== 0)
            writer.tag(868, WireType.Varint).uint32(message.discountId);
        /* uint32 discount_begin_time = 922; */
        if (message.discountBeginTime !== 0)
            writer.tag(922, WireType.Varint).uint32(message.discountBeginTime);
        /* uint32 discount_end_time = 1847; */
        if (message.discountEndTime !== 0)
            writer.tag(1847, WireType.Varint).uint32(message.discountEndTime);
        /* uint32 single_limit = 1654; */
        if (message.singleLimit !== 0)
            writer.tag(1654, WireType.Varint).uint32(message.singleLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShopGoods
 */
export const ShopGoods = new ShopGoods$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopMcoinProduct$Type extends MessageType<ShopMcoinProduct> {
    constructor() {
        super("ShopMcoinProduct", [
            { no: 1, name: "product_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mcoin_base", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "mcoin_non_first", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "mcoin_first", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "bought_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_audit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ShopMcoinProduct>): ShopMcoinProduct {
        const message = { productId: "", priceTier: "", mcoinBase: 0, mcoinNonFirst: 0, mcoinFirst: 0, boughtNum: 0, isAudit: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShopMcoinProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopMcoinProduct): ShopMcoinProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string product_id */ 1:
                    message.productId = reader.string();
                    break;
                case /* string price_tier */ 2:
                    message.priceTier = reader.string();
                    break;
                case /* uint32 mcoin_base */ 3:
                    message.mcoinBase = reader.uint32();
                    break;
                case /* uint32 mcoin_non_first */ 4:
                    message.mcoinNonFirst = reader.uint32();
                    break;
                case /* uint32 mcoin_first */ 5:
                    message.mcoinFirst = reader.uint32();
                    break;
                case /* uint32 bought_num */ 6:
                    message.boughtNum = reader.uint32();
                    break;
                case /* bool is_audit */ 7:
                    message.isAudit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopMcoinProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string product_id = 1; */
        if (message.productId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.productId);
        /* string price_tier = 2; */
        if (message.priceTier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.priceTier);
        /* uint32 mcoin_base = 3; */
        if (message.mcoinBase !== 0)
            writer.tag(3, WireType.Varint).uint32(message.mcoinBase);
        /* uint32 mcoin_non_first = 4; */
        if (message.mcoinNonFirst !== 0)
            writer.tag(4, WireType.Varint).uint32(message.mcoinNonFirst);
        /* uint32 mcoin_first = 5; */
        if (message.mcoinFirst !== 0)
            writer.tag(5, WireType.Varint).uint32(message.mcoinFirst);
        /* uint32 bought_num = 6; */
        if (message.boughtNum !== 0)
            writer.tag(6, WireType.Varint).uint32(message.boughtNum);
        /* bool is_audit = 7; */
        if (message.isAudit !== false)
            writer.tag(7, WireType.Varint).bool(message.isAudit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShopMcoinProduct
 */
export const ShopMcoinProduct = new ShopMcoinProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShortAbilityHashPair$Type extends MessageType<ShortAbilityHashPair> {
    constructor() {
        super("ShortAbilityHashPair", [
            { no: 1, name: "ability_name_hash", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ability_config_hash", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShortAbilityHashPair>): ShortAbilityHashPair {
        const message = { abilityNameHash: 0, abilityConfigHash: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShortAbilityHashPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShortAbilityHashPair): ShortAbilityHashPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ability_name_hash */ 1:
                    message.abilityNameHash = reader.int32();
                    break;
                case /* int32 ability_config_hash */ 2:
                    message.abilityConfigHash = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShortAbilityHashPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ability_name_hash = 1; */
        if (message.abilityNameHash !== 0)
            writer.tag(1, WireType.Varint).int32(message.abilityNameHash);
        /* int32 ability_config_hash = 2; */
        if (message.abilityConfigHash !== 0)
            writer.tag(2, WireType.Varint).int32(message.abilityConfigHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShortAbilityHashPair
 */
export const ShortAbilityHashPair = new ShortAbilityHashPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShowAvatarInfo$Type extends MessageType<ShowAvatarInfo> {
    constructor() {
        super("ShowAvatarInfo", [
            { no: 1, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } },
            { no: 3, name: "talent_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "fight_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } },
            { no: 5, name: "skill_depot_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "core_proud_skill_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "inherent_proud_skill_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "skill_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 9, name: "proud_skill_extra_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 10, name: "equip_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShowEquip },
            { no: 11, name: "fetter_info", kind: "message", T: () => AvatarFetterInfo },
            { no: 12, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "excel_info", kind: "message", T: () => AvatarExcelInfo }
        ]);
    }
    create(value?: PartialMessage<ShowAvatarInfo>): ShowAvatarInfo {
        const message = { avatarId: 0, propMap: {}, talentIdList: [], fightPropMap: {}, skillDepotId: 0, coreProudSkillLevel: 0, inherentProudSkillList: [], skillLevelMap: {}, proudSkillExtraLevelMap: {}, equipList: [], costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShowAvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShowAvatarInfo): ShowAvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 1:
                    message.avatarId = reader.uint32();
                    break;
                case /* map<uint32, PropValue> prop_map */ 2:
                    this.binaryReadMap2(message.propMap, reader, options);
                    break;
                case /* repeated uint32 talent_id_list */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.talentIdList.push(reader.uint32());
                    else
                        message.talentIdList.push(reader.uint32());
                    break;
                case /* map<uint32, float> fight_prop_map */ 4:
                    this.binaryReadMap4(message.fightPropMap, reader, options);
                    break;
                case /* uint32 skill_depot_id */ 5:
                    message.skillDepotId = reader.uint32();
                    break;
                case /* uint32 core_proud_skill_level */ 6:
                    message.coreProudSkillLevel = reader.uint32();
                    break;
                case /* repeated uint32 inherent_proud_skill_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inherentProudSkillList.push(reader.uint32());
                    else
                        message.inherentProudSkillList.push(reader.uint32());
                    break;
                case /* map<uint32, uint32> skill_level_map */ 8:
                    this.binaryReadMap8(message.skillLevelMap, reader, options);
                    break;
                case /* map<uint32, uint32> proud_skill_extra_level_map */ 9:
                    this.binaryReadMap9(message.proudSkillExtraLevelMap, reader, options);
                    break;
                case /* repeated ShowEquip equip_list */ 10:
                    message.equipList.push(ShowEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* AvatarFetterInfo fetter_info */ 11:
                    message.fetterInfo = AvatarFetterInfo.internalBinaryRead(reader, reader.uint32(), options, message.fetterInfo);
                    break;
                case /* uint32 costume_id */ 12:
                    message.costumeId = reader.uint32();
                    break;
                case /* AvatarExcelInfo excel_info */ 13:
                    message.excelInfo = AvatarExcelInfo.internalBinaryRead(reader, reader.uint32(), options, message.excelInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ShowAvatarInfo["propMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShowAvatarInfo["propMap"] | undefined, val: ShowAvatarInfo["propMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ShowAvatarInfo.prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    private binaryReadMap4(map: ShowAvatarInfo["fightPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShowAvatarInfo["fightPropMap"] | undefined, val: ShowAvatarInfo["fightPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ShowAvatarInfo.fight_prop_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap8(map: ShowAvatarInfo["skillLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShowAvatarInfo["skillLevelMap"] | undefined, val: ShowAvatarInfo["skillLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ShowAvatarInfo.skill_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap9(map: ShowAvatarInfo["proudSkillExtraLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShowAvatarInfo["proudSkillExtraLevelMap"] | undefined, val: ShowAvatarInfo["proudSkillExtraLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ShowAvatarInfo.proud_skill_extra_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: ShowAvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 1; */
        if (message.avatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.avatarId);
        /* map<uint32, PropValue> prop_map = 2; */
        for (let k of Object.keys(message.propMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.propMap[k as any], writer, options);
            writer.join().join();
        }
        /* repeated uint32 talent_id_list = 3; */
        if (message.talentIdList.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.talentIdList.length; i++)
                writer.uint32(message.talentIdList[i]);
            writer.join();
        }
        /* map<uint32, float> fight_prop_map = 4; */
        for (let k of Object.keys(message.fightPropMap))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit32).float(message.fightPropMap[k as any]).join();
        /* uint32 skill_depot_id = 5; */
        if (message.skillDepotId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.skillDepotId);
        /* uint32 core_proud_skill_level = 6; */
        if (message.coreProudSkillLevel !== 0)
            writer.tag(6, WireType.Varint).uint32(message.coreProudSkillLevel);
        /* repeated uint32 inherent_proud_skill_list = 7; */
        if (message.inherentProudSkillList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.inherentProudSkillList.length; i++)
                writer.uint32(message.inherentProudSkillList[i]);
            writer.join();
        }
        /* map<uint32, uint32> skill_level_map = 8; */
        for (let k of Object.keys(message.skillLevelMap))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skillLevelMap[k as any]).join();
        /* map<uint32, uint32> proud_skill_extra_level_map = 9; */
        for (let k of Object.keys(message.proudSkillExtraLevelMap))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.proudSkillExtraLevelMap[k as any]).join();
        /* repeated ShowEquip equip_list = 10; */
        for (let i = 0; i < message.equipList.length; i++)
            ShowEquip.internalBinaryWrite(message.equipList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* AvatarFetterInfo fetter_info = 11; */
        if (message.fetterInfo)
            AvatarFetterInfo.internalBinaryWrite(message.fetterInfo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 costume_id = 12; */
        if (message.costumeId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.costumeId);
        /* AvatarExcelInfo excel_info = 13; */
        if (message.excelInfo)
            AvatarExcelInfo.internalBinaryWrite(message.excelInfo, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShowAvatarInfo
 */
export const ShowAvatarInfo = new ShowAvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShowEquip$Type extends MessageType<ShowEquip> {
    constructor() {
        super("ShowEquip", [
            { no: 2, name: "reliquary", kind: "message", oneof: "detail", T: () => Reliquary },
            { no: 3, name: "weapon", kind: "message", oneof: "detail", T: () => Weapon },
            { no: 1, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShowEquip>): ShowEquip {
        const message = { detail: { oneofKind: undefined }, itemId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShowEquip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShowEquip): ShowEquip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Reliquary reliquary */ 2:
                    message.detail = {
                        oneofKind: "reliquary",
                        reliquary: Reliquary.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).reliquary)
                    };
                    break;
                case /* Weapon weapon */ 3:
                    message.detail = {
                        oneofKind: "weapon",
                        weapon: Weapon.internalBinaryRead(reader, reader.uint32(), options, (message.detail as any).weapon)
                    };
                    break;
                case /* uint32 item_id */ 1:
                    message.itemId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShowEquip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Reliquary reliquary = 2; */
        if (message.detail.oneofKind === "reliquary")
            Reliquary.internalBinaryWrite(message.detail.reliquary, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* Weapon weapon = 3; */
        if (message.detail.oneofKind === "weapon")
            Weapon.internalBinaryWrite(message.detail.weapon, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 item_id = 1; */
        if (message.itemId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.itemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ShowEquip
 */
export const ShowEquip = new ShowEquip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkyCrystalDetectorQuickUseResult$Type extends MessageType<SkyCrystalDetectorQuickUseResult> {
    constructor() {
        super("SkyCrystalDetectorQuickUseResult", [
            { no: 9, name: "Unk2700_COIELIGEACL", kind: "message", jsonName: "Unk2700COIELIGEACL", T: () => Unk2700_CCEOEOHLAPK },
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SkyCrystalDetectorQuickUseResult>): SkyCrystalDetectorQuickUseResult {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SkyCrystalDetectorQuickUseResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkyCrystalDetectorQuickUseResult): SkyCrystalDetectorQuickUseResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Unk2700_CCEOEOHLAPK Unk2700_COIELIGEACL = 9 [json_name = "Unk2700COIELIGEACL"];*/ 9:
                    message.unk2700COIELIGEACL = Unk2700_CCEOEOHLAPK.internalBinaryRead(reader, reader.uint32(), options, message.unk2700COIELIGEACL);
                    break;
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkyCrystalDetectorQuickUseResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Unk2700_CCEOEOHLAPK Unk2700_COIELIGEACL = 9 [json_name = "Unk2700COIELIGEACL"]; */
        if (message.unk2700COIELIGEACL)
            Unk2700_CCEOEOHLAPK.internalBinaryWrite(message.unk2700COIELIGEACL, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SkyCrystalDetectorQuickUseResult
 */
export const SkyCrystalDetectorQuickUseResult = new SkyCrystalDetectorQuickUseResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SocialDetail$Type extends MessageType<SocialDetail> {
    constructor() {
        super("SocialDetail", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "birthday", kind: "message", T: () => Birthday },
            { no: 7, name: "world_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "reserved_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "online_state", kind: "enum", T: () => ["FriendOnlineState", FriendOnlineState, "FRIEND_ONLINE_STATE_"] },
            { no: 10, name: "param", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_friend", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "is_mp_mode_available", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "online_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_in_blacklist", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "is_chat_no_disturb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "remark_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "finish_achievement_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "tower_floor_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "tower_level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "is_show_avatar", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "show_avatar_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SocialShowAvatarInfo },
            { no: 23, name: "show_name_card_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "friend_enter_home_option", kind: "enum", T: () => ["FriendEnterHomeOption", FriendEnterHomeOption, "FRIEND_ENTER_HOME_OPTION_"] },
            { no: 25, name: "profile_picture", kind: "message", T: () => ProfilePicture }
        ]);
    }
    create(value?: PartialMessage<SocialDetail>): SocialDetail {
        const message = { uid: 0, nickname: "", level: 0, avatarId: 0, signature: "", worldLevel: 0, reservedList: [], onlineState: 0, param: 0, isFriend: false, isMpModeAvailable: false, onlineId: "", nameCardId: 0, isInBlacklist: false, isChatNoDisturb: false, remarkName: "", finishAchievementNum: 0, towerFloorIndex: 0, towerLevelIndex: 0, isShowAvatar: false, showAvatarInfoList: [], showNameCardIdList: [], friendEnterHomeOption: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SocialDetail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SocialDetail): SocialDetail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* string nickname */ 2:
                    message.nickname = reader.string();
                    break;
                case /* uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* uint32 avatar_id */ 4:
                    message.avatarId = reader.uint32();
                    break;
                case /* string signature */ 5:
                    message.signature = reader.string();
                    break;
                case /* Birthday birthday */ 6:
                    message.birthday = Birthday.internalBinaryRead(reader, reader.uint32(), options, message.birthday);
                    break;
                case /* uint32 world_level */ 7:
                    message.worldLevel = reader.uint32();
                    break;
                case /* repeated uint32 reserved_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reservedList.push(reader.uint32());
                    else
                        message.reservedList.push(reader.uint32());
                    break;
                case /* FriendOnlineState online_state */ 9:
                    message.onlineState = reader.int32();
                    break;
                case /* uint32 param */ 10:
                    message.param = reader.uint32();
                    break;
                case /* bool is_friend */ 11:
                    message.isFriend = reader.bool();
                    break;
                case /* bool is_mp_mode_available */ 12:
                    message.isMpModeAvailable = reader.bool();
                    break;
                case /* string online_id */ 13:
                    message.onlineId = reader.string();
                    break;
                case /* uint32 name_card_id */ 14:
                    message.nameCardId = reader.uint32();
                    break;
                case /* bool is_in_blacklist */ 15:
                    message.isInBlacklist = reader.bool();
                    break;
                case /* bool is_chat_no_disturb */ 16:
                    message.isChatNoDisturb = reader.bool();
                    break;
                case /* string remark_name */ 17:
                    message.remarkName = reader.string();
                    break;
                case /* uint32 finish_achievement_num */ 18:
                    message.finishAchievementNum = reader.uint32();
                    break;
                case /* uint32 tower_floor_index */ 19:
                    message.towerFloorIndex = reader.uint32();
                    break;
                case /* uint32 tower_level_index */ 20:
                    message.towerLevelIndex = reader.uint32();
                    break;
                case /* bool is_show_avatar */ 21:
                    message.isShowAvatar = reader.bool();
                    break;
                case /* repeated SocialShowAvatarInfo show_avatar_info_list */ 22:
                    message.showAvatarInfoList.push(SocialShowAvatarInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 show_name_card_id_list */ 23:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.showNameCardIdList.push(reader.uint32());
                    else
                        message.showNameCardIdList.push(reader.uint32());
                    break;
                case /* FriendEnterHomeOption friend_enter_home_option */ 24:
                    message.friendEnterHomeOption = reader.int32();
                    break;
                case /* ProfilePicture profile_picture */ 25:
                    message.profilePicture = ProfilePicture.internalBinaryRead(reader, reader.uint32(), options, message.profilePicture);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SocialDetail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* string nickname = 2; */
        if (message.nickname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nickname);
        /* uint32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* uint32 avatar_id = 4; */
        if (message.avatarId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.avatarId);
        /* string signature = 5; */
        if (message.signature !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signature);
        /* Birthday birthday = 6; */
        if (message.birthday)
            Birthday.internalBinaryWrite(message.birthday, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 world_level = 7; */
        if (message.worldLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.worldLevel);
        /* repeated uint32 reserved_list = 8; */
        if (message.reservedList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reservedList.length; i++)
                writer.uint32(message.reservedList[i]);
            writer.join();
        }
        /* FriendOnlineState online_state = 9; */
        if (message.onlineState !== 0)
            writer.tag(9, WireType.Varint).int32(message.onlineState);
        /* uint32 param = 10; */
        if (message.param !== 0)
            writer.tag(10, WireType.Varint).uint32(message.param);
        /* bool is_friend = 11; */
        if (message.isFriend !== false)
            writer.tag(11, WireType.Varint).bool(message.isFriend);
        /* bool is_mp_mode_available = 12; */
        if (message.isMpModeAvailable !== false)
            writer.tag(12, WireType.Varint).bool(message.isMpModeAvailable);
        /* string online_id = 13; */
        if (message.onlineId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.onlineId);
        /* uint32 name_card_id = 14; */
        if (message.nameCardId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.nameCardId);
        /* bool is_in_blacklist = 15; */
        if (message.isInBlacklist !== false)
            writer.tag(15, WireType.Varint).bool(message.isInBlacklist);
        /* bool is_chat_no_disturb = 16; */
        if (message.isChatNoDisturb !== false)
            writer.tag(16, WireType.Varint).bool(message.isChatNoDisturb);
        /* string remark_name = 17; */
        if (message.remarkName !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.remarkName);
        /* uint32 finish_achievement_num = 18; */
        if (message.finishAchievementNum !== 0)
            writer.tag(18, WireType.Varint).uint32(message.finishAchievementNum);
        /* uint32 tower_floor_index = 19; */
        if (message.towerFloorIndex !== 0)
            writer.tag(19, WireType.Varint).uint32(message.towerFloorIndex);
        /* uint32 tower_level_index = 20; */
        if (message.towerLevelIndex !== 0)
            writer.tag(20, WireType.Varint).uint32(message.towerLevelIndex);
        /* bool is_show_avatar = 21; */
        if (message.isShowAvatar !== false)
            writer.tag(21, WireType.Varint).bool(message.isShowAvatar);
        /* repeated SocialShowAvatarInfo show_avatar_info_list = 22; */
        for (let i = 0; i < message.showAvatarInfoList.length; i++)
            SocialShowAvatarInfo.internalBinaryWrite(message.showAvatarInfoList[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 show_name_card_id_list = 23; */
        if (message.showNameCardIdList.length) {
            writer.tag(23, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.showNameCardIdList.length; i++)
                writer.uint32(message.showNameCardIdList[i]);
            writer.join();
        }
        /* FriendEnterHomeOption friend_enter_home_option = 24; */
        if (message.friendEnterHomeOption !== 0)
            writer.tag(24, WireType.Varint).int32(message.friendEnterHomeOption);
        /* ProfilePicture profile_picture = 25; */
        if (message.profilePicture)
            ProfilePicture.internalBinaryWrite(message.profilePicture, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SocialDetail
 */
export const SocialDetail = new SocialDetail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SocialShowAvatarInfo$Type extends MessageType<SocialShowAvatarInfo> {
    constructor() {
        super("SocialShowAvatarInfo", [
            { no: 1, name: "avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "costume_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SocialShowAvatarInfo>): SocialShowAvatarInfo {
        const message = { avatarId: 0, level: 0, costumeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SocialShowAvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SocialShowAvatarInfo): SocialShowAvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 avatar_id */ 1:
                    message.avatarId = reader.uint32();
                    break;
                case /* uint32 level */ 2:
                    message.level = reader.uint32();
                    break;
                case /* uint32 costume_id */ 3:
                    message.costumeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SocialShowAvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 avatar_id = 1; */
        if (message.avatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.avatarId);
        /* uint32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).uint32(message.level);
        /* uint32 costume_id = 3; */
        if (message.costumeId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.costumeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SocialShowAvatarInfo
 */
export const SocialShowAvatarInfo = new SocialShowAvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatueGadgetInfo$Type extends MessageType<StatueGadgetInfo> {
    constructor() {
        super("StatueGadgetInfo", [
            { no: 1, name: "opened_statue_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StatueGadgetInfo>): StatueGadgetInfo {
        const message = { openedStatueUidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatueGadgetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatueGadgetInfo): StatueGadgetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 opened_statue_uid_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openedStatueUidList.push(reader.uint32());
                    else
                        message.openedStatueUidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatueGadgetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 opened_statue_uid_list = 1; */
        if (message.openedStatueUidList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.openedStatueUidList.length; i++)
                writer.uint32(message.openedStatueUidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatueGadgetInfo
 */
export const StatueGadgetInfo = new StatueGadgetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopServerInfo$Type extends MessageType<StopServerInfo> {
    constructor() {
        super("StopServerInfo", [
            { no: 1, name: "stop_begin_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stop_end_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "content_msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopServerInfo>): StopServerInfo {
        const message = { stopBeginTime: 0, stopEndTime: 0, url: "", contentMsg: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopServerInfo): StopServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 stop_begin_time */ 1:
                    message.stopBeginTime = reader.uint32();
                    break;
                case /* uint32 stop_end_time */ 2:
                    message.stopEndTime = reader.uint32();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* string content_msg */ 4:
                    message.contentMsg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 stop_begin_time = 1; */
        if (message.stopBeginTime !== 0)
            writer.tag(1, WireType.Varint).uint32(message.stopBeginTime);
        /* uint32 stop_end_time = 2; */
        if (message.stopEndTime !== 0)
            writer.tag(2, WireType.Varint).uint32(message.stopEndTime);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* string content_msg = 4; */
        if (message.contentMsg !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.contentMsg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StopServerInfo
 */
export const StopServerInfo = new StopServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItemChangeNotify$Type extends MessageType<StoreItemChangeNotify> {
    constructor() {
        super("StoreItemChangeNotify", [
            { no: 9, name: "store_type", kind: "enum", T: () => ["StoreType", StoreType, "STORE_TYPE_"] },
            { no: 3, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Item }
        ]);
    }
    create(value?: PartialMessage<StoreItemChangeNotify>): StoreItemChangeNotify {
        const message = { storeType: 0, itemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreItemChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItemChangeNotify): StoreItemChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StoreType store_type */ 9:
                    message.storeType = reader.int32();
                    break;
                case /* repeated Item item_list */ 3:
                    message.itemList.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItemChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StoreType store_type = 9; */
        if (message.storeType !== 0)
            writer.tag(9, WireType.Varint).int32(message.storeType);
        /* repeated Item item_list = 3; */
        for (let i = 0; i < message.itemList.length; i++)
            Item.internalBinaryWrite(message.itemList[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItemChangeNotify
 */
export const StoreItemChangeNotify = new StoreItemChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreItemDelNotify$Type extends MessageType<StoreItemDelNotify> {
    constructor() {
        super("StoreItemDelNotify", [
            { no: 14, name: "store_type", kind: "enum", T: () => ["StoreType", StoreType, "STORE_TYPE_"] },
            { no: 10, name: "guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StoreItemDelNotify>): StoreItemDelNotify {
        const message = { storeType: 0, guidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreItemDelNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreItemDelNotify): StoreItemDelNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StoreType store_type */ 14:
                    message.storeType = reader.int32();
                    break;
                case /* repeated uint64 guid_list */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guidList.push(reader.uint64().toBigInt());
                    else
                        message.guidList.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreItemDelNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StoreType store_type = 14; */
        if (message.storeType !== 0)
            writer.tag(14, WireType.Varint).int32(message.storeType);
        /* repeated uint64 guid_list = 10; */
        if (message.guidList.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guidList.length; i++)
                writer.uint64(message.guidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreItemDelNotify
 */
export const StoreItemDelNotify = new StoreItemDelNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreWeightLimitNotify$Type extends MessageType<StoreWeightLimitNotify> {
    constructor() {
        super("StoreWeightLimitNotify", [
            { no: 4, name: "store_type", kind: "enum", T: () => ["StoreType", StoreType, "STORE_TYPE_"] },
            { no: 2, name: "weight_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "material_count_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "weapon_count_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "reliquary_count_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "furniture_count_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StoreWeightLimitNotify>): StoreWeightLimitNotify {
        const message = { storeType: 0, weightLimit: 0, materialCountLimit: 0, weaponCountLimit: 0, reliquaryCountLimit: 0, furnitureCountLimit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreWeightLimitNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreWeightLimitNotify): StoreWeightLimitNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StoreType store_type */ 4:
                    message.storeType = reader.int32();
                    break;
                case /* uint32 weight_limit */ 2:
                    message.weightLimit = reader.uint32();
                    break;
                case /* uint32 material_count_limit */ 1:
                    message.materialCountLimit = reader.uint32();
                    break;
                case /* uint32 weapon_count_limit */ 5:
                    message.weaponCountLimit = reader.uint32();
                    break;
                case /* uint32 reliquary_count_limit */ 6:
                    message.reliquaryCountLimit = reader.uint32();
                    break;
                case /* uint32 furniture_count_limit */ 8:
                    message.furnitureCountLimit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreWeightLimitNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StoreType store_type = 4; */
        if (message.storeType !== 0)
            writer.tag(4, WireType.Varint).int32(message.storeType);
        /* uint32 weight_limit = 2; */
        if (message.weightLimit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.weightLimit);
        /* uint32 material_count_limit = 1; */
        if (message.materialCountLimit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.materialCountLimit);
        /* uint32 weapon_count_limit = 5; */
        if (message.weaponCountLimit !== 0)
            writer.tag(5, WireType.Varint).uint32(message.weaponCountLimit);
        /* uint32 reliquary_count_limit = 6; */
        if (message.reliquaryCountLimit !== 0)
            writer.tag(6, WireType.Varint).uint32(message.reliquaryCountLimit);
        /* uint32 furniture_count_limit = 8; */
        if (message.furnitureCountLimit !== 0)
            writer.tag(8, WireType.Varint).uint32(message.furnitureCountLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StoreWeightLimitNotify
 */
export const StoreWeightLimitNotify = new StoreWeightLimitNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrengthenPointData$Type extends MessageType<StrengthenPointData> {
    constructor() {
        super("StrengthenPointData", [
            { no: 1, name: "base_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cur_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<StrengthenPointData>): StrengthenPointData {
        const message = { basePoint: 0, curPoint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StrengthenPointData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StrengthenPointData): StrengthenPointData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 base_point */ 1:
                    message.basePoint = reader.uint32();
                    break;
                case /* uint32 cur_point */ 2:
                    message.curPoint = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StrengthenPointData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 base_point = 1; */
        if (message.basePoint !== 0)
            writer.tag(1, WireType.Varint).uint32(message.basePoint);
        /* uint32 cur_point = 2; */
        if (message.curPoint !== 0)
            writer.tag(2, WireType.Varint).uint32(message.curPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StrengthenPointData
 */
export const StrengthenPointData = new StrengthenPointData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummerTimeV2DungeonSettleInfo$Type extends MessageType<SummerTimeV2DungeonSettleInfo> {
    constructor() {
        super("SummerTimeV2DungeonSettleInfo", [
            { no: 5, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "Unk2800_ELHBCNPKOJG", kind: "scalar", jsonName: "Unk2800ELHBCNPKOJG", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "Unk2800_HDEFJKGDNEH", kind: "scalar", jsonName: "Unk2800HDEFJKGDNEH", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SummerTimeV2DungeonSettleInfo>): SummerTimeV2DungeonSettleInfo {
        const message = { isSuccess: false, unk2800ELHBCNPKOJG: 0, unk2800HDEFJKGDNEH: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummerTimeV2DungeonSettleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummerTimeV2DungeonSettleInfo): SummerTimeV2DungeonSettleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_success */ 5:
                    message.isSuccess = reader.bool();
                    break;
                case /* uint32 Unk2800_ELHBCNPKOJG = 2 [json_name = "Unk2800ELHBCNPKOJG"];*/ 2:
                    message.unk2800ELHBCNPKOJG = reader.uint32();
                    break;
                case /* uint32 Unk2800_HDEFJKGDNEH = 11 [json_name = "Unk2800HDEFJKGDNEH"];*/ 11:
                    message.unk2800HDEFJKGDNEH = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummerTimeV2DungeonSettleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_success = 5; */
        if (message.isSuccess !== false)
            writer.tag(5, WireType.Varint).bool(message.isSuccess);
        /* uint32 Unk2800_ELHBCNPKOJG = 2 [json_name = "Unk2800ELHBCNPKOJG"]; */
        if (message.unk2800ELHBCNPKOJG !== 0)
            writer.tag(2, WireType.Varint).uint32(message.unk2800ELHBCNPKOJG);
        /* uint32 Unk2800_HDEFJKGDNEH = 11 [json_name = "Unk2800HDEFJKGDNEH"]; */
        if (message.unk2800HDEFJKGDNEH !== 0)
            writer.tag(11, WireType.Varint).uint32(message.unk2800HDEFJKGDNEH);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummerTimeV2DungeonSettleInfo
 */
export const SummerTimeV2DungeonSettleInfo = new SummerTimeV2DungeonSettleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncScenePlayTeamEntityNotify$Type extends MessageType<SyncScenePlayTeamEntityNotify> {
    constructor() {
        super("SyncScenePlayTeamEntityNotify", [
            { no: 13, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "entity_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayTeamEntityInfo }
        ]);
    }
    create(value?: PartialMessage<SyncScenePlayTeamEntityNotify>): SyncScenePlayTeamEntityNotify {
        const message = { sceneId: 0, entityInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyncScenePlayTeamEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncScenePlayTeamEntityNotify): SyncScenePlayTeamEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 13:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated PlayTeamEntityInfo entity_info_list */ 2:
                    message.entityInfoList.push(PlayTeamEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncScenePlayTeamEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 13; */
        if (message.sceneId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.sceneId);
        /* repeated PlayTeamEntityInfo entity_info_list = 2; */
        for (let i = 0; i < message.entityInfoList.length; i++)
            PlayTeamEntityInfo.internalBinaryWrite(message.entityInfoList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SyncScenePlayTeamEntityNotify
 */
export const SyncScenePlayTeamEntityNotify = new SyncScenePlayTeamEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SyncTeamEntityNotify$Type extends MessageType<SyncTeamEntityNotify> {
    constructor() {
        super("SyncTeamEntityNotify", [
            { no: 13, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "team_entity_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamEntityInfo }
        ]);
    }
    create(value?: PartialMessage<SyncTeamEntityNotify>): SyncTeamEntityNotify {
        const message = { sceneId: 0, teamEntityInfoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SyncTeamEntityNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SyncTeamEntityNotify): SyncTeamEntityNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 13:
                    message.sceneId = reader.uint32();
                    break;
                case /* repeated TeamEntityInfo team_entity_info_list */ 2:
                    message.teamEntityInfoList.push(TeamEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SyncTeamEntityNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 13; */
        if (message.sceneId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.sceneId);
        /* repeated TeamEntityInfo team_entity_info_list = 2; */
        for (let i = 0; i < message.teamEntityInfoList.length; i++)
            TeamEntityInfo.internalBinaryWrite(message.teamEntityInfoList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SyncTeamEntityNotify
 */
export const SyncTeamEntityNotify = new SyncTeamEntityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemHint$Type extends MessageType<SystemHint> {
    constructor() {
        super("SystemHint", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SystemHint>): SystemHint {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemHint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemHint): SystemHint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemHint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SystemHint
 */
export const SystemHint = new SystemHint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeAchievementRewardReq$Type extends MessageType<TakeAchievementRewardReq> {
    constructor() {
        super("TakeAchievementRewardReq", [
            { no: 2, name: "id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeAchievementRewardReq>): TakeAchievementRewardReq {
        const message = { idList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeAchievementRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeAchievementRewardReq): TakeAchievementRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.idList.push(reader.uint32());
                    else
                        message.idList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeAchievementRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 id_list = 2; */
        if (message.idList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.idList.length; i++)
                writer.uint32(message.idList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeAchievementRewardReq
 */
export const TakeAchievementRewardReq = new TakeAchievementRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeBattlePassMissionPointReq$Type extends MessageType<TakeBattlePassMissionPointReq> {
    constructor() {
        super("TakeBattlePassMissionPointReq", [
            { no: 7, name: "mission_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeBattlePassMissionPointReq>): TakeBattlePassMissionPointReq {
        const message = { missionIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeBattlePassMissionPointReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeBattlePassMissionPointReq): TakeBattlePassMissionPointReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 mission_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.missionIdList.push(reader.uint32());
                    else
                        message.missionIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeBattlePassMissionPointReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 mission_id_list = 7; */
        if (message.missionIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.missionIdList.length; i++)
                writer.uint32(message.missionIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeBattlePassMissionPointReq
 */
export const TakeBattlePassMissionPointReq = new TakeBattlePassMissionPointReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeBattlePassMissionPointRsp$Type extends MessageType<TakeBattlePassMissionPointRsp> {
    constructor() {
        super("TakeBattlePassMissionPointRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "mission_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeBattlePassMissionPointRsp>): TakeBattlePassMissionPointRsp {
        const message = { retcode: 0, missionIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeBattlePassMissionPointRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeBattlePassMissionPointRsp): TakeBattlePassMissionPointRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 mission_id_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.missionIdList.push(reader.uint32());
                    else
                        message.missionIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeBattlePassMissionPointRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* repeated uint32 mission_id_list = 2; */
        if (message.missionIdList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.missionIdList.length; i++)
                writer.uint32(message.missionIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeBattlePassMissionPointRsp
 */
export const TakeBattlePassMissionPointRsp = new TakeBattlePassMissionPointRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeBattlePassRewardReq$Type extends MessageType<TakeBattlePassRewardReq> {
    constructor() {
        super("TakeBattlePassRewardReq", [
            { no: 4, name: "take_option_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BattlePassRewardTakeOption }
        ]);
    }
    create(value?: PartialMessage<TakeBattlePassRewardReq>): TakeBattlePassRewardReq {
        const message = { takeOptionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeBattlePassRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeBattlePassRewardReq): TakeBattlePassRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BattlePassRewardTakeOption take_option_list */ 4:
                    message.takeOptionList.push(BattlePassRewardTakeOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeBattlePassRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BattlePassRewardTakeOption take_option_list = 4; */
        for (let i = 0; i < message.takeOptionList.length; i++)
            BattlePassRewardTakeOption.internalBinaryWrite(message.takeOptionList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeBattlePassRewardReq
 */
export const TakeBattlePassRewardReq = new TakeBattlePassRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeBattlePassRewardRsp$Type extends MessageType<TakeBattlePassRewardRsp> {
    constructor() {
        super("TakeBattlePassRewardRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "take_option_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BattlePassRewardTakeOption },
            { no: 5, name: "item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<TakeBattlePassRewardRsp>): TakeBattlePassRewardRsp {
        const message = { retcode: 0, takeOptionList: [], itemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeBattlePassRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeBattlePassRewardRsp): TakeBattlePassRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* repeated BattlePassRewardTakeOption take_option_list */ 1:
                    message.takeOptionList.push(BattlePassRewardTakeOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam item_list */ 5:
                    message.itemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeBattlePassRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* repeated BattlePassRewardTakeOption take_option_list = 1; */
        for (let i = 0; i < message.takeOptionList.length; i++)
            BattlePassRewardTakeOption.internalBinaryWrite(message.takeOptionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam item_list = 5; */
        for (let i = 0; i < message.itemList.length; i++)
            ItemParam.internalBinaryWrite(message.itemList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeBattlePassRewardRsp
 */
export const TakeBattlePassRewardRsp = new TakeBattlePassRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeFurnitureMakeReq$Type extends MessageType<TakeFurnitureMakeReq> {
    constructor() {
        super("TakeFurnitureMakeReq", [
            { no: 9, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "make_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_fast_finish", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TakeFurnitureMakeReq>): TakeFurnitureMakeReq {
        const message = { index: 0, makeId: 0, isFastFinish: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeFurnitureMakeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeFurnitureMakeReq): TakeFurnitureMakeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 9:
                    message.index = reader.uint32();
                    break;
                case /* uint32 make_id */ 4:
                    message.makeId = reader.uint32();
                    break;
                case /* bool is_fast_finish */ 2:
                    message.isFastFinish = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeFurnitureMakeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 9; */
        if (message.index !== 0)
            writer.tag(9, WireType.Varint).uint32(message.index);
        /* uint32 make_id = 4; */
        if (message.makeId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.makeId);
        /* bool is_fast_finish = 2; */
        if (message.isFastFinish !== false)
            writer.tag(2, WireType.Varint).bool(message.isFastFinish);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeFurnitureMakeReq
 */
export const TakeFurnitureMakeReq = new TakeFurnitureMakeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeFurnitureMakeRsp$Type extends MessageType<TakeFurnitureMakeRsp> {
    constructor() {
        super("TakeFurnitureMakeRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "make_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "furniture_make_slot", kind: "message", T: () => FurnitureMakeSlot },
            { no: 10, name: "output_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 5, name: "return_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<TakeFurnitureMakeRsp>): TakeFurnitureMakeRsp {
        const message = { retcode: 0, makeId: 0, outputItemList: [], returnItemList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeFurnitureMakeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeFurnitureMakeRsp): TakeFurnitureMakeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 make_id */ 2:
                    message.makeId = reader.uint32();
                    break;
                case /* FurnitureMakeSlot furniture_make_slot */ 15:
                    message.furnitureMakeSlot = FurnitureMakeSlot.internalBinaryRead(reader, reader.uint32(), options, message.furnitureMakeSlot);
                    break;
                case /* repeated ItemParam output_item_list */ 10:
                    message.outputItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ItemParam return_item_list */ 5:
                    message.returnItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeFurnitureMakeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 make_id = 2; */
        if (message.makeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.makeId);
        /* FurnitureMakeSlot furniture_make_slot = 15; */
        if (message.furnitureMakeSlot)
            FurnitureMakeSlot.internalBinaryWrite(message.furnitureMakeSlot, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam output_item_list = 10; */
        for (let i = 0; i < message.outputItemList.length; i++)
            ItemParam.internalBinaryWrite(message.outputItemList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated ItemParam return_item_list = 5; */
        for (let i = 0; i < message.returnItemList.length; i++)
            ItemParam.internalBinaryWrite(message.returnItemList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeFurnitureMakeRsp
 */
export const TakeFurnitureMakeRsp = new TakeFurnitureMakeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeoffEquipReq$Type extends MessageType<TakeoffEquipReq> {
    constructor() {
        super("TakeoffEquipReq", [
            { no: 15, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "slot", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeoffEquipReq>): TakeoffEquipReq {
        const message = { avatarGuid: 0n, slot: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeoffEquipReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeoffEquipReq): TakeoffEquipReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 15:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 slot */ 9:
                    message.slot = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeoffEquipReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 15; */
        if (message.avatarGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 slot = 9; */
        if (message.slot !== 0)
            writer.tag(9, WireType.Varint).uint32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeoffEquipReq
 */
export const TakeoffEquipReq = new TakeoffEquipReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeoffEquipRsp$Type extends MessageType<TakeoffEquipRsp> {
    constructor() {
        super("TakeoffEquipRsp", [
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "slot", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeoffEquipRsp>): TakeoffEquipRsp {
        const message = { retcode: 0, avatarGuid: 0n, slot: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeoffEquipRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeoffEquipRsp): TakeoffEquipRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 3:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 slot */ 4:
                    message.slot = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeoffEquipRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 3; */
        if (message.avatarGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 slot = 4; */
        if (message.slot !== 0)
            writer.tag(4, WireType.Varint).uint32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeoffEquipRsp
 */
export const TakeoffEquipRsp = new TakeoffEquipRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakePlayerLevelRewardReq$Type extends MessageType<TakePlayerLevelRewardReq> {
    constructor() {
        super("TakePlayerLevelRewardReq", [
            { no: 5, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakePlayerLevelRewardReq>): TakePlayerLevelRewardReq {
        const message = { level: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakePlayerLevelRewardReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakePlayerLevelRewardReq): TakePlayerLevelRewardReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level */ 5:
                    message.level = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakePlayerLevelRewardReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 level = 5; */
        if (message.level !== 0)
            writer.tag(5, WireType.Varint).uint32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakePlayerLevelRewardReq
 */
export const TakePlayerLevelRewardReq = new TakePlayerLevelRewardReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakePlayerLevelRewardRsp$Type extends MessageType<TakePlayerLevelRewardRsp> {
    constructor() {
        super("TakePlayerLevelRewardRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakePlayerLevelRewardRsp>): TakePlayerLevelRewardRsp {
        const message = { retcode: 0, level: 0, rewardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakePlayerLevelRewardRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakePlayerLevelRewardRsp): TakePlayerLevelRewardRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 level */ 13:
                    message.level = reader.uint32();
                    break;
                case /* uint32 reward_id */ 12:
                    message.rewardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakePlayerLevelRewardRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint32 level = 13; */
        if (message.level !== 0)
            writer.tag(13, WireType.Varint).uint32(message.level);
        /* uint32 reward_id = 12; */
        if (message.rewardId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.rewardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakePlayerLevelRewardRsp
 */
export const TakePlayerLevelRewardRsp = new TakePlayerLevelRewardRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamEnterSceneInfo$Type extends MessageType<TeamEnterSceneInfo> {
    constructor() {
        super("TeamEnterSceneInfo", [
            { no: 14, name: "team_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "team_ability_info", kind: "message", T: () => AbilitySyncStateInfo },
            { no: 10, name: "ability_control_block", kind: "message", T: () => AbilityControlBlock }
        ]);
    }
    create(value?: PartialMessage<TeamEnterSceneInfo>): TeamEnterSceneInfo {
        const message = { teamEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamEnterSceneInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamEnterSceneInfo): TeamEnterSceneInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 team_entity_id */ 14:
                    message.teamEntityId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo team_ability_info */ 4:
                    message.teamAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamAbilityInfo);
                    break;
                case /* AbilityControlBlock ability_control_block */ 10:
                    message.abilityControlBlock = AbilityControlBlock.internalBinaryRead(reader, reader.uint32(), options, message.abilityControlBlock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamEnterSceneInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 team_entity_id = 14; */
        if (message.teamEntityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.teamEntityId);
        /* AbilitySyncStateInfo team_ability_info = 4; */
        if (message.teamAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.teamAbilityInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* AbilityControlBlock ability_control_block = 10; */
        if (message.abilityControlBlock)
            AbilityControlBlock.internalBinaryWrite(message.abilityControlBlock, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TeamEnterSceneInfo
 */
export const TeamEnterSceneInfo = new TeamEnterSceneInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamEntityInfo$Type extends MessageType<TeamEntityInfo> {
    constructor() {
        super("TeamEntityInfo", [
            { no: 1, name: "team_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "authority_peer_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "team_ability_info", kind: "message", T: () => AbilitySyncStateInfo }
        ]);
    }
    create(value?: PartialMessage<TeamEntityInfo>): TeamEntityInfo {
        const message = { teamEntityId: 0, authorityPeerId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamEntityInfo): TeamEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 team_entity_id */ 1:
                    message.teamEntityId = reader.uint32();
                    break;
                case /* uint32 authority_peer_id */ 2:
                    message.authorityPeerId = reader.uint32();
                    break;
                case /* AbilitySyncStateInfo team_ability_info */ 3:
                    message.teamAbilityInfo = AbilitySyncStateInfo.internalBinaryRead(reader, reader.uint32(), options, message.teamAbilityInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 team_entity_id = 1; */
        if (message.teamEntityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.teamEntityId);
        /* uint32 authority_peer_id = 2; */
        if (message.authorityPeerId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.authorityPeerId);
        /* AbilitySyncStateInfo team_ability_info = 3; */
        if (message.teamAbilityInfo)
            AbilitySyncStateInfo.internalBinaryWrite(message.teamAbilityInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TeamEntityInfo
 */
export const TeamEntityInfo = new TeamEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamResonanceChangeNotify$Type extends MessageType<TeamResonanceChangeNotify> {
    constructor() {
        super("TeamResonanceChangeNotify", [
            { no: 15, name: "info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AvatarTeamResonanceInfo }
        ]);
    }
    create(value?: PartialMessage<TeamResonanceChangeNotify>): TeamResonanceChangeNotify {
        const message = { infoList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamResonanceChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamResonanceChangeNotify): TeamResonanceChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AvatarTeamResonanceInfo info_list */ 15:
                    message.infoList.push(AvatarTeamResonanceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamResonanceChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AvatarTeamResonanceInfo info_list = 15; */
        for (let i = 0; i < message.infoList.length; i++)
            AvatarTeamResonanceInfo.internalBinaryWrite(message.infoList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TeamResonanceChangeNotify
 */
export const TeamResonanceChangeNotify = new TeamResonanceChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerAllDataRsp$Type extends MessageType<TowerAllDataRsp> {
    constructor() {
        super("TowerAllDataRsp", [
            { no: 13, name: "tower_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "tower_floor_record_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerFloorRecord },
            { no: 9, name: "daily_floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "daily_level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cur_level_record", kind: "message", T: () => TowerCurLevelRecord },
            { no: 8, name: "next_schedule_change_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "floor_open_time_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 14, name: "is_first_interact", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "monthly_brief", kind: "message", T: () => TowerMonthlyBrief },
            { no: 3, name: "skip_to_floor_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "commemorative_reward_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "skip_floor_granted_reward_item_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 10, name: "valid_tower_record_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "is_finished_entrance_floor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 490, name: "schedule_start_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 395, name: "last_schedule_monthly_brief", kind: "message", T: () => TowerMonthlyBrief }
        ]);
    }
    create(value?: PartialMessage<TowerAllDataRsp>): TowerAllDataRsp {
        const message = { towerScheduleId: 0, towerFloorRecordList: [], dailyFloorId: 0, dailyLevelIndex: 0, nextScheduleChangeTime: 0, floorOpenTimeMap: {}, isFirstInteract: false, skipToFloorIndex: 0, commemorativeRewardId: 0, skipFloorGrantedRewardItemMap: {}, validTowerRecordNum: 0, retcode: 0, isFinishedEntranceFloor: false, scheduleStartTime: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerAllDataRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerAllDataRsp): TowerAllDataRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tower_schedule_id */ 13:
                    message.towerScheduleId = reader.uint32();
                    break;
                case /* repeated TowerFloorRecord tower_floor_record_list */ 12:
                    message.towerFloorRecordList.push(TowerFloorRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 daily_floor_id */ 9:
                    message.dailyFloorId = reader.uint32();
                    break;
                case /* uint32 daily_level_index */ 6:
                    message.dailyLevelIndex = reader.uint32();
                    break;
                case /* TowerCurLevelRecord cur_level_record */ 2:
                    message.curLevelRecord = TowerCurLevelRecord.internalBinaryRead(reader, reader.uint32(), options, message.curLevelRecord);
                    break;
                case /* uint32 next_schedule_change_time */ 8:
                    message.nextScheduleChangeTime = reader.uint32();
                    break;
                case /* map<uint32, uint32> floor_open_time_map */ 11:
                    this.binaryReadMap11(message.floorOpenTimeMap, reader, options);
                    break;
                case /* bool is_first_interact */ 14:
                    message.isFirstInteract = reader.bool();
                    break;
                case /* TowerMonthlyBrief monthly_brief */ 1:
                    message.monthlyBrief = TowerMonthlyBrief.internalBinaryRead(reader, reader.uint32(), options, message.monthlyBrief);
                    break;
                case /* uint32 skip_to_floor_index */ 3:
                    message.skipToFloorIndex = reader.uint32();
                    break;
                case /* uint32 commemorative_reward_id */ 15:
                    message.commemorativeRewardId = reader.uint32();
                    break;
                case /* map<uint32, uint32> skip_floor_granted_reward_item_map */ 5:
                    this.binaryReadMap5(message.skipFloorGrantedRewardItemMap, reader, options);
                    break;
                case /* uint32 valid_tower_record_num */ 10:
                    message.validTowerRecordNum = reader.uint32();
                    break;
                case /* int32 retcode */ 4:
                    message.retcode = reader.int32();
                    break;
                case /* bool is_finished_entrance_floor */ 7:
                    message.isFinishedEntranceFloor = reader.bool();
                    break;
                case /* uint32 schedule_start_time */ 490:
                    message.scheduleStartTime = reader.uint32();
                    break;
                case /* TowerMonthlyBrief last_schedule_monthly_brief */ 395:
                    message.lastScheduleMonthlyBrief = TowerMonthlyBrief.internalBinaryRead(reader, reader.uint32(), options, message.lastScheduleMonthlyBrief);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap11(map: TowerAllDataRsp["floorOpenTimeMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TowerAllDataRsp["floorOpenTimeMap"] | undefined, val: TowerAllDataRsp["floorOpenTimeMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field TowerAllDataRsp.floor_open_time_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap5(map: TowerAllDataRsp["skipFloorGrantedRewardItemMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TowerAllDataRsp["skipFloorGrantedRewardItemMap"] | undefined, val: TowerAllDataRsp["skipFloorGrantedRewardItemMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field TowerAllDataRsp.skip_floor_granted_reward_item_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TowerAllDataRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tower_schedule_id = 13; */
        if (message.towerScheduleId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.towerScheduleId);
        /* repeated TowerFloorRecord tower_floor_record_list = 12; */
        for (let i = 0; i < message.towerFloorRecordList.length; i++)
            TowerFloorRecord.internalBinaryWrite(message.towerFloorRecordList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint32 daily_floor_id = 9; */
        if (message.dailyFloorId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.dailyFloorId);
        /* uint32 daily_level_index = 6; */
        if (message.dailyLevelIndex !== 0)
            writer.tag(6, WireType.Varint).uint32(message.dailyLevelIndex);
        /* TowerCurLevelRecord cur_level_record = 2; */
        if (message.curLevelRecord)
            TowerCurLevelRecord.internalBinaryWrite(message.curLevelRecord, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 next_schedule_change_time = 8; */
        if (message.nextScheduleChangeTime !== 0)
            writer.tag(8, WireType.Varint).uint32(message.nextScheduleChangeTime);
        /* map<uint32, uint32> floor_open_time_map = 11; */
        for (let k of Object.keys(message.floorOpenTimeMap))
            writer.tag(11, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.floorOpenTimeMap[k as any]).join();
        /* bool is_first_interact = 14; */
        if (message.isFirstInteract !== false)
            writer.tag(14, WireType.Varint).bool(message.isFirstInteract);
        /* TowerMonthlyBrief monthly_brief = 1; */
        if (message.monthlyBrief)
            TowerMonthlyBrief.internalBinaryWrite(message.monthlyBrief, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 skip_to_floor_index = 3; */
        if (message.skipToFloorIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.skipToFloorIndex);
        /* uint32 commemorative_reward_id = 15; */
        if (message.commemorativeRewardId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.commemorativeRewardId);
        /* map<uint32, uint32> skip_floor_granted_reward_item_map = 5; */
        for (let k of Object.keys(message.skipFloorGrantedRewardItemMap))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.skipFloorGrantedRewardItemMap[k as any]).join();
        /* uint32 valid_tower_record_num = 10; */
        if (message.validTowerRecordNum !== 0)
            writer.tag(10, WireType.Varint).uint32(message.validTowerRecordNum);
        /* int32 retcode = 4; */
        if (message.retcode !== 0)
            writer.tag(4, WireType.Varint).int32(message.retcode);
        /* bool is_finished_entrance_floor = 7; */
        if (message.isFinishedEntranceFloor !== false)
            writer.tag(7, WireType.Varint).bool(message.isFinishedEntranceFloor);
        /* uint32 schedule_start_time = 490; */
        if (message.scheduleStartTime !== 0)
            writer.tag(490, WireType.Varint).uint32(message.scheduleStartTime);
        /* TowerMonthlyBrief last_schedule_monthly_brief = 395; */
        if (message.lastScheduleMonthlyBrief)
            TowerMonthlyBrief.internalBinaryWrite(message.lastScheduleMonthlyBrief, writer.tag(395, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerAllDataRsp
 */
export const TowerAllDataRsp = new TowerAllDataRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerBuffSelectReq$Type extends MessageType<TowerBuffSelectReq> {
    constructor() {
        super("TowerBuffSelectReq", [
            { no: 2, name: "tower_buff_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerBuffSelectReq>): TowerBuffSelectReq {
        const message = { towerBuffId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerBuffSelectReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerBuffSelectReq): TowerBuffSelectReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tower_buff_id */ 2:
                    message.towerBuffId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerBuffSelectReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tower_buff_id = 2; */
        if (message.towerBuffId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.towerBuffId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerBuffSelectReq
 */
export const TowerBuffSelectReq = new TowerBuffSelectReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerBuffSelectRsp$Type extends MessageType<TowerBuffSelectRsp> {
    constructor() {
        super("TowerBuffSelectRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "tower_buff_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerBuffSelectRsp>): TowerBuffSelectRsp {
        const message = { retcode: 0, towerBuffId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerBuffSelectRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerBuffSelectRsp): TowerBuffSelectRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 tower_buff_id */ 6:
                    message.towerBuffId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerBuffSelectRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 tower_buff_id = 6; */
        if (message.towerBuffId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.towerBuffId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerBuffSelectRsp
 */
export const TowerBuffSelectRsp = new TowerBuffSelectRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerCurLevelRecord$Type extends MessageType<TowerCurLevelRecord> {
    constructor() {
        super("TowerCurLevelRecord", [
            { no: 13, name: "cur_floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "cur_level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "tower_team_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerTeam },
            { no: 15, name: "buff_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_empty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TowerCurLevelRecord>): TowerCurLevelRecord {
        const message = { curFloorId: 0, curLevelIndex: 0, towerTeamList: [], buffIdList: [], isEmpty: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerCurLevelRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerCurLevelRecord): TowerCurLevelRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cur_floor_id */ 13:
                    message.curFloorId = reader.uint32();
                    break;
                case /* uint32 cur_level_index */ 9:
                    message.curLevelIndex = reader.uint32();
                    break;
                case /* repeated TowerTeam tower_team_list */ 14:
                    message.towerTeamList.push(TowerTeam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 buff_id_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.buffIdList.push(reader.uint32());
                    else
                        message.buffIdList.push(reader.uint32());
                    break;
                case /* bool is_empty */ 5:
                    message.isEmpty = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerCurLevelRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cur_floor_id = 13; */
        if (message.curFloorId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.curFloorId);
        /* uint32 cur_level_index = 9; */
        if (message.curLevelIndex !== 0)
            writer.tag(9, WireType.Varint).uint32(message.curLevelIndex);
        /* repeated TowerTeam tower_team_list = 14; */
        for (let i = 0; i < message.towerTeamList.length; i++)
            TowerTeam.internalBinaryWrite(message.towerTeamList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 buff_id_list = 15; */
        if (message.buffIdList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.buffIdList.length; i++)
                writer.uint32(message.buffIdList[i]);
            writer.join();
        }
        /* bool is_empty = 5; */
        if (message.isEmpty !== false)
            writer.tag(5, WireType.Varint).bool(message.isEmpty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerCurLevelRecord
 */
export const TowerCurLevelRecord = new TowerCurLevelRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerCurLevelRecordChangeNotify$Type extends MessageType<TowerCurLevelRecordChangeNotify> {
    constructor() {
        super("TowerCurLevelRecordChangeNotify", [
            { no: 10, name: "cur_level_record", kind: "message", T: () => TowerCurLevelRecord }
        ]);
    }
    create(value?: PartialMessage<TowerCurLevelRecordChangeNotify>): TowerCurLevelRecordChangeNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerCurLevelRecordChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerCurLevelRecordChangeNotify): TowerCurLevelRecordChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TowerCurLevelRecord cur_level_record */ 10:
                    message.curLevelRecord = TowerCurLevelRecord.internalBinaryRead(reader, reader.uint32(), options, message.curLevelRecord);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerCurLevelRecordChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* TowerCurLevelRecord cur_level_record = 10; */
        if (message.curLevelRecord)
            TowerCurLevelRecord.internalBinaryWrite(message.curLevelRecord, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerCurLevelRecordChangeNotify
 */
export const TowerCurLevelRecordChangeNotify = new TowerCurLevelRecordChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerEnterLevelReq$Type extends MessageType<TowerEnterLevelReq> {
    constructor() {
        super("TowerEnterLevelReq", [
            { no: 4, name: "enter_point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerEnterLevelReq>): TowerEnterLevelReq {
        const message = { enterPointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerEnterLevelReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerEnterLevelReq): TowerEnterLevelReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 enter_point_id */ 4:
                    message.enterPointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerEnterLevelReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 enter_point_id = 4; */
        if (message.enterPointId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.enterPointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerEnterLevelReq
 */
export const TowerEnterLevelReq = new TowerEnterLevelReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerEnterLevelRsp$Type extends MessageType<TowerEnterLevelRsp> {
    constructor() {
        super("TowerEnterLevelRsp", [
            { no: 14, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "tower_buff_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerEnterLevelRsp>): TowerEnterLevelRsp {
        const message = { retcode: 0, floorId: 0, levelIndex: 0, towerBuffIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerEnterLevelRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerEnterLevelRsp): TowerEnterLevelRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 14:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 floor_id */ 6:
                    message.floorId = reader.uint32();
                    break;
                case /* uint32 level_index */ 8:
                    message.levelIndex = reader.uint32();
                    break;
                case /* repeated uint32 tower_buff_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.towerBuffIdList.push(reader.uint32());
                    else
                        message.towerBuffIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerEnterLevelRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 14; */
        if (message.retcode !== 0)
            writer.tag(14, WireType.Varint).int32(message.retcode);
        /* uint32 floor_id = 6; */
        if (message.floorId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.floorId);
        /* uint32 level_index = 8; */
        if (message.levelIndex !== 0)
            writer.tag(8, WireType.Varint).uint32(message.levelIndex);
        /* repeated uint32 tower_buff_id_list = 7; */
        if (message.towerBuffIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.towerBuffIdList.length; i++)
                writer.uint32(message.towerBuffIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerEnterLevelRsp
 */
export const TowerEnterLevelRsp = new TowerEnterLevelRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerFloorRecord$Type extends MessageType<TowerFloorRecord> {
    constructor() {
        super("TowerFloorRecord", [
            { no: 1, name: "floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "passed_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 3, name: "floor_star_reward_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "passed_level_record_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerLevelRecord }
        ]);
    }
    create(value?: PartialMessage<TowerFloorRecord>): TowerFloorRecord {
        const message = { floorId: 0, passedLevelMap: {}, floorStarRewardProgress: 0, passedLevelRecordList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerFloorRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerFloorRecord): TowerFloorRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 floor_id */ 1:
                    message.floorId = reader.uint32();
                    break;
                case /* map<uint32, uint32> passed_level_map */ 2:
                    this.binaryReadMap2(message.passedLevelMap, reader, options);
                    break;
                case /* uint32 floor_star_reward_progress */ 3:
                    message.floorStarRewardProgress = reader.uint32();
                    break;
                case /* repeated TowerLevelRecord passed_level_record_list */ 4:
                    message.passedLevelRecordList.push(TowerLevelRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: TowerFloorRecord["passedLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TowerFloorRecord["passedLevelMap"] | undefined, val: TowerFloorRecord["passedLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field TowerFloorRecord.passed_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: TowerFloorRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 floor_id = 1; */
        if (message.floorId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.floorId);
        /* map<uint32, uint32> passed_level_map = 2; */
        for (let k of Object.keys(message.passedLevelMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.passedLevelMap[k as any]).join();
        /* uint32 floor_star_reward_progress = 3; */
        if (message.floorStarRewardProgress !== 0)
            writer.tag(3, WireType.Varint).uint32(message.floorStarRewardProgress);
        /* repeated TowerLevelRecord passed_level_record_list = 4; */
        for (let i = 0; i < message.passedLevelRecordList.length; i++)
            TowerLevelRecord.internalBinaryWrite(message.passedLevelRecordList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerFloorRecord
 */
export const TowerFloorRecord = new TowerFloorRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerFloorRecordChangeNotify$Type extends MessageType<TowerFloorRecordChangeNotify> {
    constructor() {
        super("TowerFloorRecordChangeNotify", [
            { no: 9, name: "tower_floor_record_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerFloorRecord },
            { no: 1, name: "is_finished_entrance_floor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TowerFloorRecordChangeNotify>): TowerFloorRecordChangeNotify {
        const message = { towerFloorRecordList: [], isFinishedEntranceFloor: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerFloorRecordChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerFloorRecordChangeNotify): TowerFloorRecordChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TowerFloorRecord tower_floor_record_list */ 9:
                    message.towerFloorRecordList.push(TowerFloorRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_finished_entrance_floor */ 1:
                    message.isFinishedEntranceFloor = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerFloorRecordChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated TowerFloorRecord tower_floor_record_list = 9; */
        for (let i = 0; i < message.towerFloorRecordList.length; i++)
            TowerFloorRecord.internalBinaryWrite(message.towerFloorRecordList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool is_finished_entrance_floor = 1; */
        if (message.isFinishedEntranceFloor !== false)
            writer.tag(1, WireType.Varint).bool(message.isFinishedEntranceFloor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerFloorRecordChangeNotify
 */
export const TowerFloorRecordChangeNotify = new TowerFloorRecordChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerLevelEndNotify$Type extends MessageType<TowerLevelEndNotify> {
    constructor() {
        super("TowerLevelEndNotify", [
            { no: 14, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "finished_star_cond_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "reward_item_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam },
            { no: 2, name: "continue_state", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "next_floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerLevelEndNotify>): TowerLevelEndNotify {
        const message = { isSuccess: false, finishedStarCondList: [], rewardItemList: [], continueState: 0, nextFloorId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerLevelEndNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerLevelEndNotify): TowerLevelEndNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_success */ 14:
                    message.isSuccess = reader.bool();
                    break;
                case /* repeated uint32 finished_star_cond_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishedStarCondList.push(reader.uint32());
                    else
                        message.finishedStarCondList.push(reader.uint32());
                    break;
                case /* repeated ItemParam reward_item_list */ 9:
                    message.rewardItemList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 continue_state */ 2:
                    message.continueState = reader.uint32();
                    break;
                case /* uint32 next_floor_id */ 8:
                    message.nextFloorId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerLevelEndNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_success = 14; */
        if (message.isSuccess !== false)
            writer.tag(14, WireType.Varint).bool(message.isSuccess);
        /* repeated uint32 finished_star_cond_list = 1; */
        if (message.finishedStarCondList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.finishedStarCondList.length; i++)
                writer.uint32(message.finishedStarCondList[i]);
            writer.join();
        }
        /* repeated ItemParam reward_item_list = 9; */
        for (let i = 0; i < message.rewardItemList.length; i++)
            ItemParam.internalBinaryWrite(message.rewardItemList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 continue_state = 2; */
        if (message.continueState !== 0)
            writer.tag(2, WireType.Varint).uint32(message.continueState);
        /* uint32 next_floor_id = 8; */
        if (message.nextFloorId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.nextFloorId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerLevelEndNotify
 */
export const TowerLevelEndNotify = new TowerLevelEndNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerLevelRecord$Type extends MessageType<TowerLevelRecord> {
    constructor() {
        super("TowerLevelRecord", [
            { no: 1, name: "level_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "satisfied_cond_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerLevelRecord>): TowerLevelRecord {
        const message = { levelId: 0, satisfiedCondList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerLevelRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerLevelRecord): TowerLevelRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level_id */ 1:
                    message.levelId = reader.uint32();
                    break;
                case /* repeated uint32 satisfied_cond_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.satisfiedCondList.push(reader.uint32());
                    else
                        message.satisfiedCondList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerLevelRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 level_id = 1; */
        if (message.levelId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.levelId);
        /* repeated uint32 satisfied_cond_list = 2; */
        if (message.satisfiedCondList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.satisfiedCondList.length; i++)
                writer.uint32(message.satisfiedCondList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerLevelRecord
 */
export const TowerLevelRecord = new TowerLevelRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerLevelStarCondData$Type extends MessageType<TowerLevelStarCondData> {
    constructor() {
        super("TowerLevelStarCondData", [
            { no: 3, name: "star_cond_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cond_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "OAFMGGMJPIL", kind: "scalar", jsonName: "OAFMGGMJPIL", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TowerLevelStarCondData>): TowerLevelStarCondData {
        const message = { starCondIndex: 0, condValue: 0, isPause: false, oAFMGGMJPIL: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerLevelStarCondData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerLevelStarCondData): TowerLevelStarCondData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 star_cond_index */ 3:
                    message.starCondIndex = reader.uint32();
                    break;
                case /* uint32 cond_value */ 4:
                    message.condValue = reader.uint32();
                    break;
                case /* bool is_pause */ 5:
                    message.isPause = reader.bool();
                    break;
                case /* bool OAFMGGMJPIL = 6 [json_name = "OAFMGGMJPIL"];*/ 6:
                    message.oAFMGGMJPIL = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerLevelStarCondData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 star_cond_index = 3; */
        if (message.starCondIndex !== 0)
            writer.tag(3, WireType.Varint).uint32(message.starCondIndex);
        /* uint32 cond_value = 4; */
        if (message.condValue !== 0)
            writer.tag(4, WireType.Varint).uint32(message.condValue);
        /* bool is_pause = 5; */
        if (message.isPause !== false)
            writer.tag(5, WireType.Varint).bool(message.isPause);
        /* bool OAFMGGMJPIL = 6 [json_name = "OAFMGGMJPIL"]; */
        if (message.oAFMGGMJPIL !== false)
            writer.tag(6, WireType.Varint).bool(message.oAFMGGMJPIL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerLevelStarCondData
 */
export const TowerLevelStarCondData = new TowerLevelStarCondData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerLevelStarCondNotify$Type extends MessageType<TowerLevelStarCondNotify> {
    constructor() {
        super("TowerLevelStarCondNotify", [
            { no: 3, name: "floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cond_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerLevelStarCondData }
        ]);
    }
    create(value?: PartialMessage<TowerLevelStarCondNotify>): TowerLevelStarCondNotify {
        const message = { floorId: 0, levelIndex: 0, condDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerLevelStarCondNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerLevelStarCondNotify): TowerLevelStarCondNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 floor_id */ 3:
                    message.floorId = reader.uint32();
                    break;
                case /* uint32 level_index */ 6:
                    message.levelIndex = reader.uint32();
                    break;
                case /* repeated TowerLevelStarCondData cond_data_list */ 12:
                    message.condDataList.push(TowerLevelStarCondData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerLevelStarCondNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 floor_id = 3; */
        if (message.floorId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.floorId);
        /* uint32 level_index = 6; */
        if (message.levelIndex !== 0)
            writer.tag(6, WireType.Varint).uint32(message.levelIndex);
        /* repeated TowerLevelStarCondData cond_data_list = 12; */
        for (let i = 0; i < message.condDataList.length; i++)
            TowerLevelStarCondData.internalBinaryWrite(message.condDataList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerLevelStarCondNotify
 */
export const TowerLevelStarCondNotify = new TowerLevelStarCondNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerMiddleLevelChangeTeamNotify$Type extends MessageType<TowerMiddleLevelChangeTeamNotify> {
    constructor() {
        super("TowerMiddleLevelChangeTeamNotify", []);
    }
    create(value?: PartialMessage<TowerMiddleLevelChangeTeamNotify>): TowerMiddleLevelChangeTeamNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerMiddleLevelChangeTeamNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerMiddleLevelChangeTeamNotify): TowerMiddleLevelChangeTeamNotify {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TowerMiddleLevelChangeTeamNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerMiddleLevelChangeTeamNotify
 */
export const TowerMiddleLevelChangeTeamNotify = new TowerMiddleLevelChangeTeamNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerMonthlyBrief$Type extends MessageType<TowerMonthlyBrief> {
    constructor() {
        super("TowerMonthlyBrief", [
            { no: 4, name: "tower_schedule_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "best_floor_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "best_level_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "total_star_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerMonthlyBrief>): TowerMonthlyBrief {
        const message = { towerScheduleId: 0, bestFloorIndex: 0, bestLevelIndex: 0, totalStarCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerMonthlyBrief>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerMonthlyBrief): TowerMonthlyBrief {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tower_schedule_id */ 4:
                    message.towerScheduleId = reader.uint32();
                    break;
                case /* uint32 best_floor_index */ 5:
                    message.bestFloorIndex = reader.uint32();
                    break;
                case /* uint32 best_level_index */ 12:
                    message.bestLevelIndex = reader.uint32();
                    break;
                case /* uint32 total_star_count */ 2:
                    message.totalStarCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerMonthlyBrief, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tower_schedule_id = 4; */
        if (message.towerScheduleId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.towerScheduleId);
        /* uint32 best_floor_index = 5; */
        if (message.bestFloorIndex !== 0)
            writer.tag(5, WireType.Varint).uint32(message.bestFloorIndex);
        /* uint32 best_level_index = 12; */
        if (message.bestLevelIndex !== 0)
            writer.tag(12, WireType.Varint).uint32(message.bestLevelIndex);
        /* uint32 total_star_count = 2; */
        if (message.totalStarCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalStarCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerMonthlyBrief
 */
export const TowerMonthlyBrief = new TowerMonthlyBrief$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerTeam$Type extends MessageType<TowerTeam> {
    constructor() {
        super("TowerTeam", [
            { no: 1, name: "tower_team_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avatar_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TowerTeam>): TowerTeam {
        const message = { towerTeamId: 0, avatarGuidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerTeam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerTeam): TowerTeam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tower_team_id */ 1:
                    message.towerTeamId = reader.uint32();
                    break;
                case /* repeated uint64 avatar_guid_list */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avatarGuidList.push(reader.uint64().toBigInt());
                    else
                        message.avatarGuidList.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerTeam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 tower_team_id = 1; */
        if (message.towerTeamId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.towerTeamId);
        /* repeated uint64 avatar_guid_list = 2; */
        if (message.avatarGuidList.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avatarGuidList.length; i++)
                writer.uint64(message.avatarGuidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerTeam
 */
export const TowerTeam = new TowerTeam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerTeamSelectReq$Type extends MessageType<TowerTeamSelectReq> {
    constructor() {
        super("TowerTeamSelectReq", [
            { no: 15, name: "floor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tower_team_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TowerTeam }
        ]);
    }
    create(value?: PartialMessage<TowerTeamSelectReq>): TowerTeamSelectReq {
        const message = { floorId: 0, towerTeamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerTeamSelectReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerTeamSelectReq): TowerTeamSelectReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 floor_id */ 15:
                    message.floorId = reader.uint32();
                    break;
                case /* repeated TowerTeam tower_team_list */ 2:
                    message.towerTeamList.push(TowerTeam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerTeamSelectReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 floor_id = 15; */
        if (message.floorId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.floorId);
        /* repeated TowerTeam tower_team_list = 2; */
        for (let i = 0; i < message.towerTeamList.length; i++)
            TowerTeam.internalBinaryWrite(message.towerTeamList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerTeamSelectReq
 */
export const TowerTeamSelectReq = new TowerTeamSelectReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TowerTeamSelectRsp$Type extends MessageType<TowerTeamSelectRsp> {
    constructor() {
        super("TowerTeamSelectRsp", [
            { no: 1, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TowerTeamSelectRsp>): TowerTeamSelectRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TowerTeamSelectRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TowerTeamSelectRsp): TowerTeamSelectRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 1:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TowerTeamSelectRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 1; */
        if (message.retcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TowerTeamSelectRsp
 */
export const TowerTeamSelectRsp = new TowerTeamSelectRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackingIOInfo$Type extends MessageType<TrackingIOInfo> {
    constructor() {
        super("TrackingIOInfo", [
            { no: 3, name: "appid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "deviceid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "mac", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rydevicetype", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "client_tz", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_caid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "cached_caid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackingIOInfo>): TrackingIOInfo {
        const message = { appid: "", deviceid: "", mac: "", rydevicetype: "", clientTz: "", currentCaid: "", cachedCaid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrackingIOInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackingIOInfo): TrackingIOInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string appid */ 3:
                    message.appid = reader.string();
                    break;
                case /* string deviceid */ 9:
                    message.deviceid = reader.string();
                    break;
                case /* string mac */ 6:
                    message.mac = reader.string();
                    break;
                case /* string rydevicetype */ 2:
                    message.rydevicetype = reader.string();
                    break;
                case /* string client_tz */ 1:
                    message.clientTz = reader.string();
                    break;
                case /* string current_caid */ 5:
                    message.currentCaid = reader.string();
                    break;
                case /* string cached_caid */ 12:
                    message.cachedCaid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackingIOInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string appid = 3; */
        if (message.appid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appid);
        /* string deviceid = 9; */
        if (message.deviceid !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.deviceid);
        /* string mac = 6; */
        if (message.mac !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mac);
        /* string rydevicetype = 2; */
        if (message.rydevicetype !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rydevicetype);
        /* string client_tz = 1; */
        if (message.clientTz !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientTz);
        /* string current_caid = 5; */
        if (message.currentCaid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.currentCaid);
        /* string cached_caid = 12; */
        if (message.cachedCaid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.cachedCaid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrackingIOInfo
 */
export const TrackingIOInfo = new TrackingIOInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrialAvatarFirstPassDungeonNotify$Type extends MessageType<TrialAvatarFirstPassDungeonNotify> {
    constructor() {
        super("TrialAvatarFirstPassDungeonNotify", [
            { no: 2, name: "trial_avatar_index_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrialAvatarFirstPassDungeonNotify>): TrialAvatarFirstPassDungeonNotify {
        const message = { trialAvatarIndexId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrialAvatarFirstPassDungeonNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrialAvatarFirstPassDungeonNotify): TrialAvatarFirstPassDungeonNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 trial_avatar_index_id */ 2:
                    message.trialAvatarIndexId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrialAvatarFirstPassDungeonNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 trial_avatar_index_id = 2; */
        if (message.trialAvatarIndexId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.trialAvatarIndexId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrialAvatarFirstPassDungeonNotify
 */
export const TrialAvatarFirstPassDungeonNotify = new TrialAvatarFirstPassDungeonNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrialAvatarGrantRecord$Type extends MessageType<TrialAvatarGrantRecord> {
    constructor() {
        super("TrialAvatarGrantRecord", [
            { no: 1, name: "grant_reason", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "from_parent_quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrialAvatarGrantRecord>): TrialAvatarGrantRecord {
        const message = { grantReason: 0, fromParentQuestId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrialAvatarGrantRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrialAvatarGrantRecord): TrialAvatarGrantRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 grant_reason */ 1:
                    message.grantReason = reader.uint32();
                    break;
                case /* uint32 from_parent_quest_id */ 2:
                    message.fromParentQuestId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrialAvatarGrantRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 grant_reason = 1; */
        if (message.grantReason !== 0)
            writer.tag(1, WireType.Varint).uint32(message.grantReason);
        /* uint32 from_parent_quest_id = 2; */
        if (message.fromParentQuestId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.fromParentQuestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrialAvatarGrantRecord
 */
export const TrialAvatarGrantRecord = new TrialAvatarGrantRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrialAvatarInfo$Type extends MessageType<TrialAvatarInfo> {
    constructor() {
        super("TrialAvatarInfo", [
            { no: 1, name: "trial_avatar_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "trial_equip_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Item },
            { no: 3, name: "grant_record", kind: "message", T: () => TrialAvatarGrantRecord }
        ]);
    }
    create(value?: PartialMessage<TrialAvatarInfo>): TrialAvatarInfo {
        const message = { trialAvatarId: 0, trialEquipList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrialAvatarInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrialAvatarInfo): TrialAvatarInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 trial_avatar_id */ 1:
                    message.trialAvatarId = reader.uint32();
                    break;
                case /* repeated Item trial_equip_list */ 2:
                    message.trialEquipList.push(Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TrialAvatarGrantRecord grant_record */ 3:
                    message.grantRecord = TrialAvatarGrantRecord.internalBinaryRead(reader, reader.uint32(), options, message.grantRecord);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrialAvatarInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 trial_avatar_id = 1; */
        if (message.trialAvatarId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.trialAvatarId);
        /* repeated Item trial_equip_list = 2; */
        for (let i = 0; i < message.trialEquipList.length; i++)
            Item.internalBinaryWrite(message.trialEquipList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* TrialAvatarGrantRecord grant_record = 3; */
        if (message.grantRecord)
            TrialAvatarGrantRecord.internalBinaryWrite(message.grantRecord, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrialAvatarInfo
 */
export const TrialAvatarInfo = new TrialAvatarInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TryEnterHomeReq$Type extends MessageType<TryEnterHomeReq> {
    constructor() {
        super("TryEnterHomeReq", [
            { no: 10, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "target_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TryEnterHomeReq>): TryEnterHomeReq {
        const message = { targetUid: 0, targetPoint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TryEnterHomeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TryEnterHomeReq): TryEnterHomeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_uid */ 10:
                    message.targetUid = reader.uint32();
                    break;
                case /* uint32 target_point */ 13:
                    message.targetPoint = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TryEnterHomeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_uid = 10; */
        if (message.targetUid !== 0)
            writer.tag(10, WireType.Varint).uint32(message.targetUid);
        /* uint32 target_point = 13; */
        if (message.targetPoint !== 0)
            writer.tag(13, WireType.Varint).uint32(message.targetPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TryEnterHomeReq
 */
export const TryEnterHomeReq = new TryEnterHomeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TryEnterHomeRsp$Type extends MessageType<TryEnterHomeRsp> {
    constructor() {
        super("TryEnterHomeRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "target_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "param_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TryEnterHomeRsp>): TryEnterHomeRsp {
        const message = { retcode: 0, targetUid: 0, paramList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TryEnterHomeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TryEnterHomeRsp): TryEnterHomeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 target_uid */ 2:
                    message.targetUid = reader.uint32();
                    break;
                case /* repeated uint32 param_list */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.paramList.push(reader.uint32());
                    else
                        message.paramList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TryEnterHomeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint32 target_uid = 2; */
        if (message.targetUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.targetUid);
        /* repeated uint32 param_list = 11; */
        if (message.paramList.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.paramList.length; i++)
                writer.uint32(message.paramList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TryEnterHomeRsp
 */
export const TryEnterHomeRsp = new TryEnterHomeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uint32Pair$Type extends MessageType<Uint32Pair> {
    constructor() {
        super("Uint32Pair", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Uint32Pair>): Uint32Pair {
        const message = { key: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Uint32Pair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uint32Pair): Uint32Pair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* uint32 value */ 2:
                    message.value = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uint32Pair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* uint32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).uint32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Uint32Pair
 */
export const Uint32Pair = new Uint32Pair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnionCmd$Type extends MessageType<UnionCmd> {
    constructor() {
        super("UnionCmd", [
            { no: 9, name: "message_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UnionCmd>): UnionCmd {
        const message = { messageId: 0, body: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnionCmd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnionCmd): UnionCmd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 message_id */ 9:
                    message.messageId = reader.uint32();
                    break;
                case /* bytes body */ 13:
                    message.body = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnionCmd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 message_id = 9; */
        if (message.messageId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.messageId);
        /* bytes body = 13; */
        if (message.body.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnionCmd
 */
export const UnionCmd = new UnionCmd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnionCmdNotify$Type extends MessageType<UnionCmdNotify> {
    constructor() {
        super("UnionCmdNotify", [
            { no: 13, name: "cmd_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UnionCmd }
        ]);
    }
    create(value?: PartialMessage<UnionCmdNotify>): UnionCmdNotify {
        const message = { cmdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnionCmdNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnionCmdNotify): UnionCmdNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UnionCmd cmd_list */ 13:
                    message.cmdList.push(UnionCmd.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnionCmdNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UnionCmd cmd_list = 13; */
        for (let i = 0; i < message.cmdList.length; i++)
            UnionCmd.internalBinaryWrite(message.cmdList[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnionCmdNotify
 */
export const UnionCmdNotify = new UnionCmdNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2700_BIEMCDLIFOD$Type extends MessageType<Unk2700_BIEMCDLIFOD> {
    constructor() {
        super("Unk2700_BIEMCDLIFOD", [
            { no: 11, name: "guid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "spawn_pos", kind: "message", T: () => Vector },
            { no: 12, name: "included_furniture_index_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2700_BIEMCDLIFOD>): Unk2700_BIEMCDLIFOD {
        const message = { guid: 0, includedFurnitureIndexList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2700_BIEMCDLIFOD>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2700_BIEMCDLIFOD): Unk2700_BIEMCDLIFOD {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 guid */ 11:
                    message.guid = reader.uint32();
                    break;
                case /* Vector spawn_pos */ 14:
                    message.spawnPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.spawnPos);
                    break;
                case /* repeated int32 included_furniture_index_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.includedFurnitureIndexList.push(reader.int32());
                    else
                        message.includedFurnitureIndexList.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2700_BIEMCDLIFOD, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 guid = 11; */
        if (message.guid !== 0)
            writer.tag(11, WireType.Varint).uint32(message.guid);
        /* Vector spawn_pos = 14; */
        if (message.spawnPos)
            Vector.internalBinaryWrite(message.spawnPos, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 included_furniture_index_list = 12; */
        if (message.includedFurnitureIndexList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.includedFurnitureIndexList.length; i++)
                writer.int32(message.includedFurnitureIndexList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2700_BIEMCDLIFOD
 */
export const Unk2700_BIEMCDLIFOD = new Unk2700_BIEMCDLIFOD$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2700_CCEOEOHLAPK$Type extends MessageType<Unk2700_CCEOEOHLAPK> {
    constructor() {
        super("Unk2700_CCEOEOHLAPK", [
            { no: 3, name: "is_hint_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "hint_center_pos", kind: "message", T: () => Vector },
            { no: 6, name: "group_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "config_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2700_CCEOEOHLAPK>): Unk2700_CCEOEOHLAPK {
        const message = { isHintValid: false, groupId: 0, configId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2700_CCEOEOHLAPK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2700_CCEOEOHLAPK): Unk2700_CCEOEOHLAPK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_hint_valid */ 3:
                    message.isHintValid = reader.bool();
                    break;
                case /* Vector hint_center_pos */ 8:
                    message.hintCenterPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.hintCenterPos);
                    break;
                case /* uint32 group_id */ 6:
                    message.groupId = reader.uint32();
                    break;
                case /* uint32 config_id */ 9:
                    message.configId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2700_CCEOEOHLAPK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_hint_valid = 3; */
        if (message.isHintValid !== false)
            writer.tag(3, WireType.Varint).bool(message.isHintValid);
        /* Vector hint_center_pos = 8; */
        if (message.hintCenterPos)
            Vector.internalBinaryWrite(message.hintCenterPos, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 group_id = 6; */
        if (message.groupId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.groupId);
        /* uint32 config_id = 9; */
        if (message.configId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.configId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2700_CCEOEOHLAPK
 */
export const Unk2700_CCEOEOHLAPK = new Unk2700_CCEOEOHLAPK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2700_FDEGJOCDDGH$Type extends MessageType<Unk2700_FDEGJOCDDGH> {
    constructor() {
        super("Unk2700_FDEGJOCDDGH", [
            { no: 9, name: "cur_progress", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "challenge_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "challenge_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2700_FDEGJOCDDGH>): Unk2700_FDEGJOCDDGH {
        const message = { curProgress: 0, challengeIndex: 0, isSuccess: false, challengeId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2700_FDEGJOCDDGH>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2700_FDEGJOCDDGH): Unk2700_FDEGJOCDDGH {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cur_progress */ 9:
                    message.curProgress = reader.uint32();
                    break;
                case /* uint32 challenge_index */ 10:
                    message.challengeIndex = reader.uint32();
                    break;
                case /* bool is_success */ 4:
                    message.isSuccess = reader.bool();
                    break;
                case /* uint32 challenge_id */ 8:
                    message.challengeId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2700_FDEGJOCDDGH, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 cur_progress = 9; */
        if (message.curProgress !== 0)
            writer.tag(9, WireType.Varint).uint32(message.curProgress);
        /* uint32 challenge_index = 10; */
        if (message.challengeIndex !== 0)
            writer.tag(10, WireType.Varint).uint32(message.challengeIndex);
        /* bool is_success = 4; */
        if (message.isSuccess !== false)
            writer.tag(4, WireType.Varint).bool(message.isSuccess);
        /* uint32 challenge_id = 8; */
        if (message.challengeId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.challengeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2700_FDEGJOCDDGH
 */
export const Unk2700_FDEGJOCDDGH = new Unk2700_FDEGJOCDDGH$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2700_GOHMLAFNBGF$Type extends MessageType<Unk2700_GOHMLAFNBGF> {
    constructor() {
        super("Unk2700_GOHMLAFNBGF", [
            { no: 8, name: "Unk2700_OALCFEGIBOL", kind: "scalar", jsonName: "Unk2700OALCFEGIBOL", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "Unk2700_CKPNCKDIJMB", kind: "message", jsonName: "Unk2700CKPNCKDIJMB", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeFurnitureData }
        ]);
    }
    create(value?: PartialMessage<Unk2700_GOHMLAFNBGF>): Unk2700_GOHMLAFNBGF {
        const message = { unk2700OALCFEGIBOL: 0, unk2700CKPNCKDIJMB: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2700_GOHMLAFNBGF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2700_GOHMLAFNBGF): Unk2700_GOHMLAFNBGF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 Unk2700_OALCFEGIBOL = 8 [json_name = "Unk2700OALCFEGIBOL"];*/ 8:
                    message.unk2700OALCFEGIBOL = reader.uint32();
                    break;
                case /* repeated HomeFurnitureData Unk2700_CKPNCKDIJMB = 3 [json_name = "Unk2700CKPNCKDIJMB"];*/ 3:
                    message.unk2700CKPNCKDIJMB.push(HomeFurnitureData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2700_GOHMLAFNBGF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 Unk2700_OALCFEGIBOL = 8 [json_name = "Unk2700OALCFEGIBOL"]; */
        if (message.unk2700OALCFEGIBOL !== 0)
            writer.tag(8, WireType.Varint).uint32(message.unk2700OALCFEGIBOL);
        /* repeated HomeFurnitureData Unk2700_CKPNCKDIJMB = 3 [json_name = "Unk2700CKPNCKDIJMB"]; */
        for (let i = 0; i < message.unk2700CKPNCKDIJMB.length; i++)
            HomeFurnitureData.internalBinaryWrite(message.unk2700CKPNCKDIJMB[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2700_GOHMLAFNBGF
 */
export const Unk2700_GOHMLAFNBGF = new Unk2700_GOHMLAFNBGF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2700_HFMDKDHCJCM$Type extends MessageType<Unk2700_HFMDKDHCJCM> {
    constructor() {
        super("Unk2700_HFMDKDHCJCM", [
            { no: 1, name: "Unk2700_CMOMNFNGCGB", kind: "message", jsonName: "Unk2700CMOMNFNGCGB", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<Unk2700_HFMDKDHCJCM>): Unk2700_HFMDKDHCJCM {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2700_HFMDKDHCJCM>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2700_HFMDKDHCJCM): Unk2700_HFMDKDHCJCM {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector Unk2700_CMOMNFNGCGB = 1 [json_name = "Unk2700CMOMNFNGCGB"];*/ 1:
                    message.unk2700CMOMNFNGCGB = Vector.internalBinaryRead(reader, reader.uint32(), options, message.unk2700CMOMNFNGCGB);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2700_HFMDKDHCJCM, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector Unk2700_CMOMNFNGCGB = 1 [json_name = "Unk2700CMOMNFNGCGB"]; */
        if (message.unk2700CMOMNFNGCGB)
            Vector.internalBinaryWrite(message.unk2700CMOMNFNGCGB, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2700_HFMDKDHCJCM
 */
export const Unk2700_HFMDKDHCJCM = new Unk2700_HFMDKDHCJCM$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2800_FHMOLALLEEN$Type extends MessageType<Unk2800_FHMOLALLEEN> {
    constructor() {
        super("Unk2800_FHMOLALLEEN", [
            { no: 1, name: "argument_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2800_FHMOLALLEEN>): Unk2800_FHMOLALLEEN {
        const message = { argumentList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2800_FHMOLALLEEN>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2800_FHMOLALLEEN): Unk2800_FHMOLALLEEN {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 argument_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.argumentList.push(reader.uint32());
                    else
                        message.argumentList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2800_FHMOLALLEEN, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 argument_list = 1; */
        if (message.argumentList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.argumentList.length; i++)
                writer.uint32(message.argumentList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2800_FHMOLALLEEN
 */
export const Unk2800_FHMOLALLEEN = new Unk2800_FHMOLALLEEN$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2800_JKLFAJKDLDG$Type extends MessageType<Unk2800_JKLFAJKDLDG> {
    constructor() {
        super("Unk2800_JKLFAJKDLDG", [
            { no: 13, name: "quest_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2800_JKLFAJKDLDG>): Unk2800_JKLFAJKDLDG {
        const message = { questId: 0, pointId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2800_JKLFAJKDLDG>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2800_JKLFAJKDLDG): Unk2800_JKLFAJKDLDG {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quest_id */ 13:
                    message.questId = reader.uint32();
                    break;
                case /* uint32 point_id */ 6:
                    message.pointId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2800_JKLFAJKDLDG, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quest_id = 13; */
        if (message.questId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.questId);
        /* uint32 point_id = 6; */
        if (message.pointId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.pointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2800_JKLFAJKDLDG
 */
export const Unk2800_JKLFAJKDLDG = new Unk2800_JKLFAJKDLDG$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2800_MHCFAGCKGIB$Type extends MessageType<Unk2800_MHCFAGCKGIB> {
    constructor() {
        super("Unk2800_MHCFAGCKGIB", [
            { no: 12, name: "scene_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "point_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "dungeon_entry_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DungeonEntryInfo },
            { no: 8, name: "recommend_dungeon_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2800_MHCFAGCKGIB>): Unk2800_MHCFAGCKGIB {
        const message = { sceneId: 0, pointId: 0, dungeonEntryList: [], recommendDungeonId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2800_MHCFAGCKGIB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2800_MHCFAGCKGIB): Unk2800_MHCFAGCKGIB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 scene_id */ 12:
                    message.sceneId = reader.uint32();
                    break;
                case /* uint32 point_id */ 6:
                    message.pointId = reader.uint32();
                    break;
                case /* repeated DungeonEntryInfo dungeon_entry_list */ 1:
                    message.dungeonEntryList.push(DungeonEntryInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 recommend_dungeon_id */ 8:
                    message.recommendDungeonId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2800_MHCFAGCKGIB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 scene_id = 12; */
        if (message.sceneId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.sceneId);
        /* uint32 point_id = 6; */
        if (message.pointId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.pointId);
        /* repeated DungeonEntryInfo dungeon_entry_list = 1; */
        for (let i = 0; i < message.dungeonEntryList.length; i++)
            DungeonEntryInfo.internalBinaryWrite(message.dungeonEntryList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 recommend_dungeon_id = 8; */
        if (message.recommendDungeonId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.recommendDungeonId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2800_MHCFAGCKGIB
 */
export const Unk2800_MHCFAGCKGIB = new Unk2800_MHCFAGCKGIB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Unk2800_PHPHMILPOLC$Type extends MessageType<Unk2800_PHPHMILPOLC> {
    constructor() {
        super("Unk2800_PHPHMILPOLC", [
            { no: 10, name: "state", kind: "enum", T: () => ["Unk2800_FDLKPKFOIIK", Unk2800_FDLKPKFOIIK] },
            { no: 4, name: "Unk2800_CLOCMPFBGMD", kind: "scalar", jsonName: "Unk2800CLOCMPFBGMD", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Unk2800_PHPHMILPOLC>): Unk2800_PHPHMILPOLC {
        const message = { state: 0, unk2800CLOCMPFBGMD: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Unk2800_PHPHMILPOLC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Unk2800_PHPHMILPOLC): Unk2800_PHPHMILPOLC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Unk2800_FDLKPKFOIIK state */ 10:
                    message.state = reader.int32();
                    break;
                case /* uint32 Unk2800_CLOCMPFBGMD = 4 [json_name = "Unk2800CLOCMPFBGMD"];*/ 4:
                    message.unk2800CLOCMPFBGMD = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Unk2800_PHPHMILPOLC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Unk2800_FDLKPKFOIIK state = 10; */
        if (message.state !== 0)
            writer.tag(10, WireType.Varint).int32(message.state);
        /* uint32 Unk2800_CLOCMPFBGMD = 4 [json_name = "Unk2800CLOCMPFBGMD"]; */
        if (message.unk2800CLOCMPFBGMD !== 0)
            writer.tag(4, WireType.Varint).uint32(message.unk2800CLOCMPFBGMD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Unk2800_PHPHMILPOLC
 */
export const Unk2800_PHPHMILPOLC = new Unk2800_PHPHMILPOLC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockAvatarTalentReq$Type extends MessageType<UnlockAvatarTalentReq> {
    constructor() {
        super("UnlockAvatarTalentReq", [
            { no: 13, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "talent_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockAvatarTalentReq>): UnlockAvatarTalentReq {
        const message = { avatarGuid: 0n, talentId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockAvatarTalentReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockAvatarTalentReq): UnlockAvatarTalentReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 13:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 talent_id */ 9:
                    message.talentId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockAvatarTalentReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 13; */
        if (message.avatarGuid !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 talent_id = 9; */
        if (message.talentId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.talentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockAvatarTalentReq
 */
export const UnlockAvatarTalentReq = new UnlockAvatarTalentReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockAvatarTalentRsp$Type extends MessageType<UnlockAvatarTalentRsp> {
    constructor() {
        super("UnlockAvatarTalentRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "talent_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockAvatarTalentRsp>): UnlockAvatarTalentRsp {
        const message = { retcode: 0, avatarGuid: 0n, talentId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockAvatarTalentRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockAvatarTalentRsp): UnlockAvatarTalentRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 14:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 talent_id */ 12:
                    message.talentId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockAvatarTalentRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 14; */
        if (message.avatarGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 talent_id = 12; */
        if (message.talentId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.talentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockAvatarTalentRsp
 */
export const UnlockAvatarTalentRsp = new UnlockAvatarTalentRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockedFurnitureFormulaDataNotify$Type extends MessageType<UnlockedFurnitureFormulaDataNotify> {
    constructor() {
        super("UnlockedFurnitureFormulaDataNotify", [
            { no: 14, name: "is_all", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "furniture_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockedFurnitureFormulaDataNotify>): UnlockedFurnitureFormulaDataNotify {
        const message = { isAll: false, furnitureIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockedFurnitureFormulaDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockedFurnitureFormulaDataNotify): UnlockedFurnitureFormulaDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_all */ 14:
                    message.isAll = reader.bool();
                    break;
                case /* repeated uint32 furniture_id_list */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.furnitureIdList.push(reader.uint32());
                    else
                        message.furnitureIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockedFurnitureFormulaDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_all = 14; */
        if (message.isAll !== false)
            writer.tag(14, WireType.Varint).bool(message.isAll);
        /* repeated uint32 furniture_id_list = 7; */
        if (message.furnitureIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.furnitureIdList.length; i++)
                writer.uint32(message.furnitureIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockedFurnitureFormulaDataNotify
 */
export const UnlockedFurnitureFormulaDataNotify = new UnlockedFurnitureFormulaDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockedFurnitureSuiteDataNotify$Type extends MessageType<UnlockedFurnitureSuiteDataNotify> {
    constructor() {
        super("UnlockedFurnitureSuiteDataNotify", [
            { no: 10, name: "is_all", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "furniture_suite_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockedFurnitureSuiteDataNotify>): UnlockedFurnitureSuiteDataNotify {
        const message = { isAll: false, furnitureSuiteIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockedFurnitureSuiteDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockedFurnitureSuiteDataNotify): UnlockedFurnitureSuiteDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_all */ 10:
                    message.isAll = reader.bool();
                    break;
                case /* repeated uint32 furniture_suite_id_list */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.furnitureSuiteIdList.push(reader.uint32());
                    else
                        message.furnitureSuiteIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockedFurnitureSuiteDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_all = 10; */
        if (message.isAll !== false)
            writer.tag(10, WireType.Varint).bool(message.isAll);
        /* repeated uint32 furniture_suite_id_list = 15; */
        if (message.furnitureSuiteIdList.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.furnitureSuiteIdList.length; i++)
                writer.uint32(message.furnitureSuiteIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockedFurnitureSuiteDataNotify
 */
export const UnlockedFurnitureSuiteDataNotify = new UnlockedFurnitureSuiteDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockNameCardNotify$Type extends MessageType<UnlockNameCardNotify> {
    constructor() {
        super("UnlockNameCardNotify", [
            { no: 14, name: "name_card_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockNameCardNotify>): UnlockNameCardNotify {
        const message = { nameCardId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockNameCardNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockNameCardNotify): UnlockNameCardNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 name_card_id */ 14:
                    message.nameCardId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockNameCardNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 name_card_id = 14; */
        if (message.nameCardId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.nameCardId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockNameCardNotify
 */
export const UnlockNameCardNotify = new UnlockNameCardNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockPersonalLineReq$Type extends MessageType<UnlockPersonalLineReq> {
    constructor() {
        super("UnlockPersonalLineReq", [
            { no: 8, name: "personal_line_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockPersonalLineReq>): UnlockPersonalLineReq {
        const message = { personalLineId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockPersonalLineReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockPersonalLineReq): UnlockPersonalLineReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 personal_line_id */ 8:
                    message.personalLineId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockPersonalLineReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 personal_line_id = 8; */
        if (message.personalLineId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.personalLineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockPersonalLineReq
 */
export const UnlockPersonalLineReq = new UnlockPersonalLineReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockPersonalLineRsp$Type extends MessageType<UnlockPersonalLineRsp> {
    constructor() {
        super("UnlockPersonalLineRsp", [
            { no: 7, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "personal_line_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "level", kind: "scalar", oneof: "param", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "chapter_id", kind: "scalar", oneof: "param", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockPersonalLineRsp>): UnlockPersonalLineRsp {
        const message = { retcode: 0, personalLineId: 0, param: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockPersonalLineRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockPersonalLineRsp): UnlockPersonalLineRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 7:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 personal_line_id */ 8:
                    message.personalLineId = reader.uint32();
                    break;
                case /* uint32 level */ 1:
                    message.param = {
                        oneofKind: "level",
                        level: reader.uint32()
                    };
                    break;
                case /* uint32 chapter_id */ 15:
                    message.param = {
                        oneofKind: "chapterId",
                        chapterId: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockPersonalLineRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 7; */
        if (message.retcode !== 0)
            writer.tag(7, WireType.Varint).int32(message.retcode);
        /* uint32 personal_line_id = 8; */
        if (message.personalLineId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.personalLineId);
        /* uint32 level = 1; */
        if (message.param.oneofKind === "level")
            writer.tag(1, WireType.Varint).uint32(message.param.level);
        /* uint32 chapter_id = 15; */
        if (message.param.oneofKind === "chapterId")
            writer.tag(15, WireType.Varint).uint32(message.param.chapterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockPersonalLineRsp
 */
export const UnlockPersonalLineRsp = new UnlockPersonalLineRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePlayerShowAvatarListReq$Type extends MessageType<UpdatePlayerShowAvatarListReq> {
    constructor() {
        super("UpdatePlayerShowAvatarListReq", [
            { no: 13, name: "show_avatar_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_show_avatar", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePlayerShowAvatarListReq>): UpdatePlayerShowAvatarListReq {
        const message = { showAvatarIdList: [], isShowAvatar: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePlayerShowAvatarListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePlayerShowAvatarListReq): UpdatePlayerShowAvatarListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 show_avatar_id_list */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.showAvatarIdList.push(reader.uint32());
                    else
                        message.showAvatarIdList.push(reader.uint32());
                    break;
                case /* bool is_show_avatar */ 2:
                    message.isShowAvatar = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePlayerShowAvatarListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 show_avatar_id_list = 13; */
        if (message.showAvatarIdList.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.showAvatarIdList.length; i++)
                writer.uint32(message.showAvatarIdList[i]);
            writer.join();
        }
        /* bool is_show_avatar = 2; */
        if (message.isShowAvatar !== false)
            writer.tag(2, WireType.Varint).bool(message.isShowAvatar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdatePlayerShowAvatarListReq
 */
export const UpdatePlayerShowAvatarListReq = new UpdatePlayerShowAvatarListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePlayerShowAvatarListRsp$Type extends MessageType<UpdatePlayerShowAvatarListRsp> {
    constructor() {
        super("UpdatePlayerShowAvatarListRsp", [
            { no: 2, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "show_avatar_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_show_avatar", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePlayerShowAvatarListRsp>): UpdatePlayerShowAvatarListRsp {
        const message = { retcode: 0, showAvatarIdList: [], isShowAvatar: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePlayerShowAvatarListRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePlayerShowAvatarListRsp): UpdatePlayerShowAvatarListRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 2:
                    message.retcode = reader.int32();
                    break;
                case /* repeated uint32 show_avatar_id_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.showAvatarIdList.push(reader.uint32());
                    else
                        message.showAvatarIdList.push(reader.uint32());
                    break;
                case /* bool is_show_avatar */ 8:
                    message.isShowAvatar = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePlayerShowAvatarListRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 2; */
        if (message.retcode !== 0)
            writer.tag(2, WireType.Varint).int32(message.retcode);
        /* repeated uint32 show_avatar_id_list = 1; */
        if (message.showAvatarIdList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.showAvatarIdList.length; i++)
                writer.uint32(message.showAvatarIdList[i]);
            writer.join();
        }
        /* bool is_show_avatar = 8; */
        if (message.isShowAvatar !== false)
            writer.tag(8, WireType.Varint).bool(message.isShowAvatar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdatePlayerShowAvatarListRsp
 */
export const UpdatePlayerShowAvatarListRsp = new UpdatePlayerShowAvatarListRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseItemReq$Type extends MessageType<UseItemReq> {
    constructor() {
        super("UseItemReq", [
            { no: 1, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "target_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "option_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_enter_mp_dungeon_team", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UseItemReq>): UseItemReq {
        const message = { guid: 0n, count: 0, targetGuid: 0n, optionIdx: 0, isEnterMpDungeonTeam: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseItemReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseItemReq): UseItemReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 guid */ 1:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 count */ 12:
                    message.count = reader.uint32();
                    break;
                case /* uint64 target_guid */ 14:
                    message.targetGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 option_idx */ 10:
                    message.optionIdx = reader.uint32();
                    break;
                case /* bool is_enter_mp_dungeon_team */ 3:
                    message.isEnterMpDungeonTeam = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseItemReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 guid = 1; */
        if (message.guid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.guid);
        /* uint32 count = 12; */
        if (message.count !== 0)
            writer.tag(12, WireType.Varint).uint32(message.count);
        /* uint64 target_guid = 14; */
        if (message.targetGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.targetGuid);
        /* uint32 option_idx = 10; */
        if (message.optionIdx !== 0)
            writer.tag(10, WireType.Varint).uint32(message.optionIdx);
        /* bool is_enter_mp_dungeon_team = 3; */
        if (message.isEnterMpDungeonTeam !== false)
            writer.tag(3, WireType.Varint).bool(message.isEnterMpDungeonTeam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseItemReq
 */
export const UseItemReq = new UseItemReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseItemRsp$Type extends MessageType<UseItemRsp> {
    constructor() {
        super("UseItemRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "item_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "target_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "option_idx", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseItemRsp>): UseItemRsp {
        const message = { retcode: 0, guid: 0n, itemId: 0, targetGuid: 0n, optionIdx: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseItemRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseItemRsp): UseItemRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 guid */ 8:
                    message.guid = reader.uint64().toBigInt();
                    break;
                case /* uint32 item_id */ 11:
                    message.itemId = reader.uint32();
                    break;
                case /* uint64 target_guid */ 12:
                    message.targetGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 option_idx */ 13:
                    message.optionIdx = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseItemRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint64 guid = 8; */
        if (message.guid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.guid);
        /* uint32 item_id = 11; */
        if (message.itemId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.itemId);
        /* uint64 target_guid = 12; */
        if (message.targetGuid !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.targetGuid);
        /* uint32 option_idx = 13; */
        if (message.optionIdx !== 0)
            writer.tag(13, WireType.Varint).uint32(message.optionIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseItemRsp
 */
export const UseItemRsp = new UseItemRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseWidgetCreateGadgetReq$Type extends MessageType<UseWidgetCreateGadgetReq> {
    constructor() {
        super("UseWidgetCreateGadgetReq", [
            { no: 1, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "pos", kind: "message", T: () => Vector },
            { no: 4, name: "rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<UseWidgetCreateGadgetReq>): UseWidgetCreateGadgetReq {
        const message = { materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseWidgetCreateGadgetReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseWidgetCreateGadgetReq): UseWidgetCreateGadgetReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 1:
                    message.materialId = reader.uint32();
                    break;
                case /* Vector pos */ 10:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 4:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseWidgetCreateGadgetReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 1; */
        if (message.materialId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.materialId);
        /* Vector pos = 10; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 4; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseWidgetCreateGadgetReq
 */
export const UseWidgetCreateGadgetReq = new UseWidgetCreateGadgetReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseWidgetCreateGadgetRsp$Type extends MessageType<UseWidgetCreateGadgetRsp> {
    constructor() {
        super("UseWidgetCreateGadgetRsp", [
            { no: 13, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseWidgetCreateGadgetRsp>): UseWidgetCreateGadgetRsp {
        const message = { retcode: 0, materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseWidgetCreateGadgetRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseWidgetCreateGadgetRsp): UseWidgetCreateGadgetRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 13:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 material_id */ 2:
                    message.materialId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseWidgetCreateGadgetRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 13; */
        if (message.retcode !== 0)
            writer.tag(13, WireType.Varint).int32(message.retcode);
        /* uint32 material_id = 2; */
        if (message.materialId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.materialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseWidgetCreateGadgetRsp
 */
export const UseWidgetCreateGadgetRsp = new UseWidgetCreateGadgetRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseWidgetRetractGadgetReq$Type extends MessageType<UseWidgetRetractGadgetReq> {
    constructor() {
        super("UseWidgetRetractGadgetReq", [
            { no: 7, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseWidgetRetractGadgetReq>): UseWidgetRetractGadgetReq {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseWidgetRetractGadgetReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseWidgetRetractGadgetReq): UseWidgetRetractGadgetReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 7:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseWidgetRetractGadgetReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 7; */
        if (message.entityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseWidgetRetractGadgetReq
 */
export const UseWidgetRetractGadgetReq = new UseWidgetRetractGadgetReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseWidgetRetractGadgetRsp$Type extends MessageType<UseWidgetRetractGadgetRsp> {
    constructor() {
        super("UseWidgetRetractGadgetRsp", [
            { no: 9, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseWidgetRetractGadgetRsp>): UseWidgetRetractGadgetRsp {
        const message = { retcode: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseWidgetRetractGadgetRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseWidgetRetractGadgetRsp): UseWidgetRetractGadgetRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 9:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 entity_id */ 15:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseWidgetRetractGadgetRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 9; */
        if (message.retcode !== 0)
            writer.tag(9, WireType.Varint).int32(message.retcode);
        /* uint32 entity_id = 15; */
        if (message.entityId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseWidgetRetractGadgetRsp
 */
export const UseWidgetRetractGadgetRsp = new UseWidgetRetractGadgetRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector$Type extends MessageType<Vector> {
    constructor() {
        super("Vector", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Vector>): Vector {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Vector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector): Vector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Vector
 */
export const Vector = new Vector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector3Int$Type extends MessageType<Vector3Int> {
    constructor() {
        super("Vector3Int", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Vector3Int>): Vector3Int {
        const message = { x: 0, y: 0, z: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Vector3Int>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector3Int): Vector3Int {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                case /* int32 z */ 3:
                    message.z = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector3Int, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        /* int32 z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Varint).int32(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Vector3Int
 */
export const Vector3Int = new Vector3Int$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleInfo$Type extends MessageType<VehicleInfo> {
    constructor() {
        super("VehicleInfo", [
            { no: 1, name: "member_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VehicleMember },
            { no: 2, name: "owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cur_stamina", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleInfo>): VehicleInfo {
        const message = { memberList: [], ownerUid: 0, curStamina: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleInfo): VehicleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated VehicleMember member_list */ 1:
                    message.memberList.push(VehicleMember.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 owner_uid */ 2:
                    message.ownerUid = reader.uint32();
                    break;
                case /* float cur_stamina */ 3:
                    message.curStamina = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated VehicleMember member_list = 1; */
        for (let i = 0; i < message.memberList.length; i++)
            VehicleMember.internalBinaryWrite(message.memberList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 owner_uid = 2; */
        if (message.ownerUid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.ownerUid);
        /* float cur_stamina = 3; */
        if (message.curStamina !== 0)
            writer.tag(3, WireType.Bit32).float(message.curStamina);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleInfo
 */
export const VehicleInfo = new VehicleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleInteractReq$Type extends MessageType<VehicleInteractReq> {
    constructor() {
        super("VehicleInteractReq", [
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "interact_type", kind: "enum", T: () => ["VehicleInteractType", VehicleInteractType, "VEHICLE_INTERACT_TYPE_"] },
            { no: 10, name: "pos", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleInteractReq>): VehicleInteractReq {
        const message = { entityId: 0, interactType: 0, pos: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleInteractReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleInteractReq): VehicleInteractReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* VehicleInteractType interact_type */ 3:
                    message.interactType = reader.int32();
                    break;
                case /* uint32 pos */ 10:
                    message.pos = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleInteractReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* VehicleInteractType interact_type = 3; */
        if (message.interactType !== 0)
            writer.tag(3, WireType.Varint).int32(message.interactType);
        /* uint32 pos = 10; */
        if (message.pos !== 0)
            writer.tag(10, WireType.Varint).uint32(message.pos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleInteractReq
 */
export const VehicleInteractReq = new VehicleInteractReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleInteractRsp$Type extends MessageType<VehicleInteractRsp> {
    constructor() {
        super("VehicleInteractRsp", [
            { no: 15, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "interact_type", kind: "enum", T: () => ["VehicleInteractType", VehicleInteractType, "VEHICLE_INTERACT_TYPE_"] },
            { no: 1, name: "member", kind: "message", T: () => VehicleMember }
        ]);
    }
    create(value?: PartialMessage<VehicleInteractRsp>): VehicleInteractRsp {
        const message = { retcode: 0, entityId: 0, interactType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleInteractRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleInteractRsp): VehicleInteractRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 15:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 entity_id */ 14:
                    message.entityId = reader.uint32();
                    break;
                case /* VehicleInteractType interact_type */ 3:
                    message.interactType = reader.int32();
                    break;
                case /* VehicleMember member */ 1:
                    message.member = VehicleMember.internalBinaryRead(reader, reader.uint32(), options, message.member);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleInteractRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 15; */
        if (message.retcode !== 0)
            writer.tag(15, WireType.Varint).int32(message.retcode);
        /* uint32 entity_id = 14; */
        if (message.entityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.entityId);
        /* VehicleInteractType interact_type = 3; */
        if (message.interactType !== 0)
            writer.tag(3, WireType.Varint).int32(message.interactType);
        /* VehicleMember member = 1; */
        if (message.member)
            VehicleMember.internalBinaryWrite(message.member, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleInteractRsp
 */
export const VehicleInteractRsp = new VehicleInteractRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleLocationInfo$Type extends MessageType<VehicleLocationInfo> {
    constructor() {
        super("VehicleLocationInfo", [
            { no: 1, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "owner_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "pos", kind: "message", T: () => Vector },
            { no: 5, name: "rot", kind: "message", T: () => Vector },
            { no: 6, name: "cur_hp", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "max_hp", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleLocationInfo>): VehicleLocationInfo {
        const message = { entityId: 0, gadgetId: 0, ownerUid: 0, curHp: 0, maxHp: 0, uidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleLocationInfo): VehicleLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 1:
                    message.entityId = reader.uint32();
                    break;
                case /* uint32 gadget_id */ 2:
                    message.gadgetId = reader.uint32();
                    break;
                case /* uint32 owner_uid */ 3:
                    message.ownerUid = reader.uint32();
                    break;
                case /* Vector pos */ 4:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 5:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* float cur_hp */ 6:
                    message.curHp = reader.float();
                    break;
                case /* float max_hp */ 7:
                    message.maxHp = reader.float();
                    break;
                case /* repeated uint32 uid_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uidList.push(reader.uint32());
                    else
                        message.uidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 1; */
        if (message.entityId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.entityId);
        /* uint32 gadget_id = 2; */
        if (message.gadgetId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.gadgetId);
        /* uint32 owner_uid = 3; */
        if (message.ownerUid !== 0)
            writer.tag(3, WireType.Varint).uint32(message.ownerUid);
        /* Vector pos = 4; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 5; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* float cur_hp = 6; */
        if (message.curHp !== 0)
            writer.tag(6, WireType.Bit32).float(message.curHp);
        /* float max_hp = 7; */
        if (message.maxHp !== 0)
            writer.tag(7, WireType.Bit32).float(message.maxHp);
        /* repeated uint32 uid_list = 8; */
        if (message.uidList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uidList.length; i++)
                writer.uint32(message.uidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleLocationInfo
 */
export const VehicleLocationInfo = new VehicleLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleMember$Type extends MessageType<VehicleMember> {
    constructor() {
        super("VehicleMember", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "pos", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleMember>): VehicleMember {
        const message = { uid: 0, avatarGuid: 0n, pos: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleMember>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleMember): VehicleMember {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint64 avatar_guid */ 2:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 pos */ 3:
                    message.pos = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint64 avatar_guid = 2; */
        if (message.avatarGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.avatarGuid);
        /* uint32 pos = 3; */
        if (message.pos !== 0)
            writer.tag(3, WireType.Varint).uint32(message.pos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleMember
 */
export const VehicleMember = new VehicleMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleStaminaNotify$Type extends MessageType<VehicleStaminaNotify> {
    constructor() {
        super("VehicleStaminaNotify", [
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cur_stamina", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleStaminaNotify>): VehicleStaminaNotify {
        const message = { entityId: 0, curStamina: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleStaminaNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleStaminaNotify): VehicleStaminaNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* float cur_stamina */ 4:
                    message.curStamina = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleStaminaNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* float cur_stamina = 4; */
        if (message.curStamina !== 0)
            writer.tag(4, WireType.Bit32).float(message.curStamina);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VehicleStaminaNotify
 */
export const VehicleStaminaNotify = new VehicleStaminaNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Weapon$Type extends MessageType<Weapon> {
    constructor() {
        super("Weapon", [
            { no: 1, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "exp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "affix_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<Weapon>): Weapon {
        const message = { level: 0, exp: 0, promoteLevel: 0, affixMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Weapon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Weapon): Weapon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                case /* uint32 exp */ 2:
                    message.exp = reader.uint32();
                    break;
                case /* uint32 promote_level */ 3:
                    message.promoteLevel = reader.uint32();
                    break;
                case /* map<uint32, uint32> affix_map */ 4:
                    this.binaryReadMap4(message.affixMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: Weapon["affixMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Weapon["affixMap"] | undefined, val: Weapon["affixMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Weapon.affix_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: Weapon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).uint32(message.level);
        /* uint32 exp = 2; */
        if (message.exp !== 0)
            writer.tag(2, WireType.Varint).uint32(message.exp);
        /* uint32 promote_level = 3; */
        if (message.promoteLevel !== 0)
            writer.tag(3, WireType.Varint).uint32(message.promoteLevel);
        /* map<uint32, uint32> affix_map = 4; */
        for (let k of Object.keys(message.affixMap))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.affixMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Weapon
 */
export const Weapon = new Weapon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponAwakenReq$Type extends MessageType<WeaponAwakenReq> {
    constructor() {
        super("WeaponAwakenReq", [
            { no: 9, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "item_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "affix_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<WeaponAwakenReq>): WeaponAwakenReq {
        const message = { targetWeaponGuid: 0n, itemGuid: 0n, affixLevelMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponAwakenReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponAwakenReq): WeaponAwakenReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_weapon_guid */ 9:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint64 item_guid */ 3:
                    message.itemGuid = reader.uint64().toBigInt();
                    break;
                case /* map<uint32, uint32> affix_level_map */ 2:
                    this.binaryReadMap2(message.affixLevelMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: WeaponAwakenReq["affixLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeaponAwakenReq["affixLevelMap"] | undefined, val: WeaponAwakenReq["affixLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field WeaponAwakenReq.affix_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: WeaponAwakenReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_weapon_guid = 9; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.targetWeaponGuid);
        /* uint64 item_guid = 3; */
        if (message.itemGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.itemGuid);
        /* map<uint32, uint32> affix_level_map = 2; */
        for (let k of Object.keys(message.affixLevelMap))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.affixLevelMap[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponAwakenReq
 */
export const WeaponAwakenReq = new WeaponAwakenReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponAwakenRsp$Type extends MessageType<WeaponAwakenRsp> {
    constructor() {
        super("WeaponAwakenRsp", [
            { no: 3, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "target_weapon_awaken_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "old_affix_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 14, name: "cur_affix_level_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 10, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WeaponAwakenRsp>): WeaponAwakenRsp {
        const message = { retcode: 0, targetWeaponGuid: 0n, targetWeaponAwakenLevel: 0, oldAffixLevelMap: {}, curAffixLevelMap: {}, avatarGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponAwakenRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponAwakenRsp): WeaponAwakenRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 3:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_weapon_guid */ 1:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 target_weapon_awaken_level */ 13:
                    message.targetWeaponAwakenLevel = reader.uint32();
                    break;
                case /* map<uint32, uint32> old_affix_level_map */ 7:
                    this.binaryReadMap7(message.oldAffixLevelMap, reader, options);
                    break;
                case /* map<uint32, uint32> cur_affix_level_map */ 14:
                    this.binaryReadMap14(message.curAffixLevelMap, reader, options);
                    break;
                case /* uint64 avatar_guid */ 10:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: WeaponAwakenRsp["oldAffixLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeaponAwakenRsp["oldAffixLevelMap"] | undefined, val: WeaponAwakenRsp["oldAffixLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field WeaponAwakenRsp.old_affix_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    private binaryReadMap14(map: WeaponAwakenRsp["curAffixLevelMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeaponAwakenRsp["curAffixLevelMap"] | undefined, val: WeaponAwakenRsp["curAffixLevelMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field WeaponAwakenRsp.cur_affix_level_map");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: WeaponAwakenRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 3; */
        if (message.retcode !== 0)
            writer.tag(3, WireType.Varint).int32(message.retcode);
        /* uint64 target_weapon_guid = 1; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.targetWeaponGuid);
        /* uint32 target_weapon_awaken_level = 13; */
        if (message.targetWeaponAwakenLevel !== 0)
            writer.tag(13, WireType.Varint).uint32(message.targetWeaponAwakenLevel);
        /* map<uint32, uint32> old_affix_level_map = 7; */
        for (let k of Object.keys(message.oldAffixLevelMap))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.oldAffixLevelMap[k as any]).join();
        /* map<uint32, uint32> cur_affix_level_map = 14; */
        for (let k of Object.keys(message.curAffixLevelMap))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.curAffixLevelMap[k as any]).join();
        /* uint64 avatar_guid = 10; */
        if (message.avatarGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.avatarGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponAwakenRsp
 */
export const WeaponAwakenRsp = new WeaponAwakenRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponPromoteReq$Type extends MessageType<WeaponPromoteReq> {
    constructor() {
        super("WeaponPromoteReq", [
            { no: 6, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WeaponPromoteReq>): WeaponPromoteReq {
        const message = { targetWeaponGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponPromoteReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponPromoteReq): WeaponPromoteReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_weapon_guid */ 6:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeaponPromoteReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_weapon_guid = 6; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.targetWeaponGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponPromoteReq
 */
export const WeaponPromoteReq = new WeaponPromoteReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponPromoteRsp$Type extends MessageType<WeaponPromoteRsp> {
    constructor() {
        super("WeaponPromoteRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "old_promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cur_promote_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WeaponPromoteRsp>): WeaponPromoteRsp {
        const message = { retcode: 0, targetWeaponGuid: 0n, oldPromoteLevel: 0, curPromoteLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponPromoteRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponPromoteRsp): WeaponPromoteRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_weapon_guid */ 15:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 old_promote_level */ 5:
                    message.oldPromoteLevel = reader.uint32();
                    break;
                case /* uint32 cur_promote_level */ 2:
                    message.curPromoteLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeaponPromoteRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint64 target_weapon_guid = 15; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.targetWeaponGuid);
        /* uint32 old_promote_level = 5; */
        if (message.oldPromoteLevel !== 0)
            writer.tag(5, WireType.Varint).uint32(message.oldPromoteLevel);
        /* uint32 cur_promote_level = 2; */
        if (message.curPromoteLevel !== 0)
            writer.tag(2, WireType.Varint).uint32(message.curPromoteLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponPromoteRsp
 */
export const WeaponPromoteRsp = new WeaponPromoteRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponUpgradeReq$Type extends MessageType<WeaponUpgradeReq> {
    constructor() {
        super("WeaponUpgradeReq", [
            { no: 3, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "food_weapon_guid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<WeaponUpgradeReq>): WeaponUpgradeReq {
        const message = { targetWeaponGuid: 0n, foodWeaponGuidList: [], itemParamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponUpgradeReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponUpgradeReq): WeaponUpgradeReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 target_weapon_guid */ 3:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 food_weapon_guid_list */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.foodWeaponGuidList.push(reader.uint64().toBigInt());
                    else
                        message.foodWeaponGuidList.push(reader.uint64().toBigInt());
                    break;
                case /* repeated ItemParam item_param_list */ 14:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeaponUpgradeReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 target_weapon_guid = 3; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.targetWeaponGuid);
        /* repeated uint64 food_weapon_guid_list = 8; */
        if (message.foodWeaponGuidList.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.foodWeaponGuidList.length; i++)
                writer.uint64(message.foodWeaponGuidList[i]);
            writer.join();
        }
        /* repeated ItemParam item_param_list = 14; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponUpgradeReq
 */
export const WeaponUpgradeReq = new WeaponUpgradeReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeaponUpgradeRsp$Type extends MessageType<WeaponUpgradeRsp> {
    constructor() {
        super("WeaponUpgradeRsp", [
            { no: 11, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "target_weapon_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cur_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "item_param_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ItemParam }
        ]);
    }
    create(value?: PartialMessage<WeaponUpgradeRsp>): WeaponUpgradeRsp {
        const message = { retcode: 0, targetWeaponGuid: 0n, oldLevel: 0, curLevel: 0, itemParamList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeaponUpgradeRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeaponUpgradeRsp): WeaponUpgradeRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 11:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 target_weapon_guid */ 8:
                    message.targetWeaponGuid = reader.uint64().toBigInt();
                    break;
                case /* uint32 old_level */ 4:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 cur_level */ 7:
                    message.curLevel = reader.uint32();
                    break;
                case /* repeated ItemParam item_param_list */ 2:
                    message.itemParamList.push(ItemParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeaponUpgradeRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 11; */
        if (message.retcode !== 0)
            writer.tag(11, WireType.Varint).int32(message.retcode);
        /* uint64 target_weapon_guid = 8; */
        if (message.targetWeaponGuid !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.targetWeaponGuid);
        /* uint32 old_level = 4; */
        if (message.oldLevel !== 0)
            writer.tag(4, WireType.Varint).uint32(message.oldLevel);
        /* uint32 cur_level = 7; */
        if (message.curLevel !== 0)
            writer.tag(7, WireType.Varint).uint32(message.curLevel);
        /* repeated ItemParam item_param_list = 2; */
        for (let i = 0; i < message.itemParamList.length; i++)
            ItemParam.internalBinaryWrite(message.itemParamList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeaponUpgradeRsp
 */
export const WeaponUpgradeRsp = new WeaponUpgradeRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WearEquipReq$Type extends MessageType<WearEquipReq> {
    constructor() {
        super("WearEquipReq", [
            { no: 14, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equip_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WearEquipReq>): WearEquipReq {
        const message = { avatarGuid: 0n, equipGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WearEquipReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WearEquipReq): WearEquipReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 avatar_guid */ 14:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint64 equip_guid */ 2:
                    message.equipGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WearEquipReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 avatar_guid = 14; */
        if (message.avatarGuid !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.avatarGuid);
        /* uint64 equip_guid = 2; */
        if (message.equipGuid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.equipGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WearEquipReq
 */
export const WearEquipReq = new WearEquipReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WearEquipRsp$Type extends MessageType<WearEquipRsp> {
    constructor() {
        super("WearEquipRsp", [
            { no: 6, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "avatar_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "equip_guid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<WearEquipRsp>): WearEquipRsp {
        const message = { retcode: 0, avatarGuid: 0n, equipGuid: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WearEquipRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WearEquipRsp): WearEquipRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 6:
                    message.retcode = reader.int32();
                    break;
                case /* uint64 avatar_guid */ 10:
                    message.avatarGuid = reader.uint64().toBigInt();
                    break;
                case /* uint64 equip_guid */ 5:
                    message.equipGuid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WearEquipRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 6; */
        if (message.retcode !== 0)
            writer.tag(6, WireType.Varint).int32(message.retcode);
        /* uint64 avatar_guid = 10; */
        if (message.avatarGuid !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.avatarGuid);
        /* uint64 equip_guid = 5; */
        if (message.equipGuid !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.equipGuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WearEquipRsp
 */
export const WearEquipRsp = new WearEquipRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeatherInfo$Type extends MessageType<WeatherInfo> {
    constructor() {
        super("WeatherInfo", [
            { no: 1, name: "weather_area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WeatherInfo>): WeatherInfo {
        const message = { weatherAreaId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeatherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeatherInfo): WeatherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 weather_area_id */ 1:
                    message.weatherAreaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeatherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 weather_area_id = 1; */
        if (message.weatherAreaId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.weatherAreaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeatherInfo
 */
export const WeatherInfo = new WeatherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeekendDjinnInfo$Type extends MessageType<WeekendDjinnInfo> {
    constructor() {
        super("WeekendDjinnInfo", [
            { no: 14, name: "rot", kind: "message", T: () => Vector },
            { no: 10, name: "pos", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<WeekendDjinnInfo>): WeekendDjinnInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeekendDjinnInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeekendDjinnInfo): WeekendDjinnInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector rot */ 14:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                case /* Vector pos */ 10:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeekendDjinnInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector rot = 14; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* Vector pos = 10; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeekendDjinnInfo
 */
export const WeekendDjinnInfo = new WeekendDjinnInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeeklyBossResinDiscountInfo$Type extends MessageType<WeeklyBossResinDiscountInfo> {
    constructor() {
        super("WeeklyBossResinDiscountInfo", [
            { no: 1, name: "discount_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "discount_num_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "resin_cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "original_resin_cost", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WeeklyBossResinDiscountInfo>): WeeklyBossResinDiscountInfo {
        const message = { discountNum: 0, discountNumLimit: 0, resinCost: 0, originalResinCost: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WeeklyBossResinDiscountInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeeklyBossResinDiscountInfo): WeeklyBossResinDiscountInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 discount_num */ 1:
                    message.discountNum = reader.uint32();
                    break;
                case /* uint32 discount_num_limit */ 2:
                    message.discountNumLimit = reader.uint32();
                    break;
                case /* uint32 resin_cost */ 3:
                    message.resinCost = reader.uint32();
                    break;
                case /* uint32 original_resin_cost */ 4:
                    message.originalResinCost = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeeklyBossResinDiscountInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 discount_num = 1; */
        if (message.discountNum !== 0)
            writer.tag(1, WireType.Varint).uint32(message.discountNum);
        /* uint32 discount_num_limit = 2; */
        if (message.discountNumLimit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.discountNumLimit);
        /* uint32 resin_cost = 3; */
        if (message.resinCost !== 0)
            writer.tag(3, WireType.Varint).uint32(message.resinCost);
        /* uint32 original_resin_cost = 4; */
        if (message.originalResinCost !== 0)
            writer.tag(4, WireType.Varint).uint32(message.originalResinCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeeklyBossResinDiscountInfo
 */
export const WeeklyBossResinDiscountInfo = new WeeklyBossResinDiscountInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetActiveChangeNotify$Type extends MessageType<WidgetActiveChangeNotify> {
    constructor() {
        super("WidgetActiveChangeNotify", [
            { no: 4, name: "widget_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetSlotData }
        ]);
    }
    create(value?: PartialMessage<WidgetActiveChangeNotify>): WidgetActiveChangeNotify {
        const message = { widgetDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetActiveChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetActiveChangeNotify): WidgetActiveChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated WidgetSlotData widget_data_list */ 4:
                    message.widgetDataList.push(WidgetSlotData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetActiveChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated WidgetSlotData widget_data_list = 4; */
        for (let i = 0; i < message.widgetDataList.length; i++)
            WidgetSlotData.internalBinaryWrite(message.widgetDataList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetActiveChangeNotify
 */
export const WidgetActiveChangeNotify = new WidgetActiveChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetCameraInfo$Type extends MessageType<WidgetCameraInfo> {
    constructor() {
        super("WidgetCameraInfo", [
            { no: 14, name: "target_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetCameraInfo>): WidgetCameraInfo {
        const message = { targetEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetCameraInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetCameraInfo): WidgetCameraInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 target_entity_id */ 14:
                    message.targetEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetCameraInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 target_entity_id = 14; */
        if (message.targetEntityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.targetEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetCameraInfo
 */
export const WidgetCameraInfo = new WidgetCameraInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetCoolDownData$Type extends MessageType<WidgetCoolDownData> {
    constructor() {
        super("WidgetCoolDownData", [
            { no: 2, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "cool_down_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetCoolDownData>): WidgetCoolDownData {
        const message = { id: 0, coolDownTime: 0n, isSuccess: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetCoolDownData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetCoolDownData): WidgetCoolDownData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 2:
                    message.id = reader.uint32();
                    break;
                case /* uint64 cool_down_time */ 9:
                    message.coolDownTime = reader.uint64().toBigInt();
                    break;
                case /* bool is_success */ 10:
                    message.isSuccess = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetCoolDownData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).uint32(message.id);
        /* uint64 cool_down_time = 9; */
        if (message.coolDownTime !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.coolDownTime);
        /* bool is_success = 10; */
        if (message.isSuccess !== false)
            writer.tag(10, WireType.Varint).bool(message.isSuccess);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetCoolDownData
 */
export const WidgetCoolDownData = new WidgetCoolDownData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetCoolDownNotify$Type extends MessageType<WidgetCoolDownNotify> {
    constructor() {
        super("WidgetCoolDownNotify", [
            { no: 4, name: "group_cool_down_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetCoolDownData },
            { no: 8, name: "normal_cool_down_data_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetCoolDownData }
        ]);
    }
    create(value?: PartialMessage<WidgetCoolDownNotify>): WidgetCoolDownNotify {
        const message = { groupCoolDownDataList: [], normalCoolDownDataList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetCoolDownNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetCoolDownNotify): WidgetCoolDownNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated WidgetCoolDownData group_cool_down_data_list */ 4:
                    message.groupCoolDownDataList.push(WidgetCoolDownData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated WidgetCoolDownData normal_cool_down_data_list */ 8:
                    message.normalCoolDownDataList.push(WidgetCoolDownData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetCoolDownNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated WidgetCoolDownData group_cool_down_data_list = 4; */
        for (let i = 0; i < message.groupCoolDownDataList.length; i++)
            WidgetCoolDownData.internalBinaryWrite(message.groupCoolDownDataList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated WidgetCoolDownData normal_cool_down_data_list = 8; */
        for (let i = 0; i < message.normalCoolDownDataList.length; i++)
            WidgetCoolDownData.internalBinaryWrite(message.normalCoolDownDataList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetCoolDownNotify
 */
export const WidgetCoolDownNotify = new WidgetCoolDownNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetCreateLocationInfo$Type extends MessageType<WidgetCreateLocationInfo> {
    constructor() {
        super("WidgetCreateLocationInfo", [
            { no: 14, name: "pos", kind: "message", T: () => Vector },
            { no: 4, name: "rot", kind: "message", T: () => Vector }
        ]);
    }
    create(value?: PartialMessage<WidgetCreateLocationInfo>): WidgetCreateLocationInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetCreateLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetCreateLocationInfo): WidgetCreateLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Vector pos */ 14:
                    message.pos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* Vector rot */ 4:
                    message.rot = Vector.internalBinaryRead(reader, reader.uint32(), options, message.rot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetCreateLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Vector pos = 14; */
        if (message.pos)
            Vector.internalBinaryWrite(message.pos, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* Vector rot = 4; */
        if (message.rot)
            Vector.internalBinaryWrite(message.rot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetCreateLocationInfo
 */
export const WidgetCreateLocationInfo = new WidgetCreateLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetCreatorInfo$Type extends MessageType<WidgetCreatorInfo> {
    constructor() {
        super("WidgetCreatorInfo", [
            { no: 11, name: "op_type", kind: "enum", T: () => ["WidgetCreatorOpType", WidgetCreatorOpType, "WIDGET_CREATOR_OP_TYPE_"] },
            { no: 8, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "location_info", kind: "message", T: () => WidgetCreateLocationInfo }
        ]);
    }
    create(value?: PartialMessage<WidgetCreatorInfo>): WidgetCreatorInfo {
        const message = { opType: 0, entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetCreatorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetCreatorInfo): WidgetCreatorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetCreatorOpType op_type */ 11:
                    message.opType = reader.int32();
                    break;
                case /* uint32 entity_id */ 8:
                    message.entityId = reader.uint32();
                    break;
                case /* WidgetCreateLocationInfo location_info */ 10:
                    message.locationInfo = WidgetCreateLocationInfo.internalBinaryRead(reader, reader.uint32(), options, message.locationInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetCreatorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetCreatorOpType op_type = 11; */
        if (message.opType !== 0)
            writer.tag(11, WireType.Varint).int32(message.opType);
        /* uint32 entity_id = 8; */
        if (message.entityId !== 0)
            writer.tag(8, WireType.Varint).uint32(message.entityId);
        /* WidgetCreateLocationInfo location_info = 10; */
        if (message.locationInfo)
            WidgetCreateLocationInfo.internalBinaryWrite(message.locationInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetCreatorInfo
 */
export const WidgetCreatorInfo = new WidgetCreatorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetDoBagReq$Type extends MessageType<WidgetDoBagReq> {
    constructor() {
        super("WidgetDoBagReq", [
            { no: 15, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 351, name: "location_info", kind: "message", oneof: "opInfo", T: () => WidgetCreateLocationInfo },
            { no: 46, name: "widget_creator_info", kind: "message", oneof: "opInfo", T: () => WidgetCreatorInfo }
        ]);
    }
    create(value?: PartialMessage<WidgetDoBagReq>): WidgetDoBagReq {
        const message = { materialId: 0, opInfo: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetDoBagReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetDoBagReq): WidgetDoBagReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 15:
                    message.materialId = reader.uint32();
                    break;
                case /* WidgetCreateLocationInfo location_info */ 351:
                    message.opInfo = {
                        oneofKind: "locationInfo",
                        locationInfo: WidgetCreateLocationInfo.internalBinaryRead(reader, reader.uint32(), options, (message.opInfo as any).locationInfo)
                    };
                    break;
                case /* WidgetCreatorInfo widget_creator_info */ 46:
                    message.opInfo = {
                        oneofKind: "widgetCreatorInfo",
                        widgetCreatorInfo: WidgetCreatorInfo.internalBinaryRead(reader, reader.uint32(), options, (message.opInfo as any).widgetCreatorInfo)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetDoBagReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 15; */
        if (message.materialId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.materialId);
        /* WidgetCreateLocationInfo location_info = 351; */
        if (message.opInfo.oneofKind === "locationInfo")
            WidgetCreateLocationInfo.internalBinaryWrite(message.opInfo.locationInfo, writer.tag(351, WireType.LengthDelimited).fork(), options).join();
        /* WidgetCreatorInfo widget_creator_info = 46; */
        if (message.opInfo.oneofKind === "widgetCreatorInfo")
            WidgetCreatorInfo.internalBinaryWrite(message.opInfo.widgetCreatorInfo, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetDoBagReq
 */
export const WidgetDoBagReq = new WidgetDoBagReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetDoBagRsp$Type extends MessageType<WidgetDoBagRsp> {
    constructor() {
        super("WidgetDoBagRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetDoBagRsp>): WidgetDoBagRsp {
        const message = { retcode: 0, materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetDoBagRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetDoBagRsp): WidgetDoBagRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 material_id */ 9:
                    message.materialId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetDoBagRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint32 material_id = 9; */
        if (message.materialId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.materialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetDoBagRsp
 */
export const WidgetDoBagRsp = new WidgetDoBagRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetGadgetAllDataNotify$Type extends MessageType<WidgetGadgetAllDataNotify> {
    constructor() {
        super("WidgetGadgetAllDataNotify", [
            { no: 8, name: "widget_gadget_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WidgetGadgetData }
        ]);
    }
    create(value?: PartialMessage<WidgetGadgetAllDataNotify>): WidgetGadgetAllDataNotify {
        const message = { widgetGadgetData: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetGadgetAllDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetGadgetAllDataNotify): WidgetGadgetAllDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated WidgetGadgetData widget_gadget_data */ 8:
                    message.widgetGadgetData.push(WidgetGadgetData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetGadgetAllDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated WidgetGadgetData widget_gadget_data = 8; */
        for (let i = 0; i < message.widgetGadgetData.length; i++)
            WidgetGadgetData.internalBinaryWrite(message.widgetGadgetData[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetGadgetAllDataNotify
 */
export const WidgetGadgetAllDataNotify = new WidgetGadgetAllDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetGadgetData$Type extends MessageType<WidgetGadgetData> {
    constructor() {
        super("WidgetGadgetData", [
            { no: 13, name: "gadget_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gadget_entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetGadgetData>): WidgetGadgetData {
        const message = { gadgetId: 0, gadgetEntityIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetGadgetData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetGadgetData): WidgetGadgetData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_id */ 13:
                    message.gadgetId = reader.uint32();
                    break;
                case /* repeated uint32 gadget_entity_id_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.gadgetEntityIdList.push(reader.uint32());
                    else
                        message.gadgetEntityIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetGadgetData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_id = 13; */
        if (message.gadgetId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.gadgetId);
        /* repeated uint32 gadget_entity_id_list = 5; */
        if (message.gadgetEntityIdList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.gadgetEntityIdList.length; i++)
                writer.uint32(message.gadgetEntityIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetGadgetData
 */
export const WidgetGadgetData = new WidgetGadgetData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetGadgetDataNotify$Type extends MessageType<WidgetGadgetDataNotify> {
    constructor() {
        super("WidgetGadgetDataNotify", [
            { no: 13, name: "widget_gadget_data", kind: "message", T: () => WidgetGadgetData }
        ]);
    }
    create(value?: PartialMessage<WidgetGadgetDataNotify>): WidgetGadgetDataNotify {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetGadgetDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetGadgetDataNotify): WidgetGadgetDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetGadgetData widget_gadget_data */ 13:
                    message.widgetGadgetData = WidgetGadgetData.internalBinaryRead(reader, reader.uint32(), options, message.widgetGadgetData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetGadgetDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetGadgetData widget_gadget_data = 13; */
        if (message.widgetGadgetData)
            WidgetGadgetData.internalBinaryWrite(message.widgetGadgetData, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetGadgetDataNotify
 */
export const WidgetGadgetDataNotify = new WidgetGadgetDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetGadgetDestroyNotify$Type extends MessageType<WidgetGadgetDestroyNotify> {
    constructor() {
        super("WidgetGadgetDestroyNotify", [
            { no: 7, name: "entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetGadgetDestroyNotify>): WidgetGadgetDestroyNotify {
        const message = { entityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetGadgetDestroyNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetGadgetDestroyNotify): WidgetGadgetDestroyNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 entity_id */ 7:
                    message.entityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetGadgetDestroyNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 entity_id = 7; */
        if (message.entityId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetGadgetDestroyNotify
 */
export const WidgetGadgetDestroyNotify = new WidgetGadgetDestroyNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetReportReq$Type extends MessageType<WidgetReportReq> {
    constructor() {
        super("WidgetReportReq", [
            { no: 7, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_clear_hint", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_client_collect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "ICBFJGOLNOL", kind: "scalar", jsonName: "ICBFJGOLNOL", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetReportReq>): WidgetReportReq {
        const message = { materialId: 0, isClearHint: false, isClientCollect: false, iCBFJGOLNOL: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetReportReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetReportReq): WidgetReportReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 7:
                    message.materialId = reader.uint32();
                    break;
                case /* bool is_clear_hint */ 13:
                    message.isClearHint = reader.bool();
                    break;
                case /* bool is_client_collect */ 9:
                    message.isClientCollect = reader.bool();
                    break;
                case /* bool ICBFJGOLNOL = 1 [json_name = "ICBFJGOLNOL"];*/ 1:
                    message.iCBFJGOLNOL = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetReportReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 7; */
        if (message.materialId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.materialId);
        /* bool is_clear_hint = 13; */
        if (message.isClearHint !== false)
            writer.tag(13, WireType.Varint).bool(message.isClearHint);
        /* bool is_client_collect = 9; */
        if (message.isClientCollect !== false)
            writer.tag(9, WireType.Varint).bool(message.isClientCollect);
        /* bool ICBFJGOLNOL = 1 [json_name = "ICBFJGOLNOL"]; */
        if (message.iCBFJGOLNOL !== false)
            writer.tag(1, WireType.Varint).bool(message.iCBFJGOLNOL);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetReportReq
 */
export const WidgetReportReq = new WidgetReportReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetReportRsp$Type extends MessageType<WidgetReportRsp> {
    constructor() {
        super("WidgetReportRsp", [
            { no: 12, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetReportRsp>): WidgetReportRsp {
        const message = { retcode: 0, materialId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetReportRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetReportRsp): WidgetReportRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 12:
                    message.retcode = reader.int32();
                    break;
                case /* uint32 material_id */ 7:
                    message.materialId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetReportRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 12; */
        if (message.retcode !== 0)
            writer.tag(12, WireType.Varint).int32(message.retcode);
        /* uint32 material_id = 7; */
        if (message.materialId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.materialId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetReportRsp
 */
export const WidgetReportRsp = new WidgetReportRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetSlotChangeNotify$Type extends MessageType<WidgetSlotChangeNotify> {
    constructor() {
        super("WidgetSlotChangeNotify", [
            { no: 6, name: "op", kind: "enum", T: () => ["WidgetSlotOp", WidgetSlotOp, "WIDGET_SLOT_OP_"] },
            { no: 8, name: "slot", kind: "message", T: () => WidgetSlotData }
        ]);
    }
    create(value?: PartialMessage<WidgetSlotChangeNotify>): WidgetSlotChangeNotify {
        const message = { op: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetSlotChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetSlotChangeNotify): WidgetSlotChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetSlotOp op */ 6:
                    message.op = reader.int32();
                    break;
                case /* WidgetSlotData slot */ 8:
                    message.slot = WidgetSlotData.internalBinaryRead(reader, reader.uint32(), options, message.slot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetSlotChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetSlotOp op = 6; */
        if (message.op !== 0)
            writer.tag(6, WireType.Varint).int32(message.op);
        /* WidgetSlotData slot = 8; */
        if (message.slot)
            WidgetSlotData.internalBinaryWrite(message.slot, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetSlotChangeNotify
 */
export const WidgetSlotChangeNotify = new WidgetSlotChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetSlotData$Type extends MessageType<WidgetSlotData> {
    constructor() {
        super("WidgetSlotData", [
            { no: 3, name: "tag", kind: "enum", T: () => ["WidgetSlotTag", WidgetSlotTag, "WIDGET_SLOT_TAG_"] },
            { no: 10, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "cd_over_time", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetSlotData>): WidgetSlotData {
        const message = { tag: 0, materialId: 0, cdOverTime: 0, isActive: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetSlotData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetSlotData): WidgetSlotData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WidgetSlotTag tag */ 3:
                    message.tag = reader.int32();
                    break;
                case /* uint32 material_id */ 10:
                    message.materialId = reader.uint32();
                    break;
                case /* uint32 cd_over_time */ 11:
                    message.cdOverTime = reader.uint32();
                    break;
                case /* bool is_active */ 5:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetSlotData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WidgetSlotTag tag = 3; */
        if (message.tag !== 0)
            writer.tag(3, WireType.Varint).int32(message.tag);
        /* uint32 material_id = 10; */
        if (message.materialId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.materialId);
        /* uint32 cd_over_time = 11; */
        if (message.cdOverTime !== 0)
            writer.tag(11, WireType.Varint).uint32(message.cdOverTime);
        /* bool is_active = 5; */
        if (message.isActive !== false)
            writer.tag(5, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetSlotData
 */
export const WidgetSlotData = new WidgetSlotData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetSlotTagComparer$Type extends MessageType<WidgetSlotTagComparer> {
    constructor() {
        super("WidgetSlotTagComparer", []);
    }
    create(value?: PartialMessage<WidgetSlotTagComparer>): WidgetSlotTagComparer {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetSlotTagComparer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetSlotTagComparer): WidgetSlotTagComparer {
        return target ?? this.create();
    }
    internalBinaryWrite(message: WidgetSlotTagComparer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetSlotTagComparer
 */
export const WidgetSlotTagComparer = new WidgetSlotTagComparer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetThunderBirdFeatherInfo$Type extends MessageType<WidgetThunderBirdFeatherInfo> {
    constructor() {
        super("WidgetThunderBirdFeatherInfo", [
            { no: 12, name: "entity_id_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetThunderBirdFeatherInfo>): WidgetThunderBirdFeatherInfo {
        const message = { entityIdList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetThunderBirdFeatherInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetThunderBirdFeatherInfo): WidgetThunderBirdFeatherInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 entity_id_list */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.entityIdList.push(reader.uint32());
                    else
                        message.entityIdList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetThunderBirdFeatherInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 entity_id_list = 12; */
        if (message.entityIdList.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.entityIdList.length; i++)
                writer.uint32(message.entityIdList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetThunderBirdFeatherInfo
 */
export const WidgetThunderBirdFeatherInfo = new WidgetThunderBirdFeatherInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidgetUseAttachAbilityGroupChangeNotify$Type extends MessageType<WidgetUseAttachAbilityGroupChangeNotify> {
    constructor() {
        super("WidgetUseAttachAbilityGroupChangeNotify", [
            { no: 4, name: "material_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_attach", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WidgetUseAttachAbilityGroupChangeNotify>): WidgetUseAttachAbilityGroupChangeNotify {
        const message = { materialId: 0, isAttach: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WidgetUseAttachAbilityGroupChangeNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WidgetUseAttachAbilityGroupChangeNotify): WidgetUseAttachAbilityGroupChangeNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 material_id */ 4:
                    message.materialId = reader.uint32();
                    break;
                case /* bool is_attach */ 11:
                    message.isAttach = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WidgetUseAttachAbilityGroupChangeNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 material_id = 4; */
        if (message.materialId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.materialId);
        /* bool is_attach = 11; */
        if (message.isAttach !== false)
            writer.tag(11, WireType.Varint).bool(message.isAttach);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WidgetUseAttachAbilityGroupChangeNotify
 */
export const WidgetUseAttachAbilityGroupChangeNotify = new WidgetUseAttachAbilityGroupChangeNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindSeedClientNotify$Type extends MessageType<WindSeedClientNotify> {
    constructor() {
        super("WindSeedClientNotify", [
            { no: 1, name: "add_wind_bullet_notify", kind: "message", oneof: "notify", T: () => WindSeedClientNotify_AddWindBulletNotify },
            { no: 9, name: "refresh_notify", kind: "message", oneof: "notify", T: () => WindSeedClientNotify_RefreshNotify },
            { no: 15, name: "area_notify", kind: "message", oneof: "notify", T: () => WindSeedClientNotify_AreaNotify }
        ]);
    }
    create(value?: PartialMessage<WindSeedClientNotify>): WindSeedClientNotify {
        const message = { notify: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WindSeedClientNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindSeedClientNotify): WindSeedClientNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* WindSeedClientNotify.AddWindBulletNotify add_wind_bullet_notify */ 1:
                    message.notify = {
                        oneofKind: "addWindBulletNotify",
                        addWindBulletNotify: WindSeedClientNotify_AddWindBulletNotify.internalBinaryRead(reader, reader.uint32(), options, (message.notify as any).addWindBulletNotify)
                    };
                    break;
                case /* WindSeedClientNotify.RefreshNotify refresh_notify */ 9:
                    message.notify = {
                        oneofKind: "refreshNotify",
                        refreshNotify: WindSeedClientNotify_RefreshNotify.internalBinaryRead(reader, reader.uint32(), options, (message.notify as any).refreshNotify)
                    };
                    break;
                case /* WindSeedClientNotify.AreaNotify area_notify */ 15:
                    message.notify = {
                        oneofKind: "areaNotify",
                        areaNotify: WindSeedClientNotify_AreaNotify.internalBinaryRead(reader, reader.uint32(), options, (message.notify as any).areaNotify)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindSeedClientNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* WindSeedClientNotify.AddWindBulletNotify add_wind_bullet_notify = 1; */
        if (message.notify.oneofKind === "addWindBulletNotify")
            WindSeedClientNotify_AddWindBulletNotify.internalBinaryWrite(message.notify.addWindBulletNotify, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* WindSeedClientNotify.RefreshNotify refresh_notify = 9; */
        if (message.notify.oneofKind === "refreshNotify")
            WindSeedClientNotify_RefreshNotify.internalBinaryWrite(message.notify.refreshNotify, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* WindSeedClientNotify.AreaNotify area_notify = 15; */
        if (message.notify.oneofKind === "areaNotify")
            WindSeedClientNotify_AreaNotify.internalBinaryWrite(message.notify.areaNotify, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WindSeedClientNotify
 */
export const WindSeedClientNotify = new WindSeedClientNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindSeedClientNotify_RefreshNotify$Type extends MessageType<WindSeedClientNotify_RefreshNotify> {
    constructor() {
        super("WindSeedClientNotify.RefreshNotify", [
            { no: 14, name: "refresh_num", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WindSeedClientNotify_RefreshNotify>): WindSeedClientNotify_RefreshNotify {
        const message = { refreshNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WindSeedClientNotify_RefreshNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindSeedClientNotify_RefreshNotify): WindSeedClientNotify_RefreshNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 refresh_num */ 14:
                    message.refreshNum = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindSeedClientNotify_RefreshNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 refresh_num = 14; */
        if (message.refreshNum !== 0)
            writer.tag(14, WireType.Varint).uint32(message.refreshNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WindSeedClientNotify.RefreshNotify
 */
export const WindSeedClientNotify_RefreshNotify = new WindSeedClientNotify_RefreshNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindSeedClientNotify_AddWindBulletNotify$Type extends MessageType<WindSeedClientNotify_AddWindBulletNotify> {
    constructor() {
        super("WindSeedClientNotify.AddWindBulletNotify", [
            { no: 15, name: "seed_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "seed_pos", kind: "message", T: () => Vector },
            { no: 14, name: "catch_player_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WindSeedClientNotify_AddWindBulletNotify>): WindSeedClientNotify_AddWindBulletNotify {
        const message = { seedEntityId: 0, catchPlayerUid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WindSeedClientNotify_AddWindBulletNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindSeedClientNotify_AddWindBulletNotify): WindSeedClientNotify_AddWindBulletNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 seed_entity_id */ 15:
                    message.seedEntityId = reader.uint32();
                    break;
                case /* Vector seed_pos */ 13:
                    message.seedPos = Vector.internalBinaryRead(reader, reader.uint32(), options, message.seedPos);
                    break;
                case /* uint32 catch_player_uid */ 14:
                    message.catchPlayerUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindSeedClientNotify_AddWindBulletNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 seed_entity_id = 15; */
        if (message.seedEntityId !== 0)
            writer.tag(15, WireType.Varint).uint32(message.seedEntityId);
        /* Vector seed_pos = 13; */
        if (message.seedPos)
            Vector.internalBinaryWrite(message.seedPos, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 catch_player_uid = 14; */
        if (message.catchPlayerUid !== 0)
            writer.tag(14, WireType.Varint).uint32(message.catchPlayerUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WindSeedClientNotify.AddWindBulletNotify
 */
export const WindSeedClientNotify_AddWindBulletNotify = new WindSeedClientNotify_AddWindBulletNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindSeedClientNotify_AreaNotify$Type extends MessageType<WindSeedClientNotify_AreaNotify> {
    constructor() {
        super("WindSeedClientNotify.AreaNotify", [
            { no: 1, name: "area_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "area_code", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "area_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WindSeedClientNotify_AreaNotify>): WindSeedClientNotify_AreaNotify {
        const message = { areaId: 0, areaCode: new Uint8Array(0), areaType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WindSeedClientNotify_AreaNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindSeedClientNotify_AreaNotify): WindSeedClientNotify_AreaNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 area_id */ 1:
                    message.areaId = reader.uint32();
                    break;
                case /* bytes area_code */ 4:
                    message.areaCode = reader.bytes();
                    break;
                case /* uint32 area_type */ 8:
                    message.areaType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindSeedClientNotify_AreaNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 area_id = 1; */
        if (message.areaId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.areaId);
        /* bytes area_code = 4; */
        if (message.areaCode.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.areaCode);
        /* uint32 area_type = 8; */
        if (message.areaType !== 0)
            writer.tag(8, WireType.Varint).uint32(message.areaType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WindSeedClientNotify.AreaNotify
 */
export const WindSeedClientNotify_AreaNotify = new WindSeedClientNotify_AreaNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorktopInfo$Type extends MessageType<WorktopInfo> {
    constructor() {
        super("WorktopInfo", [
            { no: 1, name: "option_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_guest_can_operate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorktopInfo>): WorktopInfo {
        const message = { optionList: [], isGuestCanOperate: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorktopInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorktopInfo): WorktopInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 option_list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.optionList.push(reader.uint32());
                    else
                        message.optionList.push(reader.uint32());
                    break;
                case /* bool is_guest_can_operate */ 2:
                    message.isGuestCanOperate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorktopInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 option_list = 1; */
        if (message.optionList.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.optionList.length; i++)
                writer.uint32(message.optionList[i]);
            writer.join();
        }
        /* bool is_guest_can_operate = 2; */
        if (message.isGuestCanOperate !== false)
            writer.tag(2, WireType.Varint).bool(message.isGuestCanOperate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorktopInfo
 */
export const WorktopInfo = new WorktopInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorktopOptionNotify$Type extends MessageType<WorktopOptionNotify> {
    constructor() {
        super("WorktopOptionNotify", [
            { no: 12, name: "gadget_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "option_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorktopOptionNotify>): WorktopOptionNotify {
        const message = { gadgetEntityId: 0, optionList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorktopOptionNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorktopOptionNotify): WorktopOptionNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 gadget_entity_id */ 12:
                    message.gadgetEntityId = reader.uint32();
                    break;
                case /* repeated uint32 option_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.optionList.push(reader.uint32());
                    else
                        message.optionList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorktopOptionNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 gadget_entity_id = 12; */
        if (message.gadgetEntityId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.gadgetEntityId);
        /* repeated uint32 option_list = 5; */
        if (message.optionList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.optionList.length; i++)
                writer.uint32(message.optionList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorktopOptionNotify
 */
export const WorktopOptionNotify = new WorktopOptionNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldDataNotify$Type extends MessageType<WorldDataNotify> {
    constructor() {
        super("WorldDataNotify", [
            { no: 3, name: "world_prop_map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => PropValue } }
        ]);
    }
    create(value?: PartialMessage<WorldDataNotify>): WorldDataNotify {
        const message = { worldPropMap: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldDataNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldDataNotify): WorldDataNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, PropValue> world_prop_map */ 3:
                    this.binaryReadMap3(message.worldPropMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: WorldDataNotify["worldPropMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WorldDataNotify["worldPropMap"] | undefined, val: WorldDataNotify["worldPropMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = PropValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field WorldDataNotify.world_prop_map");
            }
        }
        map[key ?? 0] = val ?? PropValue.create();
    }
    internalBinaryWrite(message: WorldDataNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, PropValue> world_prop_map = 3; */
        for (let k of Object.keys(message.worldPropMap)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            PropValue.internalBinaryWrite(message.worldPropMap[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldDataNotify
 */
export const WorldDataNotify = new WorldDataNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerDieNotify$Type extends MessageType<WorldPlayerDieNotify> {
    constructor() {
        super("WorldPlayerDieNotify", [
            { no: 10, name: "monster_id", kind: "scalar", oneof: "entity", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "gadget_id", kind: "scalar", oneof: "entity", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "die_type", kind: "enum", T: () => ["PlayerDieType", PlayerDieType, "PLAYER_DIE_TYPE_"] },
            { no: 14, name: "murderer_entity_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorldPlayerDieNotify>): WorldPlayerDieNotify {
        const message = { entity: { oneofKind: undefined }, dieType: 0, murdererEntityId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerDieNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerDieNotify): WorldPlayerDieNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 monster_id */ 10:
                    message.entity = {
                        oneofKind: "monsterId",
                        monsterId: reader.uint32()
                    };
                    break;
                case /* uint32 gadget_id */ 11:
                    message.entity = {
                        oneofKind: "gadgetId",
                        gadgetId: reader.uint32()
                    };
                    break;
                case /* PlayerDieType die_type */ 9:
                    message.dieType = reader.int32();
                    break;
                case /* uint32 murderer_entity_id */ 14:
                    message.murdererEntityId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldPlayerDieNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 monster_id = 10; */
        if (message.entity.oneofKind === "monsterId")
            writer.tag(10, WireType.Varint).uint32(message.entity.monsterId);
        /* uint32 gadget_id = 11; */
        if (message.entity.oneofKind === "gadgetId")
            writer.tag(11, WireType.Varint).uint32(message.entity.gadgetId);
        /* PlayerDieType die_type = 9; */
        if (message.dieType !== 0)
            writer.tag(9, WireType.Varint).int32(message.dieType);
        /* uint32 murderer_entity_id = 14; */
        if (message.murdererEntityId !== 0)
            writer.tag(14, WireType.Varint).uint32(message.murdererEntityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerDieNotify
 */
export const WorldPlayerDieNotify = new WorldPlayerDieNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerInfoNotify$Type extends MessageType<WorldPlayerInfoNotify> {
    constructor() {
        super("WorldPlayerInfoNotify", [
            { no: 6, name: "player_info_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OnlinePlayerInfo },
            { no: 5, name: "player_uid_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorldPlayerInfoNotify>): WorldPlayerInfoNotify {
        const message = { playerInfoList: [], playerUidList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerInfoNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerInfoNotify): WorldPlayerInfoNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated OnlinePlayerInfo player_info_list */ 6:
                    message.playerInfoList.push(OnlinePlayerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 player_uid_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.playerUidList.push(reader.uint32());
                    else
                        message.playerUidList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldPlayerInfoNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated OnlinePlayerInfo player_info_list = 6; */
        for (let i = 0; i < message.playerInfoList.length; i++)
            OnlinePlayerInfo.internalBinaryWrite(message.playerInfoList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 player_uid_list = 5; */
        if (message.playerUidList.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.playerUidList.length; i++)
                writer.uint32(message.playerUidList[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerInfoNotify
 */
export const WorldPlayerInfoNotify = new WorldPlayerInfoNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerLocationNotify$Type extends MessageType<WorldPlayerLocationNotify> {
    constructor() {
        super("WorldPlayerLocationNotify", [
            { no: 6, name: "player_loc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayerLocationInfo },
            { no: 15, name: "player_world_loc_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayerWorldLocationInfo }
        ]);
    }
    create(value?: PartialMessage<WorldPlayerLocationNotify>): WorldPlayerLocationNotify {
        const message = { playerLocList: [], playerWorldLocList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerLocationNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerLocationNotify): WorldPlayerLocationNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PlayerLocationInfo player_loc_list */ 6:
                    message.playerLocList.push(PlayerLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated PlayerWorldLocationInfo player_world_loc_list */ 15:
                    message.playerWorldLocList.push(PlayerWorldLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldPlayerLocationNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PlayerLocationInfo player_loc_list = 6; */
        for (let i = 0; i < message.playerLocList.length; i++)
            PlayerLocationInfo.internalBinaryWrite(message.playerLocList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated PlayerWorldLocationInfo player_world_loc_list = 15; */
        for (let i = 0; i < message.playerWorldLocList.length; i++)
            PlayerWorldLocationInfo.internalBinaryWrite(message.playerWorldLocList[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerLocationNotify
 */
export const WorldPlayerLocationNotify = new WorldPlayerLocationNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerReviveReq$Type extends MessageType<WorldPlayerReviveReq> {
    constructor() {
        super("WorldPlayerReviveReq", []);
    }
    create(value?: PartialMessage<WorldPlayerReviveReq>): WorldPlayerReviveReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerReviveReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerReviveReq): WorldPlayerReviveReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: WorldPlayerReviveReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerReviveReq
 */
export const WorldPlayerReviveReq = new WorldPlayerReviveReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerReviveRsp$Type extends MessageType<WorldPlayerReviveRsp> {
    constructor() {
        super("WorldPlayerReviveRsp", [
            { no: 8, name: "retcode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorldPlayerReviveRsp>): WorldPlayerReviveRsp {
        const message = { retcode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerReviveRsp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerReviveRsp): WorldPlayerReviveRsp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 retcode */ 8:
                    message.retcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldPlayerReviveRsp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 retcode = 8; */
        if (message.retcode !== 0)
            writer.tag(8, WireType.Varint).int32(message.retcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerReviveRsp
 */
export const WorldPlayerReviveRsp = new WorldPlayerReviveRsp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldPlayerRTTNotify$Type extends MessageType<WorldPlayerRTTNotify> {
    constructor() {
        super("WorldPlayerRTTNotify", [
            { no: 14, name: "player_rtt_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PlayerRTTInfo }
        ]);
    }
    create(value?: PartialMessage<WorldPlayerRTTNotify>): WorldPlayerRTTNotify {
        const message = { playerRttList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldPlayerRTTNotify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldPlayerRTTNotify): WorldPlayerRTTNotify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PlayerRTTInfo player_rtt_list */ 14:
                    message.playerRttList.push(PlayerRTTInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldPlayerRTTNotify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PlayerRTTInfo player_rtt_list = 14; */
        for (let i = 0; i < message.playerRttList.length; i++)
            PlayerRTTInfo.internalBinaryWrite(message.playerRttList[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WorldPlayerRTTNotify
 */
export const WorldPlayerRTTNotify = new WorldPlayerRTTNotify$Type();
